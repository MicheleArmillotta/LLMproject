[
  {
    "function_name": "git_reference_shorthand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1299-1302",
    "snippet": "const char *git_reference_shorthand(const git_reference *ref)\n{\n\treturn git_reference__shorthand(ref->name);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference__shorthand",
          "args": [
            "ref->name"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__shorthand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1284-1297",
          "snippet": "const char *git_reference__shorthand(const char *name)\n{\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\treturn name + strlen(GIT_REFS_HEADS_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_TAGS_DIR))\n\t\treturn name + strlen(GIT_REFS_TAGS_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_REMOTES_DIR))\n\t\treturn name + strlen(GIT_REFS_REMOTES_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_DIR))\n\t\treturn name + strlen(GIT_REFS_DIR);\n\n\t/* No shorthands are avaiable, so just return the name */\n\treturn name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference__shorthand(const char *name)\n{\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\treturn name + strlen(GIT_REFS_HEADS_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_TAGS_DIR))\n\t\treturn name + strlen(GIT_REFS_TAGS_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_REMOTES_DIR))\n\t\treturn name + strlen(GIT_REFS_REMOTES_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_DIR))\n\t\treturn name + strlen(GIT_REFS_DIR);\n\n\t/* No shorthands are avaiable, so just return the name */\n\treturn name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_shorthand(const git_reference *ref)\n{\n\treturn git_reference__shorthand(ref->name);\n}"
  },
  {
    "function_name": "git_reference__shorthand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1284-1297",
    "snippet": "const char *git_reference__shorthand(const char *name)\n{\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\treturn name + strlen(GIT_REFS_HEADS_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_TAGS_DIR))\n\t\treturn name + strlen(GIT_REFS_TAGS_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_REMOTES_DIR))\n\t\treturn name + strlen(GIT_REFS_REMOTES_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_DIR))\n\t\treturn name + strlen(GIT_REFS_DIR);\n\n\t/* No shorthands are avaiable, so just return the name */\n\treturn name;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_DIR"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "name",
            "GIT_REFS_DIR"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_REMOTES_DIR"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_TAGS_DIR"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference__shorthand(const char *name)\n{\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\treturn name + strlen(GIT_REFS_HEADS_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_TAGS_DIR))\n\t\treturn name + strlen(GIT_REFS_TAGS_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_REMOTES_DIR))\n\t\treturn name + strlen(GIT_REFS_REMOTES_DIR);\n\telse if (!git__prefixcmp(name, GIT_REFS_DIR))\n\t\treturn name + strlen(GIT_REFS_DIR);\n\n\t/* No shorthands are avaiable, so just return the name */\n\treturn name;\n}"
  },
  {
    "function_name": "git_reference_is_valid_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1279-1282",
    "snippet": "int git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference__is_valid_name",
          "args": [
            "refname",
            "GIT_REF_FORMAT_ALLOW_ONELEVEL"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1269-1277",
          "snippet": "int git_reference__is_valid_name(const char *refname, unsigned int flags)\n{\n\tif (git_reference__normalize_name(NULL, refname, flags) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_valid_name(const char *refname, unsigned int flags)\n{\n\tif (git_reference__normalize_name(NULL, refname, flags) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}"
  },
  {
    "function_name": "git_reference__is_valid_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1269-1277",
    "snippet": "int git_reference__is_valid_name(const char *refname, unsigned int flags)\n{\n\tif (git_reference__normalize_name(NULL, refname, flags) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__normalize_name",
          "args": [
            "NULL",
            "refname",
            "flags"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__normalize_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "858-974",
          "snippet": "int git_reference__normalize_name(\n\tgit_buf *buf,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tconst char *current;\n\tint segment_len, segments_count = 0, error = GIT_EINVALIDSPEC;\n\tunsigned int process_flags;\n\tbool normalize = (buf != NULL);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tassert(name);\n\n\tprocess_flags = flags;\n\tcurrent = (char *)name;\n\n\tif (*current == '/')\n\t\tgoto cleanup;\n\n\tif (normalize)\n\t\tgit_buf_clear(buf);\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_REF_FORMAT__PRECOMPOSE_UNICODE) != 0) {\n\t\tsize_t namelen = strlen(current);\n\t\tif ((error = git_path_iconv_init_precompose(&ic)) < 0 ||\n\t\t\t(error = git_path_iconv(&ic, &current, &namelen)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n#endif\n\n\twhile (true) {\n\t\tsegment_len = ensure_segment_validity(current);\n\t\tif (segment_len < 0) {\n\t\t\tif ((process_flags & GIT_REF_FORMAT_REFSPEC_PATTERN) &&\n\t\t\t\t\tcurrent[0] == '*' &&\n\t\t\t\t\t(current[1] == '\\0' || current[1] == '/')) {\n\t\t\t\t/* Accept one wildcard as a full refname component. */\n\t\t\t\tprocess_flags &= ~GIT_REF_FORMAT_REFSPEC_PATTERN;\n\t\t\t\tsegment_len = 1;\n\t\t\t} else\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (segment_len > 0) {\n\t\t\tif (normalize) {\n\t\t\t\tsize_t cur_len = git_buf_len(buf);\n\n\t\t\t\tgit_buf_joinpath(buf, git_buf_cstr(buf), current);\n\t\t\t\tgit_buf_truncate(buf,\n\t\t\t\t\tcur_len + segment_len + (segments_count ? 1 : 0));\n\n\t\t\t\tif (git_buf_oom(buf)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsegments_count++;\n\t\t}\n\n\t\t/* No empty segment is allowed when not normalizing */\n\t\tif (segment_len == 0 && !normalize)\n\t\t\tgoto cleanup;\n\n\t\tif (current[segment_len] == '\\0')\n\t\t\tbreak;\n\n\t\tcurrent += segment_len + 1;\n\t}\n\n\t/* A refname can not be empty */\n\tif (segment_len == 0 && segments_count == 0)\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \".\" */\n\tif (current[segment_len - 1] == '.')\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \"/\" */\n\tif (current[segment_len - 1] == '/')\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) && !(flags & GIT_REF_FORMAT_ALLOW_ONELEVEL))\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) &&\n\t    !(flags & GIT_REF_FORMAT_REFSPEC_SHORTHAND) &&\n\t\t!(is_all_caps_and_underscore(name, (size_t)segment_len) ||\n\t\t\t((flags & GIT_REF_FORMAT_REFSPEC_PATTERN) && !strcmp(\"*\", name))))\n\t\t\tgoto cleanup;\n\n\tif ((segments_count > 1)\n\t\t&& (is_all_caps_and_underscore(name, strchr(name, '/') - name)))\n\t\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tif (error == GIT_EINVALIDSPEC)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE,\n\t\t\t\"The given reference name '%s' is not valid\", name);\n\n\tif (error && normalize)\n\t\tgit_buf_free(buf);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__normalize_name(\n\tgit_buf *buf,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tconst char *current;\n\tint segment_len, segments_count = 0, error = GIT_EINVALIDSPEC;\n\tunsigned int process_flags;\n\tbool normalize = (buf != NULL);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tassert(name);\n\n\tprocess_flags = flags;\n\tcurrent = (char *)name;\n\n\tif (*current == '/')\n\t\tgoto cleanup;\n\n\tif (normalize)\n\t\tgit_buf_clear(buf);\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_REF_FORMAT__PRECOMPOSE_UNICODE) != 0) {\n\t\tsize_t namelen = strlen(current);\n\t\tif ((error = git_path_iconv_init_precompose(&ic)) < 0 ||\n\t\t\t(error = git_path_iconv(&ic, &current, &namelen)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n#endif\n\n\twhile (true) {\n\t\tsegment_len = ensure_segment_validity(current);\n\t\tif (segment_len < 0) {\n\t\t\tif ((process_flags & GIT_REF_FORMAT_REFSPEC_PATTERN) &&\n\t\t\t\t\tcurrent[0] == '*' &&\n\t\t\t\t\t(current[1] == '\\0' || current[1] == '/')) {\n\t\t\t\t/* Accept one wildcard as a full refname component. */\n\t\t\t\tprocess_flags &= ~GIT_REF_FORMAT_REFSPEC_PATTERN;\n\t\t\t\tsegment_len = 1;\n\t\t\t} else\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (segment_len > 0) {\n\t\t\tif (normalize) {\n\t\t\t\tsize_t cur_len = git_buf_len(buf);\n\n\t\t\t\tgit_buf_joinpath(buf, git_buf_cstr(buf), current);\n\t\t\t\tgit_buf_truncate(buf,\n\t\t\t\t\tcur_len + segment_len + (segments_count ? 1 : 0));\n\n\t\t\t\tif (git_buf_oom(buf)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsegments_count++;\n\t\t}\n\n\t\t/* No empty segment is allowed when not normalizing */\n\t\tif (segment_len == 0 && !normalize)\n\t\t\tgoto cleanup;\n\n\t\tif (current[segment_len] == '\\0')\n\t\t\tbreak;\n\n\t\tcurrent += segment_len + 1;\n\t}\n\n\t/* A refname can not be empty */\n\tif (segment_len == 0 && segments_count == 0)\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \".\" */\n\tif (current[segment_len - 1] == '.')\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \"/\" */\n\tif (current[segment_len - 1] == '/')\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) && !(flags & GIT_REF_FORMAT_ALLOW_ONELEVEL))\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) &&\n\t    !(flags & GIT_REF_FORMAT_REFSPEC_SHORTHAND) &&\n\t\t!(is_all_caps_and_underscore(name, (size_t)segment_len) ||\n\t\t\t((flags & GIT_REF_FORMAT_REFSPEC_PATTERN) && !strcmp(\"*\", name))))\n\t\t\tgoto cleanup;\n\n\tif ((segments_count > 1)\n\t\t&& (is_all_caps_and_underscore(name, strchr(name, '/') - name)))\n\t\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tif (error == GIT_EINVALIDSPEC)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE,\n\t\t\t\"The given reference name '%s' is not valid\", name);\n\n\tif (error && normalize)\n\t\tgit_buf_free(buf);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_valid_name(const char *refname, unsigned int flags)\n{\n\tif (git_reference__normalize_name(NULL, refname, flags) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "git_reference_peel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1224-1267",
    "snippet": "int git_reference_peel(\n\tgit_object **peeled,\n\tgit_reference *ref,\n\tgit_otype target_type)\n{\n\tgit_reference *resolved = NULL;\n\tgit_object *target = NULL;\n\tint error;\n\n\tassert(ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tresolved = ref;\n\t} else {\n\t\tif ((error = git_reference_resolve(&resolved, ref)) < 0)\n\t\t\treturn peel_error(error, ref, \"Cannot resolve reference\");\n\t}\n\n\tif (!git_oid_iszero(&resolved->peel)) {\n\t\terror = git_object_lookup(&target,\n\t\t\tgit_reference_owner(ref), &resolved->peel, GIT_OBJ_ANY);\n\t} else {\n\t\terror = git_object_lookup(&target,\n\t\t\tgit_reference_owner(ref), &resolved->target.oid, GIT_OBJ_ANY);\n\t}\n\n\tif (error < 0) {\n\t\tpeel_error(error, ref, \"Cannot retrieve reference target\");\n\t\tgoto cleanup;\n\t}\n\n\tif (target_type == GIT_OBJ_ANY && git_object_type(target) != GIT_OBJ_TAG)\n\t\terror = git_object_dup(peeled, target);\n\telse\n\t\terror = git_object_peel(peeled, target, target_type);\n\ncleanup:\n\tgit_object_free(target);\n\n\tif (resolved != ref)\n\t\tgit_reference_free(resolved);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "resolved"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "target"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_peel",
          "args": [
            "peeled",
            "target",
            "target_type"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "327-381",
          "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_dup",
          "args": [
            "peeled",
            "target"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "383-388",
          "snippet": "int git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type",
          "args": [
            "target"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "peel_error",
          "args": [
            "error",
            "ref",
            "\"Cannot retrieve reference target\""
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "peel_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1216-1222",
          "snippet": "static int peel_error(int error, git_reference *ref, const char* msg)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"The reference '%s' cannot be peeled - %s\", git_reference_name(ref), msg);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int peel_error(int error, git_reference *ref, const char* msg)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"The reference '%s' cannot be peeled - %s\", git_reference_name(ref), msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "&target",
            "git_reference_owner(ref)",
            "&resolved->target.oid",
            "GIT_OBJ_ANY"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_owner",
          "args": [
            "ref"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "315-319",
          "snippet": "git_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&resolved->peel"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_resolve",
          "args": [
            "&resolved",
            "ref"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "617-630",
          "snippet": "int git_reference_resolve(git_reference **ref_out, const git_reference *ref)\n{\n\tswitch (git_reference_type(ref)) {\n\tcase GIT_REF_OID:\n\t\treturn git_reference_lookup(ref_out, ref->db->repo, ref->name);\n\n\tcase GIT_REF_SYMBOLIC:\n\t\treturn git_reference_lookup_resolved(ref_out, ref->db->repo, ref->target.symbolic, -1);\n\n\tdefault:\n\t\tgiterr_set(GITERR_REFERENCE, \"Invalid reference\");\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_resolve(git_reference **ref_out, const git_reference *ref)\n{\n\tswitch (git_reference_type(ref)) {\n\tcase GIT_REF_OID:\n\t\treturn git_reference_lookup(ref_out, ref->db->repo, ref->name);\n\n\tcase GIT_REF_SYMBOLIC:\n\t\treturn git_reference_lookup_resolved(ref_out, ref->db->repo, ref->target.symbolic, -1);\n\n\tdefault:\n\t\tgiterr_set(GITERR_REFERENCE, \"Invalid reference\");\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_peel(\n\tgit_object **peeled,\n\tgit_reference *ref,\n\tgit_otype target_type)\n{\n\tgit_reference *resolved = NULL;\n\tgit_object *target = NULL;\n\tint error;\n\n\tassert(ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tresolved = ref;\n\t} else {\n\t\tif ((error = git_reference_resolve(&resolved, ref)) < 0)\n\t\t\treturn peel_error(error, ref, \"Cannot resolve reference\");\n\t}\n\n\tif (!git_oid_iszero(&resolved->peel)) {\n\t\terror = git_object_lookup(&target,\n\t\t\tgit_reference_owner(ref), &resolved->peel, GIT_OBJ_ANY);\n\t} else {\n\t\terror = git_object_lookup(&target,\n\t\t\tgit_reference_owner(ref), &resolved->target.oid, GIT_OBJ_ANY);\n\t}\n\n\tif (error < 0) {\n\t\tpeel_error(error, ref, \"Cannot retrieve reference target\");\n\t\tgoto cleanup;\n\t}\n\n\tif (target_type == GIT_OBJ_ANY && git_object_type(target) != GIT_OBJ_TAG)\n\t\terror = git_object_dup(peeled, target);\n\telse\n\t\terror = git_object_peel(peeled, target, target_type);\n\ncleanup:\n\tgit_object_free(target);\n\n\tif (resolved != ref)\n\t\tgit_reference_free(resolved);\n\n\treturn error;\n}"
  },
  {
    "function_name": "peel_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1216-1222",
    "snippet": "static int peel_error(int error, git_reference *ref, const char* msg)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"The reference '%s' cannot be peeled - %s\", git_reference_name(ref), msg);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"The reference '%s' cannot be peeled - %s\"",
            "git_reference_name(ref)",
            "msg"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "ref"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int peel_error(int error, git_reference *ref, const char* msg)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"The reference '%s' cannot be peeled - %s\", git_reference_name(ref), msg);\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference_is_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1210-1214",
    "snippet": "int git_reference_is_note(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_note(ref->name);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference__is_note",
          "args": [
            "ref->name"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1205-1208",
          "snippet": "int git_reference__is_note(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_NOTES_DIR) == 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_note(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_NOTES_DIR) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_note(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_note(ref->name);\n}"
  },
  {
    "function_name": "git_reference__is_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1205-1208",
    "snippet": "int git_reference__is_note(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_NOTES_DIR) == 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ref_name",
            "GIT_REFS_NOTES_DIR"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_note(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_NOTES_DIR) == 0;\n}"
  },
  {
    "function_name": "git_reference_is_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1199-1203",
    "snippet": "int git_reference_is_tag(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_tag(ref->name);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference__is_tag",
          "args": [
            "ref->name"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1194-1197",
          "snippet": "int git_reference__is_tag(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_TAGS_DIR) == 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_tag(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_TAGS_DIR) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_tag(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_tag(ref->name);\n}"
  },
  {
    "function_name": "git_reference__is_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1194-1197",
    "snippet": "int git_reference__is_tag(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_TAGS_DIR) == 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ref_name",
            "GIT_REFS_TAGS_DIR"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_tag(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_TAGS_DIR) == 0;\n}"
  },
  {
    "function_name": "git_reference_is_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1188-1192",
    "snippet": "int git_reference_is_remote(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_remote(ref->name);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference__is_remote",
          "args": [
            "ref->name"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1183-1186",
          "snippet": "int git_reference__is_remote(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_REMOTES_DIR) == 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_remote(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_REMOTES_DIR) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_remote(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_remote(ref->name);\n}"
  },
  {
    "function_name": "git_reference__is_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1183-1186",
    "snippet": "int git_reference__is_remote(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_REMOTES_DIR) == 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ref_name",
            "GIT_REFS_REMOTES_DIR"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_remote(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_REMOTES_DIR) == 0;\n}"
  },
  {
    "function_name": "git_reference_is_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1177-1181",
    "snippet": "int git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference__is_branch",
          "args": [
            "ref->name"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1172-1175",
          "snippet": "int git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}"
  },
  {
    "function_name": "git_reference__is_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1172-1175",
    "snippet": "int git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ref_name",
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}"
  },
  {
    "function_name": "git_reference_ensure_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1159-1170",
    "snippet": "int git_reference_ensure_log(git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_refdb *refdb;\n\n\tassert(repo && refname);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_ensure_log(refdb, refname);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_ensure_log",
          "args": [
            "refdb",
            "refname"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_ensure_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "228-233",
          "snippet": "int git_refdb_ensure_log(git_refdb *db, const char *refname)\n{\n\tassert(db && refname);\n\n\treturn db->backend->ensure_log(db->backend, refname);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_ensure_log(git_refdb *db, const char *refname)\n{\n\tassert(db && refname);\n\n\treturn db->backend->ensure_log(db->backend, refname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_refdb__weakptr",
          "args": [
            "&refdb",
            "repo"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_refdb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "779-802",
          "snippet": "int git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && refname"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_ensure_log(git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_refdb *refdb;\n\n\tassert(repo && refname);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_ensure_log(refdb, refname);\n}"
  },
  {
    "function_name": "git_reference_has_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1146-1157",
    "snippet": "int git_reference_has_log(git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_refdb *refdb;\n\n\tassert(repo && refname);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_has_log(refdb, refname);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_has_log",
          "args": [
            "refdb",
            "refname"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_has_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "221-226",
          "snippet": "int git_refdb_has_log(git_refdb *db, const char *refname)\n{\n\tassert(db && refname);\n\n\treturn db->backend->has_log(db->backend, refname);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_has_log(git_refdb *db, const char *refname)\n{\n\tassert(db && refname);\n\n\treturn db->backend->has_log(db->backend, refname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_refdb__weakptr",
          "args": [
            "&refdb",
            "repo"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_refdb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "779-802",
          "snippet": "int git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && refname"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_has_log(git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_refdb *refdb;\n\n\tassert(repo && refname);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_has_log(refdb, refname);\n}"
  },
  {
    "function_name": "git_reference__update_for_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1106-1144",
    "snippet": "int git_reference__update_for_commit(\n\tgit_repository *repo,\n\tgit_reference *ref,\n\tconst char *ref_name,\n\tconst git_oid *id,\n\tconst char *operation)\n{\n\tgit_reference *ref_new = NULL;\n\tgit_commit *commit = NULL;\n\tgit_buf reflog_msg = GIT_BUF_INIT;\n\tconst git_signature *who;\n\tint error;\n\n\tif ((error = git_commit_lookup(&commit, repo, id)) < 0 ||\n\t\t(error = git_buf_printf(&reflog_msg, \"%s%s: %s\",\n\t\t\toperation ? operation : \"commit\",\n\t\t\tgit_commit_parentcount(commit) == 0 ? \" (initial)\" : \"\",\n\t\t\tgit_commit_summary(commit))) < 0)\n\t\tgoto done;\n\n\twho = git_commit_committer(commit);\n\n\tif (ref) {\n\t\tif ((error = ensure_is_an_updatable_direct_reference(ref)) < 0)\n\t\t\treturn error;\n\n\t\terror = reference__create(&ref_new, repo, ref->name, id, NULL, 1, who,\n\t\t\t\t\t  git_buf_cstr(&reflog_msg), &ref->target.oid, NULL);\n\t}\n\telse\n\t\terror = git_reference__update_terminal(\n\t\t\trepo, ref_name, id, who, git_buf_cstr(&reflog_msg));\n\ndone:\n\tgit_reference_free(ref_new);\n\tgit_buf_free(&reflog_msg);\n\tgit_commit_free(commit);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "commit"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&reflog_msg"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref_new"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__update_terminal",
          "args": [
            "repo",
            "ref_name",
            "id",
            "who",
            "git_buf_cstr(&reflog_msg)"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__update_terminal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1066-1104",
          "snippet": "int git_reference__update_terminal(\n\tgit_repository *repo,\n\tconst char *ref_name,\n\tconst git_oid *oid,\n\tconst git_signature *sig,\n\tconst char *log_message)\n{\n\tgit_reference *ref = NULL, *ref2 = NULL;\n\tgit_signature *who = NULL;\n\tconst git_signature *to_use;\n\tint error = 0;\n\n\tif (!sig && (error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\tto_use = sig ? sig : who;\n\terror = get_terminal(&ref, repo, ref_name, 0);\n\n\t/* found a dangling symref */\n\tif (error == GIT_ENOTFOUND && ref) {\n\t\tassert(git_reference_type(ref) == GIT_REF_SYMBOLIC);\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref->target.symbolic, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t} else if (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref_name, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t}  else if (error == 0) {\n\t\tassert(git_reference_type(ref) == GIT_REF_OID);\n\t\terror = reference__create(&ref2, repo, ref->name, oid, NULL, 1, to_use,\n\t\t\t\t\t  log_message, &ref->target.oid, NULL);\n\t}\n\n\tgit_reference_free(ref2);\n\tgit_reference_free(ref);\n\tgit_signature_free(who);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__update_terminal(\n\tgit_repository *repo,\n\tconst char *ref_name,\n\tconst git_oid *oid,\n\tconst git_signature *sig,\n\tconst char *log_message)\n{\n\tgit_reference *ref = NULL, *ref2 = NULL;\n\tgit_signature *who = NULL;\n\tconst git_signature *to_use;\n\tint error = 0;\n\n\tif (!sig && (error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\tto_use = sig ? sig : who;\n\terror = get_terminal(&ref, repo, ref_name, 0);\n\n\t/* found a dangling symref */\n\tif (error == GIT_ENOTFOUND && ref) {\n\t\tassert(git_reference_type(ref) == GIT_REF_SYMBOLIC);\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref->target.symbolic, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t} else if (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref_name, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t}  else if (error == 0) {\n\t\tassert(git_reference_type(ref) == GIT_REF_OID);\n\t\terror = reference__create(&ref2, repo, ref->name, oid, NULL, 1, to_use,\n\t\t\t\t\t  log_message, &ref->target.oid, NULL);\n\t}\n\n\tgit_reference_free(ref2);\n\tgit_reference_free(ref);\n\tgit_signature_free(who);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&reflog_msg"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference__create",
          "args": [
            "&ref_new",
            "repo",
            "ref->name",
            "id",
            "NULL",
            "1",
            "who",
            "git_buf_cstr(&reflog_msg)",
            "&ref->target.oid",
            "NULL"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "reference__create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "351-414",
          "snippet": "static int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_is_an_updatable_direct_reference",
          "args": [
            "ref"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_is_an_updatable_direct_reference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "510-517",
          "snippet": "static int ensure_is_an_updatable_direct_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_OID)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set OID on symbolic reference\");\n\treturn -1;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int ensure_is_an_updatable_direct_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_OID)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set OID on symbolic reference\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_committer",
          "args": [
            "commit"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&reflog_msg",
            "\"%s%s: %s\"",
            "operation ? operation : \"commit\"",
            "git_commit_parentcount(commit) == 0 ? \" (initial)\" : \"\"",
            "git_commit_summary(commit)"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_summary",
          "args": [
            "commit"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "458-501",
          "snippet": "const char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parentcount",
          "args": [
            "commit"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_lookup",
          "args": [
            "&commit",
            "repo",
            "id"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "20-23",
          "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__update_for_commit(\n\tgit_repository *repo,\n\tgit_reference *ref,\n\tconst char *ref_name,\n\tconst git_oid *id,\n\tconst char *operation)\n{\n\tgit_reference *ref_new = NULL;\n\tgit_commit *commit = NULL;\n\tgit_buf reflog_msg = GIT_BUF_INIT;\n\tconst git_signature *who;\n\tint error;\n\n\tif ((error = git_commit_lookup(&commit, repo, id)) < 0 ||\n\t\t(error = git_buf_printf(&reflog_msg, \"%s%s: %s\",\n\t\t\toperation ? operation : \"commit\",\n\t\t\tgit_commit_parentcount(commit) == 0 ? \" (initial)\" : \"\",\n\t\t\tgit_commit_summary(commit))) < 0)\n\t\tgoto done;\n\n\twho = git_commit_committer(commit);\n\n\tif (ref) {\n\t\tif ((error = ensure_is_an_updatable_direct_reference(ref)) < 0)\n\t\t\treturn error;\n\n\t\terror = reference__create(&ref_new, repo, ref->name, id, NULL, 1, who,\n\t\t\t\t\t  git_buf_cstr(&reflog_msg), &ref->target.oid, NULL);\n\t}\n\telse\n\t\terror = git_reference__update_terminal(\n\t\t\trepo, ref_name, id, who, git_buf_cstr(&reflog_msg));\n\ndone:\n\tgit_reference_free(ref_new);\n\tgit_buf_free(&reflog_msg);\n\tgit_commit_free(commit);\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference__update_terminal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1066-1104",
    "snippet": "int git_reference__update_terminal(\n\tgit_repository *repo,\n\tconst char *ref_name,\n\tconst git_oid *oid,\n\tconst git_signature *sig,\n\tconst char *log_message)\n{\n\tgit_reference *ref = NULL, *ref2 = NULL;\n\tgit_signature *who = NULL;\n\tconst git_signature *to_use;\n\tint error = 0;\n\n\tif (!sig && (error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\tto_use = sig ? sig : who;\n\terror = get_terminal(&ref, repo, ref_name, 0);\n\n\t/* found a dangling symref */\n\tif (error == GIT_ENOTFOUND && ref) {\n\t\tassert(git_reference_type(ref) == GIT_REF_SYMBOLIC);\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref->target.symbolic, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t} else if (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref_name, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t}  else if (error == 0) {\n\t\tassert(git_reference_type(ref) == GIT_REF_OID);\n\t\terror = reference__create(&ref2, repo, ref->name, oid, NULL, 1, to_use,\n\t\t\t\t\t  log_message, &ref->target.oid, NULL);\n\t}\n\n\tgit_reference_free(ref2);\n\tgit_reference_free(ref);\n\tgit_signature_free(who);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_signature_free",
          "args": [
            "who"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "14-24",
          "snippet": "void git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference__create",
          "args": [
            "&ref2",
            "repo",
            "ref->name",
            "oid",
            "NULL",
            "1",
            "to_use",
            "log_message",
            "&ref->target.oid",
            "NULL"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "reference__create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "351-414",
          "snippet": "static int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_reference_type(ref) == GIT_REF_OID"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_type",
          "args": [
            "ref"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "303-307",
          "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_reference_type(ref) == GIT_REF_SYMBOLIC"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_terminal",
          "args": [
            "&ref",
            "repo",
            "ref_name",
            "0"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "get_terminal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1031-1059",
          "snippet": "static int get_terminal(git_reference **out, git_repository *repo, const char *ref_name, int nesting)\n{\n\tgit_reference *ref;\n\tint error = 0;\n\n\tif (nesting > MAX_NESTING_LEVEL) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Reference chain too deep (%d)\", nesting);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* set to NULL to let the caller know that they're at the end of the chain */\n\tif ((error = git_reference_lookup(&ref, repo, ref_name)) < 0) {\n\t\t*out = NULL;\n\t\treturn error;\n\t}\n\n\tif (git_reference_type(ref) == GIT_REF_OID) {\n\t\t*out = ref;\n\t\terror = 0;\n\t} else {\n\t\terror = get_terminal(out, repo, git_reference_symbolic_target(ref), nesting + 1);\n\t\tif (error == GIT_ENOTFOUND && !*out)\n\t\t\t*out = ref;\n\t\telse\n\t\t\tgit_reference_free(ref);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [
            "#define MAX_NESTING_LEVEL\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\n#define MAX_NESTING_LEVEL\t\t10\n\nstatic int get_terminal(git_reference **out, git_repository *repo, const char *ref_name, int nesting)\n{\n\tgit_reference *ref;\n\tint error = 0;\n\n\tif (nesting > MAX_NESTING_LEVEL) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Reference chain too deep (%d)\", nesting);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* set to NULL to let the caller know that they're at the end of the chain */\n\tif ((error = git_reference_lookup(&ref, repo, ref_name)) < 0) {\n\t\t*out = NULL;\n\t\treturn error;\n\t}\n\n\tif (git_reference_type(ref) == GIT_REF_OID) {\n\t\t*out = ref;\n\t\terror = 0;\n\t} else {\n\t\terror = get_terminal(out, repo, git_reference_symbolic_target(ref), nesting + 1);\n\t\tif (error == GIT_ENOTFOUND && !*out)\n\t\t\t*out = ref;\n\t\telse\n\t\t\tgit_reference_free(ref);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__log_signature",
          "args": [
            "&who",
            "repo"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__log_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "425-437",
          "snippet": "int git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__update_terminal(\n\tgit_repository *repo,\n\tconst char *ref_name,\n\tconst git_oid *oid,\n\tconst git_signature *sig,\n\tconst char *log_message)\n{\n\tgit_reference *ref = NULL, *ref2 = NULL;\n\tgit_signature *who = NULL;\n\tconst git_signature *to_use;\n\tint error = 0;\n\n\tif (!sig && (error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\tto_use = sig ? sig : who;\n\terror = get_terminal(&ref, repo, ref_name, 0);\n\n\t/* found a dangling symref */\n\tif (error == GIT_ENOTFOUND && ref) {\n\t\tassert(git_reference_type(ref) == GIT_REF_SYMBOLIC);\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref->target.symbolic, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t} else if (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref_name, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t}  else if (error == 0) {\n\t\tassert(git_reference_type(ref) == GIT_REF_OID);\n\t\terror = reference__create(&ref2, repo, ref->name, oid, NULL, 1, to_use,\n\t\t\t\t\t  log_message, &ref->target.oid, NULL);\n\t}\n\n\tgit_reference_free(ref2);\n\tgit_reference_free(ref);\n\tgit_signature_free(who);\n\treturn error;\n}"
  },
  {
    "function_name": "get_terminal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1031-1059",
    "snippet": "static int get_terminal(git_reference **out, git_repository *repo, const char *ref_name, int nesting)\n{\n\tgit_reference *ref;\n\tint error = 0;\n\n\tif (nesting > MAX_NESTING_LEVEL) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Reference chain too deep (%d)\", nesting);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* set to NULL to let the caller know that they're at the end of the chain */\n\tif ((error = git_reference_lookup(&ref, repo, ref_name)) < 0) {\n\t\t*out = NULL;\n\t\treturn error;\n\t}\n\n\tif (git_reference_type(ref) == GIT_REF_OID) {\n\t\t*out = ref;\n\t\terror = 0;\n\t} else {\n\t\terror = get_terminal(out, repo, git_reference_symbolic_target(ref), nesting + 1);\n\t\tif (error == GIT_ENOTFOUND && !*out)\n\t\t\t*out = ref;\n\t\telse\n\t\t\tgit_reference_free(ref);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [
      "#define MAX_NESTING_LEVEL\t\t10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_terminal",
          "args": [
            "out",
            "repo",
            "git_reference_symbolic_target(ref)",
            "nesting + 1"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "get_terminal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1031-1059",
          "snippet": "static int get_terminal(git_reference **out, git_repository *repo, const char *ref_name, int nesting)\n{\n\tgit_reference *ref;\n\tint error = 0;\n\n\tif (nesting > MAX_NESTING_LEVEL) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Reference chain too deep (%d)\", nesting);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* set to NULL to let the caller know that they're at the end of the chain */\n\tif ((error = git_reference_lookup(&ref, repo, ref_name)) < 0) {\n\t\t*out = NULL;\n\t\treturn error;\n\t}\n\n\tif (git_reference_type(ref) == GIT_REF_OID) {\n\t\t*out = ref;\n\t\terror = 0;\n\t} else {\n\t\terror = get_terminal(out, repo, git_reference_symbolic_target(ref), nesting + 1);\n\t\tif (error == GIT_ENOTFOUND && !*out)\n\t\t\t*out = ref;\n\t\telse\n\t\t\tgit_reference_free(ref);\n\t}\n\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_symbolic_target",
          "args": [
            "ref"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_symbolic_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "341-349",
          "snippet": "const char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_type",
          "args": [
            "ref"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "303-307",
          "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&ref",
            "repo",
            "ref_name"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Reference chain too deep (%d)\"",
            "nesting"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\n#define MAX_NESTING_LEVEL\t\t10\n\nstatic int get_terminal(git_reference **out, git_repository *repo, const char *ref_name, int nesting)\n{\n\tgit_reference *ref;\n\tint error = 0;\n\n\tif (nesting > MAX_NESTING_LEVEL) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Reference chain too deep (%d)\", nesting);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* set to NULL to let the caller know that they're at the end of the chain */\n\tif ((error = git_reference_lookup(&ref, repo, ref_name)) < 0) {\n\t\t*out = NULL;\n\t\treturn error;\n\t}\n\n\tif (git_reference_type(ref) == GIT_REF_OID) {\n\t\t*out = ref;\n\t\terror = 0;\n\t} else {\n\t\terror = get_terminal(out, repo, git_reference_symbolic_target(ref), nesting + 1);\n\t\tif (error == GIT_ENOTFOUND && !*out)\n\t\t\t*out = ref;\n\t\telse\n\t\t\tgit_reference_free(ref);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "1007-1025",
    "snippet": "int git_reference_cmp(\n\tconst git_reference *ref1,\n\tconst git_reference *ref2)\n{\n\tgit_ref_t type1, type2;\n\tassert(ref1 && ref2);\n\n\ttype1 = git_reference_type(ref1);\n\ttype2 = git_reference_type(ref2);\n\n\t/* let's put symbolic refs before OIDs */\n\tif (type1 != type2)\n\t\treturn (type1 == GIT_REF_SYMBOLIC) ? -1 : 1;\n\n\tif (type1 == GIT_REF_SYMBOLIC)\n\t\treturn strcmp(ref1->target.symbolic, ref2->target.symbolic);\n\n\treturn git_oid__cmp(&ref1->target.oid, &ref2->target.oid);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&ref1->target.oid",
            "&ref2->target.oid"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ref1->target.symbolic",
            "ref2->target.symbolic"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_type",
          "args": [
            "ref2"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "303-307",
          "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref1 && ref2"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_cmp(\n\tconst git_reference *ref1,\n\tconst git_reference *ref2)\n{\n\tgit_ref_t type1, type2;\n\tassert(ref1 && ref2);\n\n\ttype1 = git_reference_type(ref1);\n\ttype2 = git_reference_type(ref2);\n\n\t/* let's put symbolic refs before OIDs */\n\tif (type1 != type2)\n\t\treturn (type1 == GIT_REF_SYMBOLIC) ? -1 : 1;\n\n\tif (type1 == GIT_REF_SYMBOLIC)\n\t\treturn strcmp(ref1->target.symbolic, ref2->target.symbolic);\n\n\treturn git_oid__cmp(&ref1->target.oid, &ref2->target.oid);\n}"
  },
  {
    "function_name": "git_reference_normalize_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "976-1003",
    "snippet": "int git_reference_normalize_name(\n\tchar *buffer_out,\n\tsize_t buffer_size,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_reference__normalize_name(&buf, name, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_len(&buf) > buffer_size - 1) {\n\t\tgiterr_set(\n\t\tGITERR_REFERENCE,\n\t\t\"The provided buffer is too short to hold the normalization of '%s'\", name);\n\t\terror = GIT_EBUFS;\n\t\tgoto cleanup;\n\t}\n\n\tgit_buf_copy_cstr(buffer_out, buffer_size, &buf);\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&buf);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_copy_cstr",
          "args": [
            "buffer_out",
            "buffer_size",
            "&buf"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_copy_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "418-434",
          "snippet": "void git_buf_copy_cstr(char *data, size_t datasize, const git_buf *buf)\n{\n\tsize_t copylen;\n\n\tassert(data && datasize && buf);\n\n\tdata[0] = '\\0';\n\n\tif (buf->size == 0 || buf->asize <= 0)\n\t\treturn;\n\n\tcopylen = buf->size;\n\tif (copylen > datasize - 1)\n\t\tcopylen = datasize - 1;\n\tmemmove(data, buf->ptr, copylen);\n\tdata[copylen] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_copy_cstr(char *data, size_t datasize, const git_buf *buf)\n{\n\tsize_t copylen;\n\n\tassert(data && datasize && buf);\n\n\tdata[0] = '\\0';\n\n\tif (buf->size == 0 || buf->asize <= 0)\n\t\treturn;\n\n\tcopylen = buf->size;\n\tif (copylen > datasize - 1)\n\t\tcopylen = datasize - 1;\n\tmemmove(data, buf->ptr, copylen);\n\tdata[copylen] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"The provided buffer is too short to hold the normalization of '%s'\"",
            "name"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&buf"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__normalize_name",
          "args": [
            "&buf",
            "name",
            "flags"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__normalize_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "858-974",
          "snippet": "int git_reference__normalize_name(\n\tgit_buf *buf,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tconst char *current;\n\tint segment_len, segments_count = 0, error = GIT_EINVALIDSPEC;\n\tunsigned int process_flags;\n\tbool normalize = (buf != NULL);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tassert(name);\n\n\tprocess_flags = flags;\n\tcurrent = (char *)name;\n\n\tif (*current == '/')\n\t\tgoto cleanup;\n\n\tif (normalize)\n\t\tgit_buf_clear(buf);\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_REF_FORMAT__PRECOMPOSE_UNICODE) != 0) {\n\t\tsize_t namelen = strlen(current);\n\t\tif ((error = git_path_iconv_init_precompose(&ic)) < 0 ||\n\t\t\t(error = git_path_iconv(&ic, &current, &namelen)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n#endif\n\n\twhile (true) {\n\t\tsegment_len = ensure_segment_validity(current);\n\t\tif (segment_len < 0) {\n\t\t\tif ((process_flags & GIT_REF_FORMAT_REFSPEC_PATTERN) &&\n\t\t\t\t\tcurrent[0] == '*' &&\n\t\t\t\t\t(current[1] == '\\0' || current[1] == '/')) {\n\t\t\t\t/* Accept one wildcard as a full refname component. */\n\t\t\t\tprocess_flags &= ~GIT_REF_FORMAT_REFSPEC_PATTERN;\n\t\t\t\tsegment_len = 1;\n\t\t\t} else\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (segment_len > 0) {\n\t\t\tif (normalize) {\n\t\t\t\tsize_t cur_len = git_buf_len(buf);\n\n\t\t\t\tgit_buf_joinpath(buf, git_buf_cstr(buf), current);\n\t\t\t\tgit_buf_truncate(buf,\n\t\t\t\t\tcur_len + segment_len + (segments_count ? 1 : 0));\n\n\t\t\t\tif (git_buf_oom(buf)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsegments_count++;\n\t\t}\n\n\t\t/* No empty segment is allowed when not normalizing */\n\t\tif (segment_len == 0 && !normalize)\n\t\t\tgoto cleanup;\n\n\t\tif (current[segment_len] == '\\0')\n\t\t\tbreak;\n\n\t\tcurrent += segment_len + 1;\n\t}\n\n\t/* A refname can not be empty */\n\tif (segment_len == 0 && segments_count == 0)\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \".\" */\n\tif (current[segment_len - 1] == '.')\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \"/\" */\n\tif (current[segment_len - 1] == '/')\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) && !(flags & GIT_REF_FORMAT_ALLOW_ONELEVEL))\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) &&\n\t    !(flags & GIT_REF_FORMAT_REFSPEC_SHORTHAND) &&\n\t\t!(is_all_caps_and_underscore(name, (size_t)segment_len) ||\n\t\t\t((flags & GIT_REF_FORMAT_REFSPEC_PATTERN) && !strcmp(\"*\", name))))\n\t\t\tgoto cleanup;\n\n\tif ((segments_count > 1)\n\t\t&& (is_all_caps_and_underscore(name, strchr(name, '/') - name)))\n\t\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tif (error == GIT_EINVALIDSPEC)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE,\n\t\t\t\"The given reference name '%s' is not valid\", name);\n\n\tif (error && normalize)\n\t\tgit_buf_free(buf);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__normalize_name(\n\tgit_buf *buf,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tconst char *current;\n\tint segment_len, segments_count = 0, error = GIT_EINVALIDSPEC;\n\tunsigned int process_flags;\n\tbool normalize = (buf != NULL);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tassert(name);\n\n\tprocess_flags = flags;\n\tcurrent = (char *)name;\n\n\tif (*current == '/')\n\t\tgoto cleanup;\n\n\tif (normalize)\n\t\tgit_buf_clear(buf);\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_REF_FORMAT__PRECOMPOSE_UNICODE) != 0) {\n\t\tsize_t namelen = strlen(current);\n\t\tif ((error = git_path_iconv_init_precompose(&ic)) < 0 ||\n\t\t\t(error = git_path_iconv(&ic, &current, &namelen)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n#endif\n\n\twhile (true) {\n\t\tsegment_len = ensure_segment_validity(current);\n\t\tif (segment_len < 0) {\n\t\t\tif ((process_flags & GIT_REF_FORMAT_REFSPEC_PATTERN) &&\n\t\t\t\t\tcurrent[0] == '*' &&\n\t\t\t\t\t(current[1] == '\\0' || current[1] == '/')) {\n\t\t\t\t/* Accept one wildcard as a full refname component. */\n\t\t\t\tprocess_flags &= ~GIT_REF_FORMAT_REFSPEC_PATTERN;\n\t\t\t\tsegment_len = 1;\n\t\t\t} else\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (segment_len > 0) {\n\t\t\tif (normalize) {\n\t\t\t\tsize_t cur_len = git_buf_len(buf);\n\n\t\t\t\tgit_buf_joinpath(buf, git_buf_cstr(buf), current);\n\t\t\t\tgit_buf_truncate(buf,\n\t\t\t\t\tcur_len + segment_len + (segments_count ? 1 : 0));\n\n\t\t\t\tif (git_buf_oom(buf)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsegments_count++;\n\t\t}\n\n\t\t/* No empty segment is allowed when not normalizing */\n\t\tif (segment_len == 0 && !normalize)\n\t\t\tgoto cleanup;\n\n\t\tif (current[segment_len] == '\\0')\n\t\t\tbreak;\n\n\t\tcurrent += segment_len + 1;\n\t}\n\n\t/* A refname can not be empty */\n\tif (segment_len == 0 && segments_count == 0)\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \".\" */\n\tif (current[segment_len - 1] == '.')\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \"/\" */\n\tif (current[segment_len - 1] == '/')\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) && !(flags & GIT_REF_FORMAT_ALLOW_ONELEVEL))\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) &&\n\t    !(flags & GIT_REF_FORMAT_REFSPEC_SHORTHAND) &&\n\t\t!(is_all_caps_and_underscore(name, (size_t)segment_len) ||\n\t\t\t((flags & GIT_REF_FORMAT_REFSPEC_PATTERN) && !strcmp(\"*\", name))))\n\t\t\tgoto cleanup;\n\n\tif ((segments_count > 1)\n\t\t&& (is_all_caps_and_underscore(name, strchr(name, '/') - name)))\n\t\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tif (error == GIT_EINVALIDSPEC)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE,\n\t\t\t\"The given reference name '%s' is not valid\", name);\n\n\tif (error && normalize)\n\t\tgit_buf_free(buf);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_normalize_name(\n\tchar *buffer_out,\n\tsize_t buffer_size,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_reference__normalize_name(&buf, name, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_len(&buf) > buffer_size - 1) {\n\t\tgiterr_set(\n\t\tGITERR_REFERENCE,\n\t\t\"The provided buffer is too short to hold the normalization of '%s'\", name);\n\t\terror = GIT_EBUFS;\n\t\tgoto cleanup;\n\t}\n\n\tgit_buf_copy_cstr(buffer_out, buffer_size, &buf);\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&buf);\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference__normalize_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "858-974",
    "snippet": "int git_reference__normalize_name(\n\tgit_buf *buf,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tconst char *current;\n\tint segment_len, segments_count = 0, error = GIT_EINVALIDSPEC;\n\tunsigned int process_flags;\n\tbool normalize = (buf != NULL);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tassert(name);\n\n\tprocess_flags = flags;\n\tcurrent = (char *)name;\n\n\tif (*current == '/')\n\t\tgoto cleanup;\n\n\tif (normalize)\n\t\tgit_buf_clear(buf);\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_REF_FORMAT__PRECOMPOSE_UNICODE) != 0) {\n\t\tsize_t namelen = strlen(current);\n\t\tif ((error = git_path_iconv_init_precompose(&ic)) < 0 ||\n\t\t\t(error = git_path_iconv(&ic, &current, &namelen)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n#endif\n\n\twhile (true) {\n\t\tsegment_len = ensure_segment_validity(current);\n\t\tif (segment_len < 0) {\n\t\t\tif ((process_flags & GIT_REF_FORMAT_REFSPEC_PATTERN) &&\n\t\t\t\t\tcurrent[0] == '*' &&\n\t\t\t\t\t(current[1] == '\\0' || current[1] == '/')) {\n\t\t\t\t/* Accept one wildcard as a full refname component. */\n\t\t\t\tprocess_flags &= ~GIT_REF_FORMAT_REFSPEC_PATTERN;\n\t\t\t\tsegment_len = 1;\n\t\t\t} else\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (segment_len > 0) {\n\t\t\tif (normalize) {\n\t\t\t\tsize_t cur_len = git_buf_len(buf);\n\n\t\t\t\tgit_buf_joinpath(buf, git_buf_cstr(buf), current);\n\t\t\t\tgit_buf_truncate(buf,\n\t\t\t\t\tcur_len + segment_len + (segments_count ? 1 : 0));\n\n\t\t\t\tif (git_buf_oom(buf)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsegments_count++;\n\t\t}\n\n\t\t/* No empty segment is allowed when not normalizing */\n\t\tif (segment_len == 0 && !normalize)\n\t\t\tgoto cleanup;\n\n\t\tif (current[segment_len] == '\\0')\n\t\t\tbreak;\n\n\t\tcurrent += segment_len + 1;\n\t}\n\n\t/* A refname can not be empty */\n\tif (segment_len == 0 && segments_count == 0)\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \".\" */\n\tif (current[segment_len - 1] == '.')\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \"/\" */\n\tif (current[segment_len - 1] == '/')\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) && !(flags & GIT_REF_FORMAT_ALLOW_ONELEVEL))\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) &&\n\t    !(flags & GIT_REF_FORMAT_REFSPEC_SHORTHAND) &&\n\t\t!(is_all_caps_and_underscore(name, (size_t)segment_len) ||\n\t\t\t((flags & GIT_REF_FORMAT_REFSPEC_PATTERN) && !strcmp(\"*\", name))))\n\t\t\tgoto cleanup;\n\n\tif ((segments_count > 1)\n\t\t&& (is_all_caps_and_underscore(name, strchr(name, '/') - name)))\n\t\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tif (error == GIT_EINVALIDSPEC)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE,\n\t\t\t\"The given reference name '%s' is not valid\", name);\n\n\tif (error && normalize)\n\t\tgit_buf_free(buf);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_iconv_clear",
          "args": [
            "&ic"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_iconv_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "894-901",
          "snippet": "void git_path_iconv_clear(git_path_iconv_t *ic)\n{\n\tif (ic) {\n\t\tif (ic->map != (iconv_t)-1)\n\t\t\ticonv_close(ic->map);\n\t\tgit_buf_free(&ic->buf);\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_iconv_clear(git_path_iconv_t *ic)\n{\n\tif (ic) {\n\t\tif (ic->map != (iconv_t)-1)\n\t\t\ticonv_close(ic->map);\n\t\tgit_buf_free(&ic->buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "buf"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"The given reference name '%s' is not valid\"",
            "name"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_all_caps_and_underscore",
          "args": [
            "name",
            "strchr(name, '/') - name"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "is_all_caps_and_underscore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "837-855",
          "snippet": "static bool is_all_caps_and_underscore(const char *name, size_t len)\n{\n\tsize_t i;\n\tchar c;\n\n\tassert(name && len > 0);\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tc = name[i];\n\t\tif ((c < 'A' || c > 'Z') && c != '_')\n\t\t\treturn false;\n\t}\n\n\tif (*name == '_' || name[len - 1] == '_')\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic bool is_all_caps_and_underscore(const char *name, size_t len)\n{\n\tsize_t i;\n\tchar c;\n\n\tassert(name && len > 0);\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tc = name[i];\n\t\tif ((c < 'A' || c > 'Z') && c != '_')\n\t\t\treturn false;\n\t}\n\n\tif (*name == '_' || name[len - 1] == '_')\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"*\"",
            "name"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "buf"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "buf",
            "cur_len + segment_len + (segments_count ? 1 : 0)"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "buf",
            "git_buf_cstr(buf)",
            "current"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "buf"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "buf"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_segment_validity",
          "args": [
            "current"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_segment_validity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "801-835",
          "snippet": "static int ensure_segment_validity(const char *name)\n{\n\tconst char *current = name;\n\tchar prev = '\\0';\n\tconst int lock_len = (int)strlen(GIT_FILELOCK_EXTENSION);\n\tint segment_len;\n\n\tif (*current == '.')\n\t\treturn -1; /* Refname starts with \".\" */\n\n\tfor (current = name; ; current++) {\n\t\tif (*current == '\\0' || *current == '/')\n\t\t\tbreak;\n\n\t\tif (!is_valid_ref_char(*current))\n\t\t\treturn -1; /* Illegal character in refname */\n\n\t\tif (prev == '.' && *current == '.')\n\t\t\treturn -1; /* Refname contains \"..\" */\n\n\t\tif (prev == '@' && *current == '{')\n\t\t\treturn -1; /* Refname contains \"@{\" */\n\n\t\tprev = *current;\n\t}\n\n\tsegment_len = (int)(current - name);\n\n\t/* A refname component can not end with \".lock\" */\n\tif (segment_len >= lock_len &&\n\t\t!memcmp(current - lock_len, GIT_FILELOCK_EXTENSION, lock_len))\n\t\t\treturn -1;\n\n\treturn segment_len;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int ensure_segment_validity(const char *name)\n{\n\tconst char *current = name;\n\tchar prev = '\\0';\n\tconst int lock_len = (int)strlen(GIT_FILELOCK_EXTENSION);\n\tint segment_len;\n\n\tif (*current == '.')\n\t\treturn -1; /* Refname starts with \".\" */\n\n\tfor (current = name; ; current++) {\n\t\tif (*current == '\\0' || *current == '/')\n\t\t\tbreak;\n\n\t\tif (!is_valid_ref_char(*current))\n\t\t\treturn -1; /* Illegal character in refname */\n\n\t\tif (prev == '.' && *current == '.')\n\t\t\treturn -1; /* Refname contains \"..\" */\n\n\t\tif (prev == '@' && *current == '{')\n\t\t\treturn -1; /* Refname contains \"@{\" */\n\n\t\tprev = *current;\n\t}\n\n\tsegment_len = (int)(current - name);\n\n\t/* A refname component can not end with \".lock\" */\n\tif (segment_len >= lock_len &&\n\t\t!memcmp(current - lock_len, GIT_FILELOCK_EXTENSION, lock_len))\n\t\t\treturn -1;\n\n\treturn segment_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_iconv",
          "args": [
            "&ic",
            "&current",
            "&namelen"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_iconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "903-955",
          "snippet": "int git_path_iconv(git_path_iconv_t *ic, const char **in, size_t *inlen)\n{\n\tchar *nfd = (char*)*in, *nfc;\n\tsize_t nfdlen = *inlen, nfclen, wantlen = nfdlen, alloclen, rv;\n\tint retry = 1;\n\n\tif (!ic || ic->map == (iconv_t)-1 ||\n\t\t!git_path_has_non_ascii(*in, *inlen))\n\t\treturn 0;\n\n\tgit_buf_clear(&ic->buf);\n\n\twhile (1) {\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, wantlen, 1);\n\t\tif (git_buf_grow(&ic->buf, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tnfc    = ic->buf.ptr   + ic->buf.size;\n\t\tnfclen = ic->buf.asize - ic->buf.size;\n\n\t\trv = iconv(ic->map, &nfd, &nfdlen, &nfc, &nfclen);\n\n\t\tic->buf.size = (nfc - ic->buf.ptr);\n\n\t\tif (rv != (size_t)-1)\n\t\t\tbreak;\n\n\t\t/* if we cannot convert the data (probably because iconv thinks\n\t\t * it is not valid UTF-8 source data), then use original data\n\t\t */\n\t\tif (errno != E2BIG)\n\t\t\treturn 0;\n\n\t\t/* make space for 2x the remaining data to be converted\n\t\t * (with per retry overhead to avoid infinite loops)\n\t\t */\n\t\twantlen = ic->buf.size + max(nfclen, nfdlen) * 2 + (size_t)(retry * 4);\n\n\t\tif (retry++ > 4)\n\t\t\tgoto fail;\n\t}\n\n\tic->buf.ptr[ic->buf.size] = '\\0';\n\n\t*in    = ic->buf.ptr;\n\t*inlen = ic->buf.size;\n\n\treturn 0;\n\nfail:\n\tgiterr_set(GITERR_OS, \"Unable to convert unicode path data\");\n\treturn -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_iconv(git_path_iconv_t *ic, const char **in, size_t *inlen)\n{\n\tchar *nfd = (char*)*in, *nfc;\n\tsize_t nfdlen = *inlen, nfclen, wantlen = nfdlen, alloclen, rv;\n\tint retry = 1;\n\n\tif (!ic || ic->map == (iconv_t)-1 ||\n\t\t!git_path_has_non_ascii(*in, *inlen))\n\t\treturn 0;\n\n\tgit_buf_clear(&ic->buf);\n\n\twhile (1) {\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, wantlen, 1);\n\t\tif (git_buf_grow(&ic->buf, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tnfc    = ic->buf.ptr   + ic->buf.size;\n\t\tnfclen = ic->buf.asize - ic->buf.size;\n\n\t\trv = iconv(ic->map, &nfd, &nfdlen, &nfc, &nfclen);\n\n\t\tic->buf.size = (nfc - ic->buf.ptr);\n\n\t\tif (rv != (size_t)-1)\n\t\t\tbreak;\n\n\t\t/* if we cannot convert the data (probably because iconv thinks\n\t\t * it is not valid UTF-8 source data), then use original data\n\t\t */\n\t\tif (errno != E2BIG)\n\t\t\treturn 0;\n\n\t\t/* make space for 2x the remaining data to be converted\n\t\t * (with per retry overhead to avoid infinite loops)\n\t\t */\n\t\twantlen = ic->buf.size + max(nfclen, nfdlen) * 2 + (size_t)(retry * 4);\n\n\t\tif (retry++ > 4)\n\t\t\tgoto fail;\n\t}\n\n\tic->buf.ptr[ic->buf.size] = '\\0';\n\n\t*in    = ic->buf.ptr;\n\t*inlen = ic->buf.size;\n\n\treturn 0;\n\nfail:\n\tgiterr_set(GITERR_OS, \"Unable to convert unicode path data\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_iconv_init_precompose",
          "args": [
            "&ic"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_iconv_init_precompose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "887-892",
          "snippet": "int git_path_iconv_init_precompose(git_path_iconv_t *ic)\n{\n\tgit_buf_init(&ic->buf, 0);\n\tic->map = iconv_open(GIT_PATH_REPO_ENCODING, GIT_PATH_NATIVE_ENCODING);\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_iconv_init_precompose(git_path_iconv_t *ic)\n{\n\tgit_buf_init(&ic->buf, 0);\n\tic->map = iconv_open(GIT_PATH_REPO_ENCODING, GIT_PATH_NATIVE_ENCODING);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "current"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__normalize_name(\n\tgit_buf *buf,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tconst char *current;\n\tint segment_len, segments_count = 0, error = GIT_EINVALIDSPEC;\n\tunsigned int process_flags;\n\tbool normalize = (buf != NULL);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tassert(name);\n\n\tprocess_flags = flags;\n\tcurrent = (char *)name;\n\n\tif (*current == '/')\n\t\tgoto cleanup;\n\n\tif (normalize)\n\t\tgit_buf_clear(buf);\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_REF_FORMAT__PRECOMPOSE_UNICODE) != 0) {\n\t\tsize_t namelen = strlen(current);\n\t\tif ((error = git_path_iconv_init_precompose(&ic)) < 0 ||\n\t\t\t(error = git_path_iconv(&ic, &current, &namelen)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n#endif\n\n\twhile (true) {\n\t\tsegment_len = ensure_segment_validity(current);\n\t\tif (segment_len < 0) {\n\t\t\tif ((process_flags & GIT_REF_FORMAT_REFSPEC_PATTERN) &&\n\t\t\t\t\tcurrent[0] == '*' &&\n\t\t\t\t\t(current[1] == '\\0' || current[1] == '/')) {\n\t\t\t\t/* Accept one wildcard as a full refname component. */\n\t\t\t\tprocess_flags &= ~GIT_REF_FORMAT_REFSPEC_PATTERN;\n\t\t\t\tsegment_len = 1;\n\t\t\t} else\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (segment_len > 0) {\n\t\t\tif (normalize) {\n\t\t\t\tsize_t cur_len = git_buf_len(buf);\n\n\t\t\t\tgit_buf_joinpath(buf, git_buf_cstr(buf), current);\n\t\t\t\tgit_buf_truncate(buf,\n\t\t\t\t\tcur_len + segment_len + (segments_count ? 1 : 0));\n\n\t\t\t\tif (git_buf_oom(buf)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsegments_count++;\n\t\t}\n\n\t\t/* No empty segment is allowed when not normalizing */\n\t\tif (segment_len == 0 && !normalize)\n\t\t\tgoto cleanup;\n\n\t\tif (current[segment_len] == '\\0')\n\t\t\tbreak;\n\n\t\tcurrent += segment_len + 1;\n\t}\n\n\t/* A refname can not be empty */\n\tif (segment_len == 0 && segments_count == 0)\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \".\" */\n\tif (current[segment_len - 1] == '.')\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \"/\" */\n\tif (current[segment_len - 1] == '/')\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) && !(flags & GIT_REF_FORMAT_ALLOW_ONELEVEL))\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) &&\n\t    !(flags & GIT_REF_FORMAT_REFSPEC_SHORTHAND) &&\n\t\t!(is_all_caps_and_underscore(name, (size_t)segment_len) ||\n\t\t\t((flags & GIT_REF_FORMAT_REFSPEC_PATTERN) && !strcmp(\"*\", name))))\n\t\t\tgoto cleanup;\n\n\tif ((segments_count > 1)\n\t\t&& (is_all_caps_and_underscore(name, strchr(name, '/') - name)))\n\t\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tif (error == GIT_EINVALIDSPEC)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE,\n\t\t\t\"The given reference name '%s' is not valid\", name);\n\n\tif (error && normalize)\n\t\tgit_buf_free(buf);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
  },
  {
    "function_name": "is_all_caps_and_underscore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "837-855",
    "snippet": "static bool is_all_caps_and_underscore(const char *name, size_t len)\n{\n\tsize_t i;\n\tchar c;\n\n\tassert(name && len > 0);\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tc = name[i];\n\t\tif ((c < 'A' || c > 'Z') && c != '_')\n\t\t\treturn false;\n\t}\n\n\tif (*name == '_' || name[len - 1] == '_')\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name && len > 0"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic bool is_all_caps_and_underscore(const char *name, size_t len)\n{\n\tsize_t i;\n\tchar c;\n\n\tassert(name && len > 0);\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tc = name[i];\n\t\tif ((c < 'A' || c > 'Z') && c != '_')\n\t\t\treturn false;\n\t}\n\n\tif (*name == '_' || name[len - 1] == '_')\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "ensure_segment_validity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "801-835",
    "snippet": "static int ensure_segment_validity(const char *name)\n{\n\tconst char *current = name;\n\tchar prev = '\\0';\n\tconst int lock_len = (int)strlen(GIT_FILELOCK_EXTENSION);\n\tint segment_len;\n\n\tif (*current == '.')\n\t\treturn -1; /* Refname starts with \".\" */\n\n\tfor (current = name; ; current++) {\n\t\tif (*current == '\\0' || *current == '/')\n\t\t\tbreak;\n\n\t\tif (!is_valid_ref_char(*current))\n\t\t\treturn -1; /* Illegal character in refname */\n\n\t\tif (prev == '.' && *current == '.')\n\t\t\treturn -1; /* Refname contains \"..\" */\n\n\t\tif (prev == '@' && *current == '{')\n\t\t\treturn -1; /* Refname contains \"@{\" */\n\n\t\tprev = *current;\n\t}\n\n\tsegment_len = (int)(current - name);\n\n\t/* A refname component can not end with \".lock\" */\n\tif (segment_len >= lock_len &&\n\t\t!memcmp(current - lock_len, GIT_FILELOCK_EXTENSION, lock_len))\n\t\t\treturn -1;\n\n\treturn segment_len;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "current - lock_len",
            "GIT_FILELOCK_EXTENSION",
            "lock_len"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_valid_ref_char",
          "args": [
            "*current"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_ref_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "782-799",
          "snippet": "static int is_valid_ref_char(char ch)\n{\n\tif ((unsigned) ch <= ' ')\n\t\treturn 0;\n\n\tswitch (ch) {\n\tcase '~':\n\tcase '^':\n\tcase ':':\n\tcase '\\\\':\n\tcase '?':\n\tcase '[':\n\tcase '*':\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int is_valid_ref_char(char ch)\n{\n\tif ((unsigned) ch <= ' ')\n\t\treturn 0;\n\n\tswitch (ch) {\n\tcase '~':\n\tcase '^':\n\tcase ':':\n\tcase '\\\\':\n\tcase '?':\n\tcase '[':\n\tcase '*':\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_FILELOCK_EXTENSION"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int ensure_segment_validity(const char *name)\n{\n\tconst char *current = name;\n\tchar prev = '\\0';\n\tconst int lock_len = (int)strlen(GIT_FILELOCK_EXTENSION);\n\tint segment_len;\n\n\tif (*current == '.')\n\t\treturn -1; /* Refname starts with \".\" */\n\n\tfor (current = name; ; current++) {\n\t\tif (*current == '\\0' || *current == '/')\n\t\t\tbreak;\n\n\t\tif (!is_valid_ref_char(*current))\n\t\t\treturn -1; /* Illegal character in refname */\n\n\t\tif (prev == '.' && *current == '.')\n\t\t\treturn -1; /* Refname contains \"..\" */\n\n\t\tif (prev == '@' && *current == '{')\n\t\t\treturn -1; /* Refname contains \"@{\" */\n\n\t\tprev = *current;\n\t}\n\n\tsegment_len = (int)(current - name);\n\n\t/* A refname component can not end with \".lock\" */\n\tif (segment_len >= lock_len &&\n\t\t!memcmp(current - lock_len, GIT_FILELOCK_EXTENSION, lock_len))\n\t\t\treturn -1;\n\n\treturn segment_len;\n}"
  },
  {
    "function_name": "is_valid_ref_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "782-799",
    "snippet": "static int is_valid_ref_char(char ch)\n{\n\tif ((unsigned) ch <= ' ')\n\t\treturn 0;\n\n\tswitch (ch) {\n\tcase '~':\n\tcase '^':\n\tcase ':':\n\tcase '\\\\':\n\tcase '?':\n\tcase '[':\n\tcase '*':\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int is_valid_ref_char(char ch)\n{\n\tif ((unsigned) ch <= ' ')\n\t\treturn 0;\n\n\tswitch (ch) {\n\tcase '~':\n\tcase '^':\n\tcase ':':\n\tcase '\\\\':\n\tcase '?':\n\tcase '[':\n\tcase '*':\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "git_reference_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "757-780",
    "snippet": "int git_reference_list(\n\tgit_strarray *array,\n\tgit_repository *repo)\n{\n\tgit_vector ref_list;\n\n\tassert(array && repo);\n\n\tarray->strings = NULL;\n\tarray->count = 0;\n\n\tif (git_vector_init(&ref_list, 8, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_reference_foreach_name(\n\t\t\trepo, &cb__reflist_add, (void *)&ref_list) < 0) {\n\t\tgit_vector_free(&ref_list);\n\t\treturn -1;\n\t}\n\n\tarray->strings = (char **)git_vector_detach(&array->count, NULL, &ref_list);\n\n\treturn 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_detach",
          "args": [
            "&array->count",
            "NULL",
            "&ref_list"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "110-124",
          "snippet": "void **git_vector_detach(size_t *size, size_t *asize, git_vector *v)\n{\n\tvoid **data = v->contents;\n\n\tif (size)\n\t\t*size = v->length;\n\tif (asize)\n\t\t*asize = v->_alloc_size;\n\n\tv->_alloc_size = 0;\n\tv->length   = 0;\n\tv->contents = NULL;\n\n\treturn data;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid **git_vector_detach(size_t *size, size_t *asize, git_vector *v)\n{\n\tvoid **data = v->contents;\n\n\tif (size)\n\t\t*size = v->length;\n\tif (asize)\n\t\t*asize = v->_alloc_size;\n\n\tv->_alloc_size = 0;\n\tv->length   = 0;\n\tv->contents = NULL;\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&ref_list"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_foreach_name",
          "args": [
            "repo",
            "&cb__reflist_add",
            "(void *)&ref_list"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_foreach_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "658-682",
          "snippet": "int git_reference_foreach_name(\n\tgit_repository *repo,\n\tgit_reference_foreach_name_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tconst char *refname;\n\tint error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next_name(&refname, iter))) {\n\t\tif ((error = callback(refname, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_foreach_name(\n\tgit_repository *repo,\n\tgit_reference_foreach_name_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tconst char *refname;\n\tint error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next_name(&refname, iter))) {\n\t\tif ((error = callback(refname, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&ref_list",
            "8",
            "NULL"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "array && repo"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_list(\n\tgit_strarray *array,\n\tgit_repository *repo)\n{\n\tgit_vector ref_list;\n\n\tassert(array && repo);\n\n\tarray->strings = NULL;\n\tarray->count = 0;\n\n\tif (git_vector_init(&ref_list, 8, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_reference_foreach_name(\n\t\t\trepo, &cb__reflist_add, (void *)&ref_list) < 0) {\n\t\tgit_vector_free(&ref_list);\n\t\treturn -1;\n\t}\n\n\tarray->strings = (char **)git_vector_detach(&array->count, NULL, &ref_list);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cb__reflist_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "750-755",
    "snippet": "static int cb__reflist_add(const char *ref, void *data)\n{\n\tchar *name = git__strdup(ref);\n\tGITERR_CHECK_ALLOC(name);\n\treturn git_vector_insert((git_vector *)data, name);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "(git_vector *)data",
            "name"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "name"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "ref"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int cb__reflist_add(const char *ref, void *data)\n{\n\tchar *name = git__strdup(ref);\n\tGITERR_CHECK_ALLOC(name);\n\treturn git_vector_insert((git_vector *)data, name);\n}"
  },
  {
    "function_name": "git_reference_iterator_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "742-748",
    "snippet": "void git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_iterator_free",
          "args": [
            "iter"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "160-164",
          "snippet": "void git_refdb_iterator_free(git_reference_iterator *iter)\n{\n\tGIT_REFCOUNT_DEC(iter->db, git_refdb__free);\n\titer->free(iter);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nvoid git_refdb_iterator_free(git_reference_iterator *iter)\n{\n\tGIT_REFCOUNT_DEC(iter->db, git_refdb__free);\n\titer->free(iter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}"
  },
  {
    "function_name": "git_reference_next_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "737-740",
    "snippet": "int git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_iterator_next_name",
          "args": [
            "out",
            "iter"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_iterator_next_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "155-158",
          "snippet": "int git_refdb_iterator_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn iter->next_name(out, iter);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_iterator_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn iter->next_name(out, iter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}"
  },
  {
    "function_name": "git_reference_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "732-735",
    "snippet": "int git_reference_next(git_reference **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next(out, iter);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_iterator_next",
          "args": [
            "out",
            "iter"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_iterator_next_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "155-158",
          "snippet": "int git_refdb_iterator_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn iter->next_name(out, iter);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_iterator_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn iter->next_name(out, iter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_next(git_reference **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next(out, iter);\n}"
  },
  {
    "function_name": "git_reference_iterator_glob_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "721-730",
    "snippet": "int git_reference_iterator_glob_new(\n\tgit_reference_iterator **out, git_repository *repo, const char *glob)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, glob);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_iterator",
          "args": [
            "out",
            "refdb",
            "glob"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_iterator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "126-140",
          "snippet": "int git_refdb_iterator(git_reference_iterator **out, git_refdb *db, const char *glob)\n{\n\tif (!db->backend || !db->backend->iterator) {\n\t\tgiterr_set(GITERR_REFERENCE, \"This backend doesn't support iterators\");\n\t\treturn -1;\n\t}\n\n\tif (db->backend->iterator(out, db->backend, glob) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(db);\n\t(*out)->db = db;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_iterator(git_reference_iterator **out, git_refdb *db, const char *glob)\n{\n\tif (!db->backend || !db->backend->iterator) {\n\t\tgiterr_set(GITERR_REFERENCE, \"This backend doesn't support iterators\");\n\t\treturn -1;\n\t}\n\n\tif (db->backend->iterator(out, db->backend, glob) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(db);\n\t(*out)->db = db;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_refdb__weakptr",
          "args": [
            "&refdb",
            "repo"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_refdb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "779-802",
          "snippet": "int git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_iterator_glob_new(\n\tgit_reference_iterator **out, git_repository *repo, const char *glob)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, glob);\n}"
  },
  {
    "function_name": "git_reference_iterator_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "711-719",
    "snippet": "int git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_iterator",
          "args": [
            "out",
            "refdb",
            "NULL"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_iterator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "126-140",
          "snippet": "int git_refdb_iterator(git_reference_iterator **out, git_refdb *db, const char *glob)\n{\n\tif (!db->backend || !db->backend->iterator) {\n\t\tgiterr_set(GITERR_REFERENCE, \"This backend doesn't support iterators\");\n\t\treturn -1;\n\t}\n\n\tif (db->backend->iterator(out, db->backend, glob) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(db);\n\t(*out)->db = db;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_iterator(git_reference_iterator **out, git_refdb *db, const char *glob)\n{\n\tif (!db->backend || !db->backend->iterator) {\n\t\tgiterr_set(GITERR_REFERENCE, \"This backend doesn't support iterators\");\n\t\treturn -1;\n\t}\n\n\tif (db->backend->iterator(out, db->backend, glob) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(db);\n\t(*out)->db = db;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_refdb__weakptr",
          "args": [
            "&refdb",
            "repo"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_refdb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "779-802",
          "snippet": "int git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}"
  },
  {
    "function_name": "git_reference_foreach_glob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "684-709",
    "snippet": "int git_reference_foreach_glob(\n\tgit_repository *repo,\n\tconst char *glob,\n\tgit_reference_foreach_name_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tconst char *refname;\n\tint error;\n\n\tif ((error = git_reference_iterator_glob_new(&iter, repo, glob)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next_name(&refname, iter))) {\n\t\tif ((error = callback(refname, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_iterator_free",
          "args": [
            "iter"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "742-748",
          "snippet": "void git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "refname",
            "payload"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_next_name",
          "args": [
            "&refname",
            "iter"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_next_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "737-740",
          "snippet": "int git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_iterator_glob_new",
          "args": [
            "&iter",
            "repo",
            "glob"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_glob_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "721-730",
          "snippet": "int git_reference_iterator_glob_new(\n\tgit_reference_iterator **out, git_repository *repo, const char *glob)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, glob);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_iterator_glob_new(\n\tgit_reference_iterator **out, git_repository *repo, const char *glob)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, glob);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_foreach_glob(\n\tgit_repository *repo,\n\tconst char *glob,\n\tgit_reference_foreach_name_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tconst char *refname;\n\tint error;\n\n\tif ((error = git_reference_iterator_glob_new(&iter, repo, glob)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next_name(&refname, iter))) {\n\t\tif ((error = callback(refname, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference_foreach_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "658-682",
    "snippet": "int git_reference_foreach_name(\n\tgit_repository *repo,\n\tgit_reference_foreach_name_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tconst char *refname;\n\tint error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next_name(&refname, iter))) {\n\t\tif ((error = callback(refname, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_iterator_free",
          "args": [
            "iter"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "742-748",
          "snippet": "void git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "refname",
            "payload"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_next_name",
          "args": [
            "&refname",
            "iter"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_next_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "737-740",
          "snippet": "int git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_iterator_new",
          "args": [
            "&iter",
            "repo"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "711-719",
          "snippet": "int git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_foreach_name(\n\tgit_repository *repo,\n\tgit_reference_foreach_name_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tconst char *refname;\n\tint error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next_name(&refname, iter))) {\n\t\tif ((error = callback(refname, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "632-656",
    "snippet": "int git_reference_foreach(\n\tgit_repository *repo,\n\tgit_reference_foreach_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tgit_reference *ref;\n\tint error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next(&ref, iter))) {\n\t\tif ((error = callback(ref, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_iterator_free",
          "args": [
            "iter"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "742-748",
          "snippet": "void git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "ref",
            "payload"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_next",
          "args": [
            "&ref",
            "iter"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_next_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "737-740",
          "snippet": "int git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_iterator_new",
          "args": [
            "&iter",
            "repo"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "711-719",
          "snippet": "int git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_foreach(\n\tgit_repository *repo,\n\tgit_reference_foreach_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tgit_reference *ref;\n\tint error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next(&ref, iter))) {\n\t\tif ((error = callback(ref, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "617-630",
    "snippet": "int git_reference_resolve(git_reference **ref_out, const git_reference *ref)\n{\n\tswitch (git_reference_type(ref)) {\n\tcase GIT_REF_OID:\n\t\treturn git_reference_lookup(ref_out, ref->db->repo, ref->name);\n\n\tcase GIT_REF_SYMBOLIC:\n\t\treturn git_reference_lookup_resolved(ref_out, ref->db->repo, ref->target.symbolic, -1);\n\n\tdefault:\n\t\tgiterr_set(GITERR_REFERENCE, \"Invalid reference\");\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Invalid reference\""
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup_resolved",
          "args": [
            "ref_out",
            "ref->db->repo",
            "ref->target.symbolic",
            "-1"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "181-234",
          "snippet": "int git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [
            "#define MAX_NESTING_LEVEL\t\t10",
            "#define DEFAULT_NESTING_LEVEL\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\n#define MAX_NESTING_LEVEL\t\t10\n#define DEFAULT_NESTING_LEVEL\t5\n\nint git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "ref_out",
            "ref->db->repo",
            "ref->name"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_type",
          "args": [
            "ref"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "303-307",
          "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_resolve(git_reference **ref_out, const git_reference *ref)\n{\n\tswitch (git_reference_type(ref)) {\n\tcase GIT_REF_OID:\n\t\treturn git_reference_lookup(ref_out, ref->db->repo, ref->name);\n\n\tcase GIT_REF_SYMBOLIC:\n\t\treturn git_reference_lookup_resolved(ref_out, ref->db->repo, ref->target.symbolic, -1);\n\n\tdefault:\n\t\tgiterr_set(GITERR_REFERENCE, \"Invalid reference\");\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "git_reference_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "598-615",
    "snippet": "int git_reference_rename(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *new_name,\n\tint force,\n\tconst char *log_message)\n{\n\tgit_signature *who;\n\tint error;\n\n\tif ((error = git_reference__log_signature(&who, ref->db->repo)) < 0)\n\t\treturn error;\n\n\terror = reference__rename(out, ref, new_name, force, who, log_message);\n\tgit_signature_free(who);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_signature_free",
          "args": [
            "who"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "14-24",
          "snippet": "void git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference__rename",
          "args": [
            "out",
            "ref",
            "new_name",
            "force",
            "who",
            "log_message"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "reference__rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "564-595",
          "snippet": "static int reference__rename(git_reference **out, git_reference *ref, const char *new_name, int force,\n\t\t\t\t const git_signature *signature, const char *message)\n{\n\tgit_refname_t normalized;\n\tbool should_head_be_updated = false;\n\tint error = 0;\n\n\tassert(ref && new_name && signature);\n\n\tif ((error = reference_normalize_for_repo(\n\t\t\tnormalized, git_reference_owner(ref), new_name)) < 0)\n\t\treturn error;\n\n\n\t/* Check if we have to update HEAD. */\n\tif ((error = git_branch_is_head(ref)) < 0)\n\t\treturn error;\n\n\tshould_head_be_updated = (error > 0);\n\n\tif ((error = git_refdb_rename(out, ref->db, ref->name, normalized, force, signature, message)) < 0)\n\t\treturn error;\n\n\t/* Update HEAD it was pointing to the reference being renamed */\n\tif (should_head_be_updated &&\n\t\t(error = git_repository_set_head(ref->db->repo, normalized)) < 0) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Failed to update HEAD after renaming reference\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference__rename(git_reference **out, git_reference *ref, const char *new_name, int force,\n\t\t\t\t const git_signature *signature, const char *message)\n{\n\tgit_refname_t normalized;\n\tbool should_head_be_updated = false;\n\tint error = 0;\n\n\tassert(ref && new_name && signature);\n\n\tif ((error = reference_normalize_for_repo(\n\t\t\tnormalized, git_reference_owner(ref), new_name)) < 0)\n\t\treturn error;\n\n\n\t/* Check if we have to update HEAD. */\n\tif ((error = git_branch_is_head(ref)) < 0)\n\t\treturn error;\n\n\tshould_head_be_updated = (error > 0);\n\n\tif ((error = git_refdb_rename(out, ref->db, ref->name, normalized, force, signature, message)) < 0)\n\t\treturn error;\n\n\t/* Update HEAD it was pointing to the reference being renamed */\n\tif (should_head_be_updated &&\n\t\t(error = git_repository_set_head(ref->db->repo, normalized)) < 0) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Failed to update HEAD after renaming reference\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__log_signature",
          "args": [
            "&who",
            "ref->db->repo"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__log_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "425-437",
          "snippet": "int git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_rename(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *new_name,\n\tint force,\n\tconst char *log_message)\n{\n\tgit_signature *who;\n\tint error;\n\n\tif ((error = git_reference__log_signature(&who, ref->db->repo)) < 0)\n\t\treturn error;\n\n\terror = reference__rename(out, ref, new_name, force, who, log_message);\n\tgit_signature_free(who);\n\n\treturn error;\n}"
  },
  {
    "function_name": "reference__rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "564-595",
    "snippet": "static int reference__rename(git_reference **out, git_reference *ref, const char *new_name, int force,\n\t\t\t\t const git_signature *signature, const char *message)\n{\n\tgit_refname_t normalized;\n\tbool should_head_be_updated = false;\n\tint error = 0;\n\n\tassert(ref && new_name && signature);\n\n\tif ((error = reference_normalize_for_repo(\n\t\t\tnormalized, git_reference_owner(ref), new_name)) < 0)\n\t\treturn error;\n\n\n\t/* Check if we have to update HEAD. */\n\tif ((error = git_branch_is_head(ref)) < 0)\n\t\treturn error;\n\n\tshould_head_be_updated = (error > 0);\n\n\tif ((error = git_refdb_rename(out, ref->db, ref->name, normalized, force, signature, message)) < 0)\n\t\treturn error;\n\n\t/* Update HEAD it was pointing to the reference being renamed */\n\tif (should_head_be_updated &&\n\t\t(error = git_repository_set_head(ref->db->repo, normalized)) < 0) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Failed to update HEAD after renaming reference\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Failed to update HEAD after renaming reference\""
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_set_head",
          "args": [
            "ref->db->repo",
            "normalized"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_set_head_detached_from_annotated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "2167-2174",
          "snippet": "int git_repository_set_head_detached_from_annotated(\n\tgit_repository *repo,\n\tconst git_annotated_commit *commitish)\n{\n\tassert(repo && commitish);\n\n\treturn detach(repo, git_annotated_commit_id(commitish), commitish->ref_name);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_set_head_detached_from_annotated(\n\tgit_repository *repo,\n\tconst git_annotated_commit *commitish)\n{\n\tassert(repo && commitish);\n\n\treturn detach(repo, git_annotated_commit_id(commitish), commitish->ref_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refdb_rename",
          "args": [
            "out",
            "ref->db",
            "ref->name",
            "normalized",
            "force",
            "signature",
            "message"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "176-198",
          "snippet": "int git_refdb_rename(\n\tgit_reference **out,\n\tgit_refdb *db,\n\tconst char *old_name,\n\tconst char *new_name,\n\tint force,\n\tconst git_signature *who,\n\tconst char *message)\n{\n\tint error;\n\n\tassert(db && db->backend);\n\terror = db->backend->rename(out, db->backend, old_name, new_name, force, who, message);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (out) {\n\t\tGIT_REFCOUNT_INC(db);\n\t\t(*out)->db = db;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_rename(\n\tgit_reference **out,\n\tgit_refdb *db,\n\tconst char *old_name,\n\tconst char *new_name,\n\tint force,\n\tconst git_signature *who,\n\tconst char *message)\n{\n\tint error;\n\n\tassert(db && db->backend);\n\terror = db->backend->rename(out, db->backend, old_name, new_name, force, who, message);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (out) {\n\t\tGIT_REFCOUNT_INC(db);\n\t\t(*out)->db = db;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_is_head",
          "args": [
            "ref"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_is_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "631-658",
          "snippet": "int git_branch_is_head(\n\t\tconst git_reference *branch)\n{\n\tgit_reference *head;\n\tbool is_same = false;\n\tint error;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn false;\n\n\terror = git_repository_head(&head, git_reference_owner(branch));\n\n\tif (error == GIT_EUNBORNBRANCH || error == GIT_ENOTFOUND)\n\t\treturn false;\n\n\tif (error < 0)\n\t\treturn -1;\n\n\tis_same = strcmp(\n\t\tgit_reference_name(branch),\n\t\tgit_reference_name(head)) == 0;\n\n\tgit_reference_free(head);\n\n\treturn is_same;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_is_head(\n\t\tconst git_reference *branch)\n{\n\tgit_reference *head;\n\tbool is_same = false;\n\tint error;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn false;\n\n\terror = git_repository_head(&head, git_reference_owner(branch));\n\n\tif (error == GIT_EUNBORNBRANCH || error == GIT_ENOTFOUND)\n\t\treturn false;\n\n\tif (error < 0)\n\t\treturn -1;\n\n\tis_same = strcmp(\n\t\tgit_reference_name(branch),\n\t\tgit_reference_name(head)) == 0;\n\n\tgit_reference_free(head);\n\n\treturn is_same;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference_normalize_for_repo",
          "args": [
            "normalized",
            "git_reference_owner(ref)",
            "new_name"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "reference_normalize_for_repo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "166-179",
          "snippet": "static int reference_normalize_for_repo(\n\tgit_refname_t out,\n\tgit_repository *repo,\n\tconst char *name)\n{\n\tint precompose;\n\tunsigned int flags = GIT_REF_FORMAT_ALLOW_ONELEVEL;\n\n\tif (!git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) &&\n\t\tprecompose)\n\t\tflags |= GIT_REF_FORMAT__PRECOMPOSE_UNICODE;\n\n\treturn git_reference_normalize_name(out, GIT_REFNAME_MAX, name, flags);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference_normalize_for_repo(\n\tgit_refname_t out,\n\tgit_repository *repo,\n\tconst char *name)\n{\n\tint precompose;\n\tunsigned int flags = GIT_REF_FORMAT_ALLOW_ONELEVEL;\n\n\tif (!git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) &&\n\t\tprecompose)\n\t\tflags |= GIT_REF_FORMAT__PRECOMPOSE_UNICODE;\n\n\treturn git_reference_normalize_name(out, GIT_REFNAME_MAX, name, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_owner",
          "args": [
            "ref"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "315-319",
          "snippet": "git_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref && new_name && signature"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference__rename(git_reference **out, git_reference *ref, const char *new_name, int force,\n\t\t\t\t const git_signature *signature, const char *message)\n{\n\tgit_refname_t normalized;\n\tbool should_head_be_updated = false;\n\tint error = 0;\n\n\tassert(ref && new_name && signature);\n\n\tif ((error = reference_normalize_for_repo(\n\t\t\tnormalized, git_reference_owner(ref), new_name)) < 0)\n\t\treturn error;\n\n\n\t/* Check if we have to update HEAD. */\n\tif ((error = git_branch_is_head(ref)) < 0)\n\t\treturn error;\n\n\tshould_head_be_updated = (error > 0);\n\n\tif ((error = git_refdb_rename(out, ref->db, ref->name, normalized, force, signature, message)) < 0)\n\t\treturn error;\n\n\t/* Update HEAD it was pointing to the reference being renamed */\n\tif (should_head_be_updated &&\n\t\t(error = git_repository_set_head(ref->db->repo, normalized)) < 0) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Failed to update HEAD after renaming reference\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_reference_symbolic_set_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "547-562",
    "snippet": "int git_reference_symbolic_set_target(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *target,\n\tconst char *log_message)\n{\n\tint error;\n\n\tassert(out && ref && target);\n\n\tif ((error = ensure_is_an_updatable_symbolic_reference(ref)) < 0)\n\t\treturn error;\n\n\treturn git_reference_symbolic_create_matching(\n\t\tout, ref->db->repo, ref->name, target, 1, ref->target.symbolic, log_message);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_symbolic_create_matching",
          "args": [
            "out",
            "ref->db->repo",
            "ref->name",
            "target",
            "1",
            "ref->target.symbolic",
            "log_message"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_symbolic_create_matching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "475-497",
          "snippet": "int git_reference_symbolic_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *target,\n\tint force,\n\tconst char *old_target,\n\tconst char *log_message)\n{\n\tint error;\n\tgit_signature *who = NULL;\n\n\tassert(target);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, NULL, target, force, who, log_message, NULL, old_target);\n\n\tgit_signature_free(who);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_symbolic_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *target,\n\tint force,\n\tconst char *old_target,\n\tconst char *log_message)\n{\n\tint error;\n\tgit_signature *who = NULL;\n\n\tassert(target);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, NULL, target, force, who, log_message, NULL, old_target);\n\n\tgit_signature_free(who);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_is_an_updatable_symbolic_reference",
          "args": [
            "ref"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_is_an_updatable_symbolic_reference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "538-545",
          "snippet": "static int ensure_is_an_updatable_symbolic_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set symbolic target on a direct reference\");\n\treturn -1;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int ensure_is_an_updatable_symbolic_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set symbolic target on a direct reference\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && ref && target"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_symbolic_set_target(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *target,\n\tconst char *log_message)\n{\n\tint error;\n\n\tassert(out && ref && target);\n\n\tif ((error = ensure_is_an_updatable_symbolic_reference(ref)) < 0)\n\t\treturn error;\n\n\treturn git_reference_symbolic_create_matching(\n\t\tout, ref->db->repo, ref->name, target, 1, ref->target.symbolic, log_message);\n}"
  },
  {
    "function_name": "ensure_is_an_updatable_symbolic_reference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "538-545",
    "snippet": "static int ensure_is_an_updatable_symbolic_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set symbolic target on a direct reference\");\n\treturn -1;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Cannot set symbolic target on a direct reference\""
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int ensure_is_an_updatable_symbolic_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set symbolic target on a direct reference\");\n\treturn -1;\n}"
  },
  {
    "function_name": "git_reference_set_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "519-536",
    "snippet": "int git_reference_set_target(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst git_oid *id,\n\tconst char *log_message)\n{\n\tint error;\n\tgit_repository *repo;\n\n\tassert(out && ref && id);\n\n\trepo = ref->db->repo;\n\n\tif ((error = ensure_is_an_updatable_direct_reference(ref)) < 0)\n\t\treturn error;\n\n\treturn git_reference_create_matching(out, repo, ref->name, id, 1, &ref->target.oid, log_message);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_create_matching",
          "args": [
            "out",
            "repo",
            "ref->name",
            "id",
            "1",
            "&ref->target.oid",
            "log_message"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create_matching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "439-462",
          "snippet": "int git_reference_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst git_oid *old_id,\n\tconst char *log_message)\n\n{\n\tint error;\n\tgit_signature *who = NULL;\n\t\n\tassert(id);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, id, NULL, force, who, log_message, old_id, NULL);\n\n\tgit_signature_free(who);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst git_oid *old_id,\n\tconst char *log_message)\n\n{\n\tint error;\n\tgit_signature *who = NULL;\n\t\n\tassert(id);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, id, NULL, force, who, log_message, old_id, NULL);\n\n\tgit_signature_free(who);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_is_an_updatable_direct_reference",
          "args": [
            "ref"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_is_an_updatable_direct_reference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "510-517",
          "snippet": "static int ensure_is_an_updatable_direct_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_OID)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set OID on symbolic reference\");\n\treturn -1;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int ensure_is_an_updatable_direct_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_OID)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set OID on symbolic reference\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && ref && id"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_set_target(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst git_oid *id,\n\tconst char *log_message)\n{\n\tint error;\n\tgit_repository *repo;\n\n\tassert(out && ref && id);\n\n\trepo = ref->db->repo;\n\n\tif ((error = ensure_is_an_updatable_direct_reference(ref)) < 0)\n\t\treturn error;\n\n\treturn git_reference_create_matching(out, repo, ref->name, id, 1, &ref->target.oid, log_message);\n}"
  },
  {
    "function_name": "ensure_is_an_updatable_direct_reference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "510-517",
    "snippet": "static int ensure_is_an_updatable_direct_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_OID)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set OID on symbolic reference\");\n\treturn -1;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Cannot set OID on symbolic reference\""
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int ensure_is_an_updatable_direct_reference(git_reference *ref)\n{\n\tif (ref->type == GIT_REF_OID)\n\t\treturn 0;\n\n\tgiterr_set(GITERR_REFERENCE, \"Cannot set OID on symbolic reference\");\n\treturn -1;\n}"
  },
  {
    "function_name": "git_reference_symbolic_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "499-508",
    "snippet": "int git_reference_symbolic_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *target,\n\tint force,\n\tconst char *log_message)\n{\n\treturn git_reference_symbolic_create_matching(ref_out, repo, name, target, force, NULL, log_message);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_symbolic_create_matching",
          "args": [
            "ref_out",
            "repo",
            "name",
            "target",
            "force",
            "NULL",
            "log_message"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_symbolic_create_matching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "475-497",
          "snippet": "int git_reference_symbolic_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *target,\n\tint force,\n\tconst char *old_target,\n\tconst char *log_message)\n{\n\tint error;\n\tgit_signature *who = NULL;\n\n\tassert(target);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, NULL, target, force, who, log_message, NULL, old_target);\n\n\tgit_signature_free(who);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_symbolic_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *target,\n\tint force,\n\tconst char *old_target,\n\tconst char *log_message)\n{\n\tint error;\n\tgit_signature *who = NULL;\n\n\tassert(target);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, NULL, target, force, who, log_message, NULL, old_target);\n\n\tgit_signature_free(who);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_symbolic_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *target,\n\tint force,\n\tconst char *log_message)\n{\n\treturn git_reference_symbolic_create_matching(ref_out, repo, name, target, force, NULL, log_message);\n}"
  },
  {
    "function_name": "git_reference_symbolic_create_matching",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "475-497",
    "snippet": "int git_reference_symbolic_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *target,\n\tint force,\n\tconst char *old_target,\n\tconst char *log_message)\n{\n\tint error;\n\tgit_signature *who = NULL;\n\n\tassert(target);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, NULL, target, force, who, log_message, NULL, old_target);\n\n\tgit_signature_free(who);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_signature_free",
          "args": [
            "who"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "14-24",
          "snippet": "void git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference__create",
          "args": [
            "ref_out",
            "repo",
            "name",
            "NULL",
            "target",
            "force",
            "who",
            "log_message",
            "NULL",
            "old_target"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "reference__create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "351-414",
          "snippet": "static int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__log_signature",
          "args": [
            "&who",
            "repo"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__log_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "425-437",
          "snippet": "int git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "target"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_symbolic_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *target,\n\tint force,\n\tconst char *old_target,\n\tconst char *log_message)\n{\n\tint error;\n\tgit_signature *who = NULL;\n\n\tassert(target);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, NULL, target, force, who, log_message, NULL, old_target);\n\n\tgit_signature_free(who);\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "464-473",
    "snippet": "int git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_create_matching",
          "args": [
            "ref_out",
            "repo",
            "name",
            "id",
            "force",
            "NULL",
            "log_message"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create_matching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "439-462",
          "snippet": "int git_reference_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst git_oid *old_id,\n\tconst char *log_message)\n\n{\n\tint error;\n\tgit_signature *who = NULL;\n\t\n\tassert(id);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, id, NULL, force, who, log_message, old_id, NULL);\n\n\tgit_signature_free(who);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst git_oid *old_id,\n\tconst char *log_message)\n\n{\n\tint error;\n\tgit_signature *who = NULL;\n\t\n\tassert(id);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, id, NULL, force, who, log_message, old_id, NULL);\n\n\tgit_signature_free(who);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}"
  },
  {
    "function_name": "git_reference_create_matching",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "439-462",
    "snippet": "int git_reference_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst git_oid *old_id,\n\tconst char *log_message)\n\n{\n\tint error;\n\tgit_signature *who = NULL;\n\t\n\tassert(id);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, id, NULL, force, who, log_message, old_id, NULL);\n\n\tgit_signature_free(who);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_signature_free",
          "args": [
            "who"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "14-24",
          "snippet": "void git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference__create",
          "args": [
            "ref_out",
            "repo",
            "name",
            "id",
            "NULL",
            "force",
            "who",
            "log_message",
            "old_id",
            "NULL"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "reference__create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "351-414",
          "snippet": "static int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__log_signature",
          "args": [
            "&who",
            "repo"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__log_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "425-437",
          "snippet": "int git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "id"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst git_oid *old_id,\n\tconst char *log_message)\n\n{\n\tint error;\n\tgit_signature *who = NULL;\n\t\n\tassert(id);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, id, NULL, force, who, log_message, old_id, NULL);\n\n\tgit_signature_free(who);\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference__log_signature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "425-437",
    "snippet": "int git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_signature_now",
          "args": [
            "&who",
            "\"unknown\"",
            "\"unknown\""
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "146-176",
          "snippet": "int git_signature_now(git_signature **sig_out, const char *name, const char *email)\n{\n\ttime_t now;\n\ttime_t offset;\n\tstruct tm *utc_tm;\n\tgit_signature *sig;\n\tstruct tm _utc;\n\n\t*sig_out = NULL;\n\n\t/*\n\t * Get the current time as seconds since the epoch and\n\t * transform that into a tm struct containing the time at\n\t * UTC. Give that to mktime which considers it a local time\n\t * (tm_isdst = -1 asks it to take DST into account) and gives\n\t * us that time as seconds since the epoch. The difference\n\t * between its return value and 'now' is our offset to UTC.\n\t */\n\ttime(&now);\n\tutc_tm = p_gmtime_r(&now, &_utc);\n\tutc_tm->tm_isdst = -1;\n\toffset = (time_t)difftime(now, mktime(utc_tm));\n\toffset /= 60;\n\n\tif (git_signature_new(&sig, name, email, now, (int)offset) < 0)\n\t\treturn -1;\n\n\t*sig_out = sig;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nint git_signature_now(git_signature **sig_out, const char *name, const char *email)\n{\n\ttime_t now;\n\ttime_t offset;\n\tstruct tm *utc_tm;\n\tgit_signature *sig;\n\tstruct tm _utc;\n\n\t*sig_out = NULL;\n\n\t/*\n\t * Get the current time as seconds since the epoch and\n\t * transform that into a tm struct containing the time at\n\t * UTC. Give that to mktime which considers it a local time\n\t * (tm_isdst = -1 asks it to take DST into account) and gives\n\t * us that time as seconds since the epoch. The difference\n\t * between its return value and 'now' is our offset to UTC.\n\t */\n\ttime(&now);\n\tutc_tm = p_gmtime_r(&now, &_utc);\n\tutc_tm->tm_isdst = -1;\n\toffset = (time_t)difftime(now, mktime(utc_tm));\n\toffset /= 60;\n\n\tif (git_signature_new(&sig, name, email, now, (int)offset) < 0)\n\t\treturn -1;\n\n\t*sig_out = sig;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature_default",
          "args": [
            "&who",
            "repo"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "178-193",
          "snippet": "int git_signature_default(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *cfg;\n\tconst char *user_name, *user_email;\n\n\tif ((error = git_repository_config_snapshot(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_config_get_string(&user_name, cfg, \"user.name\")) &&\n\t\t!(error = git_config_get_string(&user_email, cfg, \"user.email\")))\n\t\terror = git_signature_now(out, user_name, user_email);\n\n\tgit_config_free(cfg);\n\treturn error;\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nint git_signature_default(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *cfg;\n\tconst char *user_name, *user_email;\n\n\tif ((error = git_repository_config_snapshot(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_config_get_string(&user_name, cfg, \"user.name\")) &&\n\t\t!(error = git_config_get_string(&user_email, cfg, \"user.email\")))\n\t\terror = git_signature_now(out, user_name, user_email);\n\n\tgit_config_free(cfg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configured_ident",
          "args": [
            "&who",
            "repo"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "configured_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "416-423",
          "snippet": "int configured_ident(git_signature **out, const git_repository *repo)\n{\n\tif (repo->ident_name && repo->ident_email)\n\t\treturn git_signature_now(out, repo->ident_name, repo->ident_email);\n\n\t/* if not configured let us fall-through to the next method  */\n\treturn -1;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint configured_ident(git_signature **out, const git_repository *repo)\n{\n\tif (repo->ident_name && repo->ident_email)\n\t\treturn git_signature_now(out, repo->ident_name, repo->ident_email);\n\n\t/* if not configured let us fall-through to the next method  */\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}"
  },
  {
    "function_name": "configured_ident",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "416-423",
    "snippet": "int configured_ident(git_signature **out, const git_repository *repo)\n{\n\tif (repo->ident_name && repo->ident_email)\n\t\treturn git_signature_now(out, repo->ident_name, repo->ident_email);\n\n\t/* if not configured let us fall-through to the next method  */\n\treturn -1;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_signature_now",
          "args": [
            "out",
            "repo->ident_name",
            "repo->ident_email"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "146-176",
          "snippet": "int git_signature_now(git_signature **sig_out, const char *name, const char *email)\n{\n\ttime_t now;\n\ttime_t offset;\n\tstruct tm *utc_tm;\n\tgit_signature *sig;\n\tstruct tm _utc;\n\n\t*sig_out = NULL;\n\n\t/*\n\t * Get the current time as seconds since the epoch and\n\t * transform that into a tm struct containing the time at\n\t * UTC. Give that to mktime which considers it a local time\n\t * (tm_isdst = -1 asks it to take DST into account) and gives\n\t * us that time as seconds since the epoch. The difference\n\t * between its return value and 'now' is our offset to UTC.\n\t */\n\ttime(&now);\n\tutc_tm = p_gmtime_r(&now, &_utc);\n\tutc_tm->tm_isdst = -1;\n\toffset = (time_t)difftime(now, mktime(utc_tm));\n\toffset /= 60;\n\n\tif (git_signature_new(&sig, name, email, now, (int)offset) < 0)\n\t\treturn -1;\n\n\t*sig_out = sig;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nint git_signature_now(git_signature **sig_out, const char *name, const char *email)\n{\n\ttime_t now;\n\ttime_t offset;\n\tstruct tm *utc_tm;\n\tgit_signature *sig;\n\tstruct tm _utc;\n\n\t*sig_out = NULL;\n\n\t/*\n\t * Get the current time as seconds since the epoch and\n\t * transform that into a tm struct containing the time at\n\t * UTC. Give that to mktime which considers it a local time\n\t * (tm_isdst = -1 asks it to take DST into account) and gives\n\t * us that time as seconds since the epoch. The difference\n\t * between its return value and 'now' is our offset to UTC.\n\t */\n\ttime(&now);\n\tutc_tm = p_gmtime_r(&now, &_utc);\n\tutc_tm->tm_isdst = -1;\n\toffset = (time_t)difftime(now, mktime(utc_tm));\n\toffset /= 60;\n\n\tif (git_signature_new(&sig, name, email, now, (int)offset) < 0)\n\t\treturn -1;\n\n\t*sig_out = sig;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint configured_ident(git_signature **out, const git_repository *repo)\n{\n\tif (repo->ident_name && repo->ident_email)\n\t\treturn git_signature_now(out, repo->ident_name, repo->ident_email);\n\n\t/* if not configured let us fall-through to the next method  */\n\treturn -1;\n}"
  },
  {
    "function_name": "reference__create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "351-414",
    "snippet": "static int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refdb_write",
          "args": [
            "refdb",
            "ref",
            "force",
            "signature",
            "log_message",
            "old_id",
            "old_target"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "166-174",
          "snippet": "int git_refdb_write(git_refdb *db, git_reference *ref, int force, const git_signature *who, const char *message, const git_oid *old_id, const char *old_target)\n{\n\tassert(db && db->backend);\n\n\tGIT_REFCOUNT_INC(db);\n\tref->db = db;\n\n\treturn db->backend->write(db->backend, ref, force, who, message, old_id, old_target);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_write(git_refdb *db, git_reference *ref, int force, const git_signature *who, const char *message, const git_oid *old_id, const char *old_target)\n{\n\tassert(db && db->backend);\n\n\tGIT_REFCOUNT_INC(db);\n\tref->db = db;\n\n\treturn db->backend->write(db->backend, ref, force, who, message, old_id, old_target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "ref"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference__alloc_symbolic",
          "args": [
            "normalized",
            "normalized_target"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__alloc_symbolic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "50-69",
          "snippet": "git_reference *git_reference__alloc_symbolic(\n\tconst char *name, const char *target)\n{\n\tgit_reference *ref;\n\n\tassert(name && target);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_SYMBOLIC;\n\n\tif ((ref->target.symbolic = git__strdup(target)) == NULL) {\n\t\tgit__free(ref);\n\t\treturn NULL;\n\t}\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc_symbolic(\n\tconst char *name, const char *target)\n{\n\tgit_reference *ref;\n\n\tassert(name && target);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_SYMBOLIC;\n\n\tif ((ref->target.symbolic = git__strdup(target)) == NULL) {\n\t\tgit__free(ref);\n\t\treturn NULL;\n\t}\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference_normalize_for_repo",
          "args": [
            "normalized_target",
            "repo",
            "symbolic"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "reference_normalize_for_repo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "166-179",
          "snippet": "static int reference_normalize_for_repo(\n\tgit_refname_t out,\n\tgit_repository *repo,\n\tconst char *name)\n{\n\tint precompose;\n\tunsigned int flags = GIT_REF_FORMAT_ALLOW_ONELEVEL;\n\n\tif (!git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) &&\n\t\tprecompose)\n\t\tflags |= GIT_REF_FORMAT__PRECOMPOSE_UNICODE;\n\n\treturn git_reference_normalize_name(out, GIT_REFNAME_MAX, name, flags);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference_normalize_for_repo(\n\tgit_refname_t out,\n\tgit_repository *repo,\n\tconst char *name)\n{\n\tint precompose;\n\tunsigned int flags = GIT_REF_FORMAT_ALLOW_ONELEVEL;\n\n\tif (!git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) &&\n\t\tprecompose)\n\t\tflags |= GIT_REF_FORMAT__PRECOMPOSE_UNICODE;\n\n\treturn git_reference_normalize_name(out, GIT_REFNAME_MAX, name, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__alloc",
          "args": [
            "normalized",
            "oid",
            "NULL"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "71-91",
          "snippet": "git_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Target OID for the reference doesn't exist on the repository\""
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object__is_valid",
          "args": [
            "repo",
            "oid",
            "GIT_OBJ_ANY"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "git_object__is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "467-489",
          "snippet": "bool git_object__is_valid(\n\tgit_repository *repo, const git_oid *id, git_otype expected_type)\n{\n\tgit_odb *odb;\n\tgit_otype actual_type;\n\tsize_t len;\n\tint error;\n\n\tif (!git_object__strict_input_validation)\n\t\treturn true;\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_read_header(&len, &actual_type, odb, id)) < 0)\n\t\treturn false;\n\n\tif (expected_type != GIT_OBJ_ANY && expected_type != actual_type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"the requested type does not match the type in the ODB\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool git_object__strict_input_validation = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nbool git_object__strict_input_validation = true;\n\nbool git_object__is_valid(\n\tgit_repository *repo, const git_oid *id, git_otype expected_type)\n{\n\tgit_odb *odb;\n\tgit_otype actual_type;\n\tsize_t len;\n\tint error;\n\n\tif (!git_object__strict_input_validation)\n\t\treturn true;\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_read_header(&len, &actual_type, odb, id)) < 0)\n\t\treturn false;\n\n\tif (expected_type != GIT_OBJ_ANY && expected_type != actual_type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"the requested type does not match the type in the ODB\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "symbolic == NULL"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_refdb__weakptr",
          "args": [
            "&refdb",
            "repo"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_refdb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "779-802",
          "snippet": "int git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "symbolic || signature"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && name"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference__create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst char *symbolic,\n\tint force,\n\tconst git_signature *signature,\n\tconst char *log_message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\tgit_refname_t normalized;\n\tgit_refdb *refdb;\n\tgit_reference *ref = NULL;\n\tint error = 0;\n\n\tassert(repo && name);\n\tassert(symbolic || signature);\n\n\tif (ref_out)\n\t\t*ref_out = NULL;\n\n\terror = reference_normalize_for_repo(normalized, repo, name);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_repository_refdb__weakptr(&refdb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (oid != NULL) {\n\t\tassert(symbolic == NULL);\n\n\t\tif (!git_object__is_valid(repo, oid, GIT_OBJ_ANY)) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Target OID for the reference doesn't exist on the repository\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tref = git_reference__alloc(normalized, oid, NULL);\n\t} else {\n\t\tgit_refname_t normalized_target;\n\n\t\tif ((error = reference_normalize_for_repo(normalized_target, repo, symbolic)) < 0)\n\t\t\treturn error;\n\n\t\tref = git_reference__alloc_symbolic(normalized, normalized_target);\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\n\tif ((error = git_refdb_write(refdb, ref, force, signature, log_message, old_id, old_target)) < 0) {\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\tif (ref_out == NULL)\n\t\tgit_reference_free(ref);\n\telse\n\t\t*ref_out = ref;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_reference_symbolic_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "341-349",
    "snippet": "const char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}"
  },
  {
    "function_name": "git_reference_target_peel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "331-339",
    "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&ref->peel"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
  },
  {
    "function_name": "git_reference_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "321-329",
    "snippet": "const git_oid *git_reference_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID)\n\t\treturn NULL;\n\n\treturn &ref->target.oid;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID)\n\t\treturn NULL;\n\n\treturn &ref->target.oid;\n}"
  },
  {
    "function_name": "git_reference_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "315-319",
    "snippet": "git_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}"
  },
  {
    "function_name": "git_reference_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "309-313",
    "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
  },
  {
    "function_name": "git_reference_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "303-307",
    "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
  },
  {
    "function_name": "git_reference_dwim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "236-298",
    "snippet": "int git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&refnamebuf"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"no reference found for shorthand '%s'\"",
            "refname"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&name"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup_resolved",
          "args": [
            "&ref",
            "repo",
            "git_buf_cstr(&refnamebuf)",
            "-1"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "181-234",
          "snippet": "int git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [
            "#define MAX_NESTING_LEVEL\t\t10",
            "#define DEFAULT_NESTING_LEVEL\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\n#define MAX_NESTING_LEVEL\t\t10\n#define DEFAULT_NESTING_LEVEL\t5\n\nint git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_valid_name",
          "args": [
            "git_buf_cstr(&refnamebuf)"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1279-1282",
          "snippet": "int git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&refnamebuf",
            "formatters[i]",
            "git_buf_cstr(&name)"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&refnamebuf"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&name",
            "GIT_HEAD_FILE"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}"
  },
  {
    "function_name": "git_reference_lookup_resolved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "181-234",
    "snippet": "int git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [
      "#define MAX_NESTING_LEVEL\t\t10",
      "#define DEFAULT_NESTING_LEVEL\t5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Cannot resolve reference (>%u levels deep)\"",
            "max_nesting"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refdb_lookup",
          "args": [
            "&ref",
            "refdb",
            "scan_name"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "108-124",
          "snippet": "int git_refdb_lookup(git_reference **out, git_refdb *db, const char *ref_name)\n{\n\tgit_reference *ref;\n\tint error;\n\n\tassert(db && db->backend && out && ref_name);\n\n\terror = db->backend->lookup(&ref, db->backend, ref_name);\n\tif (error < 0)\n\t\treturn error;\n\n\tGIT_REFCOUNT_INC(db);\n\tref->db = db;\n\n\t*out = ref;\n\treturn 0;\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_lookup(git_reference **out, git_refdb *db, const char *ref_name)\n{\n\tgit_reference *ref;\n\tint error;\n\n\tassert(db && db->backend && out && ref_name);\n\n\terror = db->backend->lookup(&ref, db->backend, ref_name);\n\tif (error < 0)\n\t\treturn error;\n\n\tGIT_REFCOUNT_INC(db);\n\tref->db = db;\n\n\t*out = ref;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "scan_name",
            "ref->target.symbolic",
            "sizeof(scan_name)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_refdb__weakptr",
          "args": [
            "&refdb",
            "repo"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_refdb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "779-802",
          "snippet": "int git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference_normalize_for_repo",
          "args": [
            "scan_name",
            "repo",
            "name"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "reference_normalize_for_repo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "166-179",
          "snippet": "static int reference_normalize_for_repo(\n\tgit_refname_t out,\n\tgit_repository *repo,\n\tconst char *name)\n{\n\tint precompose;\n\tunsigned int flags = GIT_REF_FORMAT_ALLOW_ONELEVEL;\n\n\tif (!git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) &&\n\t\tprecompose)\n\t\tflags |= GIT_REF_FORMAT__PRECOMPOSE_UNICODE;\n\n\treturn git_reference_normalize_name(out, GIT_REFNAME_MAX, name, flags);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference_normalize_for_repo(\n\tgit_refname_t out,\n\tgit_repository *repo,\n\tconst char *name)\n{\n\tint precompose;\n\tunsigned int flags = GIT_REF_FORMAT_ALLOW_ONELEVEL;\n\n\tif (!git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) &&\n\t\tprecompose)\n\t\tflags |= GIT_REF_FORMAT__PRECOMPOSE_UNICODE;\n\n\treturn git_reference_normalize_name(out, GIT_REFNAME_MAX, name, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref_out && repo && name"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\n#define MAX_NESTING_LEVEL\t\t10\n#define DEFAULT_NESTING_LEVEL\t5\n\nint git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}"
  },
  {
    "function_name": "reference_normalize_for_repo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "166-179",
    "snippet": "static int reference_normalize_for_repo(\n\tgit_refname_t out,\n\tgit_repository *repo,\n\tconst char *name)\n{\n\tint precompose;\n\tunsigned int flags = GIT_REF_FORMAT_ALLOW_ONELEVEL;\n\n\tif (!git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) &&\n\t\tprecompose)\n\t\tflags |= GIT_REF_FORMAT__PRECOMPOSE_UNICODE;\n\n\treturn git_reference_normalize_name(out, GIT_REFNAME_MAX, name, flags);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_normalize_name",
          "args": [
            "out",
            "GIT_REFNAME_MAX",
            "name",
            "flags"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_normalize_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "976-1003",
          "snippet": "int git_reference_normalize_name(\n\tchar *buffer_out,\n\tsize_t buffer_size,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_reference__normalize_name(&buf, name, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_len(&buf) > buffer_size - 1) {\n\t\tgiterr_set(\n\t\tGITERR_REFERENCE,\n\t\t\"The provided buffer is too short to hold the normalization of '%s'\", name);\n\t\terror = GIT_EBUFS;\n\t\tgoto cleanup;\n\t}\n\n\tgit_buf_copy_cstr(buffer_out, buffer_size, &buf);\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_normalize_name(\n\tchar *buffer_out,\n\tsize_t buffer_size,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_reference__normalize_name(&buf, name, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_len(&buf) > buffer_size - 1) {\n\t\tgiterr_set(\n\t\tGITERR_REFERENCE,\n\t\t\"The provided buffer is too short to hold the normalization of '%s'\", name);\n\t\terror = GIT_EBUFS;\n\t\tgoto cleanup;\n\t}\n\n\tgit_buf_copy_cstr(buffer_out, buffer_size, &buf);\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&precompose",
            "repo",
            "GIT_CVAR_PRECOMPOSE"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reference_normalize_for_repo(\n\tgit_refname_t out,\n\tgit_repository *repo,\n\tconst char *name)\n{\n\tint precompose;\n\tunsigned int flags = GIT_REF_FORMAT_ALLOW_ONELEVEL;\n\n\tif (!git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) &&\n\t\tprecompose)\n\t\tflags |= GIT_REF_FORMAT__PRECOMPOSE_UNICODE;\n\n\treturn git_reference_normalize_name(out, GIT_REFNAME_MAX, name, flags);\n}"
  },
  {
    "function_name": "git_reference_name_to_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "152-164",
    "snippet": "int git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "out",
            "git_reference_target(ref)"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "ref"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup_resolved",
          "args": [
            "&ref",
            "repo",
            "name",
            "-1"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "181-234",
          "snippet": "int git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [
            "#define MAX_NESTING_LEVEL\t\t10",
            "#define DEFAULT_NESTING_LEVEL\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\n#define MAX_NESTING_LEVEL\t\t10\n#define DEFAULT_NESTING_LEVEL\t5\n\nint git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_reference_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "146-150",
    "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_lookup_resolved",
          "args": [
            "ref_out",
            "repo",
            "name",
            "0"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "181-234",
          "snippet": "int git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [
            "#define MAX_NESTING_LEVEL\t\t10",
            "#define DEFAULT_NESTING_LEVEL\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\n#define MAX_NESTING_LEVEL\t\t10\n#define DEFAULT_NESTING_LEVEL\t5\n\nint git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
  },
  {
    "function_name": "git_reference_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "135-144",
    "snippet": "int git_reference_remove(git_repository *repo, const char *name)\n{\n\tgit_refdb *db;\n\tint error;\n\n\tif ((error = git_repository_refdb__weakptr(&db, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_delete(db, name, NULL, NULL);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_delete",
          "args": [
            "db",
            "name",
            "NULL",
            "NULL"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "200-204",
          "snippet": "int git_refdb_delete(struct git_refdb *db, const char *ref_name, const git_oid *old_id, const char *old_target)\n{\n\tassert(db && db->backend);\n\treturn db->backend->del(db->backend, ref_name, old_id, old_target);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_delete(struct git_refdb *db, const char *ref_name, const git_oid *old_id, const char *old_target)\n{\n\tassert(db && db->backend);\n\treturn db->backend->del(db->backend, ref_name, old_id, old_target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_refdb__weakptr",
          "args": [
            "&db",
            "repo"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_refdb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "779-802",
          "snippet": "int git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_refdb__weakptr(git_refdb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_refdb == NULL) {\n\t\tgit_refdb *refdb;\n\n\t\terror = git_refdb_open(&refdb, repo);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(refdb, repo);\n\n\t\t\trefdb = git__compare_and_swap(&repo->_refdb, NULL, refdb);\n\t\t\tif (refdb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(refdb, NULL);\n\t\t\t\tgit_refdb_free(refdb);\n\t\t\t}\n\t\t}\n\t}\n\n\t*out = repo->_refdb;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_remove(git_repository *repo, const char *name)\n{\n\tgit_refdb *db;\n\tint error;\n\n\tif ((error = git_repository_refdb__weakptr(&db, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_delete(db, name, NULL, NULL);\n}"
  },
  {
    "function_name": "git_reference_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "122-133",
    "snippet": "int git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_delete",
          "args": [
            "ref->db",
            "ref->name",
            "old_id",
            "old_target"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "200-204",
          "snippet": "int git_refdb_delete(struct git_refdb *db, const char *ref_name, const git_oid *old_id, const char *old_target)\n{\n\tassert(db && db->backend);\n\treturn db->backend->del(db->backend, ref_name, old_id, old_target);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_delete(struct git_refdb *db, const char *ref_name, const git_oid *old_id, const char *old_target)\n{\n\tassert(db && db->backend);\n\treturn db->backend->del(db->backend, ref_name, old_id, old_target);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}"
  },
  {
    "function_name": "git_reference_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "108-120",
    "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "reference"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_DEC",
          "args": [
            "reference->db",
            "git_refdb__free"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
  },
  {
    "function_name": "git_reference__set_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "93-106",
    "snippet": "git_reference *git_reference__set_name(\n\tgit_reference *ref, const char *name)\n{\n\tsize_t namelen = strlen(name);\n\tsize_t reflen;\n\tgit_reference *rewrite = NULL;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(rewrite = git__realloc(ref, reflen)) != NULL)\n\t\tmemcpy(rewrite->name, name, namelen + 1);\n\n\treturn rewrite;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rewrite->name",
            "name",
            "namelen + 1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__realloc",
          "args": [
            "ref",
            "reflen"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "git__realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "215-220",
          "snippet": "GIT_INLINE(void *) git__realloc(void *ptr, size_t size)\n{\n\tvoid *new_ptr = realloc(ptr, size);\n\tif (!new_ptr) giterr_set_oom();\n\treturn new_ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__realloc(void *ptr, size_t size)\n{\n\tvoid *new_ptr = realloc(ptr, size);\n\tif (!new_ptr) giterr_set_oom();\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&reflen",
            "reflen",
            "1"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&reflen",
            "sizeof(git_reference)",
            "namelen"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__set_name(\n\tgit_reference *ref, const char *name)\n{\n\tsize_t namelen = strlen(name);\n\tsize_t reflen;\n\tgit_reference *rewrite = NULL;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(rewrite = git__realloc(ref, reflen)) != NULL)\n\t\tmemcpy(rewrite->name, name, namelen + 1);\n\n\treturn rewrite;\n}"
  },
  {
    "function_name": "git_reference__alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "71-91",
    "snippet": "git_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&ref->peel",
            "peel"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ref",
          "args": [
            "name"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "37-48",
          "snippet": "static git_reference *alloc_ref(const char *name)\n{\n\tgit_reference *ref = NULL;\n\tsize_t namelen = strlen(name), reflen;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(ref = git__calloc(1, reflen)) != NULL)\n\t\tmemcpy(ref->name, name, namelen + 1);\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic git_reference *alloc_ref(const char *name)\n{\n\tgit_reference *ref = NULL;\n\tsize_t namelen = strlen(name), reflen;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(ref = git__calloc(1, reflen)) != NULL)\n\t\tmemcpy(ref->name, name, namelen + 1);\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name && oid"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}"
  },
  {
    "function_name": "git_reference__alloc_symbolic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "50-69",
    "snippet": "git_reference *git_reference__alloc_symbolic(\n\tconst char *name, const char *target)\n{\n\tgit_reference *ref;\n\n\tassert(name && target);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_SYMBOLIC;\n\n\tif ((ref->target.symbolic = git__strdup(target)) == NULL) {\n\t\tgit__free(ref);\n\t\treturn NULL;\n\t}\n\n\treturn ref;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "ref"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "target"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ref",
          "args": [
            "name"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "37-48",
          "snippet": "static git_reference *alloc_ref(const char *name)\n{\n\tgit_reference *ref = NULL;\n\tsize_t namelen = strlen(name), reflen;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(ref = git__calloc(1, reflen)) != NULL)\n\t\tmemcpy(ref->name, name, namelen + 1);\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic git_reference *alloc_ref(const char *name)\n{\n\tgit_reference *ref = NULL;\n\tsize_t namelen = strlen(name), reflen;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(ref = git__calloc(1, reflen)) != NULL)\n\t\tmemcpy(ref->name, name, namelen + 1);\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name && target"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc_symbolic(\n\tconst char *name, const char *target)\n{\n\tgit_reference *ref;\n\n\tassert(name && target);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_SYMBOLIC;\n\n\tif ((ref->target.symbolic = git__strdup(target)) == NULL) {\n\t\tgit__free(ref);\n\t\treturn NULL;\n\t}\n\n\treturn ref;\n}"
  },
  {
    "function_name": "alloc_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
    "lines": "37-48",
    "snippet": "static git_reference *alloc_ref(const char *name)\n{\n\tgit_reference *ref = NULL;\n\tsize_t namelen = strlen(name), reflen;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(ref = git__calloc(1, reflen)) != NULL)\n\t\tmemcpy(ref->name, name, namelen + 1);\n\n\treturn ref;\n}",
    "includes": [
      "#include <git2/commit.h>",
      "#include <git2/signature.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/refdb.h>",
      "#include <git2/refs.h>",
      "#include <git2/branch.h>",
      "#include <git2/oid.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ref->name",
            "name",
            "namelen + 1"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "reflen"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&reflen",
            "reflen",
            "1"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&reflen",
            "sizeof(git_reference)",
            "namelen"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic git_reference *alloc_ref(const char *name)\n{\n\tgit_reference *ref = NULL;\n\tsize_t namelen = strlen(name), reflen;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(ref = git__calloc(1, reflen)) != NULL)\n\t\tmemcpy(ref->name, name, namelen + 1);\n\n\treturn ref;\n}"
  }
]