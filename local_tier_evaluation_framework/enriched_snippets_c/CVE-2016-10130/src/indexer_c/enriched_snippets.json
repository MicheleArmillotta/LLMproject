[
  {
    "function_name": "git_indexer_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "1070-1095",
    "snippet": "void git_indexer_free(git_indexer *idx)\n{\n\tif (idx == NULL)\n\t\treturn;\n\n\tgit_vector_free_deep(&idx->objects);\n\n\tif (idx->pack && idx->pack->idx_cache) {\n\t\tstruct git_pack_entry *pentry;\n\t\tkh_foreach_value(\n\t\t\tidx->pack->idx_cache, pentry, { git__free(pentry); });\n\n\t\tgit_oidmap_free(idx->pack->idx_cache);\n\t}\n\n\tgit_vector_free_deep(&idx->deltas);\n\n\tif (!git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgit_packfile_free(idx->pack);\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t}\n\n\tgit_hash_ctx_cleanup(&idx->trailer);\n\tgit_hash_ctx_cleanup(&idx->hash_ctx);\n\tgit__free(idx);\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "GIT__USE_OIDMAP\n\nextern git_mutex git__mwindow_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "idx"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_ctx_cleanup",
          "args": [
            "&idx->hash_ctx"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "268-276",
          "snippet": "void git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_free",
          "args": [
            "idx->pack"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "988-1007",
          "snippet": "void git_packfile_free(struct git_pack_file *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tcache_free(&p->bases);\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mwindow_free_all_locked(&p->mwf);\n\t\tp_close(p->mwf.fd);\n\t}\n\n\tpack_index_free(p);\n\n\tgit__free(p->bad_object_sha1);\n\n\tgit_mutex_free(&p->lock);\n\tgit_mutex_free(&p->bases.lock);\n\tgit__free(p);\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nvoid git_packfile_free(struct git_pack_file *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tcache_free(&p->bases);\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mwindow_free_all_locked(&p->mwf);\n\t\tp_close(p->mwf.fd);\n\t}\n\n\tpack_index_free(p);\n\n\tgit__free(p->bad_object_sha1);\n\n\tgit_mutex_free(&p->lock);\n\tgit_mutex_free(&p->bases.lock);\n\tgit__free(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&idx->deltas"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oidmap_free",
          "args": [
            "idx->pack->idx_cache"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_foreach_value",
          "args": [
            "idx->pack->idx_cache",
            "pentry",
            "{ git__free(pentry); }"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nGIT__USE_OIDMAP\n\nextern git_mutex git__mwindow_mutex;\n\nvoid git_indexer_free(git_indexer *idx)\n{\n\tif (idx == NULL)\n\t\treturn;\n\n\tgit_vector_free_deep(&idx->objects);\n\n\tif (idx->pack && idx->pack->idx_cache) {\n\t\tstruct git_pack_entry *pentry;\n\t\tkh_foreach_value(\n\t\t\tidx->pack->idx_cache, pentry, { git__free(pentry); });\n\n\t\tgit_oidmap_free(idx->pack->idx_cache);\n\t}\n\n\tgit_vector_free_deep(&idx->deltas);\n\n\tif (!git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgit_packfile_free(idx->pack);\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t}\n\n\tgit_hash_ctx_cleanup(&idx->trailer);\n\tgit_hash_ctx_cleanup(&idx->hash_ctx);\n\tgit__free(idx);\n}"
  },
  {
    "function_name": "git_indexer_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "903-1068",
    "snippet": "int git_indexer_commit(git_indexer *idx, git_transfer_progress *stats)\n{\n\tgit_mwindow *w = NULL;\n\tunsigned int i, long_offsets = 0, left;\n\tint error;\n\tstruct git_pack_idx_header hdr;\n\tgit_buf filename = GIT_BUF_INIT;\n\tstruct entry *entry;\n\tgit_oid trailer_hash, file_hash;\n\tgit_hash_ctx ctx;\n\tgit_filebuf index_file = {0};\n\tvoid *packfile_trailer;\n\n\tif (!idx->parsed_header) {\n\t\tgiterr_set(GITERR_INDEXER, \"incomplete pack header\");\n\t\treturn -1;\n\t}\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\t/* Test for this before resolve_deltas(), as it plays with idx->off */\n\tif (idx->off + 20 < idx->pack->mwf.size) {\n\t\tgiterr_set(GITERR_INDEXER, \"unexpected data at the end of the pack\");\n\t\treturn -1;\n\t}\n\n\tpackfile_trailer = git_mwindow_open(&idx->pack->mwf, &w, idx->pack->mwf.size - GIT_OID_RAWSZ, GIT_OID_RAWSZ, &left);\n\tif (packfile_trailer == NULL) {\n\t\tgit_mwindow_close(&w);\n\t\tgoto on_error;\n\t}\n\n\t/* Compare the packfile trailer as it was sent to us and what we calculated */\n\tgit_oid_fromraw(&file_hash, packfile_trailer);\n\tgit_mwindow_close(&w);\n\n\tgit_hash_final(&trailer_hash, &idx->trailer);\n\tif (git_oid_cmp(&file_hash, &trailer_hash)) {\n\t\tgiterr_set(GITERR_INDEXER, \"packfile trailer mismatch\");\n\t\treturn -1;\n\t}\n\n\t/* Freeze the number of deltas */\n\tstats->total_deltas = stats->total_objects - stats->indexed_objects;\n\n\tif ((error = resolve_deltas(idx, stats)) < 0)\n\t\treturn error;\n\n\tif (stats->indexed_objects != stats->total_objects) {\n\t\tgiterr_set(GITERR_INDEXER, \"early EOF\");\n\t\treturn -1;\n\t}\n\n\tif (stats->local_objects > 0) {\n\t\tif (update_header_and_rehash(idx, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgit_hash_final(&trailer_hash, &idx->trailer);\n\t\twrite_at(idx, &trailer_hash, idx->pack->mwf.size - GIT_OID_RAWSZ, GIT_OID_RAWSZ);\n\t}\n\n\tgit_vector_sort(&idx->objects);\n\n\tgit_buf_sets(&filename, idx->pack->pack_name);\n\tgit_buf_shorten(&filename, strlen(\"pack\"));\n\tgit_buf_puts(&filename, \"idx\");\n\tif (git_buf_oom(&filename))\n\t\treturn -1;\n\n\tif (git_filebuf_open(&index_file, filename.ptr,\n\t\tGIT_FILEBUF_HASH_CONTENTS, idx->mode) < 0)\n\t\tgoto on_error;\n\n\t/* Write out the header */\n\thdr.idx_signature = htonl(PACK_IDX_SIGNATURE);\n\thdr.idx_version = htonl(2);\n\tgit_filebuf_write(&index_file, &hdr, sizeof(hdr));\n\n\t/* Write out the fanout table */\n\tfor (i = 0; i < 256; ++i) {\n\t\tuint32_t n = htonl(idx->fanout[i]);\n\t\tgit_filebuf_write(&index_file, &n, sizeof(n));\n\t}\n\n\t/* Write out the object names (SHA-1 hashes) */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tgit_filebuf_write(&index_file, &entry->oid, sizeof(git_oid));\n\t\tgit_hash_update(&ctx, &entry->oid, GIT_OID_RAWSZ);\n\t}\n\tgit_hash_final(&idx->hash, &ctx);\n\n\t/* Write out the CRC32 values */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tgit_filebuf_write(&index_file, &entry->crc, sizeof(uint32_t));\n\t}\n\n\t/* Write out the offsets */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tuint32_t n;\n\n\t\tif (entry->offset == UINT32_MAX)\n\t\t\tn = htonl(0x80000000 | long_offsets++);\n\t\telse\n\t\t\tn = htonl(entry->offset);\n\n\t\tgit_filebuf_write(&index_file, &n, sizeof(uint32_t));\n\t}\n\n\t/* Write out the long offsets */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tuint32_t split[2];\n\n\t\tif (entry->offset != UINT32_MAX)\n\t\t\tcontinue;\n\n\t\tsplit[0] = htonl(entry->offset_long >> 32);\n\t\tsplit[1] = htonl(entry->offset_long & 0xffffffff);\n\n\t\tgit_filebuf_write(&index_file, &split, sizeof(uint32_t) * 2);\n\t}\n\n\t/* Write out the packfile trailer to the index */\n\tif (git_filebuf_write(&index_file, &trailer_hash, GIT_OID_RAWSZ) < 0)\n\t\tgoto on_error;\n\n\t/* Write out the hash of the idx */\n\tif (git_filebuf_hash(&trailer_hash, &index_file) < 0)\n\t\tgoto on_error;\n\n\tgit_filebuf_write(&index_file, &trailer_hash, sizeof(git_oid));\n\n\t/* Figure out what the final name should be */\n\tif (index_path(&filename, idx, \".idx\") < 0)\n\t\tgoto on_error;\n\n\t/* Commit file */\n\tif (git_filebuf_commit_at(&index_file, filename.ptr) < 0)\n\t\tgoto on_error;\n\n\tgit_mwindow_free_all(&idx->pack->mwf);\n\t/* We need to close the descriptor here so Windows doesn't choke on commit_at */\n\tif (p_close(idx->pack->mwf.fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to close packfile\");\n\t\tgoto on_error;\n\t}\n\n\tidx->pack->mwf.fd = -1;\n\n\tif (index_path(&filename, idx, \".pack\") < 0)\n\t\tgoto on_error;\n\n\t/* And don't forget to rename the packfile to its new place. */\n\tp_rename(idx->pack->pack_name, git_buf_cstr(&filename));\n\n\tgit_buf_free(&filename);\n\tgit_hash_ctx_cleanup(&ctx);\n\treturn 0;\n\non_error:\n\tgit_mwindow_free_all(&idx->pack->mwf);\n\tgit_filebuf_cleanup(&index_file);\n\tgit_buf_free(&filename);\n\tgit_hash_ctx_cleanup(&ctx);\n\treturn -1;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hash_ctx_cleanup",
          "args": [
            "&ctx"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "268-276",
          "snippet": "void git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&filename"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&index_file"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_free_all",
          "args": [
            "&idx->pack->mwf"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_free_all_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "140-172",
          "snippet": "void git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nvoid git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_rename",
          "args": [
            "idx->pack->pack_name",
            "git_buf_cstr(&filename)"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "p_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "142-153",
          "snippet": "int p_rename(const char *from, const char *to)\n{\n\tif (!link(from, to)) {\n\t\tp_unlink(from);\n\t\treturn 0;\n\t}\n\n\tif (!rename(from, to))\n\t\treturn 0;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_rename(const char *from, const char *to)\n{\n\tif (!link(from, to)) {\n\t\tp_unlink(from);\n\t\treturn 0;\n\t}\n\n\tif (!rename(from, to))\n\t\treturn 0;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&filename"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_path",
          "args": [
            "&filename",
            "idx",
            "\".pack\""
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "index_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "647-667",
          "snippet": "static int index_path(git_buf *path, git_indexer *idx, const char *suffix)\n{\n\tconst char prefix[] = \"pack-\";\n\tsize_t slash = (size_t)path->size;\n\n\t/* search backwards for '/' */\n\twhile (slash > 0 && path->ptr[slash - 1] != '/')\n\t\tslash--;\n\n\tif (git_buf_grow(path, slash + 1 + strlen(prefix) +\n\t\t\t\t\t GIT_OID_HEXSZ + strlen(suffix) + 1) < 0)\n\t\treturn -1;\n\n\tgit_buf_truncate(path, slash);\n\tgit_buf_puts(path, prefix);\n\tgit_oid_fmt(path->ptr + git_buf_len(path), &idx->hash);\n\tpath->size += GIT_OID_HEXSZ;\n\tgit_buf_puts(path, suffix);\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int index_path(git_buf *path, git_indexer *idx, const char *suffix)\n{\n\tconst char prefix[] = \"pack-\";\n\tsize_t slash = (size_t)path->size;\n\n\t/* search backwards for '/' */\n\twhile (slash > 0 && path->ptr[slash - 1] != '/')\n\t\tslash--;\n\n\tif (git_buf_grow(path, slash + 1 + strlen(prefix) +\n\t\t\t\t\t GIT_OID_HEXSZ + strlen(suffix) + 1) < 0)\n\t\treturn -1;\n\n\tgit_buf_truncate(path, slash);\n\tgit_buf_puts(path, prefix);\n\tgit_oid_fmt(path->ptr + git_buf_len(path), &idx->hash);\n\tpath->size += GIT_OID_HEXSZ;\n\tgit_buf_puts(path, suffix);\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to close packfile\""
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "idx->pack->mwf.fd"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit_at",
          "args": [
            "&index_file",
            "filename.ptr"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "401-408",
          "snippet": "int git_filebuf_commit_at(git_filebuf *file, const char *path)\n{\n\tgit__free(file->path_original);\n\tfile->path_original = git__strdup(path);\n\tGITERR_CHECK_ALLOC(file->path_original);\n\n\treturn git_filebuf_commit(file);\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit_at(git_filebuf *file, const char *path)\n{\n\tgit__free(file->path_original);\n\tfile->path_original = git__strdup(path);\n\tGITERR_CHECK_ALLOC(file->path_original);\n\n\treturn git_filebuf_commit(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "&index_file",
            "&trailer_hash",
            "sizeof(git_oid)"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_hash",
          "args": [
            "&trailer_hash",
            "&index_file"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "385-399",
          "snippet": "int git_filebuf_hash(git_oid *oid, git_filebuf *file)\n{\n\tassert(oid && file && file->compute_digest);\n\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\treturn -1;\n\n\tgit_hash_final(oid, &file->digest);\n\tgit_hash_ctx_cleanup(&file->digest);\n\tfile->compute_digest = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_hash(git_oid *oid, git_filebuf *file)\n{\n\tassert(oid && file && file->compute_digest);\n\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\treturn -1;\n\n\tgit_hash_final(oid, &file->digest);\n\tgit_hash_ctx_cleanup(&file->digest);\n\tfile->compute_digest = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->offset_long & 0xffffffff"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->offset_long >> 32"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&idx->objects",
            "i",
            "entry"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->offset"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x80000000 | long_offsets++"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&idx->objects",
            "i",
            "entry"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&idx->objects",
            "i",
            "entry"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_hash_final",
          "args": [
            "&idx->hash",
            "&ctx"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "37-42",
          "snippet": "GIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_update",
          "args": [
            "&ctx",
            "&entry->oid",
            "GIT_OID_RAWSZ"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "30-35",
          "snippet": "GIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&idx->objects",
            "i",
            "entry"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "idx->fanout[i]"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "2"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "PACK_IDX_SIGNATURE"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&index_file",
            "filename.ptr",
            "GIT_FILEBUF_HASH_CONTENTS",
            "idx->mode"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&filename"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&filename",
            "\"idx\""
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_shorten",
          "args": [
            "&filename",
            "strlen(\"pack\")"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_shorten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "456-462",
          "snippet": "void git_buf_shorten(git_buf *buf, size_t amount)\n{\n\tif (buf->size > amount)\n\t\tgit_buf_truncate(buf, buf->size - amount);\n\telse\n\t\tgit_buf_clear(buf);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_shorten(git_buf *buf, size_t amount)\n{\n\tif (buf->size > amount)\n\t\tgit_buf_truncate(buf, buf->size - amount);\n\telse\n\t\tgit_buf_clear(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"pack\""
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&filename",
            "idx->pack->pack_name"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&idx->objects"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_at",
          "args": [
            "idx",
            "&trailer_hash",
            "idx->pack->mwf.size - GIT_OID_RAWSZ",
            "GIT_OID_RAWSZ"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "write_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "449-476",
          "snippet": "static int write_at(git_indexer *idx, const void *data, git_off_t offset, size_t size)\n{\n\tgit_file fd = idx->pack->mwf.fd;\n\tsize_t mmap_alignment;\n\tsize_t page_offset;\n\tgit_off_t page_start;\n\tunsigned char *map_data;\n\tgit_map map;\n\tint error;\n\n\tassert(data && size);\n\n\tif ((error = git__mmap_alignment(&mmap_alignment)) < 0)\n\t\treturn error;\n\n\t/* the offset needs to be at the mmap boundary for the platform */\n\tpage_offset = offset % mmap_alignment;\n\tpage_start = offset - page_offset;\n\n\tif ((error = p_mmap(&map, page_offset + size, GIT_PROT_WRITE, GIT_MAP_SHARED, fd, page_start)) < 0)\n\t\treturn error;\n\n\tmap_data = (unsigned char *)map.data;\n\tmemcpy(map_data + page_offset, data, size);\n\tp_munmap(&map);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int write_at(git_indexer *idx, const void *data, git_off_t offset, size_t size)\n{\n\tgit_file fd = idx->pack->mwf.fd;\n\tsize_t mmap_alignment;\n\tsize_t page_offset;\n\tgit_off_t page_start;\n\tunsigned char *map_data;\n\tgit_map map;\n\tint error;\n\n\tassert(data && size);\n\n\tif ((error = git__mmap_alignment(&mmap_alignment)) < 0)\n\t\treturn error;\n\n\t/* the offset needs to be at the mmap boundary for the platform */\n\tpage_offset = offset % mmap_alignment;\n\tpage_start = offset - page_offset;\n\n\tif ((error = p_mmap(&map, page_offset + size, GIT_PROT_WRITE, GIT_MAP_SHARED, fd, page_start)) < 0)\n\t\treturn error;\n\n\tmap_data = (unsigned char *)map.data;\n\tmemcpy(map_data + page_offset, data, size);\n\tp_munmap(&map);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_header_and_rehash",
          "args": [
            "idx",
            "stats"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "update_header_and_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "862-901",
          "snippet": "static int update_header_and_rehash(git_indexer *idx, git_transfer_progress *stats)\n{\n\tvoid *ptr;\n\tsize_t chunk = 1024*1024;\n\tgit_off_t hashed = 0;\n\tgit_mwindow *w = NULL;\n\tgit_mwindow_file *mwf;\n\tunsigned int left;\n\n\tmwf = &idx->pack->mwf;\n\n\tgit_hash_init(&idx->trailer);\n\n\n\t/* Update the header to include the numer of local objects we injected */\n\tidx->hdr.hdr_entries = htonl(stats->total_objects + stats->local_objects);\n\tif (write_at(idx, &idx->hdr, 0, sizeof(struct git_pack_header)) < 0)\n\t\treturn -1;\n\n\t/*\n\t * We now use the same technique as before to determine the\n\t * hash. We keep reading up to the end and let\n\t * hash_partially() keep the existing trailer out of the\n\t * calculation.\n\t */\n\tgit_mwindow_free_all(mwf);\n\tidx->inbuf_len = 0;\n\twhile (hashed < mwf->size) {\n\t\tptr = git_mwindow_open(mwf, &w, hashed, chunk, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\thash_partially(idx, ptr, left);\n\t\thashed += left;\n\n\t\tgit_mwindow_close(&w);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int update_header_and_rehash(git_indexer *idx, git_transfer_progress *stats)\n{\n\tvoid *ptr;\n\tsize_t chunk = 1024*1024;\n\tgit_off_t hashed = 0;\n\tgit_mwindow *w = NULL;\n\tgit_mwindow_file *mwf;\n\tunsigned int left;\n\n\tmwf = &idx->pack->mwf;\n\n\tgit_hash_init(&idx->trailer);\n\n\n\t/* Update the header to include the numer of local objects we injected */\n\tidx->hdr.hdr_entries = htonl(stats->total_objects + stats->local_objects);\n\tif (write_at(idx, &idx->hdr, 0, sizeof(struct git_pack_header)) < 0)\n\t\treturn -1;\n\n\t/*\n\t * We now use the same technique as before to determine the\n\t * hash. We keep reading up to the end and let\n\t * hash_partially() keep the existing trailer out of the\n\t * calculation.\n\t */\n\tgit_mwindow_free_all(mwf);\n\tidx->inbuf_len = 0;\n\twhile (hashed < mwf->size) {\n\t\tptr = git_mwindow_open(mwf, &w, hashed, chunk, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\thash_partially(idx, ptr, left);\n\t\thashed += left;\n\n\t\tgit_mwindow_close(&w);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve_deltas",
          "args": [
            "idx",
            "stats"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_deltas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "815-860",
          "snippet": "static int resolve_deltas(git_indexer *idx, git_transfer_progress *stats)\n{\n\tunsigned int i;\n\tstruct delta_info *delta;\n\tint progressed = 0, non_null = 0, progress_cb_result;\n\n\twhile (idx->deltas.length > 0) {\n\t\tprogressed = 0;\n\t\tnon_null = 0;\n\t\tgit_vector_foreach(&idx->deltas, i, delta) {\n\t\t\tgit_rawobj obj = {NULL};\n\n\t\t\tif (!delta)\n\t\t\t\tcontinue;\n\n\t\t\tnon_null = 1;\n\t\t\tidx->off = delta->delta_off;\n\t\t\tif (git_packfile_unpack(&obj, idx->pack, &idx->off) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (hash_and_save(idx, &obj, delta->delta_off) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tgit__free(obj.data);\n\t\t\tstats->indexed_objects++;\n\t\t\tstats->indexed_deltas++;\n\t\t\tprogressed = 1;\n\t\t\tif ((progress_cb_result = do_progress_callback(idx, stats)) < 0)\n\t\t\t\treturn progress_cb_result;\n\n\t\t\t/* remove from the list */\n\t\t\tgit_vector_set(NULL, &idx->deltas, i, NULL);\n\t\t\tgit__free(delta);\n\t\t}\n\n\t\t/* if none were actually set, we're done */\n\t\tif (!non_null)\n\t\t\tbreak;\n\n\t\tif (!progressed && (fix_thin_pack(idx, stats) < 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int resolve_deltas(git_indexer *idx, git_transfer_progress *stats)\n{\n\tunsigned int i;\n\tstruct delta_info *delta;\n\tint progressed = 0, non_null = 0, progress_cb_result;\n\n\twhile (idx->deltas.length > 0) {\n\t\tprogressed = 0;\n\t\tnon_null = 0;\n\t\tgit_vector_foreach(&idx->deltas, i, delta) {\n\t\t\tgit_rawobj obj = {NULL};\n\n\t\t\tif (!delta)\n\t\t\t\tcontinue;\n\n\t\t\tnon_null = 1;\n\t\t\tidx->off = delta->delta_off;\n\t\t\tif (git_packfile_unpack(&obj, idx->pack, &idx->off) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (hash_and_save(idx, &obj, delta->delta_off) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tgit__free(obj.data);\n\t\t\tstats->indexed_objects++;\n\t\t\tstats->indexed_deltas++;\n\t\t\tprogressed = 1;\n\t\t\tif ((progress_cb_result = do_progress_callback(idx, stats)) < 0)\n\t\t\t\treturn progress_cb_result;\n\n\t\t\t/* remove from the list */\n\t\t\tgit_vector_set(NULL, &idx->deltas, i, NULL);\n\t\t\tgit__free(delta);\n\t\t}\n\n\t\t/* if none were actually set, we're done */\n\t\tif (!non_null)\n\t\t\tbreak;\n\n\t\tif (!progressed && (fix_thin_pack(idx, stats) < 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "&file_hash",
            "&trailer_hash"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&w"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromraw",
          "args": [
            "&file_hash",
            "packfile_trailer"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "169-172",
          "snippet": "void git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_open",
          "args": [
            "&idx->pack->mwf",
            "&w",
            "idx->pack->mwf.size - GIT_OID_RAWSZ",
            "GIT_OID_RAWSZ",
            "&left"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "318-373",
          "snippet": "unsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nunsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_ctx_init",
          "args": [
            "&ctx"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "231-248",
          "snippet": "int git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct git_hash_prov hash_prov = {0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic struct git_hash_prov hash_prov = {0};\n\nint git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nint git_indexer_commit(git_indexer *idx, git_transfer_progress *stats)\n{\n\tgit_mwindow *w = NULL;\n\tunsigned int i, long_offsets = 0, left;\n\tint error;\n\tstruct git_pack_idx_header hdr;\n\tgit_buf filename = GIT_BUF_INIT;\n\tstruct entry *entry;\n\tgit_oid trailer_hash, file_hash;\n\tgit_hash_ctx ctx;\n\tgit_filebuf index_file = {0};\n\tvoid *packfile_trailer;\n\n\tif (!idx->parsed_header) {\n\t\tgiterr_set(GITERR_INDEXER, \"incomplete pack header\");\n\t\treturn -1;\n\t}\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\t/* Test for this before resolve_deltas(), as it plays with idx->off */\n\tif (idx->off + 20 < idx->pack->mwf.size) {\n\t\tgiterr_set(GITERR_INDEXER, \"unexpected data at the end of the pack\");\n\t\treturn -1;\n\t}\n\n\tpackfile_trailer = git_mwindow_open(&idx->pack->mwf, &w, idx->pack->mwf.size - GIT_OID_RAWSZ, GIT_OID_RAWSZ, &left);\n\tif (packfile_trailer == NULL) {\n\t\tgit_mwindow_close(&w);\n\t\tgoto on_error;\n\t}\n\n\t/* Compare the packfile trailer as it was sent to us and what we calculated */\n\tgit_oid_fromraw(&file_hash, packfile_trailer);\n\tgit_mwindow_close(&w);\n\n\tgit_hash_final(&trailer_hash, &idx->trailer);\n\tif (git_oid_cmp(&file_hash, &trailer_hash)) {\n\t\tgiterr_set(GITERR_INDEXER, \"packfile trailer mismatch\");\n\t\treturn -1;\n\t}\n\n\t/* Freeze the number of deltas */\n\tstats->total_deltas = stats->total_objects - stats->indexed_objects;\n\n\tif ((error = resolve_deltas(idx, stats)) < 0)\n\t\treturn error;\n\n\tif (stats->indexed_objects != stats->total_objects) {\n\t\tgiterr_set(GITERR_INDEXER, \"early EOF\");\n\t\treturn -1;\n\t}\n\n\tif (stats->local_objects > 0) {\n\t\tif (update_header_and_rehash(idx, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgit_hash_final(&trailer_hash, &idx->trailer);\n\t\twrite_at(idx, &trailer_hash, idx->pack->mwf.size - GIT_OID_RAWSZ, GIT_OID_RAWSZ);\n\t}\n\n\tgit_vector_sort(&idx->objects);\n\n\tgit_buf_sets(&filename, idx->pack->pack_name);\n\tgit_buf_shorten(&filename, strlen(\"pack\"));\n\tgit_buf_puts(&filename, \"idx\");\n\tif (git_buf_oom(&filename))\n\t\treturn -1;\n\n\tif (git_filebuf_open(&index_file, filename.ptr,\n\t\tGIT_FILEBUF_HASH_CONTENTS, idx->mode) < 0)\n\t\tgoto on_error;\n\n\t/* Write out the header */\n\thdr.idx_signature = htonl(PACK_IDX_SIGNATURE);\n\thdr.idx_version = htonl(2);\n\tgit_filebuf_write(&index_file, &hdr, sizeof(hdr));\n\n\t/* Write out the fanout table */\n\tfor (i = 0; i < 256; ++i) {\n\t\tuint32_t n = htonl(idx->fanout[i]);\n\t\tgit_filebuf_write(&index_file, &n, sizeof(n));\n\t}\n\n\t/* Write out the object names (SHA-1 hashes) */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tgit_filebuf_write(&index_file, &entry->oid, sizeof(git_oid));\n\t\tgit_hash_update(&ctx, &entry->oid, GIT_OID_RAWSZ);\n\t}\n\tgit_hash_final(&idx->hash, &ctx);\n\n\t/* Write out the CRC32 values */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tgit_filebuf_write(&index_file, &entry->crc, sizeof(uint32_t));\n\t}\n\n\t/* Write out the offsets */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tuint32_t n;\n\n\t\tif (entry->offset == UINT32_MAX)\n\t\t\tn = htonl(0x80000000 | long_offsets++);\n\t\telse\n\t\t\tn = htonl(entry->offset);\n\n\t\tgit_filebuf_write(&index_file, &n, sizeof(uint32_t));\n\t}\n\n\t/* Write out the long offsets */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tuint32_t split[2];\n\n\t\tif (entry->offset != UINT32_MAX)\n\t\t\tcontinue;\n\n\t\tsplit[0] = htonl(entry->offset_long >> 32);\n\t\tsplit[1] = htonl(entry->offset_long & 0xffffffff);\n\n\t\tgit_filebuf_write(&index_file, &split, sizeof(uint32_t) * 2);\n\t}\n\n\t/* Write out the packfile trailer to the index */\n\tif (git_filebuf_write(&index_file, &trailer_hash, GIT_OID_RAWSZ) < 0)\n\t\tgoto on_error;\n\n\t/* Write out the hash of the idx */\n\tif (git_filebuf_hash(&trailer_hash, &index_file) < 0)\n\t\tgoto on_error;\n\n\tgit_filebuf_write(&index_file, &trailer_hash, sizeof(git_oid));\n\n\t/* Figure out what the final name should be */\n\tif (index_path(&filename, idx, \".idx\") < 0)\n\t\tgoto on_error;\n\n\t/* Commit file */\n\tif (git_filebuf_commit_at(&index_file, filename.ptr) < 0)\n\t\tgoto on_error;\n\n\tgit_mwindow_free_all(&idx->pack->mwf);\n\t/* We need to close the descriptor here so Windows doesn't choke on commit_at */\n\tif (p_close(idx->pack->mwf.fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to close packfile\");\n\t\tgoto on_error;\n\t}\n\n\tidx->pack->mwf.fd = -1;\n\n\tif (index_path(&filename, idx, \".pack\") < 0)\n\t\tgoto on_error;\n\n\t/* And don't forget to rename the packfile to its new place. */\n\tp_rename(idx->pack->pack_name, git_buf_cstr(&filename));\n\n\tgit_buf_free(&filename);\n\tgit_hash_ctx_cleanup(&ctx);\n\treturn 0;\n\non_error:\n\tgit_mwindow_free_all(&idx->pack->mwf);\n\tgit_filebuf_cleanup(&index_file);\n\tgit_buf_free(&filename);\n\tgit_hash_ctx_cleanup(&ctx);\n\treturn -1;\n}"
  },
  {
    "function_name": "update_header_and_rehash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "862-901",
    "snippet": "static int update_header_and_rehash(git_indexer *idx, git_transfer_progress *stats)\n{\n\tvoid *ptr;\n\tsize_t chunk = 1024*1024;\n\tgit_off_t hashed = 0;\n\tgit_mwindow *w = NULL;\n\tgit_mwindow_file *mwf;\n\tunsigned int left;\n\n\tmwf = &idx->pack->mwf;\n\n\tgit_hash_init(&idx->trailer);\n\n\n\t/* Update the header to include the numer of local objects we injected */\n\tidx->hdr.hdr_entries = htonl(stats->total_objects + stats->local_objects);\n\tif (write_at(idx, &idx->hdr, 0, sizeof(struct git_pack_header)) < 0)\n\t\treturn -1;\n\n\t/*\n\t * We now use the same technique as before to determine the\n\t * hash. We keep reading up to the end and let\n\t * hash_partially() keep the existing trailer out of the\n\t * calculation.\n\t */\n\tgit_mwindow_free_all(mwf);\n\tidx->inbuf_len = 0;\n\twhile (hashed < mwf->size) {\n\t\tptr = git_mwindow_open(mwf, &w, hashed, chunk, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\thash_partially(idx, ptr, left);\n\t\thashed += left;\n\n\t\tgit_mwindow_close(&w);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&w"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_partially",
          "args": [
            "idx",
            "ptr",
            "left"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "hash_partially",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "413-447",
          "snippet": "static void hash_partially(git_indexer *idx, const uint8_t *data, size_t size)\n{\n\tsize_t to_expell, to_keep;\n\n\tif (size == 0)\n\t\treturn;\n\n\t/* Easy case, dump the buffer and the data minus the last 20 bytes */\n\tif (size >= GIT_OID_RAWSZ) {\n\t\tgit_hash_update(&idx->trailer, idx->inbuf, idx->inbuf_len);\n\t\tgit_hash_update(&idx->trailer, data, size - GIT_OID_RAWSZ);\n\n\t\tdata += size - GIT_OID_RAWSZ;\n\t\tmemcpy(idx->inbuf, data, GIT_OID_RAWSZ);\n\t\tidx->inbuf_len = GIT_OID_RAWSZ;\n\t\treturn;\n\t}\n\n\t/* We can just append */\n\tif (idx->inbuf_len + size <= GIT_OID_RAWSZ) {\n\t\tmemcpy(idx->inbuf + idx->inbuf_len, data, size);\n\t\tidx->inbuf_len += size;\n\t\treturn;\n\t}\n\n\t/* We need to partially drain the buffer and then append */\n\tto_keep   = GIT_OID_RAWSZ - size;\n\tto_expell = idx->inbuf_len - to_keep;\n\n\tgit_hash_update(&idx->trailer, idx->inbuf, to_expell);\n\n\tmemmove(idx->inbuf, idx->inbuf + to_expell, to_keep);\n\tmemcpy(idx->inbuf + to_keep, data, size);\n\tidx->inbuf_len += size - to_expell;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic void hash_partially(git_indexer *idx, const uint8_t *data, size_t size)\n{\n\tsize_t to_expell, to_keep;\n\n\tif (size == 0)\n\t\treturn;\n\n\t/* Easy case, dump the buffer and the data minus the last 20 bytes */\n\tif (size >= GIT_OID_RAWSZ) {\n\t\tgit_hash_update(&idx->trailer, idx->inbuf, idx->inbuf_len);\n\t\tgit_hash_update(&idx->trailer, data, size - GIT_OID_RAWSZ);\n\n\t\tdata += size - GIT_OID_RAWSZ;\n\t\tmemcpy(idx->inbuf, data, GIT_OID_RAWSZ);\n\t\tidx->inbuf_len = GIT_OID_RAWSZ;\n\t\treturn;\n\t}\n\n\t/* We can just append */\n\tif (idx->inbuf_len + size <= GIT_OID_RAWSZ) {\n\t\tmemcpy(idx->inbuf + idx->inbuf_len, data, size);\n\t\tidx->inbuf_len += size;\n\t\treturn;\n\t}\n\n\t/* We need to partially drain the buffer and then append */\n\tto_keep   = GIT_OID_RAWSZ - size;\n\tto_expell = idx->inbuf_len - to_keep;\n\n\tgit_hash_update(&idx->trailer, idx->inbuf, to_expell);\n\n\tmemmove(idx->inbuf, idx->inbuf + to_expell, to_keep);\n\tmemcpy(idx->inbuf + to_keep, data, size);\n\tidx->inbuf_len += size - to_expell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_open",
          "args": [
            "mwf",
            "&w",
            "hashed",
            "chunk",
            "&left"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "318-373",
          "snippet": "unsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nunsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_free_all",
          "args": [
            "mwf"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_free_all_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "140-172",
          "snippet": "void git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nvoid git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_at",
          "args": [
            "idx",
            "&idx->hdr",
            "0",
            "sizeof(struct git_pack_header)"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "write_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "449-476",
          "snippet": "static int write_at(git_indexer *idx, const void *data, git_off_t offset, size_t size)\n{\n\tgit_file fd = idx->pack->mwf.fd;\n\tsize_t mmap_alignment;\n\tsize_t page_offset;\n\tgit_off_t page_start;\n\tunsigned char *map_data;\n\tgit_map map;\n\tint error;\n\n\tassert(data && size);\n\n\tif ((error = git__mmap_alignment(&mmap_alignment)) < 0)\n\t\treturn error;\n\n\t/* the offset needs to be at the mmap boundary for the platform */\n\tpage_offset = offset % mmap_alignment;\n\tpage_start = offset - page_offset;\n\n\tif ((error = p_mmap(&map, page_offset + size, GIT_PROT_WRITE, GIT_MAP_SHARED, fd, page_start)) < 0)\n\t\treturn error;\n\n\tmap_data = (unsigned char *)map.data;\n\tmemcpy(map_data + page_offset, data, size);\n\tp_munmap(&map);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int write_at(git_indexer *idx, const void *data, git_off_t offset, size_t size)\n{\n\tgit_file fd = idx->pack->mwf.fd;\n\tsize_t mmap_alignment;\n\tsize_t page_offset;\n\tgit_off_t page_start;\n\tunsigned char *map_data;\n\tgit_map map;\n\tint error;\n\n\tassert(data && size);\n\n\tif ((error = git__mmap_alignment(&mmap_alignment)) < 0)\n\t\treturn error;\n\n\t/* the offset needs to be at the mmap boundary for the platform */\n\tpage_offset = offset % mmap_alignment;\n\tpage_start = offset - page_offset;\n\n\tif ((error = p_mmap(&map, page_offset + size, GIT_PROT_WRITE, GIT_MAP_SHARED, fd, page_start)) < 0)\n\t\treturn error;\n\n\tmap_data = (unsigned char *)map.data;\n\tmemcpy(map_data + page_offset, data, size);\n\tp_munmap(&map);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "stats->total_objects + stats->local_objects"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_hash_init",
          "args": [
            "&idx->trailer"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "23-28",
          "snippet": "GIT_INLINE(int) git_hash_init(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Init(&ctx->c);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_init(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Init(&ctx->c);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int update_header_and_rehash(git_indexer *idx, git_transfer_progress *stats)\n{\n\tvoid *ptr;\n\tsize_t chunk = 1024*1024;\n\tgit_off_t hashed = 0;\n\tgit_mwindow *w = NULL;\n\tgit_mwindow_file *mwf;\n\tunsigned int left;\n\n\tmwf = &idx->pack->mwf;\n\n\tgit_hash_init(&idx->trailer);\n\n\n\t/* Update the header to include the numer of local objects we injected */\n\tidx->hdr.hdr_entries = htonl(stats->total_objects + stats->local_objects);\n\tif (write_at(idx, &idx->hdr, 0, sizeof(struct git_pack_header)) < 0)\n\t\treturn -1;\n\n\t/*\n\t * We now use the same technique as before to determine the\n\t * hash. We keep reading up to the end and let\n\t * hash_partially() keep the existing trailer out of the\n\t * calculation.\n\t */\n\tgit_mwindow_free_all(mwf);\n\tidx->inbuf_len = 0;\n\twhile (hashed < mwf->size) {\n\t\tptr = git_mwindow_open(mwf, &w, hashed, chunk, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\thash_partially(idx, ptr, left);\n\t\thashed += left;\n\n\t\tgit_mwindow_close(&w);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "resolve_deltas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "815-860",
    "snippet": "static int resolve_deltas(git_indexer *idx, git_transfer_progress *stats)\n{\n\tunsigned int i;\n\tstruct delta_info *delta;\n\tint progressed = 0, non_null = 0, progress_cb_result;\n\n\twhile (idx->deltas.length > 0) {\n\t\tprogressed = 0;\n\t\tnon_null = 0;\n\t\tgit_vector_foreach(&idx->deltas, i, delta) {\n\t\t\tgit_rawobj obj = {NULL};\n\n\t\t\tif (!delta)\n\t\t\t\tcontinue;\n\n\t\t\tnon_null = 1;\n\t\t\tidx->off = delta->delta_off;\n\t\t\tif (git_packfile_unpack(&obj, idx->pack, &idx->off) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (hash_and_save(idx, &obj, delta->delta_off) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tgit__free(obj.data);\n\t\t\tstats->indexed_objects++;\n\t\t\tstats->indexed_deltas++;\n\t\t\tprogressed = 1;\n\t\t\tif ((progress_cb_result = do_progress_callback(idx, stats)) < 0)\n\t\t\t\treturn progress_cb_result;\n\n\t\t\t/* remove from the list */\n\t\t\tgit_vector_set(NULL, &idx->deltas, i, NULL);\n\t\t\tgit__free(delta);\n\t\t}\n\n\t\t/* if none were actually set, we're done */\n\t\tif (!non_null)\n\t\t\tbreak;\n\n\t\tif (!progressed && (fix_thin_pack(idx, stats) < 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fix_thin_pack",
          "args": [
            "idx",
            "stats"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "fix_thin_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "753-813",
          "snippet": "static int fix_thin_pack(git_indexer *idx, git_transfer_progress *stats)\n{\n\tint error, found_ref_delta = 0;\n\tunsigned int i;\n\tstruct delta_info *delta;\n\tsize_t size;\n\tgit_otype type;\n\tgit_mwindow *w = NULL;\n\tgit_off_t curpos = 0;\n\tunsigned char *base_info;\n\tunsigned int left = 0;\n\tgit_oid base;\n\n\tassert(git_vector_length(&idx->deltas) > 0);\n\n\tif (idx->odb == NULL) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot fix a thin pack without an ODB\");\n\t\treturn -1;\n\t}\n\n\t/* Loop until we find the first REF delta */\n\tgit_vector_foreach(&idx->deltas, i, delta) {\n\t\tif (!delta)\n\t\t\tcontinue;\n\n\t\tcurpos = delta->delta_off;\n\t\terror = git_packfile_unpack_header(&size, &type, &idx->pack->mwf, &w, &curpos);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (type == GIT_OBJ_REF_DELTA) {\n\t\t\tfound_ref_delta = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_ref_delta) {\n\t\tgiterr_set(GITERR_INDEXER, \"no REF_DELTA found, cannot inject object\");\n\t\treturn -1;\n\t}\n\n\t/* curpos now points to the base information, which is an OID */\n\tbase_info = git_mwindow_open(&idx->pack->mwf, &w, curpos, GIT_OID_RAWSZ, &left);\n\tif (base_info == NULL) {\n\t\tgiterr_set(GITERR_INDEXER, \"failed to map delta information\");\n\t\treturn -1;\n\t}\n\n\tgit_oid_fromraw(&base, base_info);\n\tgit_mwindow_close(&w);\n\n\tif (has_entry(idx, &base))\n\t\treturn 0;\n\n\tif (inject_object(idx, &base) < 0)\n\t\treturn -1;\n\n\tstats->local_objects++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int fix_thin_pack(git_indexer *idx, git_transfer_progress *stats)\n{\n\tint error, found_ref_delta = 0;\n\tunsigned int i;\n\tstruct delta_info *delta;\n\tsize_t size;\n\tgit_otype type;\n\tgit_mwindow *w = NULL;\n\tgit_off_t curpos = 0;\n\tunsigned char *base_info;\n\tunsigned int left = 0;\n\tgit_oid base;\n\n\tassert(git_vector_length(&idx->deltas) > 0);\n\n\tif (idx->odb == NULL) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot fix a thin pack without an ODB\");\n\t\treturn -1;\n\t}\n\n\t/* Loop until we find the first REF delta */\n\tgit_vector_foreach(&idx->deltas, i, delta) {\n\t\tif (!delta)\n\t\t\tcontinue;\n\n\t\tcurpos = delta->delta_off;\n\t\terror = git_packfile_unpack_header(&size, &type, &idx->pack->mwf, &w, &curpos);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (type == GIT_OBJ_REF_DELTA) {\n\t\t\tfound_ref_delta = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_ref_delta) {\n\t\tgiterr_set(GITERR_INDEXER, \"no REF_DELTA found, cannot inject object\");\n\t\treturn -1;\n\t}\n\n\t/* curpos now points to the base information, which is an OID */\n\tbase_info = git_mwindow_open(&idx->pack->mwf, &w, curpos, GIT_OID_RAWSZ, &left);\n\tif (base_info == NULL) {\n\t\tgiterr_set(GITERR_INDEXER, \"failed to map delta information\");\n\t\treturn -1;\n\t}\n\n\tgit_oid_fromraw(&base, base_info);\n\tgit_mwindow_close(&w);\n\n\tif (has_entry(idx, &base))\n\t\treturn 0;\n\n\tif (inject_object(idx, &base) < 0)\n\t\treturn -1;\n\n\tstats->local_objects++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "delta"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set",
          "args": [
            "NULL",
            "&idx->deltas",
            "i",
            "NULL"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "333-346",
          "snippet": "int git_vector_set(void **old, git_vector *v, size_t position, void *value)\n{\n\tif (position + 1 > v->length) {\n\t\tif (git_vector_resize_to(v, position + 1) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (old != NULL)\n\t\t*old = v->contents[position];\n\n\tv->contents[position] = value;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_set(void **old, git_vector *v, size_t position, void *value)\n{\n\tif (position + 1 > v->length) {\n\t\tif (git_vector_resize_to(v, position + 1) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (old != NULL)\n\t\t*old = v->contents[position];\n\n\tv->contents[position] = value;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_progress_callback",
          "args": [
            "idx",
            "stats"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "do_progress_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "403-410",
          "snippet": "static int do_progress_callback(git_indexer *idx, git_transfer_progress *stats)\n{\n\tif (idx->progress_cb)\n\t\treturn giterr_set_after_callback_function(\n\t\t\tidx->progress_cb(stats, idx->progress_payload),\n\t\t\t\"indexer progress\");\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int do_progress_callback(git_indexer *idx, git_transfer_progress *stats)\n{\n\tif (idx->progress_cb)\n\t\treturn giterr_set_after_callback_function(\n\t\t\tidx->progress_cb(stats, idx->progress_payload),\n\t\t\t\"indexer progress\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_and_save",
          "args": [
            "idx",
            "&obj",
            "delta->delta_off"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "hash_and_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "368-401",
          "snippet": "static int hash_and_save(git_indexer *idx, git_rawobj *obj, git_off_t entry_start)\n{\n\tgit_oid oid;\n\tsize_t entry_size;\n\tstruct entry *entry;\n\tstruct git_pack_entry *pentry = NULL;\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tif (git_odb__hashobj(&oid, obj) < 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"Failed to hash object\");\n\t\tgoto on_error;\n\t}\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_oid_cpy(&pentry->sha1, &oid);\n\tgit_oid_cpy(&entry->oid, &oid);\n\tentry->crc = crc32(0L, Z_NULL, 0);\n\n\tentry_size = (size_t)(idx->off - entry_start);\n\tif (crc_object(&entry->crc, &idx->pack->mwf, entry_start, entry_size) < 0)\n\t\tgoto on_error;\n\n\treturn save_entry(idx, entry, pentry, entry_start);\n\non_error:\n\tgit__free(pentry);\n\tgit__free(entry);\n\tgit__free(obj->data);\n\treturn -1;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int hash_and_save(git_indexer *idx, git_rawobj *obj, git_off_t entry_start)\n{\n\tgit_oid oid;\n\tsize_t entry_size;\n\tstruct entry *entry;\n\tstruct git_pack_entry *pentry = NULL;\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tif (git_odb__hashobj(&oid, obj) < 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"Failed to hash object\");\n\t\tgoto on_error;\n\t}\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_oid_cpy(&pentry->sha1, &oid);\n\tgit_oid_cpy(&entry->oid, &oid);\n\tentry->crc = crc32(0L, Z_NULL, 0);\n\n\tentry_size = (size_t)(idx->off - entry_start);\n\tif (crc_object(&entry->crc, &idx->pack->mwf, entry_start, entry_size) < 0)\n\t\tgoto on_error;\n\n\treturn save_entry(idx, entry, pentry, entry_start);\n\non_error:\n\tgit__free(pentry);\n\tgit__free(entry);\n\tgit__free(obj->data);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_unpack",
          "args": [
            "&obj",
            "idx->pack",
            "&idx->off"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "627-767",
          "snippet": "int git_packfile_unpack(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_off_t *obj_offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = *obj_offset;\n\tint error, free_base = 0;\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tstruct pack_chain_elem *elem = NULL, *stack;\n\tgit_pack_cache_entry *cached = NULL;\n\tstruct pack_chain_elem small_stack[SMALL_STACK_SIZE];\n\tsize_t stack_size = 0, elem_pos, alloclen;\n\tgit_otype base_type;\n\n\t/*\n\t * TODO: optionally check the CRC on the packfile\n\t */\n\n\terror = pack_dependency_chain(&chain, &cached, obj_offset, small_stack, &stack_size, p, *obj_offset);\n\tif (error < 0)\n\t\treturn error;\n\n\tobj->data = NULL;\n\tobj->len = 0;\n\tobj->type = GIT_OBJ_BAD;\n\n\t/* let's point to the right stack */\n\tstack = chain.ptr ? chain.ptr : small_stack;\n\n\telem_pos = stack_size;\n\tif (cached) {\n\t\tmemcpy(obj, &cached->raw, sizeof(git_rawobj));\n\t\tbase_type = obj->type;\n\t\telem_pos--;\t/* stack_size includes the base, which isn't actually there */\n\t} else {\n\t\telem = &stack[--elem_pos];\n\t\tbase_type = elem->type;\n\t}\n\n\tswitch (base_type) {\n\tcase GIT_OBJ_COMMIT:\n\tcase GIT_OBJ_TREE:\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TAG:\n\t\tif (!cached) {\n\t\t\tcurpos = elem->offset;\n\t\t\terror = packfile_unpack_compressed(obj, p, &w_curs, &curpos, elem->size, elem->type);\n\t\t\tgit_mwindow_close(&w_curs);\n\t\t\tbase_type = elem->type;\n\t\t}\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase GIT_OBJ_OFS_DELTA:\n\tcase GIT_OBJ_REF_DELTA:\n\t\terror = packfile_error(\"dependency chain ends in a delta\");\n\t\tgoto cleanup;\n\tdefault:\n\t\terror = packfile_error(\"invalid packfile type in header\");\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Finding the object we want a cached base element is\n\t * problematic, as we need to make sure we don't accidentally\n\t * give the caller the cached object, which it would then feel\n\t * free to free, so we need to copy the data.\n\t */\n\tif (cached && stack_size == 1) {\n\t\tvoid *data = obj->data;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, obj->len, 1);\n\t\tobj->data = git__malloc(alloclen);\n\t\tGITERR_CHECK_ALLOC(obj->data);\n\n\t\tmemcpy(obj->data, data, obj->len + 1);\n\t\tgit_atomic_dec(&cached->refcount);\n\t\tgoto cleanup;\n\t}\n\n\t/* we now apply each consecutive delta until we run out */\n\twhile (elem_pos > 0 && !error) {\n\t\tgit_rawobj base, delta;\n\n\t\t/*\n\t\t * We can now try to add the base to the cache, as\n\t\t * long as it's not already the cached one.\n\t\t */\n\t\tif (!cached)\n\t\t\tfree_base = !!cache_add(&cached, &p->bases, obj, elem->base_key);\n\n\t\telem = &stack[elem_pos - 1];\n\t\tcurpos = elem->offset;\n\t\terror = packfile_unpack_compressed(&delta, p, &w_curs, &curpos, elem->size, elem->type);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\t/* the current object becomes the new base, on which we apply the delta */\n\t\tbase = *obj;\n\t\tobj->data = NULL;\n\t\tobj->len = 0;\n\t\tobj->type = GIT_OBJ_BAD;\n\n\t\terror = git__delta_apply(obj, base.data, base.len, delta.data, delta.len);\n\t\tobj->type = base_type;\n\t\t/*\n\t\t * We usually don't want to free the base at this\n\t\t * point, as we put it into the cache in the previous\n\t\t * iteration. free_base lets us know that we got the\n\t\t * base object directly from the packfile, so we can free it.\n\t\t */\n\t\tgit__free(delta.data);\n\t\tif (free_base) {\n\t\t\tfree_base = 0;\n\t\t\tgit__free(base.data);\n\t\t}\n\n\t\tif (cached) {\n\t\t\tgit_atomic_dec(&cached->refcount);\n\t\t\tcached = NULL;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\telem_pos--;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit__free(obj->data);\n\n\tif (elem)\n\t\t*obj_offset = curpos;\n\n\tgit_array_clear(chain);\n\treturn error;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define SMALL_STACK_SIZE 64"
          ],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\n#define SMALL_STACK_SIZE 64\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nint git_packfile_unpack(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_off_t *obj_offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = *obj_offset;\n\tint error, free_base = 0;\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tstruct pack_chain_elem *elem = NULL, *stack;\n\tgit_pack_cache_entry *cached = NULL;\n\tstruct pack_chain_elem small_stack[SMALL_STACK_SIZE];\n\tsize_t stack_size = 0, elem_pos, alloclen;\n\tgit_otype base_type;\n\n\t/*\n\t * TODO: optionally check the CRC on the packfile\n\t */\n\n\terror = pack_dependency_chain(&chain, &cached, obj_offset, small_stack, &stack_size, p, *obj_offset);\n\tif (error < 0)\n\t\treturn error;\n\n\tobj->data = NULL;\n\tobj->len = 0;\n\tobj->type = GIT_OBJ_BAD;\n\n\t/* let's point to the right stack */\n\tstack = chain.ptr ? chain.ptr : small_stack;\n\n\telem_pos = stack_size;\n\tif (cached) {\n\t\tmemcpy(obj, &cached->raw, sizeof(git_rawobj));\n\t\tbase_type = obj->type;\n\t\telem_pos--;\t/* stack_size includes the base, which isn't actually there */\n\t} else {\n\t\telem = &stack[--elem_pos];\n\t\tbase_type = elem->type;\n\t}\n\n\tswitch (base_type) {\n\tcase GIT_OBJ_COMMIT:\n\tcase GIT_OBJ_TREE:\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TAG:\n\t\tif (!cached) {\n\t\t\tcurpos = elem->offset;\n\t\t\terror = packfile_unpack_compressed(obj, p, &w_curs, &curpos, elem->size, elem->type);\n\t\t\tgit_mwindow_close(&w_curs);\n\t\t\tbase_type = elem->type;\n\t\t}\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase GIT_OBJ_OFS_DELTA:\n\tcase GIT_OBJ_REF_DELTA:\n\t\terror = packfile_error(\"dependency chain ends in a delta\");\n\t\tgoto cleanup;\n\tdefault:\n\t\terror = packfile_error(\"invalid packfile type in header\");\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Finding the object we want a cached base element is\n\t * problematic, as we need to make sure we don't accidentally\n\t * give the caller the cached object, which it would then feel\n\t * free to free, so we need to copy the data.\n\t */\n\tif (cached && stack_size == 1) {\n\t\tvoid *data = obj->data;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, obj->len, 1);\n\t\tobj->data = git__malloc(alloclen);\n\t\tGITERR_CHECK_ALLOC(obj->data);\n\n\t\tmemcpy(obj->data, data, obj->len + 1);\n\t\tgit_atomic_dec(&cached->refcount);\n\t\tgoto cleanup;\n\t}\n\n\t/* we now apply each consecutive delta until we run out */\n\twhile (elem_pos > 0 && !error) {\n\t\tgit_rawobj base, delta;\n\n\t\t/*\n\t\t * We can now try to add the base to the cache, as\n\t\t * long as it's not already the cached one.\n\t\t */\n\t\tif (!cached)\n\t\t\tfree_base = !!cache_add(&cached, &p->bases, obj, elem->base_key);\n\n\t\telem = &stack[elem_pos - 1];\n\t\tcurpos = elem->offset;\n\t\terror = packfile_unpack_compressed(&delta, p, &w_curs, &curpos, elem->size, elem->type);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\t/* the current object becomes the new base, on which we apply the delta */\n\t\tbase = *obj;\n\t\tobj->data = NULL;\n\t\tobj->len = 0;\n\t\tobj->type = GIT_OBJ_BAD;\n\n\t\terror = git__delta_apply(obj, base.data, base.len, delta.data, delta.len);\n\t\tobj->type = base_type;\n\t\t/*\n\t\t * We usually don't want to free the base at this\n\t\t * point, as we put it into the cache in the previous\n\t\t * iteration. free_base lets us know that we got the\n\t\t * base object directly from the packfile, so we can free it.\n\t\t */\n\t\tgit__free(delta.data);\n\t\tif (free_base) {\n\t\t\tfree_base = 0;\n\t\t\tgit__free(base.data);\n\t\t}\n\n\t\tif (cached) {\n\t\t\tgit_atomic_dec(&cached->refcount);\n\t\t\tcached = NULL;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\telem_pos--;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit__free(obj->data);\n\n\tif (elem)\n\t\t*obj_offset = curpos;\n\n\tgit_array_clear(chain);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&idx->deltas",
            "i",
            "delta"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int resolve_deltas(git_indexer *idx, git_transfer_progress *stats)\n{\n\tunsigned int i;\n\tstruct delta_info *delta;\n\tint progressed = 0, non_null = 0, progress_cb_result;\n\n\twhile (idx->deltas.length > 0) {\n\t\tprogressed = 0;\n\t\tnon_null = 0;\n\t\tgit_vector_foreach(&idx->deltas, i, delta) {\n\t\t\tgit_rawobj obj = {NULL};\n\n\t\t\tif (!delta)\n\t\t\t\tcontinue;\n\n\t\t\tnon_null = 1;\n\t\t\tidx->off = delta->delta_off;\n\t\t\tif (git_packfile_unpack(&obj, idx->pack, &idx->off) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (hash_and_save(idx, &obj, delta->delta_off) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tgit__free(obj.data);\n\t\t\tstats->indexed_objects++;\n\t\t\tstats->indexed_deltas++;\n\t\t\tprogressed = 1;\n\t\t\tif ((progress_cb_result = do_progress_callback(idx, stats)) < 0)\n\t\t\t\treturn progress_cb_result;\n\n\t\t\t/* remove from the list */\n\t\t\tgit_vector_set(NULL, &idx->deltas, i, NULL);\n\t\t\tgit__free(delta);\n\t\t}\n\n\t\t/* if none were actually set, we're done */\n\t\tif (!non_null)\n\t\t\tbreak;\n\n\t\tif (!progressed && (fix_thin_pack(idx, stats) < 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fix_thin_pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "753-813",
    "snippet": "static int fix_thin_pack(git_indexer *idx, git_transfer_progress *stats)\n{\n\tint error, found_ref_delta = 0;\n\tunsigned int i;\n\tstruct delta_info *delta;\n\tsize_t size;\n\tgit_otype type;\n\tgit_mwindow *w = NULL;\n\tgit_off_t curpos = 0;\n\tunsigned char *base_info;\n\tunsigned int left = 0;\n\tgit_oid base;\n\n\tassert(git_vector_length(&idx->deltas) > 0);\n\n\tif (idx->odb == NULL) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot fix a thin pack without an ODB\");\n\t\treturn -1;\n\t}\n\n\t/* Loop until we find the first REF delta */\n\tgit_vector_foreach(&idx->deltas, i, delta) {\n\t\tif (!delta)\n\t\t\tcontinue;\n\n\t\tcurpos = delta->delta_off;\n\t\terror = git_packfile_unpack_header(&size, &type, &idx->pack->mwf, &w, &curpos);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (type == GIT_OBJ_REF_DELTA) {\n\t\t\tfound_ref_delta = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_ref_delta) {\n\t\tgiterr_set(GITERR_INDEXER, \"no REF_DELTA found, cannot inject object\");\n\t\treturn -1;\n\t}\n\n\t/* curpos now points to the base information, which is an OID */\n\tbase_info = git_mwindow_open(&idx->pack->mwf, &w, curpos, GIT_OID_RAWSZ, &left);\n\tif (base_info == NULL) {\n\t\tgiterr_set(GITERR_INDEXER, \"failed to map delta information\");\n\t\treturn -1;\n\t}\n\n\tgit_oid_fromraw(&base, base_info);\n\tgit_mwindow_close(&w);\n\n\tif (has_entry(idx, &base))\n\t\treturn 0;\n\n\tif (inject_object(idx, &base) < 0)\n\t\treturn -1;\n\n\tstats->local_objects++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inject_object",
          "args": [
            "idx",
            "&base"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "inject_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "679-751",
          "snippet": "static int inject_object(git_indexer *idx, git_oid *id)\n{\n\tgit_odb_object *obj;\n\tstruct entry *entry;\n\tstruct git_pack_entry *pentry = NULL;\n\tgit_oid foo = {{0}};\n\tunsigned char hdr[64];\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_off_t entry_start;\n\tconst void *data;\n\tsize_t len, hdr_len;\n\tint error;\n\n\tseek_back_trailer(idx);\n\tentry_start = idx->pack->mwf.size;\n\n\tif (git_odb_read(&obj, idx->odb, id) < 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"missing delta bases\");\n\t\treturn -1;\n\t}\n\n\tdata = git_odb_object_data(obj);\n\tlen = git_odb_object_size(obj);\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->crc = crc32(0L, Z_NULL, 0);\n\n\t/* Write out the object header */\n\thdr_len = git_packfile__object_header(hdr, len, git_odb_object_type(obj));\n\tif ((error = append_to_pack(idx, hdr, hdr_len)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += hdr_len;\n\tentry->crc = crc32(entry->crc, hdr, (uInt)hdr_len);\n\n\tif ((error = git_zstream_deflatebuf(&buf, data, len)) < 0)\n\t\tgoto cleanup;\n\n\t/* And then the compressed object */\n\tif ((error = append_to_pack(idx, buf.ptr, buf.size)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += buf.size;\n\tentry->crc = htonl(crc32(entry->crc, (unsigned char *)buf.ptr, (uInt)buf.size));\n\tgit_buf_free(&buf);\n\n\t/* Write a fake trailer so the pack functions play ball */\n\n\tif ((error = append_to_pack(idx, &foo, GIT_OID_RAWSZ)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += GIT_OID_RAWSZ;\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_oid_cpy(&pentry->sha1, id);\n\tgit_oid_cpy(&entry->oid, id);\n\tidx->off = entry_start + hdr_len + len;\n\n\terror = save_entry(idx, entry, pentry, entry_start);\n\ncleanup:\n\tif (error) {\n\t\tgit__free(entry);\n\t\tgit__free(pentry);\n\t}\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int inject_object(git_indexer *idx, git_oid *id)\n{\n\tgit_odb_object *obj;\n\tstruct entry *entry;\n\tstruct git_pack_entry *pentry = NULL;\n\tgit_oid foo = {{0}};\n\tunsigned char hdr[64];\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_off_t entry_start;\n\tconst void *data;\n\tsize_t len, hdr_len;\n\tint error;\n\n\tseek_back_trailer(idx);\n\tentry_start = idx->pack->mwf.size;\n\n\tif (git_odb_read(&obj, idx->odb, id) < 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"missing delta bases\");\n\t\treturn -1;\n\t}\n\n\tdata = git_odb_object_data(obj);\n\tlen = git_odb_object_size(obj);\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->crc = crc32(0L, Z_NULL, 0);\n\n\t/* Write out the object header */\n\thdr_len = git_packfile__object_header(hdr, len, git_odb_object_type(obj));\n\tif ((error = append_to_pack(idx, hdr, hdr_len)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += hdr_len;\n\tentry->crc = crc32(entry->crc, hdr, (uInt)hdr_len);\n\n\tif ((error = git_zstream_deflatebuf(&buf, data, len)) < 0)\n\t\tgoto cleanup;\n\n\t/* And then the compressed object */\n\tif ((error = append_to_pack(idx, buf.ptr, buf.size)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += buf.size;\n\tentry->crc = htonl(crc32(entry->crc, (unsigned char *)buf.ptr, (uInt)buf.size));\n\tgit_buf_free(&buf);\n\n\t/* Write a fake trailer so the pack functions play ball */\n\n\tif ((error = append_to_pack(idx, &foo, GIT_OID_RAWSZ)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += GIT_OID_RAWSZ;\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_oid_cpy(&pentry->sha1, id);\n\tgit_oid_cpy(&entry->oid, id);\n\tidx->off = entry_start + hdr_len + len;\n\n\terror = save_entry(idx, entry, pentry, entry_start);\n\ncleanup:\n\tif (error) {\n\t\tgit__free(entry);\n\t\tgit__free(pentry);\n\t}\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_entry",
          "args": [
            "idx",
            "&base"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "has_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "328-333",
          "snippet": "GIT_INLINE(bool) has_entry(git_indexer *idx, git_oid *id)\n{\n\tkhiter_t k;\n\tk = kh_get(oid, idx->pack->idx_cache, id);\n\treturn (k != kh_end(idx->pack->idx_cache));\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nGIT_INLINE(bool) has_entry(git_indexer *idx, git_oid *id)\n{\n\tkhiter_t k;\n\tk = kh_get(oid, idx->pack->idx_cache, id);\n\treturn (k != kh_end(idx->pack->idx_cache));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&w"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromraw",
          "args": [
            "&base",
            "base_info"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "169-172",
          "snippet": "void git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEXER",
            "\"failed to map delta information\""
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_open",
          "args": [
            "&idx->pack->mwf",
            "&w",
            "curpos",
            "GIT_OID_RAWSZ",
            "&left"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "318-373",
          "snippet": "unsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nunsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_unpack_header",
          "args": [
            "&size",
            "&type",
            "&idx->pack->mwf",
            "&w",
            "&curpos"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_unpack_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "449-481",
          "snippet": "int git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&idx->deltas",
            "i",
            "delta"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_vector_length(&idx->deltas) > 0"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_length",
          "args": [
            "&idx->deltas"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "67-70",
          "snippet": "GIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int fix_thin_pack(git_indexer *idx, git_transfer_progress *stats)\n{\n\tint error, found_ref_delta = 0;\n\tunsigned int i;\n\tstruct delta_info *delta;\n\tsize_t size;\n\tgit_otype type;\n\tgit_mwindow *w = NULL;\n\tgit_off_t curpos = 0;\n\tunsigned char *base_info;\n\tunsigned int left = 0;\n\tgit_oid base;\n\n\tassert(git_vector_length(&idx->deltas) > 0);\n\n\tif (idx->odb == NULL) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot fix a thin pack without an ODB\");\n\t\treturn -1;\n\t}\n\n\t/* Loop until we find the first REF delta */\n\tgit_vector_foreach(&idx->deltas, i, delta) {\n\t\tif (!delta)\n\t\t\tcontinue;\n\n\t\tcurpos = delta->delta_off;\n\t\terror = git_packfile_unpack_header(&size, &type, &idx->pack->mwf, &w, &curpos);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (type == GIT_OBJ_REF_DELTA) {\n\t\t\tfound_ref_delta = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_ref_delta) {\n\t\tgiterr_set(GITERR_INDEXER, \"no REF_DELTA found, cannot inject object\");\n\t\treturn -1;\n\t}\n\n\t/* curpos now points to the base information, which is an OID */\n\tbase_info = git_mwindow_open(&idx->pack->mwf, &w, curpos, GIT_OID_RAWSZ, &left);\n\tif (base_info == NULL) {\n\t\tgiterr_set(GITERR_INDEXER, \"failed to map delta information\");\n\t\treturn -1;\n\t}\n\n\tgit_oid_fromraw(&base, base_info);\n\tgit_mwindow_close(&w);\n\n\tif (has_entry(idx, &base))\n\t\treturn 0;\n\n\tif (inject_object(idx, &base) < 0)\n\t\treturn -1;\n\n\tstats->local_objects++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "inject_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "679-751",
    "snippet": "static int inject_object(git_indexer *idx, git_oid *id)\n{\n\tgit_odb_object *obj;\n\tstruct entry *entry;\n\tstruct git_pack_entry *pentry = NULL;\n\tgit_oid foo = {{0}};\n\tunsigned char hdr[64];\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_off_t entry_start;\n\tconst void *data;\n\tsize_t len, hdr_len;\n\tint error;\n\n\tseek_back_trailer(idx);\n\tentry_start = idx->pack->mwf.size;\n\n\tif (git_odb_read(&obj, idx->odb, id) < 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"missing delta bases\");\n\t\treturn -1;\n\t}\n\n\tdata = git_odb_object_data(obj);\n\tlen = git_odb_object_size(obj);\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->crc = crc32(0L, Z_NULL, 0);\n\n\t/* Write out the object header */\n\thdr_len = git_packfile__object_header(hdr, len, git_odb_object_type(obj));\n\tif ((error = append_to_pack(idx, hdr, hdr_len)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += hdr_len;\n\tentry->crc = crc32(entry->crc, hdr, (uInt)hdr_len);\n\n\tif ((error = git_zstream_deflatebuf(&buf, data, len)) < 0)\n\t\tgoto cleanup;\n\n\t/* And then the compressed object */\n\tif ((error = append_to_pack(idx, buf.ptr, buf.size)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += buf.size;\n\tentry->crc = htonl(crc32(entry->crc, (unsigned char *)buf.ptr, (uInt)buf.size));\n\tgit_buf_free(&buf);\n\n\t/* Write a fake trailer so the pack functions play ball */\n\n\tif ((error = append_to_pack(idx, &foo, GIT_OID_RAWSZ)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += GIT_OID_RAWSZ;\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_oid_cpy(&pentry->sha1, id);\n\tgit_oid_cpy(&entry->oid, id);\n\tidx->off = entry_start + hdr_len + len;\n\n\terror = save_entry(idx, entry, pentry, entry_start);\n\ncleanup:\n\tif (error) {\n\t\tgit__free(entry);\n\t\tgit__free(pentry);\n\t}\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb_object_free",
          "args": [
            "obj"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "137-143",
          "snippet": "void git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "pentry"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_entry",
          "args": [
            "idx",
            "entry",
            "pentry",
            "entry_start"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "save_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "335-366",
          "snippet": "static int save_entry(git_indexer *idx, struct entry *entry, struct git_pack_entry *pentry, git_off_t entry_start)\n{\n\tint i, error;\n\tkhiter_t k;\n\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tpentry->offset = entry_start;\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\n\tif (error <= 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot insert object into pack\");\n\t\treturn -1;\n\t}\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\treturn -1;\n\n\tfor (i = entry->oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [
            "#define UINT31_MAX (0x7FFFFFFF)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\n#define UINT31_MAX (0x7FFFFFFF)\n\nstatic int save_entry(git_indexer *idx, struct entry *entry, struct git_pack_entry *pentry, git_off_t entry_start)\n{\n\tint i, error;\n\tkhiter_t k;\n\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tpentry->offset = entry_start;\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\n\tif (error <= 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot insert object into pack\");\n\t\treturn -1;\n\t}\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\treturn -1;\n\n\tfor (i = entry->oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&entry->oid",
            "id"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "pentry"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(struct git_pack_entry)"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_to_pack",
          "args": [
            "idx",
            "&foo",
            "GIT_OID_RAWSZ"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "append_to_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "478-493",
          "snippet": "static int append_to_pack(git_indexer *idx, const void *data, size_t size)\n{\n\tgit_off_t current_size = idx->pack->mwf.size;\n\tint fd = idx->pack->mwf.fd;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (p_lseek(fd, current_size + size - 1, SEEK_SET) < 0 ||\n\t    p_write(idx->pack->mwf.fd, data, 1) < 0) {\n\t\tgiterr_set(GITERR_OS, \"cannot extend packfile '%s'\", idx->pack->pack_name);\n\t\treturn -1;\n\t}\n\n\treturn write_at(idx, data, idx->pack->mwf.size, size);\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int append_to_pack(git_indexer *idx, const void *data, size_t size)\n{\n\tgit_off_t current_size = idx->pack->mwf.size;\n\tint fd = idx->pack->mwf.fd;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (p_lseek(fd, current_size + size - 1, SEEK_SET) < 0 ||\n\t    p_write(idx->pack->mwf.fd, data, 1) < 0) {\n\t\tgiterr_set(GITERR_OS, \"cannot extend packfile '%s'\", idx->pack->pack_name);\n\t\treturn -1;\n\t}\n\n\treturn write_at(idx, data, idx->pack->mwf.size, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "crc32(entry->crc, (unsigned char *)buf.ptr, (uInt)buf.size)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32",
          "args": [
            "entry->crc",
            "(unsigned char *)buf.ptr",
            "(uInt)buf.size"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_zstream_deflatebuf",
          "args": [
            "&buf",
            "data",
            "len"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "git_zstream_deflatebuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/zstream.c",
          "lines": "123-156",
          "snippet": "int git_zstream_deflatebuf(git_buf *out, const void *in, size_t in_len)\n{\n\tgit_zstream zs = GIT_ZSTREAM_INIT;\n\tint error = 0;\n\n\tif ((error = git_zstream_init(&zs)) < 0)\n\t\treturn error;\n\n\tif ((error = git_zstream_set_input(&zs, in, in_len)) < 0)\n\t\tgoto done;\n\n\twhile (!git_zstream_done(&zs)) {\n\t\tsize_t step = git_zstream_suggest_output_len(&zs), written;\n\n\t\tif ((error = git_buf_grow_by(out, step)) < 0)\n\t\t\tgoto done;\n\n\t\twritten = out->asize - out->size;\n\n\t\tif ((error = git_zstream_get_output(\n\t\t\t\tout->ptr + out->size, &written, &zs)) < 0)\n\t\t\tgoto done;\n\n\t\tout->size += written;\n\t}\n\n\t/* NULL terminate for consistency if possible */\n\tif (out->size < out->asize)\n\t\tout->ptr[out->size] = '\\0';\n\ndone:\n\tgit_zstream_free(&zs);\n\treturn error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"zstream.h\"",
            "#include <zlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"zstream.h\"\n#include <zlib.h>\n\nint git_zstream_deflatebuf(git_buf *out, const void *in, size_t in_len)\n{\n\tgit_zstream zs = GIT_ZSTREAM_INIT;\n\tint error = 0;\n\n\tif ((error = git_zstream_init(&zs)) < 0)\n\t\treturn error;\n\n\tif ((error = git_zstream_set_input(&zs, in, in_len)) < 0)\n\t\tgoto done;\n\n\twhile (!git_zstream_done(&zs)) {\n\t\tsize_t step = git_zstream_suggest_output_len(&zs), written;\n\n\t\tif ((error = git_buf_grow_by(out, step)) < 0)\n\t\t\tgoto done;\n\n\t\twritten = out->asize - out->size;\n\n\t\tif ((error = git_zstream_get_output(\n\t\t\t\tout->ptr + out->size, &written, &zs)) < 0)\n\t\t\tgoto done;\n\n\t\tout->size += written;\n\t}\n\n\t/* NULL terminate for consistency if possible */\n\tif (out->size < out->asize)\n\t\tout->ptr[out->size] = '\\0';\n\ndone:\n\tgit_zstream_free(&zs);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32",
          "args": [
            "entry->crc",
            "hdr",
            "(uInt)hdr_len"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_packfile__object_header",
          "args": [
            "hdr",
            "len",
            "git_odb_object_type(obj)"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile__object_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "388-409",
          "snippet": "size_t git_packfile__object_header(unsigned char *hdr, size_t size, git_otype type)\n{\n\tunsigned char *hdr_base;\n\tunsigned char c;\n\n\tassert(type >= GIT_OBJ_COMMIT && type <= GIT_OBJ_REF_DELTA);\n\n\t/* TODO: add support for chunked objects; see git.git 6c0d19b1 */\n\n\tc = (unsigned char)((type << 4) | (size & 15));\n\tsize >>= 4;\n\thdr_base = hdr;\n\n\twhile (size) {\n\t\t*hdr++ = c | 0x80;\n\t\tc = size & 0x7f;\n\t\tsize >>= 7;\n\t}\n\t*hdr++ = c;\n\n\treturn (hdr - hdr_base);\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\nsize_t git_packfile__object_header(unsigned char *hdr, size_t size, git_otype type)\n{\n\tunsigned char *hdr_base;\n\tunsigned char c;\n\n\tassert(type >= GIT_OBJ_COMMIT && type <= GIT_OBJ_REF_DELTA);\n\n\t/* TODO: add support for chunked objects; see git.git 6c0d19b1 */\n\n\tc = (unsigned char)((type << 4) | (size & 15));\n\tsize >>= 4;\n\thdr_base = hdr;\n\n\twhile (size) {\n\t\t*hdr++ = c | 0x80;\n\t\tc = size & 0x7f;\n\t\tsize >>= 7;\n\t}\n\t*hdr++ = c;\n\n\treturn (hdr - hdr_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_type",
          "args": [
            "obj"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "125-128",
          "snippet": "git_otype git_odb_object_type(git_odb_object *object)\n{\n\treturn object->cached.type;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\ngit_otype git_odb_object_type(git_odb_object *object)\n{\n\treturn object->cached.type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32",
          "args": [
            "0L",
            "Z_NULL",
            "0"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entry"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_odb_object_size",
          "args": [
            "obj"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "120-123",
          "snippet": "size_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nsize_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_data",
          "args": [
            "obj"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "115-118",
          "snippet": "const void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nconst void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEXER",
            "\"missing delta bases\""
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_read",
          "args": [
            "&obj",
            "idx->odb",
            "id"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "862-881",
          "snippet": "int git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id)\n{\n\tint error;\n\n\tassert(out && db && id);\n\n\t*out = git_cache_get_raw(odb_cache(db), id);\n\tif (*out != NULL)\n\t\treturn 0;\n\n\terror = odb_read_1(out, db, id, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_read_1(out, db, id, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id\", id, GIT_OID_HEXSZ);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id)\n{\n\tint error;\n\n\tassert(out && db && id);\n\n\t*out = git_cache_get_raw(odb_cache(db), id);\n\tif (*out != NULL)\n\t\treturn 0;\n\n\terror = odb_read_1(out, db, id, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_read_1(out, db, id, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id\", id, GIT_OID_HEXSZ);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_back_trailer",
          "args": [
            "idx"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "seek_back_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "673-677",
          "snippet": "static void seek_back_trailer(git_indexer *idx)\n{\n\tidx->pack->mwf.size -= GIT_OID_RAWSZ;\n\tgit_mwindow_free_all(&idx->pack->mwf);\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic void seek_back_trailer(git_indexer *idx)\n{\n\tidx->pack->mwf.size -= GIT_OID_RAWSZ;\n\tgit_mwindow_free_all(&idx->pack->mwf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int inject_object(git_indexer *idx, git_oid *id)\n{\n\tgit_odb_object *obj;\n\tstruct entry *entry;\n\tstruct git_pack_entry *pentry = NULL;\n\tgit_oid foo = {{0}};\n\tunsigned char hdr[64];\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_off_t entry_start;\n\tconst void *data;\n\tsize_t len, hdr_len;\n\tint error;\n\n\tseek_back_trailer(idx);\n\tentry_start = idx->pack->mwf.size;\n\n\tif (git_odb_read(&obj, idx->odb, id) < 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"missing delta bases\");\n\t\treturn -1;\n\t}\n\n\tdata = git_odb_object_data(obj);\n\tlen = git_odb_object_size(obj);\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->crc = crc32(0L, Z_NULL, 0);\n\n\t/* Write out the object header */\n\thdr_len = git_packfile__object_header(hdr, len, git_odb_object_type(obj));\n\tif ((error = append_to_pack(idx, hdr, hdr_len)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += hdr_len;\n\tentry->crc = crc32(entry->crc, hdr, (uInt)hdr_len);\n\n\tif ((error = git_zstream_deflatebuf(&buf, data, len)) < 0)\n\t\tgoto cleanup;\n\n\t/* And then the compressed object */\n\tif ((error = append_to_pack(idx, buf.ptr, buf.size)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += buf.size;\n\tentry->crc = htonl(crc32(entry->crc, (unsigned char *)buf.ptr, (uInt)buf.size));\n\tgit_buf_free(&buf);\n\n\t/* Write a fake trailer so the pack functions play ball */\n\n\tif ((error = append_to_pack(idx, &foo, GIT_OID_RAWSZ)) < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.size += GIT_OID_RAWSZ;\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_oid_cpy(&pentry->sha1, id);\n\tgit_oid_cpy(&entry->oid, id);\n\tidx->off = entry_start + hdr_len + len;\n\n\terror = save_entry(idx, entry, pentry, entry_start);\n\ncleanup:\n\tif (error) {\n\t\tgit__free(entry);\n\t\tgit__free(pentry);\n\t}\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}"
  },
  {
    "function_name": "seek_back_trailer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "673-677",
    "snippet": "static void seek_back_trailer(git_indexer *idx)\n{\n\tidx->pack->mwf.size -= GIT_OID_RAWSZ;\n\tgit_mwindow_free_all(&idx->pack->mwf);\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mwindow_free_all",
          "args": [
            "&idx->pack->mwf"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_free_all_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "140-172",
          "snippet": "void git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nvoid git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic void seek_back_trailer(git_indexer *idx)\n{\n\tidx->pack->mwf.size -= GIT_OID_RAWSZ;\n\tgit_mwindow_free_all(&idx->pack->mwf);\n}"
  },
  {
    "function_name": "index_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "647-667",
    "snippet": "static int index_path(git_buf *path, git_indexer *idx, const char *suffix)\n{\n\tconst char prefix[] = \"pack-\";\n\tsize_t slash = (size_t)path->size;\n\n\t/* search backwards for '/' */\n\twhile (slash > 0 && path->ptr[slash - 1] != '/')\n\t\tslash--;\n\n\tif (git_buf_grow(path, slash + 1 + strlen(prefix) +\n\t\t\t\t\t GIT_OID_HEXSZ + strlen(suffix) + 1) < 0)\n\t\treturn -1;\n\n\tgit_buf_truncate(path, slash);\n\tgit_buf_puts(path, prefix);\n\tgit_oid_fmt(path->ptr + git_buf_len(path), &idx->hash);\n\tpath->size += GIT_OID_HEXSZ;\n\tgit_buf_puts(path, suffix);\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "path"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "path",
            "suffix"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fmt",
          "args": [
            "path->ptr + git_buf_len(path)",
            "&idx->hash"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "88-91",
          "snippet": "void git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "path"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "path",
            "slash"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "path",
            "slash + 1 + strlen(prefix) +\n\t\t\t\t\t GIT_OID_HEXSZ + strlen(suffix) + 1"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "suffix"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int index_path(git_buf *path, git_indexer *idx, const char *suffix)\n{\n\tconst char prefix[] = \"pack-\";\n\tsize_t slash = (size_t)path->size;\n\n\t/* search backwards for '/' */\n\twhile (slash > 0 && path->ptr[slash - 1] != '/')\n\t\tslash--;\n\n\tif (git_buf_grow(path, slash + 1 + strlen(prefix) +\n\t\t\t\t\t GIT_OID_HEXSZ + strlen(suffix) + 1) < 0)\n\t\treturn -1;\n\n\tgit_buf_truncate(path, slash);\n\tgit_buf_puts(path, prefix);\n\tgit_oid_fmt(path->ptr + git_buf_len(path), &idx->hash);\n\tpath->size += GIT_OID_HEXSZ;\n\tgit_buf_puts(path, suffix);\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
  },
  {
    "function_name": "git_indexer_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "495-645",
    "snippet": "int git_indexer_append(git_indexer *idx, const void *data, size_t size, git_transfer_progress *stats)\n{\n\tint error = -1;\n\tsize_t processed;\n\tstruct git_pack_header *hdr = &idx->hdr;\n\tgit_mwindow_file *mwf = &idx->pack->mwf;\n\n\tassert(idx && data && stats);\n\n\tprocessed = stats->indexed_objects;\n\n\tif ((error = append_to_pack(idx, data, size)) < 0)\n\t\treturn error;\n\n\thash_partially(idx, data, (int)size);\n\n\t/* Make sure we set the new size of the pack */\n\tidx->pack->mwf.size += size;\n\n\tif (!idx->parsed_header) {\n\t\tunsigned int total_objects;\n\n\t\tif ((unsigned)idx->pack->mwf.size < sizeof(struct git_pack_header))\n\t\t\treturn 0;\n\n\t\tif ((error = parse_header(&idx->hdr, idx->pack)) < 0)\n\t\t\treturn error;\n\n\t\tidx->parsed_header = 1;\n\t\tidx->nr_objects = ntohl(hdr->hdr_entries);\n\t\tidx->off = sizeof(struct git_pack_header);\n\n\t\t/* for now, limit to 2^32 objects */\n\t\tassert(idx->nr_objects == (size_t)((unsigned int)idx->nr_objects));\n\t\tif (idx->nr_objects == (size_t)((unsigned int)idx->nr_objects))\n\t\t\ttotal_objects = (unsigned int)idx->nr_objects;\n\t\telse\n\t\t\ttotal_objects = UINT_MAX;\n\n\t\tidx->pack->idx_cache = git_oidmap_alloc();\n\t\tGITERR_CHECK_ALLOC(idx->pack->idx_cache);\n\n\t\tidx->pack->has_cache = 1;\n\t\tif (git_vector_init(&idx->objects, total_objects, objects_cmp) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_vector_init(&idx->deltas, total_objects / 2, NULL) < 0)\n\t\t\treturn -1;\n\n\t\tstats->received_objects = 0;\n\t\tstats->local_objects = 0;\n\t\tstats->total_deltas = 0;\n\t\tstats->indexed_deltas = 0;\n\t\tprocessed = stats->indexed_objects = 0;\n\t\tstats->total_objects = total_objects;\n\n\t\tif ((error = do_progress_callback(idx, stats)) != 0)\n\t\t\treturn error;\n\t}\n\n\t/* Now that we have data in the pack, let's try to parse it */\n\n\t/* As the file grows any windows we try to use will be out of date */\n\tgit_mwindow_free_all(mwf);\n\n\twhile (processed < idx->nr_objects) {\n\t\tgit_packfile_stream *stream = &idx->stream;\n\t\tgit_off_t entry_start = idx->off;\n\t\tsize_t entry_size;\n\t\tgit_otype type;\n\t\tgit_mwindow *w = NULL;\n\n\t\tif (idx->pack->mwf.size <= idx->off + 20)\n\t\t\treturn 0;\n\n\t\tif (!idx->have_stream) {\n\t\t\terror = git_packfile_unpack_header(&entry_size, &type, mwf, &w, &idx->off);\n\t\t\tif (error == GIT_EBUFS) {\n\t\t\t\tidx->off = entry_start;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_mwindow_close(&w);\n\t\t\tidx->entry_start = entry_start;\n\t\t\tgit_hash_init(&idx->hash_ctx);\n\n\t\t\tif (type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA) {\n\t\t\t\terror = advance_delta_offset(idx, type);\n\t\t\t\tif (error == GIT_EBUFS) {\n\t\t\t\t\tidx->off = entry_start;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto on_error;\n\n\t\t\t\tidx->have_delta = 1;\n\t\t\t} else {\n\t\t\t\tidx->have_delta = 0;\n\t\t\t\thash_header(&idx->hash_ctx, entry_size, type);\n\t\t\t}\n\n\t\t\tidx->have_stream = 1;\n\n\t\t\terror = git_packfile_stream_open(stream, idx->pack, idx->off);\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (idx->have_delta) {\n\t\t\terror = read_object_stream(idx, stream);\n\t\t} else {\n\t\t\terror = hash_object_stream(idx, stream);\n\t\t}\n\n\t\tidx->off = stream->curpos;\n\t\tif (error == GIT_EBUFS)\n\t\t\treturn 0;\n\n\t\t/* We want to free the stream reasorces no matter what here */\n\t\tidx->have_stream = 0;\n\t\tgit_packfile_stream_free(stream);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tif (idx->have_delta) {\n\t\t\terror = store_delta(idx);\n\t\t} else {\n\t\t\terror = store_object(idx);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!idx->have_delta) {\n\t\t\tstats->indexed_objects = (unsigned int)++processed;\n\t\t}\n\t\tstats->received_objects++;\n\n\t\tif ((error = do_progress_callback(idx, stats)) != 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_mwindow_free_all(mwf);\n\treturn error;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mwindow_free_all",
          "args": [
            "mwf"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_free_all_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "140-172",
          "snippet": "void git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nvoid git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_progress_callback",
          "args": [
            "idx",
            "stats"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "do_progress_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "403-410",
          "snippet": "static int do_progress_callback(git_indexer *idx, git_transfer_progress *stats)\n{\n\tif (idx->progress_cb)\n\t\treturn giterr_set_after_callback_function(\n\t\t\tidx->progress_cb(stats, idx->progress_payload),\n\t\t\t\"indexer progress\");\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int do_progress_callback(git_indexer *idx, git_transfer_progress *stats)\n{\n\tif (idx->progress_cb)\n\t\treturn giterr_set_after_callback_function(\n\t\t\tidx->progress_cb(stats, idx->progress_payload),\n\t\t\t\"indexer progress\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_object",
          "args": [
            "idx"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "store_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "263-326",
          "snippet": "static int store_object(git_indexer *idx)\n{\n\tint i, error;\n\tkhiter_t k;\n\tgit_oid oid;\n\tstruct entry *entry;\n\tgit_off_t entry_size;\n\tstruct git_pack_entry *pentry;\n\tgit_off_t entry_start = idx->entry_start;\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_hash_final(&oid, &idx->hash_ctx);\n\tentry_size = idx->off - entry_start;\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tgit_oid_cpy(&pentry->sha1, &oid);\n\tpentry->offset = entry_start;\n\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\tif (error == -1) {\n\t\tgit__free(pentry);\n\t\tgiterr_set_oom();\n\t\tgoto on_error;\n\t}\n\n\tif (error == 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"duplicate object %s found in pack\", git_oid_tostr_s(&pentry->sha1));\n\t\tgit__free(pentry);\n\t\tgoto on_error;\n\t}\n\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\tgit_oid_cpy(&entry->oid, &oid);\n\n\tif (crc_object(&entry->crc, &idx->pack->mwf, entry_start, entry_size) < 0)\n\t\tgoto on_error;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\tgoto on_error;\n\n\tfor (i = oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit__free(entry);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [
            "#define UINT31_MAX (0x7FFFFFFF)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\n#define UINT31_MAX (0x7FFFFFFF)\n\nstatic int store_object(git_indexer *idx)\n{\n\tint i, error;\n\tkhiter_t k;\n\tgit_oid oid;\n\tstruct entry *entry;\n\tgit_off_t entry_size;\n\tstruct git_pack_entry *pentry;\n\tgit_off_t entry_start = idx->entry_start;\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_hash_final(&oid, &idx->hash_ctx);\n\tentry_size = idx->off - entry_start;\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tgit_oid_cpy(&pentry->sha1, &oid);\n\tpentry->offset = entry_start;\n\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\tif (error == -1) {\n\t\tgit__free(pentry);\n\t\tgiterr_set_oom();\n\t\tgoto on_error;\n\t}\n\n\tif (error == 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"duplicate object %s found in pack\", git_oid_tostr_s(&pentry->sha1));\n\t\tgit__free(pentry);\n\t\tgoto on_error;\n\t}\n\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\tgit_oid_cpy(&entry->oid, &oid);\n\n\tif (crc_object(&entry->crc, &idx->pack->mwf, entry_start, entry_size) < 0)\n\t\tgoto on_error;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\tgoto on_error;\n\n\tfor (i = oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit__free(entry);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_delta",
          "args": [
            "idx"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "store_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "161-173",
          "snippet": "static int store_delta(git_indexer *idx)\n{\n\tstruct delta_info *delta;\n\n\tdelta = git__calloc(1, sizeof(struct delta_info));\n\tGITERR_CHECK_ALLOC(delta);\n\tdelta->delta_off = idx->entry_start;\n\n\tif (git_vector_insert(&idx->deltas, delta) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int store_delta(git_indexer *idx)\n{\n\tstruct delta_info *delta;\n\n\tdelta = git__calloc(1, sizeof(struct delta_info));\n\tGITERR_CHECK_ALLOC(delta);\n\tdelta->delta_off = idx->entry_start;\n\n\tif (git_vector_insert(&idx->deltas, delta) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_stream_free",
          "args": [
            "stream"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_stream_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "841-844",
          "snippet": "void git_packfile_stream_free(git_packfile_stream *obj)\n{\n\tinflateEnd(&obj->zstream);\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nvoid git_packfile_stream_free(git_packfile_stream *obj)\n{\n\tinflateEnd(&obj->zstream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_object_stream",
          "args": [
            "idx",
            "stream"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "hash_object_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "184-201",
          "snippet": "static int hash_object_stream(git_indexer*idx, git_packfile_stream *stream)\n{\n\tssize_t read;\n\n\tassert(idx && stream);\n\n\tdo {\n\t\tif ((read = git_packfile_stream_read(stream, idx->objbuf, sizeof(idx->objbuf))) < 0)\n\t\t\tbreak;\n\n\t\tgit_hash_update(&idx->hash_ctx, idx->objbuf, read);\n\t} while (read > 0);\n\n\tif (read < 0)\n\t\treturn (int)read;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int hash_object_stream(git_indexer*idx, git_packfile_stream *stream)\n{\n\tssize_t read;\n\n\tassert(idx && stream);\n\n\tdo {\n\t\tif ((read = git_packfile_stream_read(stream, idx->objbuf, sizeof(idx->objbuf))) < 0)\n\t\t\tbreak;\n\n\t\tgit_hash_update(&idx->hash_ctx, idx->objbuf, read);\n\t} while (read > 0);\n\n\tif (read < 0)\n\t\treturn (int)read;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_object_stream",
          "args": [
            "idx",
            "stream"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "read_object_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "223-237",
          "snippet": "static int read_object_stream(git_indexer *idx, git_packfile_stream *stream)\n{\n\tssize_t read;\n\n\tassert(stream);\n\n\tdo {\n\t\tread = git_packfile_stream_read(stream, idx->objbuf, sizeof(idx->objbuf));\n\t} while (read > 0);\n\n\tif (read < 0)\n\t\treturn (int)read;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int read_object_stream(git_indexer *idx, git_packfile_stream *stream)\n{\n\tssize_t read;\n\n\tassert(stream);\n\n\tdo {\n\t\tread = git_packfile_stream_read(stream, idx->objbuf, sizeof(idx->objbuf));\n\t} while (read > 0);\n\n\tif (read < 0)\n\t\treturn (int)read;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_stream_open",
          "args": [
            "stream",
            "idx->pack",
            "idx->off"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_stream_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "781-799",
          "snippet": "int git_packfile_stream_open(git_packfile_stream *obj, struct git_pack_file *p, git_off_t curpos)\n{\n\tint st;\n\n\tmemset(obj, 0, sizeof(git_packfile_stream));\n\tobj->curpos = curpos;\n\tobj->p = p;\n\tobj->zstream.zalloc = use_git_alloc;\n\tobj->zstream.zfree = use_git_free;\n\tobj->zstream.next_in = Z_NULL;\n\tobj->zstream.next_out = Z_NULL;\n\tst = inflateInit(&obj->zstream);\n\tif (st != Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init packfile stream\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_stream_open(git_packfile_stream *obj, struct git_pack_file *p, git_off_t curpos)\n{\n\tint st;\n\n\tmemset(obj, 0, sizeof(git_packfile_stream));\n\tobj->curpos = curpos;\n\tobj->p = p;\n\tobj->zstream.zalloc = use_git_alloc;\n\tobj->zstream.zfree = use_git_free;\n\tobj->zstream.next_in = Z_NULL;\n\tobj->zstream.next_out = Z_NULL;\n\tst = inflateInit(&obj->zstream);\n\tif (st != Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init packfile stream\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_header",
          "args": [
            "&idx->hash_ctx",
            "entry_size",
            "type"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "hash_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "175-182",
          "snippet": "static void hash_header(git_hash_ctx *ctx, git_off_t len, git_otype type)\n{\n\tchar buffer[64];\n\tsize_t hdrlen;\n\n\thdrlen = git_odb__format_object_header(buffer, sizeof(buffer), (size_t)len, type);\n\tgit_hash_update(ctx, buffer, hdrlen);\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic void hash_header(git_hash_ctx *ctx, git_off_t len, git_otype type)\n{\n\tchar buffer[64];\n\tsize_t hdrlen;\n\n\thdrlen = git_odb__format_object_header(buffer, sizeof(buffer), (size_t)len, type);\n\tgit_hash_update(ctx, buffer, hdrlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "advance_delta_offset",
          "args": [
            "idx",
            "type"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "advance_delta_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "204-220",
          "snippet": "static int advance_delta_offset(git_indexer *idx, git_otype type)\n{\n\tgit_mwindow *w = NULL;\n\n\tassert(type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA);\n\n\tif (type == GIT_OBJ_REF_DELTA) {\n\t\tidx->off += GIT_OID_RAWSZ;\n\t} else {\n\t\tgit_off_t base_off = get_delta_base(idx->pack, &w, &idx->off, type, idx->entry_start);\n\t\tgit_mwindow_close(&w);\n\t\tif (base_off < 0)\n\t\t\treturn (int)base_off;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int advance_delta_offset(git_indexer *idx, git_otype type)\n{\n\tgit_mwindow *w = NULL;\n\n\tassert(type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA);\n\n\tif (type == GIT_OBJ_REF_DELTA) {\n\t\tidx->off += GIT_OID_RAWSZ;\n\t} else {\n\t\tgit_off_t base_off = get_delta_base(idx->pack, &w, &idx->off, type, idx->entry_start);\n\t\tgit_mwindow_close(&w);\n\t\tif (base_off < 0)\n\t\t\treturn (int)base_off;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_init",
          "args": [
            "&idx->hash_ctx"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "23-28",
          "snippet": "GIT_INLINE(int) git_hash_init(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Init(&ctx->c);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_init(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Init(&ctx->c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&w"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_unpack_header",
          "args": [
            "&entry_size",
            "&type",
            "mwf",
            "&w",
            "&idx->off"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_unpack_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "449-481",
          "snippet": "int git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&idx->deltas",
            "total_objects / 2",
            "NULL"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "idx->pack->idx_cache"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oidmap_alloc",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "idx->nr_objects == (size_t)((unsigned int)idx->nr_objects)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->hdr_entries"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_header",
          "args": [
            "&idx->hdr",
            "idx->pack"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "parse_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "73-96",
          "snippet": "static int parse_header(struct git_pack_header *hdr, struct git_pack_file *pack)\n{\n\tint error;\n\tgit_map map;\n\n\tif ((error = p_mmap(&map, sizeof(*hdr), GIT_PROT_READ, GIT_MAP_SHARED, pack->mwf.fd, 0)) < 0)\n\t\treturn error;\n\n\tmemcpy(hdr, map.data, sizeof(*hdr));\n\tp_munmap(&map);\n\n\t/* Verify we recognize this pack file format. */\n\tif (hdr->hdr_signature != ntohl(PACK_SIGNATURE)) {\n\t\tgiterr_set(GITERR_INDEXER, \"Wrong pack signature\");\n\t\treturn -1;\n\t}\n\n\tif (!pack_version_ok(hdr->hdr_version)) {\n\t\tgiterr_set(GITERR_INDEXER, \"Wrong pack version\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int parse_header(struct git_pack_header *hdr, struct git_pack_file *pack)\n{\n\tint error;\n\tgit_map map;\n\n\tif ((error = p_mmap(&map, sizeof(*hdr), GIT_PROT_READ, GIT_MAP_SHARED, pack->mwf.fd, 0)) < 0)\n\t\treturn error;\n\n\tmemcpy(hdr, map.data, sizeof(*hdr));\n\tp_munmap(&map);\n\n\t/* Verify we recognize this pack file format. */\n\tif (hdr->hdr_signature != ntohl(PACK_SIGNATURE)) {\n\t\tgiterr_set(GITERR_INDEXER, \"Wrong pack signature\");\n\t\treturn -1;\n\t}\n\n\tif (!pack_version_ok(hdr->hdr_version)) {\n\t\tgiterr_set(GITERR_INDEXER, \"Wrong pack version\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_partially",
          "args": [
            "idx",
            "data",
            "(int)size"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "hash_partially",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "413-447",
          "snippet": "static void hash_partially(git_indexer *idx, const uint8_t *data, size_t size)\n{\n\tsize_t to_expell, to_keep;\n\n\tif (size == 0)\n\t\treturn;\n\n\t/* Easy case, dump the buffer and the data minus the last 20 bytes */\n\tif (size >= GIT_OID_RAWSZ) {\n\t\tgit_hash_update(&idx->trailer, idx->inbuf, idx->inbuf_len);\n\t\tgit_hash_update(&idx->trailer, data, size - GIT_OID_RAWSZ);\n\n\t\tdata += size - GIT_OID_RAWSZ;\n\t\tmemcpy(idx->inbuf, data, GIT_OID_RAWSZ);\n\t\tidx->inbuf_len = GIT_OID_RAWSZ;\n\t\treturn;\n\t}\n\n\t/* We can just append */\n\tif (idx->inbuf_len + size <= GIT_OID_RAWSZ) {\n\t\tmemcpy(idx->inbuf + idx->inbuf_len, data, size);\n\t\tidx->inbuf_len += size;\n\t\treturn;\n\t}\n\n\t/* We need to partially drain the buffer and then append */\n\tto_keep   = GIT_OID_RAWSZ - size;\n\tto_expell = idx->inbuf_len - to_keep;\n\n\tgit_hash_update(&idx->trailer, idx->inbuf, to_expell);\n\n\tmemmove(idx->inbuf, idx->inbuf + to_expell, to_keep);\n\tmemcpy(idx->inbuf + to_keep, data, size);\n\tidx->inbuf_len += size - to_expell;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic void hash_partially(git_indexer *idx, const uint8_t *data, size_t size)\n{\n\tsize_t to_expell, to_keep;\n\n\tif (size == 0)\n\t\treturn;\n\n\t/* Easy case, dump the buffer and the data minus the last 20 bytes */\n\tif (size >= GIT_OID_RAWSZ) {\n\t\tgit_hash_update(&idx->trailer, idx->inbuf, idx->inbuf_len);\n\t\tgit_hash_update(&idx->trailer, data, size - GIT_OID_RAWSZ);\n\n\t\tdata += size - GIT_OID_RAWSZ;\n\t\tmemcpy(idx->inbuf, data, GIT_OID_RAWSZ);\n\t\tidx->inbuf_len = GIT_OID_RAWSZ;\n\t\treturn;\n\t}\n\n\t/* We can just append */\n\tif (idx->inbuf_len + size <= GIT_OID_RAWSZ) {\n\t\tmemcpy(idx->inbuf + idx->inbuf_len, data, size);\n\t\tidx->inbuf_len += size;\n\t\treturn;\n\t}\n\n\t/* We need to partially drain the buffer and then append */\n\tto_keep   = GIT_OID_RAWSZ - size;\n\tto_expell = idx->inbuf_len - to_keep;\n\n\tgit_hash_update(&idx->trailer, idx->inbuf, to_expell);\n\n\tmemmove(idx->inbuf, idx->inbuf + to_expell, to_keep);\n\tmemcpy(idx->inbuf + to_keep, data, size);\n\tidx->inbuf_len += size - to_expell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_to_pack",
          "args": [
            "idx",
            "data",
            "size"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "append_to_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "478-493",
          "snippet": "static int append_to_pack(git_indexer *idx, const void *data, size_t size)\n{\n\tgit_off_t current_size = idx->pack->mwf.size;\n\tint fd = idx->pack->mwf.fd;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (p_lseek(fd, current_size + size - 1, SEEK_SET) < 0 ||\n\t    p_write(idx->pack->mwf.fd, data, 1) < 0) {\n\t\tgiterr_set(GITERR_OS, \"cannot extend packfile '%s'\", idx->pack->pack_name);\n\t\treturn -1;\n\t}\n\n\treturn write_at(idx, data, idx->pack->mwf.size, size);\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int append_to_pack(git_indexer *idx, const void *data, size_t size)\n{\n\tgit_off_t current_size = idx->pack->mwf.size;\n\tint fd = idx->pack->mwf.fd;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (p_lseek(fd, current_size + size - 1, SEEK_SET) < 0 ||\n\t    p_write(idx->pack->mwf.fd, data, 1) < 0) {\n\t\tgiterr_set(GITERR_OS, \"cannot extend packfile '%s'\", idx->pack->pack_name);\n\t\treturn -1;\n\t}\n\n\treturn write_at(idx, data, idx->pack->mwf.size, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "idx && data && stats"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nint git_indexer_append(git_indexer *idx, const void *data, size_t size, git_transfer_progress *stats)\n{\n\tint error = -1;\n\tsize_t processed;\n\tstruct git_pack_header *hdr = &idx->hdr;\n\tgit_mwindow_file *mwf = &idx->pack->mwf;\n\n\tassert(idx && data && stats);\n\n\tprocessed = stats->indexed_objects;\n\n\tif ((error = append_to_pack(idx, data, size)) < 0)\n\t\treturn error;\n\n\thash_partially(idx, data, (int)size);\n\n\t/* Make sure we set the new size of the pack */\n\tidx->pack->mwf.size += size;\n\n\tif (!idx->parsed_header) {\n\t\tunsigned int total_objects;\n\n\t\tif ((unsigned)idx->pack->mwf.size < sizeof(struct git_pack_header))\n\t\t\treturn 0;\n\n\t\tif ((error = parse_header(&idx->hdr, idx->pack)) < 0)\n\t\t\treturn error;\n\n\t\tidx->parsed_header = 1;\n\t\tidx->nr_objects = ntohl(hdr->hdr_entries);\n\t\tidx->off = sizeof(struct git_pack_header);\n\n\t\t/* for now, limit to 2^32 objects */\n\t\tassert(idx->nr_objects == (size_t)((unsigned int)idx->nr_objects));\n\t\tif (idx->nr_objects == (size_t)((unsigned int)idx->nr_objects))\n\t\t\ttotal_objects = (unsigned int)idx->nr_objects;\n\t\telse\n\t\t\ttotal_objects = UINT_MAX;\n\n\t\tidx->pack->idx_cache = git_oidmap_alloc();\n\t\tGITERR_CHECK_ALLOC(idx->pack->idx_cache);\n\n\t\tidx->pack->has_cache = 1;\n\t\tif (git_vector_init(&idx->objects, total_objects, objects_cmp) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_vector_init(&idx->deltas, total_objects / 2, NULL) < 0)\n\t\t\treturn -1;\n\n\t\tstats->received_objects = 0;\n\t\tstats->local_objects = 0;\n\t\tstats->total_deltas = 0;\n\t\tstats->indexed_deltas = 0;\n\t\tprocessed = stats->indexed_objects = 0;\n\t\tstats->total_objects = total_objects;\n\n\t\tif ((error = do_progress_callback(idx, stats)) != 0)\n\t\t\treturn error;\n\t}\n\n\t/* Now that we have data in the pack, let's try to parse it */\n\n\t/* As the file grows any windows we try to use will be out of date */\n\tgit_mwindow_free_all(mwf);\n\n\twhile (processed < idx->nr_objects) {\n\t\tgit_packfile_stream *stream = &idx->stream;\n\t\tgit_off_t entry_start = idx->off;\n\t\tsize_t entry_size;\n\t\tgit_otype type;\n\t\tgit_mwindow *w = NULL;\n\n\t\tif (idx->pack->mwf.size <= idx->off + 20)\n\t\t\treturn 0;\n\n\t\tif (!idx->have_stream) {\n\t\t\terror = git_packfile_unpack_header(&entry_size, &type, mwf, &w, &idx->off);\n\t\t\tif (error == GIT_EBUFS) {\n\t\t\t\tidx->off = entry_start;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_mwindow_close(&w);\n\t\t\tidx->entry_start = entry_start;\n\t\t\tgit_hash_init(&idx->hash_ctx);\n\n\t\t\tif (type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA) {\n\t\t\t\terror = advance_delta_offset(idx, type);\n\t\t\t\tif (error == GIT_EBUFS) {\n\t\t\t\t\tidx->off = entry_start;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto on_error;\n\n\t\t\t\tidx->have_delta = 1;\n\t\t\t} else {\n\t\t\t\tidx->have_delta = 0;\n\t\t\t\thash_header(&idx->hash_ctx, entry_size, type);\n\t\t\t}\n\n\t\t\tidx->have_stream = 1;\n\n\t\t\terror = git_packfile_stream_open(stream, idx->pack, idx->off);\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (idx->have_delta) {\n\t\t\terror = read_object_stream(idx, stream);\n\t\t} else {\n\t\t\terror = hash_object_stream(idx, stream);\n\t\t}\n\n\t\tidx->off = stream->curpos;\n\t\tif (error == GIT_EBUFS)\n\t\t\treturn 0;\n\n\t\t/* We want to free the stream reasorces no matter what here */\n\t\tidx->have_stream = 0;\n\t\tgit_packfile_stream_free(stream);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tif (idx->have_delta) {\n\t\t\terror = store_delta(idx);\n\t\t} else {\n\t\t\terror = store_object(idx);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!idx->have_delta) {\n\t\t\tstats->indexed_objects = (unsigned int)++processed;\n\t\t}\n\t\tstats->received_objects++;\n\n\t\tif ((error = do_progress_callback(idx, stats)) != 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_mwindow_free_all(mwf);\n\treturn error;\n}"
  },
  {
    "function_name": "append_to_pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "478-493",
    "snippet": "static int append_to_pack(git_indexer *idx, const void *data, size_t size)\n{\n\tgit_off_t current_size = idx->pack->mwf.size;\n\tint fd = idx->pack->mwf.fd;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (p_lseek(fd, current_size + size - 1, SEEK_SET) < 0 ||\n\t    p_write(idx->pack->mwf.fd, data, 1) < 0) {\n\t\tgiterr_set(GITERR_OS, \"cannot extend packfile '%s'\", idx->pack->pack_name);\n\t\treturn -1;\n\t}\n\n\treturn write_at(idx, data, idx->pack->mwf.size, size);\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_at",
          "args": [
            "idx",
            "data",
            "idx->pack->mwf.size",
            "size"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "write_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "449-476",
          "snippet": "static int write_at(git_indexer *idx, const void *data, git_off_t offset, size_t size)\n{\n\tgit_file fd = idx->pack->mwf.fd;\n\tsize_t mmap_alignment;\n\tsize_t page_offset;\n\tgit_off_t page_start;\n\tunsigned char *map_data;\n\tgit_map map;\n\tint error;\n\n\tassert(data && size);\n\n\tif ((error = git__mmap_alignment(&mmap_alignment)) < 0)\n\t\treturn error;\n\n\t/* the offset needs to be at the mmap boundary for the platform */\n\tpage_offset = offset % mmap_alignment;\n\tpage_start = offset - page_offset;\n\n\tif ((error = p_mmap(&map, page_offset + size, GIT_PROT_WRITE, GIT_MAP_SHARED, fd, page_start)) < 0)\n\t\treturn error;\n\n\tmap_data = (unsigned char *)map.data;\n\tmemcpy(map_data + page_offset, data, size);\n\tp_munmap(&map);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int write_at(git_indexer *idx, const void *data, git_off_t offset, size_t size)\n{\n\tgit_file fd = idx->pack->mwf.fd;\n\tsize_t mmap_alignment;\n\tsize_t page_offset;\n\tgit_off_t page_start;\n\tunsigned char *map_data;\n\tgit_map map;\n\tint error;\n\n\tassert(data && size);\n\n\tif ((error = git__mmap_alignment(&mmap_alignment)) < 0)\n\t\treturn error;\n\n\t/* the offset needs to be at the mmap boundary for the platform */\n\tpage_offset = offset % mmap_alignment;\n\tpage_start = offset - page_offset;\n\n\tif ((error = p_mmap(&map, page_offset + size, GIT_PROT_WRITE, GIT_MAP_SHARED, fd, page_start)) < 0)\n\t\treturn error;\n\n\tmap_data = (unsigned char *)map.data;\n\tmemcpy(map_data + page_offset, data, size);\n\tp_munmap(&map);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"cannot extend packfile '%s'\"",
            "idx->pack->pack_name"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write",
          "args": [
            "idx->pack->mwf.fd",
            "data",
            "1"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "p_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "189-214",
          "snippet": "int p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_lseek",
          "args": [
            "fd",
            "current_size + size - 1",
            "SEEK_SET"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int append_to_pack(git_indexer *idx, const void *data, size_t size)\n{\n\tgit_off_t current_size = idx->pack->mwf.size;\n\tint fd = idx->pack->mwf.fd;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (p_lseek(fd, current_size + size - 1, SEEK_SET) < 0 ||\n\t    p_write(idx->pack->mwf.fd, data, 1) < 0) {\n\t\tgiterr_set(GITERR_OS, \"cannot extend packfile '%s'\", idx->pack->pack_name);\n\t\treturn -1;\n\t}\n\n\treturn write_at(idx, data, idx->pack->mwf.size, size);\n}"
  },
  {
    "function_name": "write_at",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "449-476",
    "snippet": "static int write_at(git_indexer *idx, const void *data, git_off_t offset, size_t size)\n{\n\tgit_file fd = idx->pack->mwf.fd;\n\tsize_t mmap_alignment;\n\tsize_t page_offset;\n\tgit_off_t page_start;\n\tunsigned char *map_data;\n\tgit_map map;\n\tint error;\n\n\tassert(data && size);\n\n\tif ((error = git__mmap_alignment(&mmap_alignment)) < 0)\n\t\treturn error;\n\n\t/* the offset needs to be at the mmap boundary for the platform */\n\tpage_offset = offset % mmap_alignment;\n\tpage_start = offset - page_offset;\n\n\tif ((error = p_mmap(&map, page_offset + size, GIT_PROT_WRITE, GIT_MAP_SHARED, fd, page_start)) < 0)\n\t\treturn error;\n\n\tmap_data = (unsigned char *)map.data;\n\tmemcpy(map_data + page_offset, data, size);\n\tp_munmap(&map);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_munmap",
          "args": [
            "&map"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "p_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "261-267",
          "snippet": "int p_munmap(git_map *map)\n{\n\tassert(map != NULL);\n\tfree(map->data);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_munmap(git_map *map)\n{\n\tassert(map != NULL);\n\tfree(map->data);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "map_data + page_offset",
            "data",
            "size"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_mmap",
          "args": [
            "&map",
            "page_offset + size",
            "GIT_PROT_WRITE",
            "GIT_MAP_SHARED",
            "fd",
            "page_start"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "p_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "235-259",
          "snippet": "int p_mmap(git_map *out, size_t len, int prot, int flags, int fd, git_off_t offset)\n{\n\tGIT_MMAP_VALIDATE(out, len, prot, flags);\n\n\tout->data = NULL;\n\tout->len = 0;\n\n\tif ((prot & GIT_PROT_WRITE) && ((flags & GIT_MAP_TYPE) == GIT_MAP_SHARED)) {\n\t\tgiterr_set(GITERR_OS, \"Trying to map shared-writeable\");\n\t\treturn -1;\n\t}\n\n\tout->data = malloc(len);\n\tGITERR_CHECK_ALLOC(out->data);\n\n\tif (!git__is_ssizet(len) ||\n\t\t(p_lseek(fd, offset, SEEK_SET) < 0) ||\n\t\t(p_read(fd, out->data, len) != (ssize_t)len)) {\n\t\tgiterr_set(GITERR_OS, \"mmap emulation failed\");\n\t\treturn -1;\n\t}\n\n\tout->len = len;\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_mmap(git_map *out, size_t len, int prot, int flags, int fd, git_off_t offset)\n{\n\tGIT_MMAP_VALIDATE(out, len, prot, flags);\n\n\tout->data = NULL;\n\tout->len = 0;\n\n\tif ((prot & GIT_PROT_WRITE) && ((flags & GIT_MAP_TYPE) == GIT_MAP_SHARED)) {\n\t\tgiterr_set(GITERR_OS, \"Trying to map shared-writeable\");\n\t\treturn -1;\n\t}\n\n\tout->data = malloc(len);\n\tGITERR_CHECK_ALLOC(out->data);\n\n\tif (!git__is_ssizet(len) ||\n\t\t(p_lseek(fd, offset, SEEK_SET) < 0) ||\n\t\t(p_read(fd, out->data, len) != (ssize_t)len)) {\n\t\tgiterr_set(GITERR_OS, \"mmap emulation failed\");\n\t\treturn -1;\n\t}\n\n\tout->len = len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__mmap_alignment",
          "args": [
            "&mmap_alignment"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "git__mmap_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "227-232",
          "snippet": "int git__mmap_alignment(size_t *alignment)\n{\n\t/* dummy; here we don't need any alignment anyway */\n\t*alignment = 4096;\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git__mmap_alignment(size_t *alignment)\n{\n\t/* dummy; here we don't need any alignment anyway */\n\t*alignment = 4096;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "data && size"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int write_at(git_indexer *idx, const void *data, git_off_t offset, size_t size)\n{\n\tgit_file fd = idx->pack->mwf.fd;\n\tsize_t mmap_alignment;\n\tsize_t page_offset;\n\tgit_off_t page_start;\n\tunsigned char *map_data;\n\tgit_map map;\n\tint error;\n\n\tassert(data && size);\n\n\tif ((error = git__mmap_alignment(&mmap_alignment)) < 0)\n\t\treturn error;\n\n\t/* the offset needs to be at the mmap boundary for the platform */\n\tpage_offset = offset % mmap_alignment;\n\tpage_start = offset - page_offset;\n\n\tif ((error = p_mmap(&map, page_offset + size, GIT_PROT_WRITE, GIT_MAP_SHARED, fd, page_start)) < 0)\n\t\treturn error;\n\n\tmap_data = (unsigned char *)map.data;\n\tmemcpy(map_data + page_offset, data, size);\n\tp_munmap(&map);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hash_partially",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "413-447",
    "snippet": "static void hash_partially(git_indexer *idx, const uint8_t *data, size_t size)\n{\n\tsize_t to_expell, to_keep;\n\n\tif (size == 0)\n\t\treturn;\n\n\t/* Easy case, dump the buffer and the data minus the last 20 bytes */\n\tif (size >= GIT_OID_RAWSZ) {\n\t\tgit_hash_update(&idx->trailer, idx->inbuf, idx->inbuf_len);\n\t\tgit_hash_update(&idx->trailer, data, size - GIT_OID_RAWSZ);\n\n\t\tdata += size - GIT_OID_RAWSZ;\n\t\tmemcpy(idx->inbuf, data, GIT_OID_RAWSZ);\n\t\tidx->inbuf_len = GIT_OID_RAWSZ;\n\t\treturn;\n\t}\n\n\t/* We can just append */\n\tif (idx->inbuf_len + size <= GIT_OID_RAWSZ) {\n\t\tmemcpy(idx->inbuf + idx->inbuf_len, data, size);\n\t\tidx->inbuf_len += size;\n\t\treturn;\n\t}\n\n\t/* We need to partially drain the buffer and then append */\n\tto_keep   = GIT_OID_RAWSZ - size;\n\tto_expell = idx->inbuf_len - to_keep;\n\n\tgit_hash_update(&idx->trailer, idx->inbuf, to_expell);\n\n\tmemmove(idx->inbuf, idx->inbuf + to_expell, to_keep);\n\tmemcpy(idx->inbuf + to_keep, data, size);\n\tidx->inbuf_len += size - to_expell;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "idx->inbuf + to_keep",
            "data",
            "size"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "idx->inbuf",
            "idx->inbuf + to_expell",
            "to_keep"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_hash_update",
          "args": [
            "&idx->trailer",
            "idx->inbuf",
            "to_expell"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "30-35",
          "snippet": "GIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "idx->inbuf + idx->inbuf_len",
            "data",
            "size"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "idx->inbuf",
            "data",
            "GIT_OID_RAWSZ"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic void hash_partially(git_indexer *idx, const uint8_t *data, size_t size)\n{\n\tsize_t to_expell, to_keep;\n\n\tif (size == 0)\n\t\treturn;\n\n\t/* Easy case, dump the buffer and the data minus the last 20 bytes */\n\tif (size >= GIT_OID_RAWSZ) {\n\t\tgit_hash_update(&idx->trailer, idx->inbuf, idx->inbuf_len);\n\t\tgit_hash_update(&idx->trailer, data, size - GIT_OID_RAWSZ);\n\n\t\tdata += size - GIT_OID_RAWSZ;\n\t\tmemcpy(idx->inbuf, data, GIT_OID_RAWSZ);\n\t\tidx->inbuf_len = GIT_OID_RAWSZ;\n\t\treturn;\n\t}\n\n\t/* We can just append */\n\tif (idx->inbuf_len + size <= GIT_OID_RAWSZ) {\n\t\tmemcpy(idx->inbuf + idx->inbuf_len, data, size);\n\t\tidx->inbuf_len += size;\n\t\treturn;\n\t}\n\n\t/* We need to partially drain the buffer and then append */\n\tto_keep   = GIT_OID_RAWSZ - size;\n\tto_expell = idx->inbuf_len - to_keep;\n\n\tgit_hash_update(&idx->trailer, idx->inbuf, to_expell);\n\n\tmemmove(idx->inbuf, idx->inbuf + to_expell, to_keep);\n\tmemcpy(idx->inbuf + to_keep, data, size);\n\tidx->inbuf_len += size - to_expell;\n}"
  },
  {
    "function_name": "do_progress_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "403-410",
    "snippet": "static int do_progress_callback(git_indexer *idx, git_transfer_progress *stats)\n{\n\tif (idx->progress_cb)\n\t\treturn giterr_set_after_callback_function(\n\t\t\tidx->progress_cb(stats, idx->progress_payload),\n\t\t\t\"indexer progress\");\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set_after_callback_function",
          "args": [
            "idx->progress_cb(stats, idx->progress_payload)",
            "\"indexer progress\""
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idx->progress_cb",
          "args": [
            "stats",
            "idx->progress_payload"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int do_progress_callback(git_indexer *idx, git_transfer_progress *stats)\n{\n\tif (idx->progress_cb)\n\t\treturn giterr_set_after_callback_function(\n\t\t\tidx->progress_cb(stats, idx->progress_payload),\n\t\t\t\"indexer progress\");\n\treturn 0;\n}"
  },
  {
    "function_name": "hash_and_save",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "368-401",
    "snippet": "static int hash_and_save(git_indexer *idx, git_rawobj *obj, git_off_t entry_start)\n{\n\tgit_oid oid;\n\tsize_t entry_size;\n\tstruct entry *entry;\n\tstruct git_pack_entry *pentry = NULL;\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tif (git_odb__hashobj(&oid, obj) < 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"Failed to hash object\");\n\t\tgoto on_error;\n\t}\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_oid_cpy(&pentry->sha1, &oid);\n\tgit_oid_cpy(&entry->oid, &oid);\n\tentry->crc = crc32(0L, Z_NULL, 0);\n\n\tentry_size = (size_t)(idx->off - entry_start);\n\tif (crc_object(&entry->crc, &idx->pack->mwf, entry_start, entry_size) < 0)\n\t\tgoto on_error;\n\n\treturn save_entry(idx, entry, pentry, entry_start);\n\non_error:\n\tgit__free(pentry);\n\tgit__free(entry);\n\tgit__free(obj->data);\n\treturn -1;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "obj->data"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_entry",
          "args": [
            "idx",
            "entry",
            "pentry",
            "entry_start"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "save_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "335-366",
          "snippet": "static int save_entry(git_indexer *idx, struct entry *entry, struct git_pack_entry *pentry, git_off_t entry_start)\n{\n\tint i, error;\n\tkhiter_t k;\n\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tpentry->offset = entry_start;\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\n\tif (error <= 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot insert object into pack\");\n\t\treturn -1;\n\t}\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\treturn -1;\n\n\tfor (i = entry->oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [
            "#define UINT31_MAX (0x7FFFFFFF)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\n#define UINT31_MAX (0x7FFFFFFF)\n\nstatic int save_entry(git_indexer *idx, struct entry *entry, struct git_pack_entry *pentry, git_off_t entry_start)\n{\n\tint i, error;\n\tkhiter_t k;\n\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tpentry->offset = entry_start;\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\n\tif (error <= 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot insert object into pack\");\n\t\treturn -1;\n\t}\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\treturn -1;\n\n\tfor (i = entry->oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc_object",
          "args": [
            "&entry->crc",
            "&idx->pack->mwf",
            "entry_start",
            "entry_size"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "crc_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "239-261",
          "snippet": "static int crc_object(uint32_t *crc_out, git_mwindow_file *mwf, git_off_t start, git_off_t size)\n{\n\tvoid *ptr;\n\tuint32_t crc;\n\tunsigned int left, len;\n\tgit_mwindow *w = NULL;\n\n\tcrc = crc32(0L, Z_NULL, 0);\n\twhile (size) {\n\t\tptr = git_mwindow_open(mwf, &w, start, (size_t)size, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\tlen = min(left, (unsigned int)size);\n\t\tcrc = crc32(crc, ptr, len);\n\t\tsize -= len;\n\t\tstart += len;\n\t\tgit_mwindow_close(&w);\n\t}\n\n\t*crc_out = htonl(crc);\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int crc_object(uint32_t *crc_out, git_mwindow_file *mwf, git_off_t start, git_off_t size)\n{\n\tvoid *ptr;\n\tuint32_t crc;\n\tunsigned int left, len;\n\tgit_mwindow *w = NULL;\n\n\tcrc = crc32(0L, Z_NULL, 0);\n\twhile (size) {\n\t\tptr = git_mwindow_open(mwf, &w, start, (size_t)size, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\tlen = min(left, (unsigned int)size);\n\t\tcrc = crc32(crc, ptr, len);\n\t\tsize -= len;\n\t\tstart += len;\n\t\tgit_mwindow_close(&w);\n\t}\n\n\t*crc_out = htonl(crc);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32",
          "args": [
            "0L",
            "Z_NULL",
            "0"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&entry->oid",
            "&oid"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "pentry"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(struct git_pack_entry)"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEXER",
            "\"Failed to hash object\""
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__hashobj",
          "args": [
            "&oid",
            "obj"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__hashobj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "61-85",
          "snippet": "int git_odb__hashobj(git_oid *id, git_rawobj *obj)\n{\n\tgit_buf_vec vec[2];\n\tchar header[64];\n\tint hdrlen;\n\n\tassert(id && obj);\n\n\tif (!git_object_typeisloose(obj->type))\n\t\treturn -1;\n\n\tif (!obj->data && obj->len != 0)\n\t\treturn -1;\n\n\thdrlen = git_odb__format_object_header(header, sizeof(header), obj->len, obj->type);\n\n\tvec[0].data = header;\n\tvec[0].len = hdrlen;\n\tvec[1].data = obj->data;\n\tvec[1].len = obj->len;\n\n\tgit_hash_vec(id, vec, 2);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__hashobj(git_oid *id, git_rawobj *obj)\n{\n\tgit_buf_vec vec[2];\n\tchar header[64];\n\tint hdrlen;\n\n\tassert(id && obj);\n\n\tif (!git_object_typeisloose(obj->type))\n\t\treturn -1;\n\n\tif (!obj->data && obj->len != 0)\n\t\treturn -1;\n\n\thdrlen = git_odb__format_object_header(header, sizeof(header), obj->len, obj->type);\n\n\tvec[0].data = header;\n\tvec[0].len = hdrlen;\n\tvec[1].data = obj->data;\n\tvec[1].len = obj->len;\n\n\tgit_hash_vec(id, vec, 2);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entry"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int hash_and_save(git_indexer *idx, git_rawobj *obj, git_off_t entry_start)\n{\n\tgit_oid oid;\n\tsize_t entry_size;\n\tstruct entry *entry;\n\tstruct git_pack_entry *pentry = NULL;\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tif (git_odb__hashobj(&oid, obj) < 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"Failed to hash object\");\n\t\tgoto on_error;\n\t}\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_oid_cpy(&pentry->sha1, &oid);\n\tgit_oid_cpy(&entry->oid, &oid);\n\tentry->crc = crc32(0L, Z_NULL, 0);\n\n\tentry_size = (size_t)(idx->off - entry_start);\n\tif (crc_object(&entry->crc, &idx->pack->mwf, entry_start, entry_size) < 0)\n\t\tgoto on_error;\n\n\treturn save_entry(idx, entry, pentry, entry_start);\n\non_error:\n\tgit__free(pentry);\n\tgit__free(entry);\n\tgit__free(obj->data);\n\treturn -1;\n}"
  },
  {
    "function_name": "save_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "335-366",
    "snippet": "static int save_entry(git_indexer *idx, struct entry *entry, struct git_pack_entry *pentry, git_off_t entry_start)\n{\n\tint i, error;\n\tkhiter_t k;\n\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tpentry->offset = entry_start;\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\n\tif (error <= 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot insert object into pack\");\n\t\treturn -1;\n\t}\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\treturn -1;\n\n\tfor (i = entry->oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [
      "#define UINT31_MAX (0x7FFFFFFF)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&idx->objects",
            "entry"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_value",
          "args": [
            "idx->pack->idx_cache",
            "k"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEXER",
            "\"cannot insert object into pack\""
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_put",
          "args": [
            "oid",
            "idx->pack->idx_cache",
            "&pentry->sha1",
            "&error"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\n#define UINT31_MAX (0x7FFFFFFF)\n\nstatic int save_entry(git_indexer *idx, struct entry *entry, struct git_pack_entry *pentry, git_off_t entry_start)\n{\n\tint i, error;\n\tkhiter_t k;\n\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tpentry->offset = entry_start;\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\n\tif (error <= 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"cannot insert object into pack\");\n\t\treturn -1;\n\t}\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\treturn -1;\n\n\tfor (i = entry->oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "has_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "328-333",
    "snippet": "GIT_INLINE(bool) has_entry(git_indexer *idx, git_oid *id)\n{\n\tkhiter_t k;\n\tk = kh_get(oid, idx->pack->idx_cache, id);\n\treturn (k != kh_end(idx->pack->idx_cache));\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kh_end",
          "args": [
            "idx->pack->idx_cache"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_get",
          "args": [
            "oid",
            "idx->pack->idx_cache",
            "id"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nGIT_INLINE(bool) has_entry(git_indexer *idx, git_oid *id)\n{\n\tkhiter_t k;\n\tk = kh_get(oid, idx->pack->idx_cache, id);\n\treturn (k != kh_end(idx->pack->idx_cache));\n}"
  },
  {
    "function_name": "store_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "263-326",
    "snippet": "static int store_object(git_indexer *idx)\n{\n\tint i, error;\n\tkhiter_t k;\n\tgit_oid oid;\n\tstruct entry *entry;\n\tgit_off_t entry_size;\n\tstruct git_pack_entry *pentry;\n\tgit_off_t entry_start = idx->entry_start;\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_hash_final(&oid, &idx->hash_ctx);\n\tentry_size = idx->off - entry_start;\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tgit_oid_cpy(&pentry->sha1, &oid);\n\tpentry->offset = entry_start;\n\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\tif (error == -1) {\n\t\tgit__free(pentry);\n\t\tgiterr_set_oom();\n\t\tgoto on_error;\n\t}\n\n\tif (error == 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"duplicate object %s found in pack\", git_oid_tostr_s(&pentry->sha1));\n\t\tgit__free(pentry);\n\t\tgoto on_error;\n\t}\n\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\tgit_oid_cpy(&entry->oid, &oid);\n\n\tif (crc_object(&entry->crc, &idx->pack->mwf, entry_start, entry_size) < 0)\n\t\tgoto on_error;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\tgoto on_error;\n\n\tfor (i = oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit__free(entry);\n\n\treturn -1;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [
      "#define UINT31_MAX (0x7FFFFFFF)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "entry"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&idx->objects",
            "entry"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc_object",
          "args": [
            "&entry->crc",
            "&idx->pack->mwf",
            "entry_start",
            "entry_size"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "crc_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "239-261",
          "snippet": "static int crc_object(uint32_t *crc_out, git_mwindow_file *mwf, git_off_t start, git_off_t size)\n{\n\tvoid *ptr;\n\tuint32_t crc;\n\tunsigned int left, len;\n\tgit_mwindow *w = NULL;\n\n\tcrc = crc32(0L, Z_NULL, 0);\n\twhile (size) {\n\t\tptr = git_mwindow_open(mwf, &w, start, (size_t)size, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\tlen = min(left, (unsigned int)size);\n\t\tcrc = crc32(crc, ptr, len);\n\t\tsize -= len;\n\t\tstart += len;\n\t\tgit_mwindow_close(&w);\n\t}\n\n\t*crc_out = htonl(crc);\n\treturn 0;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int crc_object(uint32_t *crc_out, git_mwindow_file *mwf, git_off_t start, git_off_t size)\n{\n\tvoid *ptr;\n\tuint32_t crc;\n\tunsigned int left, len;\n\tgit_mwindow *w = NULL;\n\n\tcrc = crc32(0L, Z_NULL, 0);\n\twhile (size) {\n\t\tptr = git_mwindow_open(mwf, &w, start, (size_t)size, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\tlen = min(left, (unsigned int)size);\n\t\tcrc = crc32(crc, ptr, len);\n\t\tsize -= len;\n\t\tstart += len;\n\t\tgit_mwindow_close(&w);\n\t}\n\n\t*crc_out = htonl(crc);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&entry->oid",
            "&oid"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_value",
          "args": [
            "idx->pack->idx_cache",
            "k"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEXER",
            "\"duplicate object %s found in pack\"",
            "git_oid_tostr_s(&pentry->sha1)"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_tostr_s",
          "args": [
            "&pentry->sha1"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_tostr_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "103-108",
          "snippet": "char *git_oid_tostr_s(const git_oid *oid)\n{\n\tchar *str = GIT_GLOBAL->oid_fmt;\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ + 1, oid);\n\treturn str;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nchar *git_oid_tostr_s(const git_oid *oid)\n{\n\tchar *str = GIT_GLOBAL->oid_fmt;\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ + 1, oid);\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_oom",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "45-48",
          "snippet": "void giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};\n\nvoid giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_put",
          "args": [
            "oid",
            "idx->pack->idx_cache",
            "&pentry->sha1",
            "&error"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_hash_final",
          "args": [
            "&oid",
            "&idx->hash_ctx"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "37-42",
          "snippet": "GIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "pentry"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(struct git_pack_entry)"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entry"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\n#define UINT31_MAX (0x7FFFFFFF)\n\nstatic int store_object(git_indexer *idx)\n{\n\tint i, error;\n\tkhiter_t k;\n\tgit_oid oid;\n\tstruct entry *entry;\n\tgit_off_t entry_size;\n\tstruct git_pack_entry *pentry;\n\tgit_off_t entry_start = idx->entry_start;\n\n\tentry = git__calloc(1, sizeof(*entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tpentry = git__calloc(1, sizeof(struct git_pack_entry));\n\tGITERR_CHECK_ALLOC(pentry);\n\n\tgit_hash_final(&oid, &idx->hash_ctx);\n\tentry_size = idx->off - entry_start;\n\tif (entry_start > UINT31_MAX) {\n\t\tentry->offset = UINT32_MAX;\n\t\tentry->offset_long = entry_start;\n\t} else {\n\t\tentry->offset = (uint32_t)entry_start;\n\t}\n\n\tgit_oid_cpy(&pentry->sha1, &oid);\n\tpentry->offset = entry_start;\n\n\tk = kh_put(oid, idx->pack->idx_cache, &pentry->sha1, &error);\n\tif (error == -1) {\n\t\tgit__free(pentry);\n\t\tgiterr_set_oom();\n\t\tgoto on_error;\n\t}\n\n\tif (error == 0) {\n\t\tgiterr_set(GITERR_INDEXER, \"duplicate object %s found in pack\", git_oid_tostr_s(&pentry->sha1));\n\t\tgit__free(pentry);\n\t\tgoto on_error;\n\t}\n\n\n\tkh_value(idx->pack->idx_cache, k) = pentry;\n\n\tgit_oid_cpy(&entry->oid, &oid);\n\n\tif (crc_object(&entry->crc, &idx->pack->mwf, entry_start, entry_size) < 0)\n\t\tgoto on_error;\n\n\t/* Add the object to the list */\n\tif (git_vector_insert(&idx->objects, entry) < 0)\n\t\tgoto on_error;\n\n\tfor (i = oid.id[0]; i < 256; ++i) {\n\t\tidx->fanout[i]++;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit__free(entry);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "crc_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "239-261",
    "snippet": "static int crc_object(uint32_t *crc_out, git_mwindow_file *mwf, git_off_t start, git_off_t size)\n{\n\tvoid *ptr;\n\tuint32_t crc;\n\tunsigned int left, len;\n\tgit_mwindow *w = NULL;\n\n\tcrc = crc32(0L, Z_NULL, 0);\n\twhile (size) {\n\t\tptr = git_mwindow_open(mwf, &w, start, (size_t)size, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\tlen = min(left, (unsigned int)size);\n\t\tcrc = crc32(crc, ptr, len);\n\t\tsize -= len;\n\t\tstart += len;\n\t\tgit_mwindow_close(&w);\n\t}\n\n\t*crc_out = htonl(crc);\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "crc"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&w"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32",
          "args": [
            "crc",
            "ptr",
            "len"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "left",
            "(unsigned int)size"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "homing_search_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "130-143",
          "snippet": "static int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_open",
          "args": [
            "mwf",
            "&w",
            "start",
            "(size_t)size",
            "&left"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "318-373",
          "snippet": "unsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nunsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32",
          "args": [
            "0L",
            "Z_NULL",
            "0"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int crc_object(uint32_t *crc_out, git_mwindow_file *mwf, git_off_t start, git_off_t size)\n{\n\tvoid *ptr;\n\tuint32_t crc;\n\tunsigned int left, len;\n\tgit_mwindow *w = NULL;\n\n\tcrc = crc32(0L, Z_NULL, 0);\n\twhile (size) {\n\t\tptr = git_mwindow_open(mwf, &w, start, (size_t)size, &left);\n\t\tif (ptr == NULL)\n\t\t\treturn -1;\n\n\t\tlen = min(left, (unsigned int)size);\n\t\tcrc = crc32(crc, ptr, len);\n\t\tsize -= len;\n\t\tstart += len;\n\t\tgit_mwindow_close(&w);\n\t}\n\n\t*crc_out = htonl(crc);\n\treturn 0;\n}"
  },
  {
    "function_name": "read_object_stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "223-237",
    "snippet": "static int read_object_stream(git_indexer *idx, git_packfile_stream *stream)\n{\n\tssize_t read;\n\n\tassert(stream);\n\n\tdo {\n\t\tread = git_packfile_stream_read(stream, idx->objbuf, sizeof(idx->objbuf));\n\t} while (read > 0);\n\n\tif (read < 0)\n\t\treturn (int)read;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_packfile_stream_read",
          "args": [
            "stream",
            "idx->objbuf",
            "sizeof(idx->objbuf)"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_stream_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "801-839",
          "snippet": "ssize_t git_packfile_stream_read(git_packfile_stream *obj, void *buffer, size_t len)\n{\n\tunsigned char *in;\n\tsize_t written;\n\tint st;\n\n\tif (obj->done)\n\t\treturn 0;\n\n\tin = pack_window_open(obj->p, &obj->mw, obj->curpos, &obj->zstream.avail_in);\n\tif (in == NULL)\n\t\treturn GIT_EBUFS;\n\n\tobj->zstream.next_out = buffer;\n\tobj->zstream.avail_out = (unsigned int)len;\n\tobj->zstream.next_in = in;\n\n\tst = inflate(&obj->zstream, Z_SYNC_FLUSH);\n\tgit_mwindow_close(&obj->mw);\n\n\tobj->curpos += obj->zstream.next_in - in;\n\twritten = len - obj->zstream.avail_out;\n\n\tif (st != Z_OK && st != Z_STREAM_END) {\n\t\tgiterr_set(GITERR_ZLIB, \"error reading from the zlib stream\");\n\t\treturn -1;\n\t}\n\n\tif (st == Z_STREAM_END)\n\t\tobj->done = 1;\n\n\n\t/* If we didn't write anything out but we're not done, we need more data */\n\tif (!written && st != Z_STREAM_END)\n\t\treturn GIT_EBUFS;\n\n\treturn written;\n\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nssize_t git_packfile_stream_read(git_packfile_stream *obj, void *buffer, size_t len)\n{\n\tunsigned char *in;\n\tsize_t written;\n\tint st;\n\n\tif (obj->done)\n\t\treturn 0;\n\n\tin = pack_window_open(obj->p, &obj->mw, obj->curpos, &obj->zstream.avail_in);\n\tif (in == NULL)\n\t\treturn GIT_EBUFS;\n\n\tobj->zstream.next_out = buffer;\n\tobj->zstream.avail_out = (unsigned int)len;\n\tobj->zstream.next_in = in;\n\n\tst = inflate(&obj->zstream, Z_SYNC_FLUSH);\n\tgit_mwindow_close(&obj->mw);\n\n\tobj->curpos += obj->zstream.next_in - in;\n\twritten = len - obj->zstream.avail_out;\n\n\tif (st != Z_OK && st != Z_STREAM_END) {\n\t\tgiterr_set(GITERR_ZLIB, \"error reading from the zlib stream\");\n\t\treturn -1;\n\t}\n\n\tif (st == Z_STREAM_END)\n\t\tobj->done = 1;\n\n\n\t/* If we didn't write anything out but we're not done, we need more data */\n\tif (!written && st != Z_STREAM_END)\n\t\treturn GIT_EBUFS;\n\n\treturn written;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "stream"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int read_object_stream(git_indexer *idx, git_packfile_stream *stream)\n{\n\tssize_t read;\n\n\tassert(stream);\n\n\tdo {\n\t\tread = git_packfile_stream_read(stream, idx->objbuf, sizeof(idx->objbuf));\n\t} while (read > 0);\n\n\tif (read < 0)\n\t\treturn (int)read;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "advance_delta_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "204-220",
    "snippet": "static int advance_delta_offset(git_indexer *idx, git_otype type)\n{\n\tgit_mwindow *w = NULL;\n\n\tassert(type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA);\n\n\tif (type == GIT_OBJ_REF_DELTA) {\n\t\tidx->off += GIT_OID_RAWSZ;\n\t} else {\n\t\tgit_off_t base_off = get_delta_base(idx->pack, &w, &idx->off, type, idx->entry_start);\n\t\tgit_mwindow_close(&w);\n\t\tif (base_off < 0)\n\t\t\treturn (int)base_off;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&w"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_delta_base",
          "args": [
            "idx->pack",
            "&w",
            "&idx->off",
            "type",
            "idx->entry_start"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "get_delta_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "913-980",
          "snippet": "git_off_t get_delta_base(\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tgit_otype type,\n\tgit_off_t delta_obj_offset)\n{\n\tunsigned int left = 0;\n\tunsigned char *base_info;\n\tgit_off_t base_offset;\n\tgit_oid unused;\n\n\tbase_info = pack_window_open(p, w_curs, *curpos, &left);\n\t/* Assumption: the only reason this would fail is because the file is too small */\n\tif (base_info == NULL)\n\t\treturn GIT_EBUFS;\n\t/* pack_window_open() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window. Its actually the hash size\n\t * that is assured. An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == GIT_OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tif (left <= used)\n\t\t\t\treturn GIT_EBUFS;\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0; /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0; /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == GIT_OBJ_REF_DELTA) {\n\t\t/* If we have the cooperative cache, search in it first */\n\t\tif (p->has_cache) {\n\t\t\tkhiter_t k;\n\t\t\tgit_oid oid;\n\n\t\t\tgit_oid_fromraw(&oid, base_info);\n\t\t\tk = kh_get(oid, p->idx_cache, &oid);\n\t\t\tif (k != kh_end(p->idx_cache)) {\n\t\t\t\t*curpos += 20;\n\t\t\t\treturn ((struct git_pack_entry *)kh_value(p->idx_cache, k))->offset;\n\t\t\t} else {\n\t\t\t\t/* If we're building an index, don't try to find the pack\n\t\t\t\t * entry; we just haven't seen it yet.  We'll make\n\t\t\t\t * progress again in the next loop.\n\t\t\t\t */\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t\t}\n\t\t}\n\n\t\t/* The base entry _must_ be in the same pack */\n\t\tif (pack_entry_find_offset(&base_offset, &unused, p, (git_oid *)base_info, GIT_OID_HEXSZ) < 0)\n\t\t\treturn packfile_error(\"base entry delta is not in the same pack\");\n\t\t*curpos += 20;\n\t} else\n\t\treturn 0;\n\n\treturn base_offset;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\ngit_off_t get_delta_base(\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tgit_otype type,\n\tgit_off_t delta_obj_offset)\n{\n\tunsigned int left = 0;\n\tunsigned char *base_info;\n\tgit_off_t base_offset;\n\tgit_oid unused;\n\n\tbase_info = pack_window_open(p, w_curs, *curpos, &left);\n\t/* Assumption: the only reason this would fail is because the file is too small */\n\tif (base_info == NULL)\n\t\treturn GIT_EBUFS;\n\t/* pack_window_open() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window. Its actually the hash size\n\t * that is assured. An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == GIT_OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tif (left <= used)\n\t\t\t\treturn GIT_EBUFS;\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0; /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0; /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == GIT_OBJ_REF_DELTA) {\n\t\t/* If we have the cooperative cache, search in it first */\n\t\tif (p->has_cache) {\n\t\t\tkhiter_t k;\n\t\t\tgit_oid oid;\n\n\t\t\tgit_oid_fromraw(&oid, base_info);\n\t\t\tk = kh_get(oid, p->idx_cache, &oid);\n\t\t\tif (k != kh_end(p->idx_cache)) {\n\t\t\t\t*curpos += 20;\n\t\t\t\treturn ((struct git_pack_entry *)kh_value(p->idx_cache, k))->offset;\n\t\t\t} else {\n\t\t\t\t/* If we're building an index, don't try to find the pack\n\t\t\t\t * entry; we just haven't seen it yet.  We'll make\n\t\t\t\t * progress again in the next loop.\n\t\t\t\t */\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t\t}\n\t\t}\n\n\t\t/* The base entry _must_ be in the same pack */\n\t\tif (pack_entry_find_offset(&base_offset, &unused, p, (git_oid *)base_info, GIT_OID_HEXSZ) < 0)\n\t\t\treturn packfile_error(\"base entry delta is not in the same pack\");\n\t\t*curpos += 20;\n\t} else\n\t\treturn 0;\n\n\treturn base_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int advance_delta_offset(git_indexer *idx, git_otype type)\n{\n\tgit_mwindow *w = NULL;\n\n\tassert(type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA);\n\n\tif (type == GIT_OBJ_REF_DELTA) {\n\t\tidx->off += GIT_OID_RAWSZ;\n\t} else {\n\t\tgit_off_t base_off = get_delta_base(idx->pack, &w, &idx->off, type, idx->entry_start);\n\t\tgit_mwindow_close(&w);\n\t\tif (base_off < 0)\n\t\t\treturn (int)base_off;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hash_object_stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "184-201",
    "snippet": "static int hash_object_stream(git_indexer*idx, git_packfile_stream *stream)\n{\n\tssize_t read;\n\n\tassert(idx && stream);\n\n\tdo {\n\t\tif ((read = git_packfile_stream_read(stream, idx->objbuf, sizeof(idx->objbuf))) < 0)\n\t\t\tbreak;\n\n\t\tgit_hash_update(&idx->hash_ctx, idx->objbuf, read);\n\t} while (read > 0);\n\n\tif (read < 0)\n\t\treturn (int)read;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hash_update",
          "args": [
            "&idx->hash_ctx",
            "idx->objbuf",
            "read"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "30-35",
          "snippet": "GIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_stream_read",
          "args": [
            "stream",
            "idx->objbuf",
            "sizeof(idx->objbuf)"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_stream_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "801-839",
          "snippet": "ssize_t git_packfile_stream_read(git_packfile_stream *obj, void *buffer, size_t len)\n{\n\tunsigned char *in;\n\tsize_t written;\n\tint st;\n\n\tif (obj->done)\n\t\treturn 0;\n\n\tin = pack_window_open(obj->p, &obj->mw, obj->curpos, &obj->zstream.avail_in);\n\tif (in == NULL)\n\t\treturn GIT_EBUFS;\n\n\tobj->zstream.next_out = buffer;\n\tobj->zstream.avail_out = (unsigned int)len;\n\tobj->zstream.next_in = in;\n\n\tst = inflate(&obj->zstream, Z_SYNC_FLUSH);\n\tgit_mwindow_close(&obj->mw);\n\n\tobj->curpos += obj->zstream.next_in - in;\n\twritten = len - obj->zstream.avail_out;\n\n\tif (st != Z_OK && st != Z_STREAM_END) {\n\t\tgiterr_set(GITERR_ZLIB, \"error reading from the zlib stream\");\n\t\treturn -1;\n\t}\n\n\tif (st == Z_STREAM_END)\n\t\tobj->done = 1;\n\n\n\t/* If we didn't write anything out but we're not done, we need more data */\n\tif (!written && st != Z_STREAM_END)\n\t\treturn GIT_EBUFS;\n\n\treturn written;\n\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nssize_t git_packfile_stream_read(git_packfile_stream *obj, void *buffer, size_t len)\n{\n\tunsigned char *in;\n\tsize_t written;\n\tint st;\n\n\tif (obj->done)\n\t\treturn 0;\n\n\tin = pack_window_open(obj->p, &obj->mw, obj->curpos, &obj->zstream.avail_in);\n\tif (in == NULL)\n\t\treturn GIT_EBUFS;\n\n\tobj->zstream.next_out = buffer;\n\tobj->zstream.avail_out = (unsigned int)len;\n\tobj->zstream.next_in = in;\n\n\tst = inflate(&obj->zstream, Z_SYNC_FLUSH);\n\tgit_mwindow_close(&obj->mw);\n\n\tobj->curpos += obj->zstream.next_in - in;\n\twritten = len - obj->zstream.avail_out;\n\n\tif (st != Z_OK && st != Z_STREAM_END) {\n\t\tgiterr_set(GITERR_ZLIB, \"error reading from the zlib stream\");\n\t\treturn -1;\n\t}\n\n\tif (st == Z_STREAM_END)\n\t\tobj->done = 1;\n\n\n\t/* If we didn't write anything out but we're not done, we need more data */\n\tif (!written && st != Z_STREAM_END)\n\t\treturn GIT_EBUFS;\n\n\treturn written;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "idx && stream"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int hash_object_stream(git_indexer*idx, git_packfile_stream *stream)\n{\n\tssize_t read;\n\n\tassert(idx && stream);\n\n\tdo {\n\t\tif ((read = git_packfile_stream_read(stream, idx->objbuf, sizeof(idx->objbuf))) < 0)\n\t\t\tbreak;\n\n\t\tgit_hash_update(&idx->hash_ctx, idx->objbuf, read);\n\t} while (read > 0);\n\n\tif (read < 0)\n\t\treturn (int)read;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hash_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "175-182",
    "snippet": "static void hash_header(git_hash_ctx *ctx, git_off_t len, git_otype type)\n{\n\tchar buffer[64];\n\tsize_t hdrlen;\n\n\thdrlen = git_odb__format_object_header(buffer, sizeof(buffer), (size_t)len, type);\n\tgit_hash_update(ctx, buffer, hdrlen);\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hash_update",
          "args": [
            "ctx",
            "buffer",
            "hdrlen"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "30-35",
          "snippet": "GIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__format_object_header",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "(size_t)len",
            "type"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__format_object_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "53-59",
          "snippet": "int git_odb__format_object_header(char *hdr, size_t n, git_off_t obj_len, git_otype obj_type)\n{\n\tconst char *type_str = git_object_type2string(obj_type);\n\tint len = p_snprintf(hdr, n, \"%s %lld\", type_str, (long long)obj_len);\n\tassert(len > 0 && len <= (int)n);\n\treturn len+1;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__format_object_header(char *hdr, size_t n, git_off_t obj_len, git_otype obj_type)\n{\n\tconst char *type_str = git_object_type2string(obj_type);\n\tint len = p_snprintf(hdr, n, \"%s %lld\", type_str, (long long)obj_len);\n\tassert(len > 0 && len <= (int)n);\n\treturn len+1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic void hash_header(git_hash_ctx *ctx, git_off_t len, git_otype type)\n{\n\tchar buffer[64];\n\tsize_t hdrlen;\n\n\thdrlen = git_odb__format_object_header(buffer, sizeof(buffer), (size_t)len, type);\n\tgit_hash_update(ctx, buffer, hdrlen);\n}"
  },
  {
    "function_name": "store_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "161-173",
    "snippet": "static int store_delta(git_indexer *idx)\n{\n\tstruct delta_info *delta;\n\n\tdelta = git__calloc(1, sizeof(struct delta_info));\n\tGITERR_CHECK_ALLOC(delta);\n\tdelta->delta_off = idx->entry_start;\n\n\tif (git_vector_insert(&idx->deltas, delta) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&idx->deltas",
            "delta"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "delta"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(struct delta_info)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int store_delta(git_indexer *idx)\n{\n\tstruct delta_info *delta;\n\n\tdelta = git__calloc(1, sizeof(struct delta_info));\n\tGITERR_CHECK_ALLOC(delta);\n\tdelta->delta_off = idx->entry_start;\n\n\tif (git_vector_insert(&idx->deltas, delta) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_indexer_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "106-158",
    "snippet": "int git_indexer_new(\n\t\tgit_indexer **out,\n\t\tconst char *prefix,\n\t\tunsigned int mode,\n\t\tgit_odb *odb,\n\t\tgit_transfer_progress_cb progress_cb,\n\t\tvoid *progress_payload)\n{\n\tgit_indexer *idx;\n\tgit_buf path = GIT_BUF_INIT, tmp_path = GIT_BUF_INIT;\n\tstatic const char suff[] = \"/pack\";\n\tint error, fd = -1;\n\n\tidx = git__calloc(1, sizeof(git_indexer));\n\tGITERR_CHECK_ALLOC(idx);\n\tidx->odb = odb;\n\tidx->progress_cb = progress_cb;\n\tidx->progress_payload = progress_payload;\n\tidx->mode = mode ? mode : GIT_PACK_FILE_MODE;\n\tgit_hash_ctx_init(&idx->hash_ctx);\n\tgit_hash_ctx_init(&idx->trailer);\n\n\terror = git_buf_joinpath(&path, prefix, suff);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tfd = git_futils_mktmp(&tmp_path, git_buf_cstr(&path), idx->mode);\n\tgit_buf_free(&path);\n\tif (fd < 0)\n\t\tgoto cleanup;\n\n\terror = git_packfile_alloc(&idx->pack, git_buf_cstr(&tmp_path));\n\tgit_buf_free(&tmp_path);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.fd = fd;\n\tif ((error = git_mwindow_file_register(&idx->pack->mwf)) < 0)\n\t\tgoto cleanup;\n\n\t*out = idx;\n\treturn 0;\n\ncleanup:\n\tif (fd != -1)\n\t\tp_close(fd);\n\n\tgit_buf_free(&path);\n\tgit_buf_free(&tmp_path);\n\tgit__free(idx);\n\treturn -1;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "idx"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&tmp_path"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_file_register",
          "args": [
            "&idx->pack->mwf"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_file_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "375-395",
          "snippet": "int git_mwindow_file_register(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tint ret;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tif (ctl->windowfiles.length == 0 &&\n\t    git_vector_init(&ctl->windowfiles, 8, NULL) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn -1;\n\t}\n\n\tret = git_vector_insert(&ctl->windowfiles, mwf);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nint git_mwindow_file_register(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tint ret;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tif (ctl->windowfiles.length == 0 &&\n\t    git_vector_init(&ctl->windowfiles, 8, NULL) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn -1;\n\t}\n\n\tret = git_vector_insert(&ctl->windowfiles, mwf);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_alloc",
          "args": [
            "&idx->pack",
            "git_buf_cstr(&tmp_path)"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1107-1168",
          "snippet": "int git_packfile_alloc(struct git_pack_file **pack_out, const char *path)\n{\n\tstruct stat st;\n\tstruct git_pack_file *p;\n\tsize_t path_len = path ? strlen(path) : 0, alloc_len;\n\n\t*pack_out = NULL;\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*p), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tp = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(p);\n\n\tmemcpy(p->pack_name, path, path_len + 1);\n\n\t/*\n\t * Make sure a corresponding .pack file exists and that\n\t * the index looks sane.\n\t */\n\tif (git__suffixcmp(path, \".idx\") == 0) {\n\t\tsize_t root_len = path_len - strlen(\".idx\");\n\n\t\tmemcpy(p->pack_name + root_len, \".keep\", sizeof(\".keep\"));\n\t\tif (git_path_exists(p->pack_name) == true)\n\t\t\tp->pack_keep = 1;\n\n\t\tmemcpy(p->pack_name + root_len, \".pack\", sizeof(\".pack\"));\n\t}\n\n\tif (p_stat(p->pack_name, &st) < 0 || !S_ISREG(st.st_mode)) {\n\t\tgit__free(p);\n\t\treturn git_odb__error_notfound(\"packfile not found\", NULL, 0);\n\t}\n\n\t/* ok, it looks sane as far as we can check without\n\t * actually mapping the pack file.\n\t */\n\tp->mwf.fd = -1;\n\tp->mwf.size = st.st_size;\n\tp->pack_local = 1;\n\tp->mtime = (git_time_t)st.st_mtime;\n\tp->index_version = -1;\n\n\tif (git_mutex_init(&p->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize packfile mutex\");\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (cache_init(&p->bases) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*pack_out = p;\n\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_alloc(struct git_pack_file **pack_out, const char *path)\n{\n\tstruct stat st;\n\tstruct git_pack_file *p;\n\tsize_t path_len = path ? strlen(path) : 0, alloc_len;\n\n\t*pack_out = NULL;\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*p), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tp = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(p);\n\n\tmemcpy(p->pack_name, path, path_len + 1);\n\n\t/*\n\t * Make sure a corresponding .pack file exists and that\n\t * the index looks sane.\n\t */\n\tif (git__suffixcmp(path, \".idx\") == 0) {\n\t\tsize_t root_len = path_len - strlen(\".idx\");\n\n\t\tmemcpy(p->pack_name + root_len, \".keep\", sizeof(\".keep\"));\n\t\tif (git_path_exists(p->pack_name) == true)\n\t\t\tp->pack_keep = 1;\n\n\t\tmemcpy(p->pack_name + root_len, \".pack\", sizeof(\".pack\"));\n\t}\n\n\tif (p_stat(p->pack_name, &st) < 0 || !S_ISREG(st.st_mode)) {\n\t\tgit__free(p);\n\t\treturn git_odb__error_notfound(\"packfile not found\", NULL, 0);\n\t}\n\n\t/* ok, it looks sane as far as we can check without\n\t * actually mapping the pack file.\n\t */\n\tp->mwf.fd = -1;\n\tp->mwf.size = st.st_size;\n\tp->pack_local = 1;\n\tp->mtime = (git_time_t)st.st_mtime;\n\tp->index_version = -1;\n\n\tif (git_mutex_init(&p->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize packfile mutex\");\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (cache_init(&p->bases) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*pack_out = p;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&tmp_path"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mktmp",
          "args": [
            "&tmp_path",
            "git_buf_cstr(&path)",
            "idx->mode"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mktmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "25-51",
          "snippet": "int git_futils_mktmp(git_buf *path_out, const char *filename, mode_t mode)\n{\n\tint fd;\n\tmode_t mask;\n\n\tp_umask(mask = p_umask(0));\n\n\tgit_buf_sets(path_out, filename);\n\tgit_buf_puts(path_out, \"_git2_XXXXXX\");\n\n\tif (git_buf_oom(path_out))\n\t\treturn -1;\n\n\tif ((fd = p_mkstemp(path_out->ptr)) < 0) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to create temporary file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\tif (p_chmod(path_out->ptr, (mode & ~mask))) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to set permissions on file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mktmp(git_buf *path_out, const char *filename, mode_t mode)\n{\n\tint fd;\n\tmode_t mask;\n\n\tp_umask(mask = p_umask(0));\n\n\tgit_buf_sets(path_out, filename);\n\tgit_buf_puts(path_out, \"_git2_XXXXXX\");\n\n\tif (git_buf_oom(path_out))\n\t\treturn -1;\n\n\tif ((fd = p_mkstemp(path_out->ptr)) < 0) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to create temporary file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\tif (p_chmod(path_out->ptr, (mode & ~mask))) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to set permissions on file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "prefix",
            "suff"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_ctx_init",
          "args": [
            "&idx->trailer"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "231-248",
          "snippet": "int git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct git_hash_prov hash_prov = {0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic struct git_hash_prov hash_prov = {0};\n\nint git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "idx"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_indexer)"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nint git_indexer_new(\n\t\tgit_indexer **out,\n\t\tconst char *prefix,\n\t\tunsigned int mode,\n\t\tgit_odb *odb,\n\t\tgit_transfer_progress_cb progress_cb,\n\t\tvoid *progress_payload)\n{\n\tgit_indexer *idx;\n\tgit_buf path = GIT_BUF_INIT, tmp_path = GIT_BUF_INIT;\n\tstatic const char suff[] = \"/pack\";\n\tint error, fd = -1;\n\n\tidx = git__calloc(1, sizeof(git_indexer));\n\tGITERR_CHECK_ALLOC(idx);\n\tidx->odb = odb;\n\tidx->progress_cb = progress_cb;\n\tidx->progress_payload = progress_payload;\n\tidx->mode = mode ? mode : GIT_PACK_FILE_MODE;\n\tgit_hash_ctx_init(&idx->hash_ctx);\n\tgit_hash_ctx_init(&idx->trailer);\n\n\terror = git_buf_joinpath(&path, prefix, suff);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tfd = git_futils_mktmp(&tmp_path, git_buf_cstr(&path), idx->mode);\n\tgit_buf_free(&path);\n\tif (fd < 0)\n\t\tgoto cleanup;\n\n\terror = git_packfile_alloc(&idx->pack, git_buf_cstr(&tmp_path));\n\tgit_buf_free(&tmp_path);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.fd = fd;\n\tif ((error = git_mwindow_file_register(&idx->pack->mwf)) < 0)\n\t\tgoto cleanup;\n\n\t*out = idx;\n\treturn 0;\n\ncleanup:\n\tif (fd != -1)\n\t\tp_close(fd);\n\n\tgit_buf_free(&path);\n\tgit_buf_free(&tmp_path);\n\tgit__free(idx);\n\treturn -1;\n}"
  },
  {
    "function_name": "objects_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "98-104",
    "snippet": "static int objects_cmp(const void *a, const void *b)\n{\n\tconst struct entry *entrya = a;\n\tconst struct entry *entryb = b;\n\n\treturn git_oid__cmp(&entrya->oid, &entryb->oid);\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&entrya->oid",
            "&entryb->oid"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int objects_cmp(const void *a, const void *b)\n{\n\tconst struct entry *entrya = a;\n\tconst struct entry *entryb = b;\n\n\treturn git_oid__cmp(&entrya->oid, &entryb->oid);\n}"
  },
  {
    "function_name": "parse_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "73-96",
    "snippet": "static int parse_header(struct git_pack_header *hdr, struct git_pack_file *pack)\n{\n\tint error;\n\tgit_map map;\n\n\tif ((error = p_mmap(&map, sizeof(*hdr), GIT_PROT_READ, GIT_MAP_SHARED, pack->mwf.fd, 0)) < 0)\n\t\treturn error;\n\n\tmemcpy(hdr, map.data, sizeof(*hdr));\n\tp_munmap(&map);\n\n\t/* Verify we recognize this pack file format. */\n\tif (hdr->hdr_signature != ntohl(PACK_SIGNATURE)) {\n\t\tgiterr_set(GITERR_INDEXER, \"Wrong pack signature\");\n\t\treturn -1;\n\t}\n\n\tif (!pack_version_ok(hdr->hdr_version)) {\n\t\tgiterr_set(GITERR_INDEXER, \"Wrong pack version\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEXER",
            "\"Wrong pack version\""
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_version_ok",
          "args": [
            "hdr->hdr_version"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "PACK_SIGNATURE"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_munmap",
          "args": [
            "&map"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "p_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "261-267",
          "snippet": "int p_munmap(git_map *map)\n{\n\tassert(map != NULL);\n\tfree(map->data);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_munmap(git_map *map)\n{\n\tassert(map != NULL);\n\tfree(map->data);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hdr",
            "map.data",
            "sizeof(*hdr)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_mmap",
          "args": [
            "&map",
            "sizeof(*hdr)",
            "GIT_PROT_READ",
            "GIT_MAP_SHARED",
            "pack->mwf.fd",
            "0"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "p_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "235-259",
          "snippet": "int p_mmap(git_map *out, size_t len, int prot, int flags, int fd, git_off_t offset)\n{\n\tGIT_MMAP_VALIDATE(out, len, prot, flags);\n\n\tout->data = NULL;\n\tout->len = 0;\n\n\tif ((prot & GIT_PROT_WRITE) && ((flags & GIT_MAP_TYPE) == GIT_MAP_SHARED)) {\n\t\tgiterr_set(GITERR_OS, \"Trying to map shared-writeable\");\n\t\treturn -1;\n\t}\n\n\tout->data = malloc(len);\n\tGITERR_CHECK_ALLOC(out->data);\n\n\tif (!git__is_ssizet(len) ||\n\t\t(p_lseek(fd, offset, SEEK_SET) < 0) ||\n\t\t(p_read(fd, out->data, len) != (ssize_t)len)) {\n\t\tgiterr_set(GITERR_OS, \"mmap emulation failed\");\n\t\treturn -1;\n\t}\n\n\tout->len = len;\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_mmap(git_map *out, size_t len, int prot, int flags, int fd, git_off_t offset)\n{\n\tGIT_MMAP_VALIDATE(out, len, prot, flags);\n\n\tout->data = NULL;\n\tout->len = 0;\n\n\tif ((prot & GIT_PROT_WRITE) && ((flags & GIT_MAP_TYPE) == GIT_MAP_SHARED)) {\n\t\tgiterr_set(GITERR_OS, \"Trying to map shared-writeable\");\n\t\treturn -1;\n\t}\n\n\tout->data = malloc(len);\n\tGITERR_CHECK_ALLOC(out->data);\n\n\tif (!git__is_ssizet(len) ||\n\t\t(p_lseek(fd, offset, SEEK_SET) < 0) ||\n\t\t(p_read(fd, out->data, len) != (ssize_t)len)) {\n\t\tgiterr_set(GITERR_OS, \"mmap emulation failed\");\n\t\treturn -1;\n\t}\n\n\tout->len = len;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nstatic int parse_header(struct git_pack_header *hdr, struct git_pack_file *pack)\n{\n\tint error;\n\tgit_map map;\n\n\tif ((error = p_mmap(&map, sizeof(*hdr), GIT_PROT_READ, GIT_MAP_SHARED, pack->mwf.fd, 0)) < 0)\n\t\treturn error;\n\n\tmemcpy(hdr, map.data, sizeof(*hdr));\n\tp_munmap(&map);\n\n\t/* Verify we recognize this pack file format. */\n\tif (hdr->hdr_signature != ntohl(PACK_SIGNATURE)) {\n\t\tgiterr_set(GITERR_INDEXER, \"Wrong pack signature\");\n\t\treturn -1;\n\t}\n\n\tif (!pack_version_ok(hdr->hdr_version)) {\n\t\tgiterr_set(GITERR_INDEXER, \"Wrong pack version\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_indexer_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
    "lines": "68-71",
    "snippet": "const git_oid *git_indexer_hash(const git_indexer *idx)\n{\n\treturn &idx->hash;\n}",
    "includes": [
      "#include \"zstream.h\"",
      "#include \"oidmap.h\"",
      "#include \"oid.h\"",
      "#include \"filebuf.h\"",
      "#include \"pack.h\"",
      "#include \"posix.h\"",
      "#include \"mwindow.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/indexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nconst git_oid *git_indexer_hash(const git_indexer *idx)\n{\n\treturn &idx->hash;\n}"
  }
]