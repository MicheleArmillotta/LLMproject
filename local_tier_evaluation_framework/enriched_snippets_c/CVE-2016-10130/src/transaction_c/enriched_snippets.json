[
  {
    "function_name": "git_transaction_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "357-393",
    "snippet": "void git_transaction_free(git_transaction *tx)\n{\n\ttransaction_node *node;\n\tgit_pool pool;\n\tgit_strmap_iter pos;\n\n\tassert(tx);\n\n\tif (tx->type == TRANSACTION_CONFIG) {\n\t\tif (tx->cfg) {\n\t\t\tgit_config_unlock(tx->cfg, false);\n\t\t\tgit_config_free(tx->cfg);\n\t\t}\n\n\t\tgit__free(tx);\n\t\treturn;\n\t}\n\n\t/* start by unlocking the ones we've left hanging, if any */\n\tfor (pos = kh_begin(tx->locks); pos < kh_end(tx->locks); pos++) {\n\t\tif (!git_strmap_has_data(tx->locks, pos))\n\t\t\tcontinue;\n\n\t\tnode = git_strmap_value_at(tx->locks, pos);\n\t\tif (node->committed)\n\t\t\tcontinue;\n\n\t\tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);\n\t}\n\n\tgit_refdb_free(tx->db);\n\tgit_strmap_free(tx->locks);\n\n\t/* tx is inside the pool, so we need to extract the data */\n\tmemcpy(&pool, &tx->pool, sizeof(git_pool));\n\tgit_pool_clear(&pool);\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&pool"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&pool",
            "&tx->pool",
            "sizeof(git_pool)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_free",
          "args": [
            "tx->locks"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_refdb_free",
          "args": [
            "tx->db"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "93-99",
          "snippet": "void git_refdb_free(git_refdb *db)\n{\n\tif (db == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(db, git_refdb__free);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nvoid git_refdb_free(git_refdb *db)\n{\n\tif (db == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(db, git_refdb__free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refdb_unlock",
          "args": [
            "tx->db",
            "node->payload",
            "false",
            "false",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "254-259",
          "snippet": "int git_refdb_unlock(git_refdb *db, void *payload, int success, int update_reflog, const git_reference *ref, const git_signature *sig, const char *message)\n{\n\tassert(db);\n\n\treturn db->backend->unlock(db->backend, payload, success, update_reflog, ref, sig, message);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_unlock(git_refdb *db, void *payload, int success, int update_reflog, const git_reference *ref, const git_signature *sig, const char *message)\n{\n\tassert(db);\n\n\treturn db->backend->unlock(db->backend, payload, success, update_reflog, ref, sig, message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "tx->locks",
            "pos"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_has_data",
          "args": [
            "tx->locks",
            "pos"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_end",
          "args": [
            "tx->locks"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_begin",
          "args": [
            "tx->locks"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "tx"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "tx->cfg"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_unlock",
          "args": [
            "tx->cfg",
            "false"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1177-1191",
          "snippet": "int git_config_unlock(git_config *cfg, int commit)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file) {\n\t\tgiterr_set(GITERR_CONFIG, \"cannot lock; the config has no backends/files\");\n\t\treturn -1;\n\t}\n\n\tfile = internal->file;\n\n\treturn file->unlock(file, commit);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_unlock(git_config *cfg, int commit)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file) {\n\t\tgiterr_set(GITERR_CONFIG, \"cannot lock; the config has no backends/files\");\n\t\treturn -1;\n\t}\n\n\tfile = internal->file;\n\n\treturn file->unlock(file, commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tx"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_transaction_free(git_transaction *tx)\n{\n\ttransaction_node *node;\n\tgit_pool pool;\n\tgit_strmap_iter pos;\n\n\tassert(tx);\n\n\tif (tx->type == TRANSACTION_CONFIG) {\n\t\tif (tx->cfg) {\n\t\t\tgit_config_unlock(tx->cfg, false);\n\t\t\tgit_config_free(tx->cfg);\n\t\t}\n\n\t\tgit__free(tx);\n\t\treturn;\n\t}\n\n\t/* start by unlocking the ones we've left hanging, if any */\n\tfor (pos = kh_begin(tx->locks); pos < kh_end(tx->locks); pos++) {\n\t\tif (!git_strmap_has_data(tx->locks, pos))\n\t\t\tcontinue;\n\n\t\tnode = git_strmap_value_at(tx->locks, pos);\n\t\tif (node->committed)\n\t\t\tcontinue;\n\n\t\tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);\n\t}\n\n\tgit_refdb_free(tx->db);\n\tgit_strmap_free(tx->locks);\n\n\t/* tx is inside the pool, so we need to extract the data */\n\tmemcpy(&pool, &tx->pool, sizeof(git_pool));\n\tgit_pool_clear(&pool);\n}"
  },
  {
    "function_name": "git_transaction_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "323-355",
    "snippet": "int git_transaction_commit(git_transaction *tx)\n{\n\ttransaction_node *node;\n\tgit_strmap_iter pos;\n\tint error = 0;\n\n\tassert(tx);\n\n\tif (tx->type == TRANSACTION_CONFIG) {\n\t\terror = git_config_unlock(tx->cfg, true);\n\t\ttx->cfg = NULL;\n\n\t\treturn error;\n\t}\n\n\tfor (pos = kh_begin(tx->locks); pos < kh_end(tx->locks); pos++) {\n\t\tif (!git_strmap_has_data(tx->locks, pos))\n\t\t\tcontinue;\n\n\t\tnode = git_strmap_value_at(tx->locks, pos);\n\t\tif (node->reflog) {\n\t\t\tif ((error = tx->db->backend->reflog_write(tx->db->backend, node->reflog)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (node->ref_type != GIT_REF_INVALID) {\n\t\t\tif ((error = update_target(tx->db, node)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_target",
          "args": [
            "tx->db",
            "node"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "update_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "291-321",
          "snippet": "static int update_target(git_refdb *db, transaction_node *node)\n{\n\tgit_reference *ref;\n\tint error, update_reflog;\n\n\tif (node->ref_type == GIT_REF_OID) {\n\t\tref = git_reference__alloc(node->name, &node->target.id, NULL);\n\t} else if (node->ref_type == GIT_REF_SYMBOLIC) {\n\t\tref = git_reference__alloc_symbolic(node->name, node->target.symbolic);\n\t} else {\n\t\tabort();\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\tupdate_reflog = node->reflog == NULL;\n\n\tif (node->remove) {\n\t\terror =  git_refdb_unlock(db, node->payload, 2, false, ref, NULL, NULL);\n\t} else if (node->ref_type == GIT_REF_OID) {\n\t\terror = git_refdb_unlock(db, node->payload, true, update_reflog, ref, node->sig, node->message);\n\t} else if (node->ref_type == GIT_REF_SYMBOLIC) {\n\t\terror = git_refdb_unlock(db, node->payload, true, update_reflog, ref, node->sig, node->message);\n\t} else {\n\t\tabort();\n\t}\n\n\tgit_reference_free(ref);\n\tnode->committed = true;\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int update_target(git_refdb *db, transaction_node *node)\n{\n\tgit_reference *ref;\n\tint error, update_reflog;\n\n\tif (node->ref_type == GIT_REF_OID) {\n\t\tref = git_reference__alloc(node->name, &node->target.id, NULL);\n\t} else if (node->ref_type == GIT_REF_SYMBOLIC) {\n\t\tref = git_reference__alloc_symbolic(node->name, node->target.symbolic);\n\t} else {\n\t\tabort();\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\tupdate_reflog = node->reflog == NULL;\n\n\tif (node->remove) {\n\t\terror =  git_refdb_unlock(db, node->payload, 2, false, ref, NULL, NULL);\n\t} else if (node->ref_type == GIT_REF_OID) {\n\t\terror = git_refdb_unlock(db, node->payload, true, update_reflog, ref, node->sig, node->message);\n\t} else if (node->ref_type == GIT_REF_SYMBOLIC) {\n\t\terror = git_refdb_unlock(db, node->payload, true, update_reflog, ref, node->sig, node->message);\n\t} else {\n\t\tabort();\n\t}\n\n\tgit_reference_free(ref);\n\tnode->committed = true;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx->db->backend->reflog_write",
          "args": [
            "tx->db->backend",
            "node->reflog"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "tx->locks",
            "pos"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_has_data",
          "args": [
            "tx->locks",
            "pos"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_end",
          "args": [
            "tx->locks"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_begin",
          "args": [
            "tx->locks"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_config_unlock",
          "args": [
            "tx->cfg",
            "true"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1177-1191",
          "snippet": "int git_config_unlock(git_config *cfg, int commit)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file) {\n\t\tgiterr_set(GITERR_CONFIG, \"cannot lock; the config has no backends/files\");\n\t\treturn -1;\n\t}\n\n\tfile = internal->file;\n\n\treturn file->unlock(file, commit);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_unlock(git_config *cfg, int commit)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file) {\n\t\tgiterr_set(GITERR_CONFIG, \"cannot lock; the config has no backends/files\");\n\t\treturn -1;\n\t}\n\n\tfile = internal->file;\n\n\treturn file->unlock(file, commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tx"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_commit(git_transaction *tx)\n{\n\ttransaction_node *node;\n\tgit_strmap_iter pos;\n\tint error = 0;\n\n\tassert(tx);\n\n\tif (tx->type == TRANSACTION_CONFIG) {\n\t\terror = git_config_unlock(tx->cfg, true);\n\t\ttx->cfg = NULL;\n\n\t\treturn error;\n\t}\n\n\tfor (pos = kh_begin(tx->locks); pos < kh_end(tx->locks); pos++) {\n\t\tif (!git_strmap_has_data(tx->locks, pos))\n\t\t\tcontinue;\n\n\t\tnode = git_strmap_value_at(tx->locks, pos);\n\t\tif (node->reflog) {\n\t\t\tif ((error = tx->db->backend->reflog_write(tx->db->backend, node->reflog)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (node->ref_type != GIT_REF_INVALID) {\n\t\t\tif ((error = update_target(tx->db, node)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "291-321",
    "snippet": "static int update_target(git_refdb *db, transaction_node *node)\n{\n\tgit_reference *ref;\n\tint error, update_reflog;\n\n\tif (node->ref_type == GIT_REF_OID) {\n\t\tref = git_reference__alloc(node->name, &node->target.id, NULL);\n\t} else if (node->ref_type == GIT_REF_SYMBOLIC) {\n\t\tref = git_reference__alloc_symbolic(node->name, node->target.symbolic);\n\t} else {\n\t\tabort();\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\tupdate_reflog = node->reflog == NULL;\n\n\tif (node->remove) {\n\t\terror =  git_refdb_unlock(db, node->payload, 2, false, ref, NULL, NULL);\n\t} else if (node->ref_type == GIT_REF_OID) {\n\t\terror = git_refdb_unlock(db, node->payload, true, update_reflog, ref, node->sig, node->message);\n\t} else if (node->ref_type == GIT_REF_SYMBOLIC) {\n\t\terror = git_refdb_unlock(db, node->payload, true, update_reflog, ref, node->sig, node->message);\n\t} else {\n\t\tabort();\n\t}\n\n\tgit_reference_free(ref);\n\tnode->committed = true;\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_refdb_unlock",
          "args": [
            "db",
            "node->payload",
            "true",
            "update_reflog",
            "ref",
            "node->sig",
            "node->message"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "254-259",
          "snippet": "int git_refdb_unlock(git_refdb *db, void *payload, int success, int update_reflog, const git_reference *ref, const git_signature *sig, const char *message)\n{\n\tassert(db);\n\n\treturn db->backend->unlock(db->backend, payload, success, update_reflog, ref, sig, message);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_unlock(git_refdb *db, void *payload, int success, int update_reflog, const git_reference *ref, const git_signature *sig, const char *message)\n{\n\tassert(db);\n\n\treturn db->backend->unlock(db->backend, payload, success, update_reflog, ref, sig, message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "ref"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference__alloc_symbolic",
          "args": [
            "node->name",
            "node->target.symbolic"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__alloc_symbolic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "50-69",
          "snippet": "git_reference *git_reference__alloc_symbolic(\n\tconst char *name, const char *target)\n{\n\tgit_reference *ref;\n\n\tassert(name && target);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_SYMBOLIC;\n\n\tif ((ref->target.symbolic = git__strdup(target)) == NULL) {\n\t\tgit__free(ref);\n\t\treturn NULL;\n\t}\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc_symbolic(\n\tconst char *name, const char *target)\n{\n\tgit_reference *ref;\n\n\tassert(name && target);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_SYMBOLIC;\n\n\tif ((ref->target.symbolic = git__strdup(target)) == NULL) {\n\t\tgit__free(ref);\n\t\treturn NULL;\n\t}\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__alloc",
          "args": [
            "node->name",
            "&node->target.id",
            "NULL"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "71-91",
          "snippet": "git_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int update_target(git_refdb *db, transaction_node *node)\n{\n\tgit_reference *ref;\n\tint error, update_reflog;\n\n\tif (node->ref_type == GIT_REF_OID) {\n\t\tref = git_reference__alloc(node->name, &node->target.id, NULL);\n\t} else if (node->ref_type == GIT_REF_SYMBOLIC) {\n\t\tref = git_reference__alloc_symbolic(node->name, node->target.symbolic);\n\t} else {\n\t\tabort();\n\t}\n\n\tGITERR_CHECK_ALLOC(ref);\n\tupdate_reflog = node->reflog == NULL;\n\n\tif (node->remove) {\n\t\terror =  git_refdb_unlock(db, node->payload, 2, false, ref, NULL, NULL);\n\t} else if (node->ref_type == GIT_REF_OID) {\n\t\terror = git_refdb_unlock(db, node->payload, true, update_reflog, ref, node->sig, node->message);\n\t} else if (node->ref_type == GIT_REF_SYMBOLIC) {\n\t\terror = git_refdb_unlock(db, node->payload, true, update_reflog, ref, node->sig, node->message);\n\t} else {\n\t\tabort();\n\t}\n\n\tgit_reference_free(ref);\n\tnode->committed = true;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_transaction_set_reflog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "275-289",
    "snippet": "int git_transaction_set_reflog(git_transaction *tx, const char *refname, const git_reflog *reflog)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && reflog);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = dup_reflog(&node->reflog, reflog, &tx->pool)) < 0)\n\t\treturn error;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dup_reflog",
          "args": [
            "&node->reflog",
            "reflog",
            "&tx->pool"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "dup_reflog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "232-273",
          "snippet": "static int dup_reflog(git_reflog **out, const git_reflog *in, git_pool *pool)\n{\n\tgit_reflog *reflog;\n\tgit_reflog_entry *entries;\n\tsize_t len, i;\n\n\treflog = git_pool_mallocz(pool, sizeof(git_reflog));\n\tGITERR_CHECK_ALLOC(reflog);\n\n\treflog->ref_name = git_pool_strdup(pool, in->ref_name);\n\tGITERR_CHECK_ALLOC(reflog->ref_name);\n\n\tlen = in->entries.length;\n\treflog->entries.length = len;\n\treflog->entries.contents = git_pool_mallocz(pool, len * sizeof(void *));\n\tGITERR_CHECK_ALLOC(reflog->entries.contents);\n\n\tentries = git_pool_mallocz(pool, len * sizeof(git_reflog_entry));\n\tGITERR_CHECK_ALLOC(entries);\n\n\tfor (i = 0; i < len; i++) {\n\t\tconst git_reflog_entry *src;\n\t\tgit_reflog_entry *tgt;\n\n\t\ttgt = &entries[i];\n\t\treflog->entries.contents[i] = tgt;\n\n\t\tsrc = git_vector_get(&in->entries, i);\n\t\tgit_oid_cpy(&tgt->oid_old, &src->oid_old);\n\t\tgit_oid_cpy(&tgt->oid_cur, &src->oid_cur);\n\n\t\ttgt->msg = git_pool_strdup(pool, src->msg);\n\t\tGITERR_CHECK_ALLOC(tgt->msg);\n\n\t\tif (git_signature__pdup(&tgt->committer, src->committer, pool) < 0)\n\t\t\treturn -1;\n\t}\n\n\n\t*out = reflog;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int dup_reflog(git_reflog **out, const git_reflog *in, git_pool *pool)\n{\n\tgit_reflog *reflog;\n\tgit_reflog_entry *entries;\n\tsize_t len, i;\n\n\treflog = git_pool_mallocz(pool, sizeof(git_reflog));\n\tGITERR_CHECK_ALLOC(reflog);\n\n\treflog->ref_name = git_pool_strdup(pool, in->ref_name);\n\tGITERR_CHECK_ALLOC(reflog->ref_name);\n\n\tlen = in->entries.length;\n\treflog->entries.length = len;\n\treflog->entries.contents = git_pool_mallocz(pool, len * sizeof(void *));\n\tGITERR_CHECK_ALLOC(reflog->entries.contents);\n\n\tentries = git_pool_mallocz(pool, len * sizeof(git_reflog_entry));\n\tGITERR_CHECK_ALLOC(entries);\n\n\tfor (i = 0; i < len; i++) {\n\t\tconst git_reflog_entry *src;\n\t\tgit_reflog_entry *tgt;\n\n\t\ttgt = &entries[i];\n\t\treflog->entries.contents[i] = tgt;\n\n\t\tsrc = git_vector_get(&in->entries, i);\n\t\tgit_oid_cpy(&tgt->oid_old, &src->oid_old);\n\t\tgit_oid_cpy(&tgt->oid_cur, &src->oid_cur);\n\n\t\ttgt->msg = git_pool_strdup(pool, src->msg);\n\t\tGITERR_CHECK_ALLOC(tgt->msg);\n\n\t\tif (git_signature__pdup(&tgt->committer, src->committer, pool) < 0)\n\t\t\treturn -1;\n\t}\n\n\n\t*out = reflog;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_locked",
          "args": [
            "&node",
            "tx",
            "refname"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "find_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "135-150",
          "snippet": "static int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tx && refname && reflog"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_set_reflog(git_transaction *tx, const char *refname, const git_reflog *reflog)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && reflog);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = dup_reflog(&node->reflog, reflog, &tx->pool)) < 0)\n\t\treturn error;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dup_reflog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "232-273",
    "snippet": "static int dup_reflog(git_reflog **out, const git_reflog *in, git_pool *pool)\n{\n\tgit_reflog *reflog;\n\tgit_reflog_entry *entries;\n\tsize_t len, i;\n\n\treflog = git_pool_mallocz(pool, sizeof(git_reflog));\n\tGITERR_CHECK_ALLOC(reflog);\n\n\treflog->ref_name = git_pool_strdup(pool, in->ref_name);\n\tGITERR_CHECK_ALLOC(reflog->ref_name);\n\n\tlen = in->entries.length;\n\treflog->entries.length = len;\n\treflog->entries.contents = git_pool_mallocz(pool, len * sizeof(void *));\n\tGITERR_CHECK_ALLOC(reflog->entries.contents);\n\n\tentries = git_pool_mallocz(pool, len * sizeof(git_reflog_entry));\n\tGITERR_CHECK_ALLOC(entries);\n\n\tfor (i = 0; i < len; i++) {\n\t\tconst git_reflog_entry *src;\n\t\tgit_reflog_entry *tgt;\n\n\t\ttgt = &entries[i];\n\t\treflog->entries.contents[i] = tgt;\n\n\t\tsrc = git_vector_get(&in->entries, i);\n\t\tgit_oid_cpy(&tgt->oid_old, &src->oid_old);\n\t\tgit_oid_cpy(&tgt->oid_cur, &src->oid_cur);\n\n\t\ttgt->msg = git_pool_strdup(pool, src->msg);\n\t\tGITERR_CHECK_ALLOC(tgt->msg);\n\n\t\tif (git_signature__pdup(&tgt->committer, src->committer, pool) < 0)\n\t\t\treturn -1;\n\t}\n\n\n\t*out = reflog;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_signature__pdup",
          "args": [
            "&tgt->committer",
            "src->committer",
            "pool"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature__pdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "122-144",
          "snippet": "int git_signature__pdup(git_signature **dest, const git_signature *source, git_pool *pool)\n{\n\tgit_signature *signature;\n\n\tif (source == NULL)\n\t\treturn 0;\n\n\tsignature = git_pool_mallocz(pool, sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(signature);\n\n\tsignature->name = git_pool_strdup(pool, source->name);\n\tGITERR_CHECK_ALLOC(signature->name);\n\n\tsignature->email = git_pool_strdup(pool, source->email);\n\tGITERR_CHECK_ALLOC(signature->email);\n\n\tsignature->when.time = source->when.time;\n\tsignature->when.offset = source->when.offset;\n\n\t*dest = signature;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nint git_signature__pdup(git_signature **dest, const git_signature *source, git_pool *pool)\n{\n\tgit_signature *signature;\n\n\tif (source == NULL)\n\t\treturn 0;\n\n\tsignature = git_pool_mallocz(pool, sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(signature);\n\n\tsignature->name = git_pool_strdup(pool, source->name);\n\tGITERR_CHECK_ALLOC(signature->name);\n\n\tsignature->email = git_pool_strdup(pool, source->email);\n\tGITERR_CHECK_ALLOC(signature->email);\n\n\tsignature->when.time = source->when.time;\n\tsignature->when.offset = source->when.offset;\n\n\t*dest = signature;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tgt->msg"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "pool",
            "src->msg"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&tgt->oid_cur",
            "&src->oid_cur"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&in->entries",
            "i"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entries"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_mallocz",
          "args": [
            "pool",
            "len * sizeof(git_reflog_entry)"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "reflog->entries.contents"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "reflog->ref_name"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "reflog"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int dup_reflog(git_reflog **out, const git_reflog *in, git_pool *pool)\n{\n\tgit_reflog *reflog;\n\tgit_reflog_entry *entries;\n\tsize_t len, i;\n\n\treflog = git_pool_mallocz(pool, sizeof(git_reflog));\n\tGITERR_CHECK_ALLOC(reflog);\n\n\treflog->ref_name = git_pool_strdup(pool, in->ref_name);\n\tGITERR_CHECK_ALLOC(reflog->ref_name);\n\n\tlen = in->entries.length;\n\treflog->entries.length = len;\n\treflog->entries.contents = git_pool_mallocz(pool, len * sizeof(void *));\n\tGITERR_CHECK_ALLOC(reflog->entries.contents);\n\n\tentries = git_pool_mallocz(pool, len * sizeof(git_reflog_entry));\n\tGITERR_CHECK_ALLOC(entries);\n\n\tfor (i = 0; i < len; i++) {\n\t\tconst git_reflog_entry *src;\n\t\tgit_reflog_entry *tgt;\n\n\t\ttgt = &entries[i];\n\t\treflog->entries.contents[i] = tgt;\n\n\t\tsrc = git_vector_get(&in->entries, i);\n\t\tgit_oid_cpy(&tgt->oid_old, &src->oid_old);\n\t\tgit_oid_cpy(&tgt->oid_cur, &src->oid_cur);\n\n\t\ttgt->msg = git_pool_strdup(pool, src->msg);\n\t\tGITERR_CHECK_ALLOC(tgt->msg);\n\n\t\tif (git_signature__pdup(&tgt->committer, src->committer, pool) < 0)\n\t\t\treturn -1;\n\t}\n\n\n\t*out = reflog;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_transaction_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "218-230",
    "snippet": "int git_transaction_remove(git_transaction *tx, const char *refname)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tnode->remove = true;\n\tnode->ref_type = GIT_REF_OID; /* the id will be ignored */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_locked",
          "args": [
            "&node",
            "tx",
            "refname"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "find_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "135-150",
          "snippet": "static int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_remove(git_transaction *tx, const char *refname)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tnode->remove = true;\n\tnode->ref_type = GIT_REF_OID; /* the id will be ignored */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_transaction_set_symbolic_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "198-216",
    "snippet": "int git_transaction_set_symbolic_target(git_transaction *tx, const char *refname, const char *target, const git_signature *sig, const char *msg)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && target);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = copy_common(node, tx, sig, msg)) < 0)\n\t\treturn error;\n\n\tnode->target.symbolic = git_pool_strdup(&tx->pool, target);\n\tGITERR_CHECK_ALLOC(node->target.symbolic);\n\tnode->ref_type = GIT_REF_SYMBOLIC;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "node->target.symbolic"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "&tx->pool",
            "target"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_common",
          "args": [
            "node",
            "tx",
            "sig",
            "msg"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "copy_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "152-177",
          "snippet": "static int copy_common(transaction_node *node, git_transaction *tx, const git_signature *sig, const char *msg)\n{\n\tif (sig && git_signature__pdup(&node->sig, sig, &tx->pool) < 0)\n\t\treturn -1;\n\n\tif (!node->sig) {\n\t\tgit_signature *tmp;\n\t\tint error;\n\n\t\tif (git_reference__log_signature(&tmp, tx->repo) < 0)\n\t\t\treturn -1;\n\n\t\t/* make sure the sig we use is in our pool */\n\t\terror = git_signature__pdup(&node->sig, tmp, &tx->pool);\n\t\tgit_signature_free(tmp);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (msg) {\n\t\tnode->message = git_pool_strdup(&tx->pool, msg);\n\t\tGITERR_CHECK_ALLOC(node->message);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int copy_common(transaction_node *node, git_transaction *tx, const git_signature *sig, const char *msg)\n{\n\tif (sig && git_signature__pdup(&node->sig, sig, &tx->pool) < 0)\n\t\treturn -1;\n\n\tif (!node->sig) {\n\t\tgit_signature *tmp;\n\t\tint error;\n\n\t\tif (git_reference__log_signature(&tmp, tx->repo) < 0)\n\t\t\treturn -1;\n\n\t\t/* make sure the sig we use is in our pool */\n\t\terror = git_signature__pdup(&node->sig, tmp, &tx->pool);\n\t\tgit_signature_free(tmp);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (msg) {\n\t\tnode->message = git_pool_strdup(&tx->pool, msg);\n\t\tGITERR_CHECK_ALLOC(node->message);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_locked",
          "args": [
            "&node",
            "tx",
            "refname"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "find_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "135-150",
          "snippet": "static int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tx && refname && target"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_set_symbolic_target(git_transaction *tx, const char *refname, const char *target, const git_signature *sig, const char *msg)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && target);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = copy_common(node, tx, sig, msg)) < 0)\n\t\treturn error;\n\n\tnode->target.symbolic = git_pool_strdup(&tx->pool, target);\n\tGITERR_CHECK_ALLOC(node->target.symbolic);\n\tnode->ref_type = GIT_REF_SYMBOLIC;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_transaction_set_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "179-196",
    "snippet": "int git_transaction_set_target(git_transaction *tx, const char *refname, const git_oid *target, const git_signature *sig, const char *msg)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && target);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = copy_common(node, tx, sig, msg)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&node->target.id, target);\n\tnode->ref_type = GIT_REF_OID;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&node->target.id",
            "target"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_common",
          "args": [
            "node",
            "tx",
            "sig",
            "msg"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "copy_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "152-177",
          "snippet": "static int copy_common(transaction_node *node, git_transaction *tx, const git_signature *sig, const char *msg)\n{\n\tif (sig && git_signature__pdup(&node->sig, sig, &tx->pool) < 0)\n\t\treturn -1;\n\n\tif (!node->sig) {\n\t\tgit_signature *tmp;\n\t\tint error;\n\n\t\tif (git_reference__log_signature(&tmp, tx->repo) < 0)\n\t\t\treturn -1;\n\n\t\t/* make sure the sig we use is in our pool */\n\t\terror = git_signature__pdup(&node->sig, tmp, &tx->pool);\n\t\tgit_signature_free(tmp);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (msg) {\n\t\tnode->message = git_pool_strdup(&tx->pool, msg);\n\t\tGITERR_CHECK_ALLOC(node->message);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int copy_common(transaction_node *node, git_transaction *tx, const git_signature *sig, const char *msg)\n{\n\tif (sig && git_signature__pdup(&node->sig, sig, &tx->pool) < 0)\n\t\treturn -1;\n\n\tif (!node->sig) {\n\t\tgit_signature *tmp;\n\t\tint error;\n\n\t\tif (git_reference__log_signature(&tmp, tx->repo) < 0)\n\t\t\treturn -1;\n\n\t\t/* make sure the sig we use is in our pool */\n\t\terror = git_signature__pdup(&node->sig, tmp, &tx->pool);\n\t\tgit_signature_free(tmp);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (msg) {\n\t\tnode->message = git_pool_strdup(&tx->pool, msg);\n\t\tGITERR_CHECK_ALLOC(node->message);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_locked",
          "args": [
            "&node",
            "tx",
            "refname"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "find_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "135-150",
          "snippet": "static int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tx && refname && target"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_set_target(git_transaction *tx, const char *refname, const git_oid *target, const git_signature *sig, const char *msg)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && target);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = copy_common(node, tx, sig, msg)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&node->target.id, target);\n\tnode->ref_type = GIT_REF_OID;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "152-177",
    "snippet": "static int copy_common(transaction_node *node, git_transaction *tx, const git_signature *sig, const char *msg)\n{\n\tif (sig && git_signature__pdup(&node->sig, sig, &tx->pool) < 0)\n\t\treturn -1;\n\n\tif (!node->sig) {\n\t\tgit_signature *tmp;\n\t\tint error;\n\n\t\tif (git_reference__log_signature(&tmp, tx->repo) < 0)\n\t\t\treturn -1;\n\n\t\t/* make sure the sig we use is in our pool */\n\t\terror = git_signature__pdup(&node->sig, tmp, &tx->pool);\n\t\tgit_signature_free(tmp);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (msg) {\n\t\tnode->message = git_pool_strdup(&tx->pool, msg);\n\t\tGITERR_CHECK_ALLOC(node->message);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "node->message"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "&tx->pool",
            "msg"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature_free",
          "args": [
            "tmp"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "14-24",
          "snippet": "void git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature__pdup",
          "args": [
            "&node->sig",
            "tmp",
            "&tx->pool"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature__pdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "122-144",
          "snippet": "int git_signature__pdup(git_signature **dest, const git_signature *source, git_pool *pool)\n{\n\tgit_signature *signature;\n\n\tif (source == NULL)\n\t\treturn 0;\n\n\tsignature = git_pool_mallocz(pool, sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(signature);\n\n\tsignature->name = git_pool_strdup(pool, source->name);\n\tGITERR_CHECK_ALLOC(signature->name);\n\n\tsignature->email = git_pool_strdup(pool, source->email);\n\tGITERR_CHECK_ALLOC(signature->email);\n\n\tsignature->when.time = source->when.time;\n\tsignature->when.offset = source->when.offset;\n\n\t*dest = signature;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nint git_signature__pdup(git_signature **dest, const git_signature *source, git_pool *pool)\n{\n\tgit_signature *signature;\n\n\tif (source == NULL)\n\t\treturn 0;\n\n\tsignature = git_pool_mallocz(pool, sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(signature);\n\n\tsignature->name = git_pool_strdup(pool, source->name);\n\tGITERR_CHECK_ALLOC(signature->name);\n\n\tsignature->email = git_pool_strdup(pool, source->email);\n\tGITERR_CHECK_ALLOC(signature->email);\n\n\tsignature->when.time = source->when.time;\n\tsignature->when.offset = source->when.offset;\n\n\t*dest = signature;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__log_signature",
          "args": [
            "&tmp",
            "tx->repo"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__log_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "425-437",
          "snippet": "int git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__log_signature(git_signature **out, git_repository *repo)\n{\n\tint error;\n\tgit_signature *who;\n\n\tif(((error = configured_ident(&who, repo)) < 0) &&\n\t   ((error = git_signature_default(&who, repo)) < 0) &&\n\t   ((error = git_signature_now(&who, \"unknown\", \"unknown\")) < 0))\n\t\treturn error;\n\n\t*out = who;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int copy_common(transaction_node *node, git_transaction *tx, const git_signature *sig, const char *msg)\n{\n\tif (sig && git_signature__pdup(&node->sig, sig, &tx->pool) < 0)\n\t\treturn -1;\n\n\tif (!node->sig) {\n\t\tgit_signature *tmp;\n\t\tint error;\n\n\t\tif (git_reference__log_signature(&tmp, tx->repo) < 0)\n\t\t\treturn -1;\n\n\t\t/* make sure the sig we use is in our pool */\n\t\terror = git_signature__pdup(&node->sig, tmp, &tx->pool);\n\t\tgit_signature_free(tmp);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (msg) {\n\t\tnode->message = git_pool_strdup(&tx->pool, msg);\n\t\tGITERR_CHECK_ALLOC(node->message);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "135-150",
    "snippet": "static int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "tx->locks",
            "pos"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"the specified reference is not locked\""
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "tx->locks",
            "pos"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "tx->locks",
            "refname"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int find_locked(transaction_node **out, git_transaction *tx, const char *refname)\n{\n\tgit_strmap_iter pos;\n\ttransaction_node *node;\n\n\tpos = git_strmap_lookup_index(tx->locks, refname);\n\tif (!git_strmap_valid_index(tx->locks, pos)) {\n\t\tgiterr_set(GITERR_REFERENCE, \"the specified reference is not locked\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tnode = git_strmap_value_at(tx->locks, pos);\n\n\t*out = node;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_transaction_lock_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "107-133",
    "snippet": "int git_transaction_lock_ref(git_transaction *tx, const char *refname)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname);\n\n\tnode = git_pool_mallocz(&tx->pool, sizeof(transaction_node));\n\tGITERR_CHECK_ALLOC(node);\n\n\tnode->name = git_pool_strdup(&tx->pool, refname);\n\tGITERR_CHECK_ALLOC(node->name);\n\n\tif ((error = git_refdb_lock(&node->payload, tx->db, refname)) < 0)\n\t\treturn error;\n\n\tgit_strmap_insert(tx->locks, node->name, node, error);\n\tif (error < 0) \n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refdb_unlock",
          "args": [
            "tx->db",
            "node->payload",
            "false",
            "false",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "254-259",
          "snippet": "int git_refdb_unlock(git_refdb *db, void *payload, int success, int update_reflog, const git_reference *ref, const git_signature *sig, const char *message)\n{\n\tassert(db);\n\n\treturn db->backend->unlock(db->backend, payload, success, update_reflog, ref, sig, message);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_unlock(git_refdb *db, void *payload, int success, int update_reflog, const git_reference *ref, const git_signature *sig, const char *message)\n{\n\tassert(db);\n\n\treturn db->backend->unlock(db->backend, payload, success, update_reflog, ref, sig, message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_insert",
          "args": [
            "tx->locks",
            "node->name",
            "node",
            "error"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_refdb_lock",
          "args": [
            "&node->payload",
            "tx->db",
            "refname"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "git_refdb_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb.c",
          "lines": "242-252",
          "snippet": "int git_refdb_lock(void **payload, git_refdb *db, const char *refname)\n{\n\tassert(payload && db && refname);\n\n\tif (!db->backend->lock) {\n\t\tgiterr_set(GITERR_REFERENCE, \"backend does not support locking\");\n\t\treturn -1;\n\t}\n\n\treturn db->backend->lock(payload, db->backend, refname);\n}",
          "includes": [
            "#include \"reflog.h\"",
            "#include \"refs.h\"",
            "#include \"refdb.h\"",
            "#include \"hash.h\"",
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/object.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reflog.h\"\n#include \"refs.h\"\n#include \"refdb.h\"\n#include \"hash.h\"\n#include \"git2/sys/refdb_backend.h\"\n#include \"git2/refdb.h\"\n#include \"git2/refs.h\"\n#include \"git2/object.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_refdb_lock(void **payload, git_refdb *db, const char *refname)\n{\n\tassert(payload && db && refname);\n\n\tif (!db->backend->lock) {\n\t\tgiterr_set(GITERR_REFERENCE, \"backend does not support locking\");\n\t\treturn -1;\n\t}\n\n\treturn db->backend->lock(payload, db->backend, refname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "node->name"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "&tx->pool",
            "refname"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "node"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_mallocz",
          "args": [
            "&tx->pool",
            "sizeof(transaction_node)"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tx && refname"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_lock_ref(git_transaction *tx, const char *refname)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname);\n\n\tnode = git_pool_mallocz(&tx->pool, sizeof(transaction_node));\n\tGITERR_CHECK_ALLOC(node);\n\n\tnode->name = git_pool_strdup(&tx->pool, refname);\n\tGITERR_CHECK_ALLOC(node->name);\n\n\tif ((error = git_refdb_lock(&node->payload, tx->db, refname)) < 0)\n\t\treturn error;\n\n\tgit_strmap_insert(tx->locks, node->name, node, error);\n\tif (error < 0) \n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_transaction_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "72-105",
    "snippet": "int git_transaction_new(git_transaction **out, git_repository *repo)\n{\n\tint error;\n\tgit_pool pool;\n\tgit_transaction *tx = NULL;\n\n\tassert(out && repo);\n\n\tgit_pool_init(&pool, 1);\n\n\ttx = git_pool_mallocz(&pool, sizeof(git_transaction));\n\tif (!tx) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tif ((error = git_strmap_alloc(&tx->locks)) < 0) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tif ((error = git_repository_refdb(&tx->db, repo)) < 0)\n\t\tgoto on_error;\n\n\ttx->type = TRANSACTION_REFS;\n\tmemcpy(&tx->pool, &pool, sizeof(git_pool));\n\ttx->repo = repo;\n\t*out = tx;\n\treturn 0;\n\non_error:\n\tgit_pool_clear(&pool);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&pool"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tx->pool",
            "&pool",
            "sizeof(git_pool)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_refdb",
          "args": [
            "&tx->db",
            "repo"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_refdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "804-811",
          "snippet": "int git_repository_refdb(git_refdb **out, git_repository *repo)\n{\n\tif (git_repository_refdb__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_refdb(git_refdb **out, git_repository *repo)\n{\n\tif (git_repository_refdb__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_alloc",
          "args": [
            "&tx->locks"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_mallocz",
          "args": [
            "&pool",
            "sizeof(git_transaction)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_init",
          "args": [
            "&pool",
            "1"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "120-129",
          "snippet": "void git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_new(git_transaction **out, git_repository *repo)\n{\n\tint error;\n\tgit_pool pool;\n\tgit_transaction *tx = NULL;\n\n\tassert(out && repo);\n\n\tgit_pool_init(&pool, 1);\n\n\ttx = git_pool_mallocz(&pool, sizeof(git_transaction));\n\tif (!tx) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tif ((error = git_strmap_alloc(&tx->locks)) < 0) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tif ((error = git_repository_refdb(&tx->db, repo)) < 0)\n\t\tgoto on_error;\n\n\ttx->type = TRANSACTION_REFS;\n\tmemcpy(&tx->pool, &pool, sizeof(git_pool));\n\ttx->repo = repo;\n\t*out = tx;\n\treturn 0;\n\non_error:\n\tgit_pool_clear(&pool);\n\treturn error;\n}"
  },
  {
    "function_name": "git_transaction_config_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
    "lines": "58-70",
    "snippet": "int git_transaction_config_new(git_transaction **out, git_config *cfg)\n{\n\tgit_transaction *tx;\n\tassert(out && cfg);\n\n\ttx = git__calloc(1, sizeof(git_transaction));\n\tGITERR_CHECK_ALLOC(tx);\n\n\ttx->type = TRANSACTION_CONFIG;\n\ttx->cfg = cfg;\n\t*out = tx;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/refdb_backend.h\"",
      "#include \"git2/sys/refs.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"config.h\"",
      "#include \"signature.h\"",
      "#include \"reflog.h\"",
      "#include \"pool.h\"",
      "#include \"refdb.h\"",
      "#include \"strmap.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tx"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_transaction)"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && cfg"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_config_new(git_transaction **out, git_config *cfg)\n{\n\tgit_transaction *tx;\n\tassert(out && cfg);\n\n\ttx = git__calloc(1, sizeof(git_transaction));\n\tGITERR_CHECK_ALLOC(tx);\n\n\ttx->type = TRANSACTION_CONFIG;\n\ttx->cfg = cfg;\n\t*out = tx;\n\treturn 0;\n}"
  }
]