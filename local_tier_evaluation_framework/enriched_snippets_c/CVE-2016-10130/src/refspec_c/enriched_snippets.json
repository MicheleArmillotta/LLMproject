[
  {
    "function_name": "git_refspec__dwim_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "302-367",
    "snippet": "int git_refspec__dwim_one(git_vector *out, git_refspec *spec, git_vector *refs)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t j, pos;\n\tgit_remote_head key;\n\n\tconst char* formatters[] = {\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tNULL\n\t};\n\n\tgit_refspec *cur = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(cur);\n\n\tcur->force = spec->force;\n\tcur->push = spec->push;\n\tcur->pattern = spec->pattern;\n\tcur->matching = spec->matching;\n\tcur->string = git__strdup(spec->string);\n\n\t/* shorthand on the lhs */\n\tif (git__prefixcmp(spec->src, GIT_REFS_DIR)) {\n\t\tfor (j = 0; formatters[j]; j++) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_printf(&buf, formatters[j], spec->src);\n\t\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\tif (!git_vector_search(&pos, refs, &key)) {\n\t\t\t\t/* we found something to match the shorthand, set src to that */\n\t\t\t\tcur->src = git_buf_detach(&buf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* No shorthands found, copy over the name */\n\tif (cur->src == NULL && spec->src != NULL) {\n\t\tcur->src = git__strdup(spec->src);\n\t\tGITERR_CHECK_ALLOC(cur->src);\n\t}\n\n\tif (spec->dst && git__prefixcmp(spec->dst, GIT_REFS_DIR)) {\n\t\t/* if it starts with \"remotes\" then we just prepend \"refs/\" */\n\t\tif (!git__prefixcmp(spec->dst, \"remotes/\")) {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_DIR);\n\t\t} else {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_HEADS_DIR);\n\t\t}\n\n\t\tgit_buf_puts(&buf, spec->dst);\n\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\tcur->dst = git_buf_detach(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\n\tif (cur->dst == NULL && spec->dst != NULL) {\n\t\tcur->dst = git__strdup(spec->dst);\n\t\tGITERR_CHECK_ALLOC(cur->dst);\n\t}\n\n\treturn git_vector_insert(out, cur);\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "out",
            "cur"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "cur->dst"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "spec->dst"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&buf"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_BUF",
          "args": [
            "&buf"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&buf",
            "spec->dst"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "spec->dst",
            "\"remotes/\""
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "cur->src"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_search",
          "args": [
            "&pos",
            "refs",
            "&key"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "228-231",
          "snippet": "int git_vector_search(size_t *at_pos, const git_vector *v, const void *entry)\n{\n\treturn git_vector_search2(at_pos, v, v->_cmp ? v->_cmp : strict_comparison, entry);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_search(size_t *at_pos, const git_vector *v, const void *entry)\n{\n\treturn git_vector_search2(at_pos, v, v->_cmp ? v->_cmp : strict_comparison, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_BUF",
          "args": [
            "&buf"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "formatters[j]",
            "spec->src"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&buf"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "cur"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_refspec)"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__dwim_one(git_vector *out, git_refspec *spec, git_vector *refs)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t j, pos;\n\tgit_remote_head key;\n\n\tconst char* formatters[] = {\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tNULL\n\t};\n\n\tgit_refspec *cur = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(cur);\n\n\tcur->force = spec->force;\n\tcur->push = spec->push;\n\tcur->pattern = spec->pattern;\n\tcur->matching = spec->matching;\n\tcur->string = git__strdup(spec->string);\n\n\t/* shorthand on the lhs */\n\tif (git__prefixcmp(spec->src, GIT_REFS_DIR)) {\n\t\tfor (j = 0; formatters[j]; j++) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_printf(&buf, formatters[j], spec->src);\n\t\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\tif (!git_vector_search(&pos, refs, &key)) {\n\t\t\t\t/* we found something to match the shorthand, set src to that */\n\t\t\t\tcur->src = git_buf_detach(&buf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* No shorthands found, copy over the name */\n\tif (cur->src == NULL && spec->src != NULL) {\n\t\tcur->src = git__strdup(spec->src);\n\t\tGITERR_CHECK_ALLOC(cur->src);\n\t}\n\n\tif (spec->dst && git__prefixcmp(spec->dst, GIT_REFS_DIR)) {\n\t\t/* if it starts with \"remotes\" then we just prepend \"refs/\" */\n\t\tif (!git__prefixcmp(spec->dst, \"remotes/\")) {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_DIR);\n\t\t} else {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_HEADS_DIR);\n\t\t}\n\n\t\tgit_buf_puts(&buf, spec->dst);\n\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\tcur->dst = git_buf_detach(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\n\tif (cur->dst == NULL && spec->dst != NULL) {\n\t\tcur->dst = git__strdup(spec->dst);\n\t\tGITERR_CHECK_ALLOC(cur->dst);\n\t}\n\n\treturn git_vector_insert(out, cur);\n}"
  },
  {
    "function_name": "git_refspec_direction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "295-300",
    "snippet": "git_direction git_refspec_direction(const git_refspec *spec)\n{\n\tassert(spec);\n\n\treturn spec->push;\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "spec"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\ngit_direction git_refspec_direction(const git_refspec *spec)\n{\n\tassert(spec);\n\n\treturn spec->push;\n}"
  },
  {
    "function_name": "git_refspec_is_wildcard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "288-293",
    "snippet": "int git_refspec_is_wildcard(const git_refspec *spec)\n{\n\tassert(spec && spec->src);\n\n\treturn (spec->src[strlen(spec->src) - 1] == '*');\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "spec->src"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "spec && spec->src"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_is_wildcard(const git_refspec *spec)\n{\n\tassert(spec && spec->src);\n\n\treturn (spec->src[strlen(spec->src) - 1] == '*');\n}"
  },
  {
    "function_name": "git_refspec__serialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "276-286",
    "snippet": "int git_refspec__serialize(git_buf *out, const git_refspec *refspec)\n{\n\tif (refspec->force)\n\t\tgit_buf_putc(out, '+');\n\n\tgit_buf_printf(out, \"%s:%s\",\n\t\trefspec->src != NULL ? refspec->src : \"\",\n\t\trefspec->dst != NULL ? refspec->dst : \"\");\n\n\treturn git_buf_oom(out) == false;\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "out"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "out",
            "\"%s:%s\"",
            "refspec->src != NULL ? refspec->src : \"\"",
            "refspec->dst != NULL ? refspec->dst : \"\""
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "out",
            "'+'"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__serialize(git_buf *out, const git_refspec *refspec)\n{\n\tif (refspec->force)\n\t\tgit_buf_putc(out, '+');\n\n\tgit_buf_printf(out, \"%s:%s\",\n\t\trefspec->src != NULL ? refspec->src : \"\",\n\t\trefspec->dst != NULL ? refspec->dst : \"\");\n\n\treturn git_buf_oom(out) == false;\n}"
  },
  {
    "function_name": "git_refspec_rtransform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "260-274",
    "snippet": "int git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_dst_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the destination\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->src);\n\n\treturn refspec_transform(out, spec->dst, spec->src, name);\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refspec_transform",
          "args": [
            "out",
            "spec->dst",
            "spec->src",
            "name"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "refspec_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "201-242",
          "snippet": "static int refspec_transform(\n\tgit_buf *out, const char *from, const char *to, const char *name)\n{\n\tconst char *from_star, *to_star;\n\tconst char *name_slash, *from_slash;\n\tsize_t replacement_len, star_offset;\n\n\tgit_buf_sanitize(out);\n\tgit_buf_clear(out);\n\n\t/*\n\t * There are two parts to each side of a refspec, the bit\n\t * before the star and the bit after it. The star can be in\n\t * the middle of the pattern, so we need to look at each bit\n\t * individually.\n\t */\n\tfrom_star = strchr(from, '*');\n\tto_star = strchr(to, '*');\n\n\tassert(from_star && to_star);\n\n\t/* star offset, both in 'from' and in 'name' */\n\tstar_offset = from_star - from;\n\n\t/* the first half is copied over */\n\tgit_buf_put(out, to, to_star - to);\n\n\t/* then we copy over the replacement, from the star's offset to the next slash in 'name' */\n\tname_slash = strchr(name + star_offset, '/');\n\tif (!name_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\t/* if there is no slash after the star in 'from', we want to copy everything over */\n\tfrom_slash = strchr(from + star_offset, '/');\n\tif (!from_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\treplacement_len = (name_slash - name) - star_offset;\n\tgit_buf_put(out, name + star_offset, replacement_len);\n\n\treturn git_buf_puts(out, to_star + 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nstatic int refspec_transform(\n\tgit_buf *out, const char *from, const char *to, const char *name)\n{\n\tconst char *from_star, *to_star;\n\tconst char *name_slash, *from_slash;\n\tsize_t replacement_len, star_offset;\n\n\tgit_buf_sanitize(out);\n\tgit_buf_clear(out);\n\n\t/*\n\t * There are two parts to each side of a refspec, the bit\n\t * before the star and the bit after it. The star can be in\n\t * the middle of the pattern, so we need to look at each bit\n\t * individually.\n\t */\n\tfrom_star = strchr(from, '*');\n\tto_star = strchr(to, '*');\n\n\tassert(from_star && to_star);\n\n\t/* star offset, both in 'from' and in 'name' */\n\tstar_offset = from_star - from;\n\n\t/* the first half is copied over */\n\tgit_buf_put(out, to, to_star - to);\n\n\t/* then we copy over the replacement, from the star's offset to the next slash in 'name' */\n\tname_slash = strchr(name + star_offset, '/');\n\tif (!name_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\t/* if there is no slash after the star in 'from', we want to copy everything over */\n\tfrom_slash = strchr(from + star_offset, '/');\n\tif (!from_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\treplacement_len = (name_slash - name) - star_offset;\n\tgit_buf_put(out, name + star_offset, replacement_len);\n\n\treturn git_buf_puts(out, to_star + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "out",
            "spec->src"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"ref '%s' doesn't match the destination\"",
            "name"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_dst_matches",
          "args": [
            "spec",
            "name"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_dst_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "193-199",
          "snippet": "int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "out"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && spec && name"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_dst_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the destination\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->src);\n\n\treturn refspec_transform(out, spec->dst, spec->src, name);\n}"
  },
  {
    "function_name": "git_refspec_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "244-258",
    "snippet": "int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refspec_transform",
          "args": [
            "out",
            "spec->src",
            "spec->dst",
            "name"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "refspec_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "201-242",
          "snippet": "static int refspec_transform(\n\tgit_buf *out, const char *from, const char *to, const char *name)\n{\n\tconst char *from_star, *to_star;\n\tconst char *name_slash, *from_slash;\n\tsize_t replacement_len, star_offset;\n\n\tgit_buf_sanitize(out);\n\tgit_buf_clear(out);\n\n\t/*\n\t * There are two parts to each side of a refspec, the bit\n\t * before the star and the bit after it. The star can be in\n\t * the middle of the pattern, so we need to look at each bit\n\t * individually.\n\t */\n\tfrom_star = strchr(from, '*');\n\tto_star = strchr(to, '*');\n\n\tassert(from_star && to_star);\n\n\t/* star offset, both in 'from' and in 'name' */\n\tstar_offset = from_star - from;\n\n\t/* the first half is copied over */\n\tgit_buf_put(out, to, to_star - to);\n\n\t/* then we copy over the replacement, from the star's offset to the next slash in 'name' */\n\tname_slash = strchr(name + star_offset, '/');\n\tif (!name_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\t/* if there is no slash after the star in 'from', we want to copy everything over */\n\tfrom_slash = strchr(from + star_offset, '/');\n\tif (!from_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\treplacement_len = (name_slash - name) - star_offset;\n\tgit_buf_put(out, name + star_offset, replacement_len);\n\n\treturn git_buf_puts(out, to_star + 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nstatic int refspec_transform(\n\tgit_buf *out, const char *from, const char *to, const char *name)\n{\n\tconst char *from_star, *to_star;\n\tconst char *name_slash, *from_slash;\n\tsize_t replacement_len, star_offset;\n\n\tgit_buf_sanitize(out);\n\tgit_buf_clear(out);\n\n\t/*\n\t * There are two parts to each side of a refspec, the bit\n\t * before the star and the bit after it. The star can be in\n\t * the middle of the pattern, so we need to look at each bit\n\t * individually.\n\t */\n\tfrom_star = strchr(from, '*');\n\tto_star = strchr(to, '*');\n\n\tassert(from_star && to_star);\n\n\t/* star offset, both in 'from' and in 'name' */\n\tstar_offset = from_star - from;\n\n\t/* the first half is copied over */\n\tgit_buf_put(out, to, to_star - to);\n\n\t/* then we copy over the replacement, from the star's offset to the next slash in 'name' */\n\tname_slash = strchr(name + star_offset, '/');\n\tif (!name_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\t/* if there is no slash after the star in 'from', we want to copy everything over */\n\tfrom_slash = strchr(from + star_offset, '/');\n\tif (!from_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\treplacement_len = (name_slash - name) - star_offset;\n\tgit_buf_put(out, name + star_offset, replacement_len);\n\n\treturn git_buf_puts(out, to_star + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "out",
            "spec->dst"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"ref '%s' doesn't match the source\"",
            "name"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_src_matches",
          "args": [
            "spec",
            "name"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_src_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "185-191",
          "snippet": "int git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "out"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && spec && name"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}"
  },
  {
    "function_name": "refspec_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "201-242",
    "snippet": "static int refspec_transform(\n\tgit_buf *out, const char *from, const char *to, const char *name)\n{\n\tconst char *from_star, *to_star;\n\tconst char *name_slash, *from_slash;\n\tsize_t replacement_len, star_offset;\n\n\tgit_buf_sanitize(out);\n\tgit_buf_clear(out);\n\n\t/*\n\t * There are two parts to each side of a refspec, the bit\n\t * before the star and the bit after it. The star can be in\n\t * the middle of the pattern, so we need to look at each bit\n\t * individually.\n\t */\n\tfrom_star = strchr(from, '*');\n\tto_star = strchr(to, '*');\n\n\tassert(from_star && to_star);\n\n\t/* star offset, both in 'from' and in 'name' */\n\tstar_offset = from_star - from;\n\n\t/* the first half is copied over */\n\tgit_buf_put(out, to, to_star - to);\n\n\t/* then we copy over the replacement, from the star's offset to the next slash in 'name' */\n\tname_slash = strchr(name + star_offset, '/');\n\tif (!name_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\t/* if there is no slash after the star in 'from', we want to copy everything over */\n\tfrom_slash = strchr(from + star_offset, '/');\n\tif (!from_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\treplacement_len = (name_slash - name) - star_offset;\n\tgit_buf_put(out, name + star_offset, replacement_len);\n\n\treturn git_buf_puts(out, to_star + 1);\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "out",
            "to_star + 1"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "out",
            "name + star_offset",
            "replacement_len"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "name",
            "'\\0'"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "from + star_offset",
            "'/'"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "name",
            "'\\0'"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name + star_offset",
            "'/'"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "from_star && to_star"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "to",
            "'*'"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "from",
            "'*'"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "out"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "out"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nstatic int refspec_transform(\n\tgit_buf *out, const char *from, const char *to, const char *name)\n{\n\tconst char *from_star, *to_star;\n\tconst char *name_slash, *from_slash;\n\tsize_t replacement_len, star_offset;\n\n\tgit_buf_sanitize(out);\n\tgit_buf_clear(out);\n\n\t/*\n\t * There are two parts to each side of a refspec, the bit\n\t * before the star and the bit after it. The star can be in\n\t * the middle of the pattern, so we need to look at each bit\n\t * individually.\n\t */\n\tfrom_star = strchr(from, '*');\n\tto_star = strchr(to, '*');\n\n\tassert(from_star && to_star);\n\n\t/* star offset, both in 'from' and in 'name' */\n\tstar_offset = from_star - from;\n\n\t/* the first half is copied over */\n\tgit_buf_put(out, to, to_star - to);\n\n\t/* then we copy over the replacement, from the star's offset to the next slash in 'name' */\n\tname_slash = strchr(name + star_offset, '/');\n\tif (!name_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\t/* if there is no slash after the star in 'from', we want to copy everything over */\n\tfrom_slash = strchr(from + star_offset, '/');\n\tif (!from_slash)\n\t\tname_slash = strrchr(name, '\\0');\n\n\treplacement_len = (name_slash - name) - star_offset;\n\tgit_buf_put(out, name + star_offset, replacement_len);\n\n\treturn git_buf_puts(out, to_star + 1);\n}"
  },
  {
    "function_name": "git_refspec_dst_matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "193-199",
    "snippet": "int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_fnmatch",
          "args": [
            "refspec->dst",
            "refname",
            "0"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "230-234",
          "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}"
  },
  {
    "function_name": "git_refspec_src_matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "185-191",
    "snippet": "int git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_fnmatch",
          "args": [
            "refspec->src",
            "refname",
            "0"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "230-234",
          "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}"
  },
  {
    "function_name": "git_refspec_force",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "178-183",
    "snippet": "int git_refspec_force(const git_refspec *refspec)\n{\n\tassert(refspec);\n\n\treturn refspec->force;\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "refspec"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_force(const git_refspec *refspec)\n{\n\tassert(refspec);\n\n\treturn refspec->force;\n}"
  },
  {
    "function_name": "git_refspec_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "173-176",
    "snippet": "const char *git_refspec_string(const git_refspec *refspec)\n{\n\treturn refspec == NULL ? NULL : refspec->string;\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nconst char *git_refspec_string(const git_refspec *refspec)\n{\n\treturn refspec == NULL ? NULL : refspec->string;\n}"
  },
  {
    "function_name": "git_refspec_dst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "168-171",
    "snippet": "const char *git_refspec_dst(const git_refspec *refspec)\n{\n\treturn refspec == NULL ? NULL : refspec->dst;\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nconst char *git_refspec_dst(const git_refspec *refspec)\n{\n\treturn refspec == NULL ? NULL : refspec->dst;\n}"
  },
  {
    "function_name": "git_refspec_src",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "163-166",
    "snippet": "const char *git_refspec_src(const git_refspec *refspec)\n{\n\treturn refspec == NULL ? NULL : refspec->src;\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nconst char *git_refspec_src(const git_refspec *refspec)\n{\n\treturn refspec == NULL ? NULL : refspec->src;\n}"
  },
  {
    "function_name": "git_refspec__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "151-161",
    "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "refspec",
            "0x0",
            "sizeof(git_refspec)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "refspec->string"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
  },
  {
    "function_name": "git_refspec__parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
    "lines": "17-149",
    "snippet": "int git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}",
    "includes": [
      "#include \"vector.h\"",
      "#include \"refs.h\"",
      "#include \"posix.h\"",
      "#include \"util.h\"",
      "#include \"refspec.h\"",
      "#include \"common.h\"",
      "#include \"git2/errors.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "refspec"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"'%s' is not a valid refspec.\"",
            "input"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "refspec->string"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "input"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "refspec->dst"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference__is_valid_name",
          "args": [
            "refspec->dst",
            "flags"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1269-1277",
          "snippet": "int git_reference__is_valid_name(const char *refname, unsigned int flags)\n{\n\tif (git_reference__normalize_name(NULL, refname, flags) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_valid_name(const char *refname, unsigned int flags)\n{\n\tif (git_reference__normalize_name(NULL, refname, flags) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "lhs",
            "llen"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "lhs",
            "'*'",
            "llen"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lhs"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "rhs",
            "'*'"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "++rhs"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "refspec->dst"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "refspec->src"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "refspec->string"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "lhs",
            "':'"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "refspec",
            "0x0",
            "sizeof(git_refspec)"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "refspec && input"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}"
  }
]