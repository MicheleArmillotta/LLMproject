[
  {
    "function_name": "git_win32__crtdbg_stacktrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
    "lines": "319-342",
    "snippet": "const char *git_win32__crtdbg_stacktrace(int skip, const char *file)\n{\n\tgit_win32__stack__raw_data new_data;\n\tgit_win32__crtdbg_stacktrace__row *row;\n\tconst char * result = file;\n\n\tif (git_win32__stack_capture(&new_data, skip+1) < 0)\n\t\treturn result;\n\n\tEnterCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\tif (g_cs_ins < g_cs_end) {\n\t\trow = insert_unique(&new_data);\n\t\tresult = row->uid.uid;\n\t} else {\n\t\tg_limit_reached = true;\n\t}\n\n\tg_count_total_allocs++;\n\n\tLeaveCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\treturn result;\n}",
    "includes": [
      "#include \"w32_crtdbg_stacktrace.h\"",
      "#include \"w32_stack.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LeaveCriticalSection",
          "args": [
            "&g_crtdbg_stacktrace_cs"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_unique",
          "args": [
            "&new_data"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "insert_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
          "lines": "88-108",
          "snippet": "static git_win32__crtdbg_stacktrace__row * insert_unique(\n\tconst git_win32__stack__raw_data *pdata)\n{\n\tsize_t pos;\n\tif (git__bsearch(g_cs_index, g_cs_ins, pdata, row_cmp, &pos) < 0) {\n\t\t/* Append new unique item to row table. */\n\t\tmemcpy(&g_cs_rows[g_cs_ins].raw_data, pdata, sizeof(*pdata));\n\t\tsprintf(g_cs_rows[g_cs_ins].uid.uid, \"##%08lx\", g_cs_ins);\n\n\t\t/* Insert pointer to it into the proper place in the index table. */\n\t\tif (pos < g_cs_ins)\n\t\t\tmemmove(&g_cs_index[pos+1], &g_cs_index[pos], (g_cs_ins - pos)*sizeof(g_cs_index[0]));\n\t\tg_cs_index[pos] = &g_cs_rows[g_cs_ins];\n\n\t\tg_cs_ins++;\n\t}\n\n\tg_cs_index[pos]->count_allocs++;\n\n\treturn g_cs_index[pos];\n}",
          "includes": [
            "#include \"w32_crtdbg_stacktrace.h\"",
            "#include \"w32_stack.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nstatic git_win32__crtdbg_stacktrace__row * insert_unique(\n\tconst git_win32__stack__raw_data *pdata)\n{\n\tsize_t pos;\n\tif (git__bsearch(g_cs_index, g_cs_ins, pdata, row_cmp, &pos) < 0) {\n\t\t/* Append new unique item to row table. */\n\t\tmemcpy(&g_cs_rows[g_cs_ins].raw_data, pdata, sizeof(*pdata));\n\t\tsprintf(g_cs_rows[g_cs_ins].uid.uid, \"##%08lx\", g_cs_ins);\n\n\t\t/* Insert pointer to it into the proper place in the index table. */\n\t\tif (pos < g_cs_ins)\n\t\t\tmemmove(&g_cs_index[pos+1], &g_cs_index[pos], (g_cs_ins - pos)*sizeof(g_cs_index[0]));\n\t\tg_cs_index[pos] = &g_cs_rows[g_cs_ins];\n\n\t\tg_cs_ins++;\n\t}\n\n\tg_cs_index[pos]->count_allocs++;\n\n\treturn g_cs_index[pos];\n}"
        }
      },
      {
        "call_info": {
          "callee": "EnterCriticalSection",
          "args": [
            "&g_crtdbg_stacktrace_cs"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32__stack_capture",
          "args": [
            "&new_data",
            "skip+1"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__stack_capture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
          "lines": "54-73",
          "snippet": "int git_win32__stack_capture(git_win32__stack__raw_data *pdata, int skip)\n{\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tmemset(pdata, 0, sizeof(*pdata));\n\tpdata->nr_frames = RtlCaptureStackBackTrace(\n\t\tskip+1, GIT_WIN32__STACK__MAX_FRAMES, pdata->frames, NULL);\n\n\t/* If an \"aux\" data provider was registered, ask it to capture\n\t * whatever data it needs and give us an \"aux_id\" to it so that\n\t * we can refer to it later when reporting.\n\t */\n\tif (g_aux_cb_alloc)\n\t\t(g_aux_cb_alloc)(&pdata->aux_id);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"w32_stack.h\"",
            "#include \"win32/posix.h\"",
            "#include \"Dbghelp.h\"",
            "#include \"Windows.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\nint git_win32__stack_capture(git_win32__stack__raw_data *pdata, int skip)\n{\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tmemset(pdata, 0, sizeof(*pdata));\n\tpdata->nr_frames = RtlCaptureStackBackTrace(\n\t\tskip+1, GIT_WIN32__STACK__MAX_FRAMES, pdata->frames, NULL);\n\n\t/* If an \"aux\" data provider was registered, ask it to capture\n\t * whatever data it needs and give us an \"aux_id\" to it so that\n\t * we can refer to it later when reporting.\n\t */\n\tif (g_aux_cb_alloc)\n\t\t(g_aux_cb_alloc)(&pdata->aux_id);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nconst char *git_win32__crtdbg_stacktrace(int skip, const char *file)\n{\n\tgit_win32__stack__raw_data new_data;\n\tgit_win32__crtdbg_stacktrace__row *row;\n\tconst char * result = file;\n\n\tif (git_win32__stack_capture(&new_data, skip+1) < 0)\n\t\treturn result;\n\n\tEnterCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\tif (g_cs_ins < g_cs_end) {\n\t\trow = insert_unique(&new_data);\n\t\tresult = row->uid.uid;\n\t} else {\n\t\tg_limit_reached = true;\n\t}\n\n\tg_count_total_allocs++;\n\n\tLeaveCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\treturn result;\n}"
  },
  {
    "function_name": "git_win32__crtdbg_stacktrace_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
    "lines": "303-317",
    "snippet": "void git_win32__crtdbg_stacktrace_cleanup(void)\n{\n\t/* At shutdown/cleanup, dump cummulative leak info\n\t * with everything since startup.  This might generate\n\t * extra noise if the caller has been doing checkpoint\n\t * dumps, but it might also eliminate some false\n\t * positives for resources previously reported during\n\t * checkpoints.\n\t */\n\tgit_win32__crtdbg_stacktrace__dump(\n\t\tGIT_WIN32__CRTDBG_STACKTRACE__LEAKS_TOTAL,\n\t\t\"CLEANUP\");\n\n\tDeleteCriticalSection(&g_crtdbg_stacktrace_cs);\n}",
    "includes": [
      "#include \"w32_crtdbg_stacktrace.h\"",
      "#include \"w32_stack.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DeleteCriticalSection",
          "args": [
            "&g_crtdbg_stacktrace_cs"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32__crtdbg_stacktrace__dump",
          "args": [
            "GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_TOTAL",
            "\"CLEANUP\""
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__crtdbg_stacktrace__dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
          "lines": "240-301",
          "snippet": "int git_win32__crtdbg_stacktrace__dump(\n\tgit_win32__crtdbg_stacktrace_options opt,\n\tconst char *label)\n{\n\t_CRT_REPORT_HOOK old;\n\tunsigned int k;\n\tint r = 0;\n\n#define IS_BIT_SET(o,b) (((o) & (b)) != 0)\n\n\tbool b_set_mark         = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__SET_MARK);\n\tbool b_leaks_since_mark = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_SINCE_MARK);\n\tbool b_leaks_total      = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_TOTAL);\n\tbool b_quiet            = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__QUIET);\n\n\tif (b_leaks_since_mark && b_leaks_total) {\n\t\tgiterr_set(GITERR_INVALID, \"Cannot combine LEAKS_SINCE_MARK and LEAKS_TOTAL.\");\n\t\treturn GIT_ERROR;\n\t}\n\tif (!b_set_mark && !b_leaks_since_mark && !b_leaks_total) {\n\t\tgiterr_set(GITERR_INVALID, \"Nothing to do.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tEnterCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\tif (b_leaks_since_mark || b_leaks_total) {\n\t\t/* All variables with \"transient\" in the name are per-dump counters\n\t\t * and reset before each dump.  This lets us handle checkpoints.\n\t\t */\n\t\tg_transient_count_total_leaks = 0;\n\t\tg_transient_count_dedup_leaks = 0;\n\t\tfor (k = 0; k < g_cs_ins; k++) {\n\t\t\tg_cs_rows[k].transient_count_leaks = 0;\n\t\t}\n\t}\n\n\tg_transient_leaks_since_mark = b_leaks_since_mark;\n\n\told = _CrtSetReportHook(report_hook);\n\t_CrtDumpMemoryLeaks();\n\t_CrtSetReportHook(old);\n\n\tif (b_leaks_since_mark || b_leaks_total) {\n\t\tr = g_transient_count_dedup_leaks;\n\n\t\tif (!b_quiet)\n\t\t\tdump_summary(label);\n\t}\n\n\tif (b_set_mark) {\n\t\tfor (k = 0; k < g_cs_ins; k++) {\n\t\t\tg_cs_rows[k].count_allocs_at_last_checkpoint = g_cs_rows[k].count_allocs;\n\t\t}\n\n\t\tg_checkpoint_id++;\n\t}\n\n\tLeaveCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\treturn r;\n}",
          "includes": [
            "#include \"w32_crtdbg_stacktrace.h\"",
            "#include \"w32_stack.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nint git_win32__crtdbg_stacktrace__dump(\n\tgit_win32__crtdbg_stacktrace_options opt,\n\tconst char *label)\n{\n\t_CRT_REPORT_HOOK old;\n\tunsigned int k;\n\tint r = 0;\n\n#define IS_BIT_SET(o,b) (((o) & (b)) != 0)\n\n\tbool b_set_mark         = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__SET_MARK);\n\tbool b_leaks_since_mark = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_SINCE_MARK);\n\tbool b_leaks_total      = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_TOTAL);\n\tbool b_quiet            = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__QUIET);\n\n\tif (b_leaks_since_mark && b_leaks_total) {\n\t\tgiterr_set(GITERR_INVALID, \"Cannot combine LEAKS_SINCE_MARK and LEAKS_TOTAL.\");\n\t\treturn GIT_ERROR;\n\t}\n\tif (!b_set_mark && !b_leaks_since_mark && !b_leaks_total) {\n\t\tgiterr_set(GITERR_INVALID, \"Nothing to do.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tEnterCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\tif (b_leaks_since_mark || b_leaks_total) {\n\t\t/* All variables with \"transient\" in the name are per-dump counters\n\t\t * and reset before each dump.  This lets us handle checkpoints.\n\t\t */\n\t\tg_transient_count_total_leaks = 0;\n\t\tg_transient_count_dedup_leaks = 0;\n\t\tfor (k = 0; k < g_cs_ins; k++) {\n\t\t\tg_cs_rows[k].transient_count_leaks = 0;\n\t\t}\n\t}\n\n\tg_transient_leaks_since_mark = b_leaks_since_mark;\n\n\told = _CrtSetReportHook(report_hook);\n\t_CrtDumpMemoryLeaks();\n\t_CrtSetReportHook(old);\n\n\tif (b_leaks_since_mark || b_leaks_total) {\n\t\tr = g_transient_count_dedup_leaks;\n\n\t\tif (!b_quiet)\n\t\t\tdump_summary(label);\n\t}\n\n\tif (b_set_mark) {\n\t\tfor (k = 0; k < g_cs_ins; k++) {\n\t\t\tg_cs_rows[k].count_allocs_at_last_checkpoint = g_cs_rows[k].count_allocs;\n\t\t}\n\n\t\tg_checkpoint_id++;\n\t}\n\n\tLeaveCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nvoid git_win32__crtdbg_stacktrace_cleanup(void)\n{\n\t/* At shutdown/cleanup, dump cummulative leak info\n\t * with everything since startup.  This might generate\n\t * extra noise if the caller has been doing checkpoint\n\t * dumps, but it might also eliminate some false\n\t * positives for resources previously reported during\n\t * checkpoints.\n\t */\n\tgit_win32__crtdbg_stacktrace__dump(\n\t\tGIT_WIN32__CRTDBG_STACKTRACE__LEAKS_TOTAL,\n\t\t\"CLEANUP\");\n\n\tDeleteCriticalSection(&g_crtdbg_stacktrace_cs);\n}"
  },
  {
    "function_name": "git_win32__crtdbg_stacktrace__dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
    "lines": "240-301",
    "snippet": "int git_win32__crtdbg_stacktrace__dump(\n\tgit_win32__crtdbg_stacktrace_options opt,\n\tconst char *label)\n{\n\t_CRT_REPORT_HOOK old;\n\tunsigned int k;\n\tint r = 0;\n\n#define IS_BIT_SET(o,b) (((o) & (b)) != 0)\n\n\tbool b_set_mark         = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__SET_MARK);\n\tbool b_leaks_since_mark = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_SINCE_MARK);\n\tbool b_leaks_total      = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_TOTAL);\n\tbool b_quiet            = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__QUIET);\n\n\tif (b_leaks_since_mark && b_leaks_total) {\n\t\tgiterr_set(GITERR_INVALID, \"Cannot combine LEAKS_SINCE_MARK and LEAKS_TOTAL.\");\n\t\treturn GIT_ERROR;\n\t}\n\tif (!b_set_mark && !b_leaks_since_mark && !b_leaks_total) {\n\t\tgiterr_set(GITERR_INVALID, \"Nothing to do.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tEnterCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\tif (b_leaks_since_mark || b_leaks_total) {\n\t\t/* All variables with \"transient\" in the name are per-dump counters\n\t\t * and reset before each dump.  This lets us handle checkpoints.\n\t\t */\n\t\tg_transient_count_total_leaks = 0;\n\t\tg_transient_count_dedup_leaks = 0;\n\t\tfor (k = 0; k < g_cs_ins; k++) {\n\t\t\tg_cs_rows[k].transient_count_leaks = 0;\n\t\t}\n\t}\n\n\tg_transient_leaks_since_mark = b_leaks_since_mark;\n\n\told = _CrtSetReportHook(report_hook);\n\t_CrtDumpMemoryLeaks();\n\t_CrtSetReportHook(old);\n\n\tif (b_leaks_since_mark || b_leaks_total) {\n\t\tr = g_transient_count_dedup_leaks;\n\n\t\tif (!b_quiet)\n\t\t\tdump_summary(label);\n\t}\n\n\tif (b_set_mark) {\n\t\tfor (k = 0; k < g_cs_ins; k++) {\n\t\t\tg_cs_rows[k].count_allocs_at_last_checkpoint = g_cs_rows[k].count_allocs;\n\t\t}\n\n\t\tg_checkpoint_id++;\n\t}\n\n\tLeaveCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\treturn r;\n}",
    "includes": [
      "#include \"w32_crtdbg_stacktrace.h\"",
      "#include \"w32_stack.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LeaveCriticalSection",
          "args": [
            "&g_crtdbg_stacktrace_cs"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_summary",
          "args": [
            "label"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "dump_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
          "lines": "167-219",
          "snippet": "static void dump_summary(const char *label)\n{\n\tunsigned int k;\n\tchar buf[10 * 1024];\n\n\tif (g_transient_count_total_leaks == 0)\n\t\treturn;\n\n\tfflush(stdout);\n\tfflush(stderr);\n\tmy_output(\"\\n\");\n\n\tif (g_limit_reached) {\n\t\tsprintf(buf,\n\t\t\t\t\"LEAK SUMMARY: de-dup row table[%d] filled. Increase MY_ROW_LIMIT.\\n\",\n\t\t\t\tMY_ROW_LIMIT);\n\t\tmy_output(buf);\n\t}\n\n\tif (!label)\n\t\tlabel = \"\";\n\n\tif (g_transient_leaks_since_mark) {\n\t\tsprintf(buf, \"LEAK CHECKPOINT %d: leaks %d unique %d: %s\\n\",\n\t\t\t\tg_checkpoint_id, g_transient_count_total_leaks, g_transient_count_dedup_leaks, label);\n\t\tmy_output(buf);\n\t} else {\n\t\tsprintf(buf, \"LEAK SUMMARY: TOTAL leaks %d de-duped %d: %s\\n\",\n\t\t\t\tg_transient_count_total_leaks, g_transient_count_dedup_leaks, label);\n\t\tmy_output(buf);\n\t}\n\tmy_output(\"\\n\");\n\n\tfor (k = 0; k < g_cs_ins; k++) {\n\t\tif (g_cs_rows[k].transient_count_leaks > 0) {\n\t\t\tsprintf(buf, \"LEAK: %s leaked %d of %d times:\\n\",\n\t\t\t\t\tg_cs_rows[k].uid.uid,\n\t\t\t\t\tg_cs_rows[k].transient_count_leaks,\n\t\t\t\t\tg_cs_rows[k].count_allocs);\n\t\t\tmy_output(buf);\n\n\t\t\tif (git_win32__stack_format(\n\t\t\t\t\tbuf, sizeof(buf), &g_cs_rows[k].raw_data,\n\t\t\t\t\tNULL, NULL) >= 0) {\n\t\t\t\tmy_output(buf);\n\t\t\t}\n\n\t\t\tmy_output(\"\\n\");\n\t\t}\n\t}\n\n\tfflush(stderr);\n}",
          "includes": [
            "#include \"w32_crtdbg_stacktrace.h\"",
            "#include \"w32_stack.h\""
          ],
          "macros_used": [
            "#define MY_ROW_LIMIT (1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\n#define MY_ROW_LIMIT (1024 * 1024)\n\nstatic void dump_summary(const char *label)\n{\n\tunsigned int k;\n\tchar buf[10 * 1024];\n\n\tif (g_transient_count_total_leaks == 0)\n\t\treturn;\n\n\tfflush(stdout);\n\tfflush(stderr);\n\tmy_output(\"\\n\");\n\n\tif (g_limit_reached) {\n\t\tsprintf(buf,\n\t\t\t\t\"LEAK SUMMARY: de-dup row table[%d] filled. Increase MY_ROW_LIMIT.\\n\",\n\t\t\t\tMY_ROW_LIMIT);\n\t\tmy_output(buf);\n\t}\n\n\tif (!label)\n\t\tlabel = \"\";\n\n\tif (g_transient_leaks_since_mark) {\n\t\tsprintf(buf, \"LEAK CHECKPOINT %d: leaks %d unique %d: %s\\n\",\n\t\t\t\tg_checkpoint_id, g_transient_count_total_leaks, g_transient_count_dedup_leaks, label);\n\t\tmy_output(buf);\n\t} else {\n\t\tsprintf(buf, \"LEAK SUMMARY: TOTAL leaks %d de-duped %d: %s\\n\",\n\t\t\t\tg_transient_count_total_leaks, g_transient_count_dedup_leaks, label);\n\t\tmy_output(buf);\n\t}\n\tmy_output(\"\\n\");\n\n\tfor (k = 0; k < g_cs_ins; k++) {\n\t\tif (g_cs_rows[k].transient_count_leaks > 0) {\n\t\t\tsprintf(buf, \"LEAK: %s leaked %d of %d times:\\n\",\n\t\t\t\t\tg_cs_rows[k].uid.uid,\n\t\t\t\t\tg_cs_rows[k].transient_count_leaks,\n\t\t\t\t\tg_cs_rows[k].count_allocs);\n\t\t\tmy_output(buf);\n\n\t\t\tif (git_win32__stack_format(\n\t\t\t\t\tbuf, sizeof(buf), &g_cs_rows[k].raw_data,\n\t\t\t\t\tNULL, NULL) >= 0) {\n\t\t\t\tmy_output(buf);\n\t\t\t}\n\n\t\t\tmy_output(\"\\n\");\n\t\t}\n\t}\n\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_CrtSetReportHook",
          "args": [
            "old"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtDumpMemoryLeaks",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetReportHook",
          "args": [
            "report_hook"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EnterCriticalSection",
          "args": [
            "&g_crtdbg_stacktrace_cs"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Nothing to do.\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_BIT_SET",
          "args": [
            "opt",
            "GIT_WIN32__CRTDBG_STACKTRACE__QUIET"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BIT_SET",
          "args": [
            "opt",
            "GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_TOTAL"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BIT_SET",
          "args": [
            "opt",
            "GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_SINCE_MARK"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BIT_SET",
          "args": [
            "opt",
            "GIT_WIN32__CRTDBG_STACKTRACE__SET_MARK"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nint git_win32__crtdbg_stacktrace__dump(\n\tgit_win32__crtdbg_stacktrace_options opt,\n\tconst char *label)\n{\n\t_CRT_REPORT_HOOK old;\n\tunsigned int k;\n\tint r = 0;\n\n#define IS_BIT_SET(o,b) (((o) & (b)) != 0)\n\n\tbool b_set_mark         = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__SET_MARK);\n\tbool b_leaks_since_mark = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_SINCE_MARK);\n\tbool b_leaks_total      = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__LEAKS_TOTAL);\n\tbool b_quiet            = IS_BIT_SET(opt, GIT_WIN32__CRTDBG_STACKTRACE__QUIET);\n\n\tif (b_leaks_since_mark && b_leaks_total) {\n\t\tgiterr_set(GITERR_INVALID, \"Cannot combine LEAKS_SINCE_MARK and LEAKS_TOTAL.\");\n\t\treturn GIT_ERROR;\n\t}\n\tif (!b_set_mark && !b_leaks_since_mark && !b_leaks_total) {\n\t\tgiterr_set(GITERR_INVALID, \"Nothing to do.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tEnterCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\tif (b_leaks_since_mark || b_leaks_total) {\n\t\t/* All variables with \"transient\" in the name are per-dump counters\n\t\t * and reset before each dump.  This lets us handle checkpoints.\n\t\t */\n\t\tg_transient_count_total_leaks = 0;\n\t\tg_transient_count_dedup_leaks = 0;\n\t\tfor (k = 0; k < g_cs_ins; k++) {\n\t\t\tg_cs_rows[k].transient_count_leaks = 0;\n\t\t}\n\t}\n\n\tg_transient_leaks_since_mark = b_leaks_since_mark;\n\n\told = _CrtSetReportHook(report_hook);\n\t_CrtDumpMemoryLeaks();\n\t_CrtSetReportHook(old);\n\n\tif (b_leaks_since_mark || b_leaks_total) {\n\t\tr = g_transient_count_dedup_leaks;\n\n\t\tif (!b_quiet)\n\t\t\tdump_summary(label);\n\t}\n\n\tif (b_set_mark) {\n\t\tfor (k = 0; k < g_cs_ins; k++) {\n\t\t\tg_cs_rows[k].count_allocs_at_last_checkpoint = g_cs_rows[k].count_allocs;\n\t\t}\n\n\t\tg_checkpoint_id++;\n\t}\n\n\tLeaveCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\treturn r;\n}"
  },
  {
    "function_name": "git_win32__crtdbg_stacktrace_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
    "lines": "221-238",
    "snippet": "void git_win32__crtdbg_stacktrace_init(void)\n{\n\tInitializeCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\tEnterCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\t_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n\n\t_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);\n\t_CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);\n\t_CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);\n\n\t_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\t_CrtSetReportFile(_CRT_ERROR,  _CRTDBG_FILE_STDERR);\n\t_CrtSetReportFile(_CRT_WARN,   _CRTDBG_FILE_STDERR);\n\n\tLeaveCriticalSection(&g_crtdbg_stacktrace_cs);\n}",
    "includes": [
      "#include \"w32_crtdbg_stacktrace.h\"",
      "#include \"w32_stack.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LeaveCriticalSection",
          "args": [
            "&g_crtdbg_stacktrace_cs"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetReportFile",
          "args": [
            "_CRT_WARN",
            "_CRTDBG_FILE_STDERR"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetReportFile",
          "args": [
            "_CRT_ERROR",
            "_CRTDBG_FILE_STDERR"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetReportFile",
          "args": [
            "_CRT_ASSERT",
            "_CRTDBG_FILE_STDERR"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetReportMode",
          "args": [
            "_CRT_WARN",
            "_CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetReportMode",
          "args": [
            "_CRT_ERROR",
            "_CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetReportMode",
          "args": [
            "_CRT_ASSERT",
            "_CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetDbgFlag",
          "args": [
            "_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EnterCriticalSection",
          "args": [
            "&g_crtdbg_stacktrace_cs"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitializeCriticalSection",
          "args": [
            "&g_crtdbg_stacktrace_cs"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nvoid git_win32__crtdbg_stacktrace_init(void)\n{\n\tInitializeCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\tEnterCriticalSection(&g_crtdbg_stacktrace_cs);\n\n\t_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n\n\t_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);\n\t_CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);\n\t_CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);\n\n\t_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\t_CrtSetReportFile(_CRT_ERROR,  _CRTDBG_FILE_STDERR);\n\t_CrtSetReportFile(_CRT_WARN,   _CRTDBG_FILE_STDERR);\n\n\tLeaveCriticalSection(&g_crtdbg_stacktrace_cs);\n}"
  },
  {
    "function_name": "dump_summary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
    "lines": "167-219",
    "snippet": "static void dump_summary(const char *label)\n{\n\tunsigned int k;\n\tchar buf[10 * 1024];\n\n\tif (g_transient_count_total_leaks == 0)\n\t\treturn;\n\n\tfflush(stdout);\n\tfflush(stderr);\n\tmy_output(\"\\n\");\n\n\tif (g_limit_reached) {\n\t\tsprintf(buf,\n\t\t\t\t\"LEAK SUMMARY: de-dup row table[%d] filled. Increase MY_ROW_LIMIT.\\n\",\n\t\t\t\tMY_ROW_LIMIT);\n\t\tmy_output(buf);\n\t}\n\n\tif (!label)\n\t\tlabel = \"\";\n\n\tif (g_transient_leaks_since_mark) {\n\t\tsprintf(buf, \"LEAK CHECKPOINT %d: leaks %d unique %d: %s\\n\",\n\t\t\t\tg_checkpoint_id, g_transient_count_total_leaks, g_transient_count_dedup_leaks, label);\n\t\tmy_output(buf);\n\t} else {\n\t\tsprintf(buf, \"LEAK SUMMARY: TOTAL leaks %d de-duped %d: %s\\n\",\n\t\t\t\tg_transient_count_total_leaks, g_transient_count_dedup_leaks, label);\n\t\tmy_output(buf);\n\t}\n\tmy_output(\"\\n\");\n\n\tfor (k = 0; k < g_cs_ins; k++) {\n\t\tif (g_cs_rows[k].transient_count_leaks > 0) {\n\t\t\tsprintf(buf, \"LEAK: %s leaked %d of %d times:\\n\",\n\t\t\t\t\tg_cs_rows[k].uid.uid,\n\t\t\t\t\tg_cs_rows[k].transient_count_leaks,\n\t\t\t\t\tg_cs_rows[k].count_allocs);\n\t\t\tmy_output(buf);\n\n\t\t\tif (git_win32__stack_format(\n\t\t\t\t\tbuf, sizeof(buf), &g_cs_rows[k].raw_data,\n\t\t\t\t\tNULL, NULL) >= 0) {\n\t\t\t\tmy_output(buf);\n\t\t\t}\n\n\t\t\tmy_output(\"\\n\");\n\t\t}\n\t}\n\n\tfflush(stderr);\n}",
    "includes": [
      "#include \"w32_crtdbg_stacktrace.h\"",
      "#include \"w32_stack.h\""
    ],
    "macros_used": [
      "#define MY_ROW_LIMIT (1024 * 1024)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_output",
          "args": [
            "\"\\n\""
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "my_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
          "lines": "158-162",
          "snippet": "static void my_output(const char *buf)\n{\n\tfwrite(buf, strlen(buf), 1, stderr);\n\tOutputDebugString(buf);\n}",
          "includes": [
            "#include \"w32_crtdbg_stacktrace.h\"",
            "#include \"w32_stack.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nstatic void my_output(const char *buf)\n{\n\tfwrite(buf, strlen(buf), 1, stderr);\n\tOutputDebugString(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32__stack_format",
          "args": [
            "buf",
            "sizeof(buf)",
            "&g_cs_rows[k].raw_data",
            "NULL",
            "NULL"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__stack_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
          "lines": "82-175",
          "snippet": "int git_win32__stack_format(\n\tchar *pbuf, int buf_len,\n\tconst git_win32__stack__raw_data *pdata,\n\tconst char *prefix, const char *suffix)\n{\n#define MY_MAX_FILENAME 255\n\n\t/* SYMBOL_INFO has char FileName[1] at the end.  The docs say to\n\t * to malloc it with extra space for your desired max filename.\n\t */\n\tstruct {\n\t\tSYMBOL_INFO symbol;\n\t\tchar extra[MY_MAX_FILENAME + 1];\n\t} s;\n\n\tIMAGEHLP_LINE64 line;\n\tint buf_used = 0;\n\tunsigned int k;\n\tchar detail[MY_MAX_FILENAME * 2]; /* filename plus space for function name and formatting */\n\tint detail_len;\n\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (!prefix)\n\t\tprefix = \"\\t\";\n\tif (!suffix)\n\t\tsuffix = \"\\n\";\n\n\tmemset(pbuf, 0, buf_len);\n\n\tmemset(&s, 0, sizeof(s));\n\ts.symbol.MaxNameLen = MY_MAX_FILENAME;\n\ts.symbol.SizeOfStruct = sizeof(SYMBOL_INFO);\n\n\tmemset(&line, 0, sizeof(line));\n\tline.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n\n\tfor (k=0; k < pdata->nr_frames; k++) {\n\t\tDWORD64 frame_k = (DWORD64)pdata->frames[k];\n\t\tDWORD dwUnused;\n\n\t\tif (SymFromAddr(g_win32_stack_process, frame_k, 0, &s.symbol) &&\n\t\t\tSymGetLineFromAddr64(g_win32_stack_process, frame_k, &dwUnused, &line)) {\n\t\t\tconst char *pslash;\n\t\t\tconst char *pfile;\n\n\t\t\tpslash = strrchr(line.FileName, '\\\\');\n\t\t\tpfile = ((pslash) ? (pslash+1) : line.FileName);\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s%s:%d> %s%s\",\n\t\t\t\t\t   prefix, pfile, line.LineNumber, s.symbol.Name, suffix);\n\t\t} else {\n\t\t\t/* This happens when we cross into another module.\n\t\t\t * For example, in CLAR tests, this is typically\n\t\t\t * the CRT startup code.  Just print an unknown\n\t\t\t * frame and continue.\n\t\t\t */\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s??%s\", prefix, suffix);\n\t\t}\n\t\tdetail_len = strlen(detail);\n\n\t\tif (buf_len < (buf_used + detail_len + 1)) {\n\t\t\t/* we don't have room for this frame in the buffer, so just stop. */\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\tbuf_used += detail_len;\n\t}\n\n\t/* \"aux_id\" 0 is reserved to mean no aux data. This is needed to handle\n\t * allocs that occur before the aux callbacks were registered.\n\t */\n\tif (pdata->aux_id > 0) {\n\t\tp_snprintf(detail, sizeof(detail), \"%saux_id: %d%s\",\n\t\t\t\t   prefix, pdata->aux_id, suffix);\n\t\tdetail_len = strlen(detail);\n\t\tif ((buf_used + detail_len + 1) < buf_len) {\n\t\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\t\tbuf_used += detail_len;\n\t\t}\n\n\t\t/* If an \"aux\" data provider is still registered, ask it to append its detailed\n\t\t * data to the end of ours using the \"aux_id\" it gave us when this de-duped\n\t\t * item was created.\n\t\t */\n\t\tif (g_aux_cb_lookup)\n\t\t\t(g_aux_cb_lookup)(pdata->aux_id, &pbuf[buf_used], (buf_len - buf_used - 1));\n\t}\n\n\treturn GIT_OK;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"w32_stack.h\"",
            "#include \"win32/posix.h\"",
            "#include \"Dbghelp.h\"",
            "#include \"Windows.h\""
          ],
          "macros_used": [
            "#define MY_MAX_FILENAME 255"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\n#define MY_MAX_FILENAME 255\n\nint git_win32__stack_format(\n\tchar *pbuf, int buf_len,\n\tconst git_win32__stack__raw_data *pdata,\n\tconst char *prefix, const char *suffix)\n{\n#define MY_MAX_FILENAME 255\n\n\t/* SYMBOL_INFO has char FileName[1] at the end.  The docs say to\n\t * to malloc it with extra space for your desired max filename.\n\t */\n\tstruct {\n\t\tSYMBOL_INFO symbol;\n\t\tchar extra[MY_MAX_FILENAME + 1];\n\t} s;\n\n\tIMAGEHLP_LINE64 line;\n\tint buf_used = 0;\n\tunsigned int k;\n\tchar detail[MY_MAX_FILENAME * 2]; /* filename plus space for function name and formatting */\n\tint detail_len;\n\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (!prefix)\n\t\tprefix = \"\\t\";\n\tif (!suffix)\n\t\tsuffix = \"\\n\";\n\n\tmemset(pbuf, 0, buf_len);\n\n\tmemset(&s, 0, sizeof(s));\n\ts.symbol.MaxNameLen = MY_MAX_FILENAME;\n\ts.symbol.SizeOfStruct = sizeof(SYMBOL_INFO);\n\n\tmemset(&line, 0, sizeof(line));\n\tline.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n\n\tfor (k=0; k < pdata->nr_frames; k++) {\n\t\tDWORD64 frame_k = (DWORD64)pdata->frames[k];\n\t\tDWORD dwUnused;\n\n\t\tif (SymFromAddr(g_win32_stack_process, frame_k, 0, &s.symbol) &&\n\t\t\tSymGetLineFromAddr64(g_win32_stack_process, frame_k, &dwUnused, &line)) {\n\t\t\tconst char *pslash;\n\t\t\tconst char *pfile;\n\n\t\t\tpslash = strrchr(line.FileName, '\\\\');\n\t\t\tpfile = ((pslash) ? (pslash+1) : line.FileName);\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s%s:%d> %s%s\",\n\t\t\t\t\t   prefix, pfile, line.LineNumber, s.symbol.Name, suffix);\n\t\t} else {\n\t\t\t/* This happens when we cross into another module.\n\t\t\t * For example, in CLAR tests, this is typically\n\t\t\t * the CRT startup code.  Just print an unknown\n\t\t\t * frame and continue.\n\t\t\t */\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s??%s\", prefix, suffix);\n\t\t}\n\t\tdetail_len = strlen(detail);\n\n\t\tif (buf_len < (buf_used + detail_len + 1)) {\n\t\t\t/* we don't have room for this frame in the buffer, so just stop. */\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\tbuf_used += detail_len;\n\t}\n\n\t/* \"aux_id\" 0 is reserved to mean no aux data. This is needed to handle\n\t * allocs that occur before the aux callbacks were registered.\n\t */\n\tif (pdata->aux_id > 0) {\n\t\tp_snprintf(detail, sizeof(detail), \"%saux_id: %d%s\",\n\t\t\t\t   prefix, pdata->aux_id, suffix);\n\t\tdetail_len = strlen(detail);\n\t\tif ((buf_used + detail_len + 1) < buf_len) {\n\t\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\t\tbuf_used += detail_len;\n\t\t}\n\n\t\t/* If an \"aux\" data provider is still registered, ask it to append its detailed\n\t\t * data to the end of ours using the \"aux_id\" it gave us when this de-duped\n\t\t * item was created.\n\t\t */\n\t\tif (g_aux_cb_lookup)\n\t\t\t(g_aux_cb_lookup)(pdata->aux_id, &pbuf[buf_used], (buf_len - buf_used - 1));\n\t}\n\n\treturn GIT_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"LEAK: %s leaked %d of %d times:\\n\"",
            "g_cs_rows[k].uid.uid",
            "g_cs_rows[k].transient_count_leaks",
            "g_cs_rows[k].count_allocs"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"LEAK SUMMARY: TOTAL leaks %d de-duped %d: %s\\n\"",
            "g_transient_count_total_leaks",
            "g_transient_count_dedup_leaks",
            "label"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"LEAK CHECKPOINT %d: leaks %d unique %d: %s\\n\"",
            "g_checkpoint_id",
            "g_transient_count_total_leaks",
            "g_transient_count_dedup_leaks",
            "label"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"LEAK SUMMARY: de-dup row table[%d] filled. Increase MY_ROW_LIMIT.\\n\"",
            "MY_ROW_LIMIT"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\n#define MY_ROW_LIMIT (1024 * 1024)\n\nstatic void dump_summary(const char *label)\n{\n\tunsigned int k;\n\tchar buf[10 * 1024];\n\n\tif (g_transient_count_total_leaks == 0)\n\t\treturn;\n\n\tfflush(stdout);\n\tfflush(stderr);\n\tmy_output(\"\\n\");\n\n\tif (g_limit_reached) {\n\t\tsprintf(buf,\n\t\t\t\t\"LEAK SUMMARY: de-dup row table[%d] filled. Increase MY_ROW_LIMIT.\\n\",\n\t\t\t\tMY_ROW_LIMIT);\n\t\tmy_output(buf);\n\t}\n\n\tif (!label)\n\t\tlabel = \"\";\n\n\tif (g_transient_leaks_since_mark) {\n\t\tsprintf(buf, \"LEAK CHECKPOINT %d: leaks %d unique %d: %s\\n\",\n\t\t\t\tg_checkpoint_id, g_transient_count_total_leaks, g_transient_count_dedup_leaks, label);\n\t\tmy_output(buf);\n\t} else {\n\t\tsprintf(buf, \"LEAK SUMMARY: TOTAL leaks %d de-duped %d: %s\\n\",\n\t\t\t\tg_transient_count_total_leaks, g_transient_count_dedup_leaks, label);\n\t\tmy_output(buf);\n\t}\n\tmy_output(\"\\n\");\n\n\tfor (k = 0; k < g_cs_ins; k++) {\n\t\tif (g_cs_rows[k].transient_count_leaks > 0) {\n\t\t\tsprintf(buf, \"LEAK: %s leaked %d of %d times:\\n\",\n\t\t\t\t\tg_cs_rows[k].uid.uid,\n\t\t\t\t\tg_cs_rows[k].transient_count_leaks,\n\t\t\t\t\tg_cs_rows[k].count_allocs);\n\t\t\tmy_output(buf);\n\n\t\t\tif (git_win32__stack_format(\n\t\t\t\t\tbuf, sizeof(buf), &g_cs_rows[k].raw_data,\n\t\t\t\t\tNULL, NULL) >= 0) {\n\t\t\t\tmy_output(buf);\n\t\t\t}\n\n\t\t\tmy_output(\"\\n\");\n\t\t}\n\t}\n\n\tfflush(stderr);\n}"
  },
  {
    "function_name": "my_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
    "lines": "158-162",
    "snippet": "static void my_output(const char *buf)\n{\n\tfwrite(buf, strlen(buf), 1, stderr);\n\tOutputDebugString(buf);\n}",
    "includes": [
      "#include \"w32_crtdbg_stacktrace.h\"",
      "#include \"w32_stack.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "buf"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "buf",
            "strlen(buf)",
            "1",
            "stderr"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nstatic void my_output(const char *buf)\n{\n\tfwrite(buf, strlen(buf), 1, stderr);\n\tOutputDebugString(buf);\n}"
  },
  {
    "function_name": "report_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
    "lines": "123-151",
    "snippet": "static int __cdecl report_hook(int nRptType, char *szMsg, int *retVal)\n{\n\tstatic int hook_result = TRUE; /* FALSE to get stock dump; TRUE to suppress. */\n\tunsigned int pos;\n\n\t*retVal = 0; /* do not invoke debugger */\n\n\tif ((szMsg[0] != '#') || (szMsg[1] != '#'))\n\t\treturn hook_result;\n\n\tif (sscanf(&szMsg[2], \"%08lx\", &pos) < 1)\n\t\treturn hook_result;\n\tif (pos >= g_cs_ins)\n\t\treturn hook_result;\n\n\tif (g_transient_leaks_since_mark) {\n\t\tif (g_cs_rows[pos].count_allocs == g_cs_rows[pos].count_allocs_at_last_checkpoint)\n\t\t\treturn hook_result;\n\t}\n\n\tg_cs_rows[pos].transient_count_leaks++;\n\n\tif (g_cs_rows[pos].transient_count_leaks == 1)\n\t\tg_transient_count_dedup_leaks++;\n\n\tg_transient_count_total_leaks++;\n\n\treturn hook_result;\n}",
    "includes": [
      "#include \"w32_crtdbg_stacktrace.h\"",
      "#include \"w32_stack.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "&szMsg[2]",
            "\"%08lx\"",
            "&pos"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nstatic int __cdecl report_hook(int nRptType, char *szMsg, int *retVal)\n{\n\tstatic int hook_result = TRUE; /* FALSE to get stock dump; TRUE to suppress. */\n\tunsigned int pos;\n\n\t*retVal = 0; /* do not invoke debugger */\n\n\tif ((szMsg[0] != '#') || (szMsg[1] != '#'))\n\t\treturn hook_result;\n\n\tif (sscanf(&szMsg[2], \"%08lx\", &pos) < 1)\n\t\treturn hook_result;\n\tif (pos >= g_cs_ins)\n\t\treturn hook_result;\n\n\tif (g_transient_leaks_since_mark) {\n\t\tif (g_cs_rows[pos].count_allocs == g_cs_rows[pos].count_allocs_at_last_checkpoint)\n\t\t\treturn hook_result;\n\t}\n\n\tg_cs_rows[pos].transient_count_leaks++;\n\n\tif (g_cs_rows[pos].transient_count_leaks == 1)\n\t\tg_transient_count_dedup_leaks++;\n\n\tg_transient_count_total_leaks++;\n\n\treturn hook_result;\n}"
  },
  {
    "function_name": "insert_unique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
    "lines": "88-108",
    "snippet": "static git_win32__crtdbg_stacktrace__row * insert_unique(\n\tconst git_win32__stack__raw_data *pdata)\n{\n\tsize_t pos;\n\tif (git__bsearch(g_cs_index, g_cs_ins, pdata, row_cmp, &pos) < 0) {\n\t\t/* Append new unique item to row table. */\n\t\tmemcpy(&g_cs_rows[g_cs_ins].raw_data, pdata, sizeof(*pdata));\n\t\tsprintf(g_cs_rows[g_cs_ins].uid.uid, \"##%08lx\", g_cs_ins);\n\n\t\t/* Insert pointer to it into the proper place in the index table. */\n\t\tif (pos < g_cs_ins)\n\t\t\tmemmove(&g_cs_index[pos+1], &g_cs_index[pos], (g_cs_ins - pos)*sizeof(g_cs_index[0]));\n\t\tg_cs_index[pos] = &g_cs_rows[g_cs_ins];\n\n\t\tg_cs_ins++;\n\t}\n\n\tg_cs_index[pos]->count_allocs++;\n\n\treturn g_cs_index[pos];\n}",
    "includes": [
      "#include \"w32_crtdbg_stacktrace.h\"",
      "#include \"w32_stack.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&g_cs_index[pos+1]",
            "&g_cs_index[pos]",
            "(g_cs_ins - pos)*sizeof(g_cs_index[0])"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "g_cs_rows[g_cs_ins].uid.uid",
            "\"##%08lx\"",
            "g_cs_ins"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&g_cs_rows[g_cs_ins].raw_data",
            "pdata",
            "sizeof(*pdata)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__bsearch",
          "args": [
            "g_cs_index",
            "g_cs_ins",
            "pdata",
            "row_cmp",
            "&pos"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "git__bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "495-523",
          "snippet": "int git__bsearch(\n\tvoid **array,\n\tsize_t array_len,\n\tconst void *key,\n\tint (*compare)(const void *, const void *),\n\tsize_t *position)\n{\n\tsize_t lim;\n\tint cmp = -1;\n\tvoid **part, **base = array;\n\n\tfor (lim = array_len; lim != 0; lim >>= 1) {\n\t\tpart = base + (lim >> 1);\n\t\tcmp = (*compare)(key, *part);\n\t\tif (cmp == 0) {\n\t\t\tbase = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (cmp > 0) { /* key > p; take right partition */\n\t\t\tbase = part + 1;\n\t\t\tlim--;\n\t\t} /* else take left partition */\n\t}\n\n\tif (position)\n\t\t*position = (base - array);\n\n\treturn (cmp == 0) ? 0 : GIT_ENOTFOUND;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__bsearch(\n\tvoid **array,\n\tsize_t array_len,\n\tconst void *key,\n\tint (*compare)(const void *, const void *),\n\tsize_t *position)\n{\n\tsize_t lim;\n\tint cmp = -1;\n\tvoid **part, **base = array;\n\n\tfor (lim = array_len; lim != 0; lim >>= 1) {\n\t\tpart = base + (lim >> 1);\n\t\tcmp = (*compare)(key, *part);\n\t\tif (cmp == 0) {\n\t\t\tbase = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (cmp > 0) { /* key > p; take right partition */\n\t\t\tbase = part + 1;\n\t\t\tlim--;\n\t\t} /* else take left partition */\n\t}\n\n\tif (position)\n\t\t*position = (base - array);\n\n\treturn (cmp == 0) ? 0 : GIT_ENOTFOUND;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nstatic git_win32__crtdbg_stacktrace__row * insert_unique(\n\tconst git_win32__stack__raw_data *pdata)\n{\n\tsize_t pos;\n\tif (git__bsearch(g_cs_index, g_cs_ins, pdata, row_cmp, &pos) < 0) {\n\t\t/* Append new unique item to row table. */\n\t\tmemcpy(&g_cs_rows[g_cs_ins].raw_data, pdata, sizeof(*pdata));\n\t\tsprintf(g_cs_rows[g_cs_ins].uid.uid, \"##%08lx\", g_cs_ins);\n\n\t\t/* Insert pointer to it into the proper place in the index table. */\n\t\tif (pos < g_cs_ins)\n\t\t\tmemmove(&g_cs_index[pos+1], &g_cs_index[pos], (g_cs_ins - pos)*sizeof(g_cs_index[0]));\n\t\tg_cs_index[pos] = &g_cs_rows[g_cs_ins];\n\n\t\tg_cs_ins++;\n\t}\n\n\tg_cs_index[pos]->count_allocs++;\n\n\treturn g_cs_index[pos];\n}"
  },
  {
    "function_name": "row_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_crtdbg_stacktrace.c",
    "lines": "76-82",
    "snippet": "static int row_cmp(const void *v1, const void *v2)\n{\n\tgit_win32__stack__raw_data *d1 = (git_win32__stack__raw_data*)v1;\n\tgit_win32__crtdbg_stacktrace__row *r2 = (git_win32__crtdbg_stacktrace__row *)v2;\n\n\treturn (git_win32__stack_compare(d1, &r2->raw_data));\n}",
    "includes": [
      "#include \"w32_crtdbg_stacktrace.h\"",
      "#include \"w32_stack.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_win32__stack_compare",
          "args": [
            "d1",
            "&r2->raw_data"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__stack_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
          "lines": "75-80",
          "snippet": "int git_win32__stack_compare(\n\tgit_win32__stack__raw_data *d1,\n\tgit_win32__stack__raw_data *d2)\n{\n\treturn memcmp(d1, d2, sizeof(*d1));\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"w32_stack.h\"",
            "#include \"win32/posix.h\"",
            "#include \"Dbghelp.h\"",
            "#include \"Windows.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\nint git_win32__stack_compare(\n\tgit_win32__stack__raw_data *d1,\n\tgit_win32__stack__raw_data *d2)\n{\n\treturn memcmp(d1, d2, sizeof(*d1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"w32_crtdbg_stacktrace.h\"\n#include \"w32_stack.h\"\n\nstatic int row_cmp(const void *v1, const void *v2)\n{\n\tgit_win32__stack__raw_data *d1 = (git_win32__stack__raw_data*)v1;\n\tgit_win32__crtdbg_stacktrace__row *r2 = (git_win32__crtdbg_stacktrace__row *)v2;\n\n\treturn (git_win32__stack_compare(d1, &r2->raw_data));\n}"
  }
]