[
  {
    "function_name": "git_attr_session__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "857-866",
    "snippet": "void git_attr_session__free(git_attr_session *session)\n{\n\tif (!session)\n\t\treturn;\n\n\tgit_buf_free(&session->sysdir);\n\tgit_buf_free(&session->tmp);\n\n\tmemset(session, 0, sizeof(git_attr_session));\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "session",
            "0",
            "sizeof(git_attr_session)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&session->tmp"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_session__free(git_attr_session *session)\n{\n\tif (!session)\n\t\treturn;\n\n\tgit_buf_free(&session->sysdir);\n\tgit_buf_free(&session->tmp);\n\n\tmemset(session, 0, sizeof(git_attr_session));\n}"
  },
  {
    "function_name": "git_attr_session__init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "848-855",
    "snippet": "int git_attr_session__init(git_attr_session *session, git_repository *repo)\n{\n\tassert(repo);\n\n\tsession->key = git_atomic_inc(&repo->attr_session_key);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_atomic_inc",
          "args": [
            "&repo->attr_session_key"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "171-174",
          "snippet": "GIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_session__init(git_attr_session *session, git_repository *repo)\n{\n\tassert(repo);\n\n\tsession->key = git_atomic_inc(&repo->attr_session_key);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_attr_rule__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "842-846",
    "snippet": "void git_attr_rule__free(git_attr_rule *rule)\n{\n\tgit_attr_rule__clear(rule);\n\tgit__free(rule);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void git_attr_rule__clear(git_attr_rule *rule);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "rule"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_rule__clear",
          "args": [
            "rule"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_rule__clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "823-840",
          "snippet": "static void git_attr_rule__clear(git_attr_rule *rule)\n{\n\tunsigned int i;\n\tgit_attr_assignment *assign;\n\n\tif (!rule)\n\t\treturn;\n\n\tif (!(rule->match.flags & GIT_ATTR_FNMATCH_IGNORE)) {\n\t\tgit_vector_foreach(&rule->assigns, i, assign)\n\t\t\tGIT_REFCOUNT_DEC(assign, git_attr_assignment__free);\n\t\tgit_vector_free(&rule->assigns);\n\t}\n\n\t/* match.pattern is stored in a git_pool, so no need to free */\n\trule->match.pattern = NULL;\n\trule->match.length = 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);",
            "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nstatic void git_attr_rule__clear(git_attr_rule *rule)\n{\n\tunsigned int i;\n\tgit_attr_assignment *assign;\n\n\tif (!rule)\n\t\treturn;\n\n\tif (!(rule->match.flags & GIT_ATTR_FNMATCH_IGNORE)) {\n\t\tgit_vector_foreach(&rule->assigns, i, assign)\n\t\t\tGIT_REFCOUNT_DEC(assign, git_attr_assignment__free);\n\t\tgit_vector_free(&rule->assigns);\n\t}\n\n\t/* match.pattern is stored in a git_pool, so no need to free */\n\trule->match.pattern = NULL;\n\trule->match.length = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nvoid git_attr_rule__free(git_attr_rule *rule)\n{\n\tgit_attr_rule__clear(rule);\n\tgit__free(rule);\n}"
  },
  {
    "function_name": "git_attr_rule__clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "823-840",
    "snippet": "static void git_attr_rule__clear(git_attr_rule *rule)\n{\n\tunsigned int i;\n\tgit_attr_assignment *assign;\n\n\tif (!rule)\n\t\treturn;\n\n\tif (!(rule->match.flags & GIT_ATTR_FNMATCH_IGNORE)) {\n\t\tgit_vector_foreach(&rule->assigns, i, assign)\n\t\t\tGIT_REFCOUNT_DEC(assign, git_attr_assignment__free);\n\t\tgit_vector_free(&rule->assigns);\n\t}\n\n\t/* match.pattern is stored in a git_pool, so no need to free */\n\trule->match.pattern = NULL;\n\trule->match.length = 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void git_attr_rule__clear(git_attr_rule *rule);",
      "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&rule->assigns"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_DEC",
          "args": [
            "assign",
            "git_attr_assignment__free"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&rule->assigns",
            "i",
            "assign"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nstatic void git_attr_rule__clear(git_attr_rule *rule)\n{\n\tunsigned int i;\n\tgit_attr_assignment *assign;\n\n\tif (!rule)\n\t\treturn;\n\n\tif (!(rule->match.flags & GIT_ATTR_FNMATCH_IGNORE)) {\n\t\tgit_vector_foreach(&rule->assigns, i, assign)\n\t\t\tGIT_REFCOUNT_DEC(assign, git_attr_assignment__free);\n\t\tgit_vector_free(&rule->assigns);\n\t}\n\n\t/* match.pattern is stored in a git_pool, so no need to free */\n\trule->match.pattern = NULL;\n\trule->match.length = 0;\n}"
  },
  {
    "function_name": "git_attr_assignment__parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "714-821",
    "snippet": "int git_attr_assignment__parse(\n\tgit_repository *repo,\n\tgit_pool *pool,\n\tgit_vector *assigns,\n\tconst char **base)\n{\n\tint error;\n\tconst char *scan = *base;\n\tgit_attr_assignment *assign = NULL;\n\n\tassert(assigns && !assigns->length);\n\n\tgit_vector_set_cmp(assigns, sort_by_hash_and_name);\n\n\twhile (*scan && *scan != '\\n') {\n\t\tconst char *name_start, *value_start;\n\n\t\t/* skip leading blanks */\n\t\twhile (git__isspace(*scan) && *scan != '\\n') scan++;\n\n\t\t/* allocate assign if needed */\n\t\tif (!assign) {\n\t\t\tassign = git__calloc(1, sizeof(git_attr_assignment));\n\t\t\tGITERR_CHECK_ALLOC(assign);\n\t\t\tGIT_REFCOUNT_INC(assign);\n\t\t}\n\n\t\tassign->name_hash = 5381;\n\t\tassign->value = git_attr__true;\n\n\t\t/* look for magic name prefixes */\n\t\tif (*scan == '-') {\n\t\t\tassign->value = git_attr__false;\n\t\t\tscan++;\n\t\t} else if (*scan == '!') {\n\t\t\tassign->value = git_attr__unset; /* explicit unspecified state */\n\t\t\tscan++;\n\t\t} else if (*scan == '#') /* comment rest of line */\n\t\t\tbreak;\n\n\t\t/* find the name */\n\t\tname_start = scan;\n\t\twhile (*scan && !git__isspace(*scan) && *scan != '=') {\n\t\t\tassign->name_hash =\n\t\t\t\t((assign->name_hash << 5) + assign->name_hash) + *scan;\n\t\t\tscan++;\n\t\t}\n\t\tif (scan == name_start) {\n\t\t\t/* must have found lone prefix (\" - \") or leading = (\"=foo\")\n\t\t\t * or end of buffer -- advance until whitespace and continue\n\t\t\t */\n\t\t\twhile (*scan && !git__isspace(*scan)) scan++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* allocate permanent storage for name */\n\t\tassign->name = git_pool_strndup(pool, name_start, scan - name_start);\n\t\tGITERR_CHECK_ALLOC(assign->name);\n\n\t\t/* if there is an equals sign, find the value */\n\t\tif (*scan == '=') {\n\t\t\tfor (value_start = ++scan; *scan && !git__isspace(*scan); ++scan);\n\n\t\t\t/* if we found a value, allocate permanent storage for it */\n\t\t\tif (scan > value_start) {\n\t\t\t\tassign->value = git_pool_strndup(pool, value_start, scan - value_start);\n\t\t\t\tGITERR_CHECK_ALLOC(assign->value);\n\t\t\t}\n\t\t}\n\n\t\t/* expand macros (if given a repo with a macro cache) */\n\t\tif (repo != NULL && assign->value == git_attr__true) {\n\t\t\tgit_attr_rule *macro =\n\t\t\t\tgit_attr_cache__lookup_macro(repo, assign->name);\n\n\t\t\tif (macro != NULL) {\n\t\t\t\tunsigned int i;\n\t\t\t\tgit_attr_assignment *massign;\n\n\t\t\t\tgit_vector_foreach(&macro->assigns, i, massign) {\n\t\t\t\t\tGIT_REFCOUNT_INC(massign);\n\n\t\t\t\t\terror = git_vector_insert_sorted(\n\t\t\t\t\t\tassigns, massign, &merge_assignments);\n\t\t\t\t\tif (error < 0 && error != GIT_EEXISTS) {\n\t\t\t\t\t\tgit_attr_assignment__free(assign);\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* insert allocated assign into vector */\n\t\terror = git_vector_insert_sorted(assigns, assign, &merge_assignments);\n\t\tif (error < 0 && error != GIT_EEXISTS)\n\t\t\treturn error;\n\n\t\t/* clear assign since it is now \"owned\" by the vector */\n\t\tassign = NULL;\n\t}\n\n\tif (assign != NULL)\n\t\tgit_attr_assignment__free(assign);\n\n\t*base = git__next_line(scan);\n\n\treturn (assigns->length == 0) ? GIT_ENOTFOUND : 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__next_line",
          "args": [
            "scan"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "git__next_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "293-298",
          "snippet": "GIT_INLINE(const char *) git__next_line(const char *s)\n{\n\twhile (*s && *s != '\\n') s++;\n\twhile (*s == '\\n' || *s == '\\r') s++;\n\treturn s;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(const char *) git__next_line(const char *s)\n{\n\twhile (*s && *s != '\\n') s++;\n\twhile (*s == '\\n' || *s == '\\r') s++;\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_assignment__free",
          "args": [
            "assign"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_assignment__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "694-702",
          "snippet": "static void git_attr_assignment__free(git_attr_assignment *assign)\n{\n\t/* name and value are stored in a git_pool associated with the\n\t * git_attr_file, so they do not need to be freed here\n\t */\n\tassign->name = NULL;\n\tassign->value = NULL;\n\tgit__free(assign);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_assignment__free(git_attr_assignment *assign)\n{\n\t/* name and value are stored in a git_pool associated with the\n\t * git_attr_file, so they do not need to be freed here\n\t */\n\tassign->name = NULL;\n\tassign->value = NULL;\n\tgit__free(assign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert_sorted",
          "args": [
            "assigns",
            "assign",
            "&merge_assignments"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert_sorted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "141-173",
          "snippet": "int git_vector_insert_sorted(\n\tgit_vector *v, void *element, int (*on_dup)(void **old, void *new))\n{\n\tint result;\n\tsize_t pos;\n\n\tassert(v && v->_cmp);\n\n\tif (!git_vector_is_sorted(v))\n\t\tgit_vector_sort(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\t/* If we find the element and have a duplicate handler callback,\n\t * invoke it.  If it returns non-zero, then cancel insert, otherwise\n\t * proceed with normal insert.\n\t */\n\tif (!git__bsearch(v->contents, v->length, element, v->_cmp, &pos) &&\n\t\ton_dup && (result = on_dup(&v->contents[pos], element)) < 0)\n\t\treturn result;\n\n\t/* shift elements to the right */\n\tif (pos < v->length)\n\t\tmemmove(v->contents + pos + 1, v->contents + pos,\n\t\t        (v->length - pos) * sizeof(void *));\n\n\tv->contents[pos] = element;\n\tv->length++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert_sorted(\n\tgit_vector *v, void *element, int (*on_dup)(void **old, void *new))\n{\n\tint result;\n\tsize_t pos;\n\n\tassert(v && v->_cmp);\n\n\tif (!git_vector_is_sorted(v))\n\t\tgit_vector_sort(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\t/* If we find the element and have a duplicate handler callback,\n\t * invoke it.  If it returns non-zero, then cancel insert, otherwise\n\t * proceed with normal insert.\n\t */\n\tif (!git__bsearch(v->contents, v->length, element, v->_cmp, &pos) &&\n\t\ton_dup && (result = on_dup(&v->contents[pos], element)) < 0)\n\t\treturn result;\n\n\t/* shift elements to the right */\n\tif (pos < v->length)\n\t\tmemmove(v->contents + pos + 1, v->contents + pos,\n\t\t        (v->length - pos) * sizeof(void *));\n\n\tv->contents[pos] = element;\n\tv->length++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "massign"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&macro->assigns",
            "i",
            "massign"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_attr_cache__lookup_macro",
          "args": [
            "repo",
            "assign->name"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_cache__lookup_macro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attrcache.c",
          "lines": "443-455",
          "snippet": "git_attr_rule *git_attr_cache__lookup_macro(\n\tgit_repository *repo, const char *name)\n{\n\tgit_strmap *macros = git_repository_attr_cache(repo)->macros;\n\tkhiter_t pos;\n\n\tpos = git_strmap_lookup_index(macros, name);\n\n\tif (!git_strmap_valid_index(macros, pos))\n\t\treturn NULL;\n\n\treturn (git_attr_rule *)git_strmap_value_at(macros, pos);\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"sysdir.h\"",
            "#include \"config.h\"",
            "#include \"attr_file.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"sysdir.h\"\n#include \"config.h\"\n#include \"attr_file.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\ngit_attr_rule *git_attr_cache__lookup_macro(\n\tgit_repository *repo, const char *name)\n{\n\tgit_strmap *macros = git_repository_attr_cache(repo)->macros;\n\tkhiter_t pos;\n\n\tpos = git_strmap_lookup_index(macros, name);\n\n\tif (!git_strmap_valid_index(macros, pos))\n\t\treturn NULL;\n\n\treturn (git_attr_rule *)git_strmap_value_at(macros, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "assign->value"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_strndup",
          "args": [
            "pool",
            "value_start",
            "scan - value_start"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "190-205",
          "snippet": "char *git_pool_strndup(git_pool *pool, const char *str, size_t n)\n{\n\tchar *ptr = NULL;\n\n\tassert(pool && str && pool->item_size == sizeof(char));\n\n\tif ((uint32_t)(n + 1) < n)\n\t\treturn NULL;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(n + 1))) != NULL) {\n\t\tmemcpy(ptr, str, n);\n\t\tptr[n] = '\\0';\n\t}\n\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strndup(git_pool *pool, const char *str, size_t n)\n{\n\tchar *ptr = NULL;\n\n\tassert(pool && str && pool->item_size == sizeof(char));\n\n\tif ((uint32_t)(n + 1) < n)\n\t\treturn NULL;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(n + 1))) != NULL) {\n\t\tmemcpy(ptr, str, n);\n\t\tptr[n] = '\\0';\n\t}\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "*scan"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "assign->name"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "assign"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "assign"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_attr_assignment)"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_cmp",
          "args": [
            "assigns",
            "sort_by_hash_and_name"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "107-113",
          "snippet": "GIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "assigns && !assigns->length"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_assignment__parse(\n\tgit_repository *repo,\n\tgit_pool *pool,\n\tgit_vector *assigns,\n\tconst char **base)\n{\n\tint error;\n\tconst char *scan = *base;\n\tgit_attr_assignment *assign = NULL;\n\n\tassert(assigns && !assigns->length);\n\n\tgit_vector_set_cmp(assigns, sort_by_hash_and_name);\n\n\twhile (*scan && *scan != '\\n') {\n\t\tconst char *name_start, *value_start;\n\n\t\t/* skip leading blanks */\n\t\twhile (git__isspace(*scan) && *scan != '\\n') scan++;\n\n\t\t/* allocate assign if needed */\n\t\tif (!assign) {\n\t\t\tassign = git__calloc(1, sizeof(git_attr_assignment));\n\t\t\tGITERR_CHECK_ALLOC(assign);\n\t\t\tGIT_REFCOUNT_INC(assign);\n\t\t}\n\n\t\tassign->name_hash = 5381;\n\t\tassign->value = git_attr__true;\n\n\t\t/* look for magic name prefixes */\n\t\tif (*scan == '-') {\n\t\t\tassign->value = git_attr__false;\n\t\t\tscan++;\n\t\t} else if (*scan == '!') {\n\t\t\tassign->value = git_attr__unset; /* explicit unspecified state */\n\t\t\tscan++;\n\t\t} else if (*scan == '#') /* comment rest of line */\n\t\t\tbreak;\n\n\t\t/* find the name */\n\t\tname_start = scan;\n\t\twhile (*scan && !git__isspace(*scan) && *scan != '=') {\n\t\t\tassign->name_hash =\n\t\t\t\t((assign->name_hash << 5) + assign->name_hash) + *scan;\n\t\t\tscan++;\n\t\t}\n\t\tif (scan == name_start) {\n\t\t\t/* must have found lone prefix (\" - \") or leading = (\"=foo\")\n\t\t\t * or end of buffer -- advance until whitespace and continue\n\t\t\t */\n\t\t\twhile (*scan && !git__isspace(*scan)) scan++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* allocate permanent storage for name */\n\t\tassign->name = git_pool_strndup(pool, name_start, scan - name_start);\n\t\tGITERR_CHECK_ALLOC(assign->name);\n\n\t\t/* if there is an equals sign, find the value */\n\t\tif (*scan == '=') {\n\t\t\tfor (value_start = ++scan; *scan && !git__isspace(*scan); ++scan);\n\n\t\t\t/* if we found a value, allocate permanent storage for it */\n\t\t\tif (scan > value_start) {\n\t\t\t\tassign->value = git_pool_strndup(pool, value_start, scan - value_start);\n\t\t\t\tGITERR_CHECK_ALLOC(assign->value);\n\t\t\t}\n\t\t}\n\n\t\t/* expand macros (if given a repo with a macro cache) */\n\t\tif (repo != NULL && assign->value == git_attr__true) {\n\t\t\tgit_attr_rule *macro =\n\t\t\t\tgit_attr_cache__lookup_macro(repo, assign->name);\n\n\t\t\tif (macro != NULL) {\n\t\t\t\tunsigned int i;\n\t\t\t\tgit_attr_assignment *massign;\n\n\t\t\t\tgit_vector_foreach(&macro->assigns, i, massign) {\n\t\t\t\t\tGIT_REFCOUNT_INC(massign);\n\n\t\t\t\t\terror = git_vector_insert_sorted(\n\t\t\t\t\t\tassigns, massign, &merge_assignments);\n\t\t\t\t\tif (error < 0 && error != GIT_EEXISTS) {\n\t\t\t\t\t\tgit_attr_assignment__free(assign);\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* insert allocated assign into vector */\n\t\terror = git_vector_insert_sorted(assigns, assign, &merge_assignments);\n\t\tif (error < 0 && error != GIT_EEXISTS)\n\t\t\treturn error;\n\n\t\t/* clear assign since it is now \"owned\" by the vector */\n\t\tassign = NULL;\n\t}\n\n\tif (assign != NULL)\n\t\tgit_attr_assignment__free(assign);\n\n\t*base = git__next_line(scan);\n\n\treturn (assigns->length == 0) ? GIT_ENOTFOUND : 0;\n}"
  },
  {
    "function_name": "merge_assignments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "704-712",
    "snippet": "static int merge_assignments(void **old_raw, void *new_raw)\n{\n\tgit_attr_assignment **old = (git_attr_assignment **)old_raw;\n\tgit_attr_assignment *new = (git_attr_assignment *)new_raw;\n\n\tGIT_REFCOUNT_DEC(*old, git_attr_assignment__free);\n\t*old = new;\n\treturn GIT_EEXISTS;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_DEC",
          "args": [
            "*old",
            "git_attr_assignment__free"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int merge_assignments(void **old_raw, void *new_raw)\n{\n\tgit_attr_assignment **old = (git_attr_assignment **)old_raw;\n\tgit_attr_assignment *new = (git_attr_assignment *)new_raw;\n\n\tGIT_REFCOUNT_DEC(*old, git_attr_assignment__free);\n\t*old = new;\n\treturn GIT_EEXISTS;\n}"
  },
  {
    "function_name": "git_attr_assignment__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "694-702",
    "snippet": "static void git_attr_assignment__free(git_attr_assignment *assign)\n{\n\t/* name and value are stored in a git_pool associated with the\n\t * git_attr_file, so they do not need to be freed here\n\t */\n\tassign->name = NULL;\n\tassign->value = NULL;\n\tgit__free(assign);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "assign"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_assignment__free(git_attr_assignment *assign)\n{\n\t/* name and value are stored in a git_pool associated with the\n\t * git_attr_file, so they do not need to be freed here\n\t */\n\tassign->name = NULL;\n\tassign->value = NULL;\n\tgit__free(assign);\n}"
  },
  {
    "function_name": "sort_by_hash_and_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "681-692",
    "snippet": "static int sort_by_hash_and_name(const void *a_raw, const void *b_raw)\n{\n\tconst git_attr_name *a = a_raw;\n\tconst git_attr_name *b = b_raw;\n\n\tif (b->name_hash < a->name_hash)\n\t\treturn 1;\n\telse if (b->name_hash > a->name_hash)\n\t\treturn -1;\n\telse\n\t\treturn strcmp(b->name, a->name);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int sort_by_hash_and_name(const void *a_raw, const void *b_raw);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "b->name",
            "a->name"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int sort_by_hash_and_name(const void *a_raw, const void *b_raw);\n\nstatic int sort_by_hash_and_name(const void *a_raw, const void *b_raw)\n{\n\tconst git_attr_name *a = a_raw;\n\tconst git_attr_name *b = b_raw;\n\n\tif (b->name_hash < a->name_hash)\n\t\treturn 1;\n\telse if (b->name_hash > a->name_hash)\n\t\treturn -1;\n\telse\n\t\treturn strcmp(b->name, a->name);\n}"
  },
  {
    "function_name": "parse_optimized_patterns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "665-679",
    "snippet": "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern)\n{\n\tif (!pattern[1] && (pattern[0] == '*' || pattern[0] == '.')) {\n\t\tspec->flags = GIT_ATTR_FNMATCH_MATCH_ALL;\n\t\tspec->pattern = git_pool_strndup(pool, pattern, 1);\n\t\tspec->length = 1;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pool_strndup",
          "args": [
            "pool",
            "pattern",
            "1"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "190-205",
          "snippet": "char *git_pool_strndup(git_pool *pool, const char *str, size_t n)\n{\n\tchar *ptr = NULL;\n\n\tassert(pool && str && pool->item_size == sizeof(char));\n\n\tif ((uint32_t)(n + 1) < n)\n\t\treturn NULL;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(n + 1))) != NULL) {\n\t\tmemcpy(ptr, str, n);\n\t\tptr[n] = '\\0';\n\t}\n\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strndup(git_pool *pool, const char *str, size_t n)\n{\n\tchar *ptr = NULL;\n\n\tassert(pool && str && pool->item_size == sizeof(char));\n\n\tif ((uint32_t)(n + 1) < n)\n\t\treturn NULL;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(n + 1))) != NULL) {\n\t\tmemcpy(ptr, str, n);\n\t\tptr[n] = '\\0';\n\t}\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern)\n{\n\tif (!pattern[1] && (pattern[0] == '*' || pattern[0] == '.')) {\n\t\tspec->flags = GIT_ATTR_FNMATCH_MATCH_ALL;\n\t\tspec->pattern = git_pool_strndup(pool, pattern, 1);\n\t\tspec->length = 1;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "git_attr_fnmatch__parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "552-663",
    "snippet": "int git_attr_fnmatch__parse(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *context,\n\tconst char **base)\n{\n\tconst char *pattern, *scan;\n\tint slash_count, allow_space;\n\n\tassert(spec && base && *base);\n\n\tif (parse_optimized_patterns(spec, pool, *base))\n\t\treturn 0;\n\n\tspec->flags = (spec->flags & GIT_ATTR_FNMATCH__INCOMING);\n\tallow_space = ((spec->flags & GIT_ATTR_FNMATCH_ALLOWSPACE) != 0);\n\n\tpattern = *base;\n\n\twhile (git__isspace(*pattern)) pattern++;\n\tif (!*pattern || *pattern == '#') {\n\t\t*base = git__next_line(pattern);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (*pattern == '[' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWMACRO) != 0) {\n\t\tif (strncmp(pattern, \"[attr]\", 6) == 0) {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_MACRO;\n\t\t\tpattern += 6;\n\t\t}\n\t\t/* else a character range like [a-e]* which is accepted */\n\t}\n\n\tif (*pattern == '!' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWNEG) != 0) {\n\t\tspec->flags = spec->flags |\n\t\t\tGIT_ATTR_FNMATCH_NEGATIVE | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\tpattern++;\n\t}\n\n\tslash_count = 0;\n\tfor (scan = pattern; *scan != '\\0'; ++scan) {\n\t\t/* scan until (non-escaped) white space */\n\t\tif (git__isspace(*scan) && *(scan - 1) != '\\\\') {\n\t\t\tif (!allow_space || (*scan != ' ' && *scan != '\\t' && *scan != '\\r'))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (*scan == '/') {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_FULLPATH;\n\t\t\tslash_count++;\n\t\t\tif (pattern == scan)\n\t\t\t\tpattern++;\n\t\t}\n\t\t/* remember if we see an unescaped wildcard in pattern */\n\t\telse if (git__iswildcard(*scan) &&\n\t\t\t(scan == pattern || (*(scan - 1) != '\\\\')))\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_HASWILD;\n\t}\n\n\t*base = scan;\n\n\tif ((spec->length = scan - pattern) == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/*\n\t * Remove one trailing \\r in case this is a CRLF delimited\n\t * file, in the case of Icon\\r\\r\\n, we still leave the first\n\t * \\r there to match against.\n\t */\n\tif (pattern[spec->length - 1] == '\\r')\n\t\tif (--spec->length == 0)\n\t\t\treturn GIT_ENOTFOUND;\n\n\tif (pattern[spec->length - 1] == '/') {\n\t\tspec->length--;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_DIRECTORY;\n\t\tif (--slash_count <= 0)\n\t\t\tspec->flags = spec->flags & ~GIT_ATTR_FNMATCH_FULLPATH;\n\t}\n\tif ((spec->flags & GIT_ATTR_FNMATCH_NOLEADINGDIR) == 0 &&\n\t\tspec->length >= 2 &&\n\t\tpattern[spec->length - 1] == '*' &&\n\t\tpattern[spec->length - 2] == '/') {\n\t\tspec->length -= 2;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\t/* leave FULLPATH match on, however */\n\t}\n\n\tif (context) {\n\t\tchar *slash = strrchr(context, '/');\n\t\tsize_t len;\n\t\tif (slash) {\n\t\t\t/* include the slash for easier matching */\n\t\t\tlen = slash - context + 1;\n\t\t\tspec->containing_dir = git_pool_strndup(pool, context, len);\n\t\t\tspec->containing_dir_length = len;\n\t\t}\n\t}\n\n\tspec->pattern = git_pool_strndup(pool, pattern, spec->length);\n\n\tif (!spec->pattern) {\n\t\t*base = git__next_line(pattern);\n\t\treturn -1;\n\t} else {\n\t\t/* strip '\\' that might have be used for internal whitespace */\n\t\tspec->length = git__unescape(spec->pattern);\n\t\t/* TODO: convert remaining '\\' into '/' for POSIX ??? */\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__unescape",
          "args": [
            "spec->pattern"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "git__unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "593-612",
          "snippet": "size_t git__unescape(char *str)\n{\n\tchar *scan, *pos = str;\n\n\tif (!str)\n\t\treturn 0;\n\n\tfor (scan = str; *scan; pos++, scan++) {\n\t\tif (*scan == '\\\\' && *(scan + 1) != '\\0')\n\t\t\tscan++; /* skip '\\' but include next char */\n\t\tif (pos != scan)\n\t\t\t*pos = *scan;\n\t}\n\n\tif (pos != scan) {\n\t\t*pos = '\\0';\n\t}\n\n\treturn (pos - str);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nsize_t git__unescape(char *str)\n{\n\tchar *scan, *pos = str;\n\n\tif (!str)\n\t\treturn 0;\n\n\tfor (scan = str; *scan; pos++, scan++) {\n\t\tif (*scan == '\\\\' && *(scan + 1) != '\\0')\n\t\t\tscan++; /* skip '\\' but include next char */\n\t\tif (pos != scan)\n\t\t\t*pos = *scan;\n\t}\n\n\tif (pos != scan) {\n\t\t*pos = '\\0';\n\t}\n\n\treturn (pos - str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__next_line",
          "args": [
            "pattern"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "git__next_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "293-298",
          "snippet": "GIT_INLINE(const char *) git__next_line(const char *s)\n{\n\twhile (*s && *s != '\\n') s++;\n\twhile (*s == '\\n' || *s == '\\r') s++;\n\treturn s;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(const char *) git__next_line(const char *s)\n{\n\twhile (*s && *s != '\\n') s++;\n\twhile (*s == '\\n' || *s == '\\r') s++;\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_strndup",
          "args": [
            "pool",
            "pattern",
            "spec->length"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "190-205",
          "snippet": "char *git_pool_strndup(git_pool *pool, const char *str, size_t n)\n{\n\tchar *ptr = NULL;\n\n\tassert(pool && str && pool->item_size == sizeof(char));\n\n\tif ((uint32_t)(n + 1) < n)\n\t\treturn NULL;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(n + 1))) != NULL) {\n\t\tmemcpy(ptr, str, n);\n\t\tptr[n] = '\\0';\n\t}\n\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strndup(git_pool *pool, const char *str, size_t n)\n{\n\tchar *ptr = NULL;\n\n\tassert(pool && str && pool->item_size == sizeof(char));\n\n\tif ((uint32_t)(n + 1) < n)\n\t\treturn NULL;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(n + 1))) != NULL) {\n\t\tmemcpy(ptr, str, n);\n\t\tptr[n] = '\\0';\n\t}\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "context",
            "'/'"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__iswildcard",
          "args": [
            "*scan"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "git__iswildcard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "464-467",
          "snippet": "GIT_INLINE(bool) git__iswildcard(int c)\n{\n\treturn (c == '*' || c == '?' || c == '[');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__iswildcard(int c)\n{\n\treturn (c == '*' || c == '?' || c == '[');\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "*scan"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "pattern",
            "\"[attr]\"",
            "6"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_optimized_patterns",
          "args": [
            "spec",
            "pool",
            "*base"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "parse_optimized_patterns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "665-679",
          "snippet": "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern)\n{\n\tif (!pattern[1] && (pattern[0] == '*' || pattern[0] == '.')) {\n\t\tspec->flags = GIT_ATTR_FNMATCH_MATCH_ALL;\n\t\tspec->pattern = git_pool_strndup(pool, pattern, 1);\n\t\tspec->length = 1;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern)\n{\n\tif (!pattern[1] && (pattern[0] == '*' || pattern[0] == '.')) {\n\t\tspec->flags = GIT_ATTR_FNMATCH_MATCH_ALL;\n\t\tspec->pattern = git_pool_strndup(pool, pattern, 1);\n\t\tspec->length = 1;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "spec && base && *base"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nint git_attr_fnmatch__parse(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *context,\n\tconst char **base)\n{\n\tconst char *pattern, *scan;\n\tint slash_count, allow_space;\n\n\tassert(spec && base && *base);\n\n\tif (parse_optimized_patterns(spec, pool, *base))\n\t\treturn 0;\n\n\tspec->flags = (spec->flags & GIT_ATTR_FNMATCH__INCOMING);\n\tallow_space = ((spec->flags & GIT_ATTR_FNMATCH_ALLOWSPACE) != 0);\n\n\tpattern = *base;\n\n\twhile (git__isspace(*pattern)) pattern++;\n\tif (!*pattern || *pattern == '#') {\n\t\t*base = git__next_line(pattern);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (*pattern == '[' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWMACRO) != 0) {\n\t\tif (strncmp(pattern, \"[attr]\", 6) == 0) {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_MACRO;\n\t\t\tpattern += 6;\n\t\t}\n\t\t/* else a character range like [a-e]* which is accepted */\n\t}\n\n\tif (*pattern == '!' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWNEG) != 0) {\n\t\tspec->flags = spec->flags |\n\t\t\tGIT_ATTR_FNMATCH_NEGATIVE | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\tpattern++;\n\t}\n\n\tslash_count = 0;\n\tfor (scan = pattern; *scan != '\\0'; ++scan) {\n\t\t/* scan until (non-escaped) white space */\n\t\tif (git__isspace(*scan) && *(scan - 1) != '\\\\') {\n\t\t\tif (!allow_space || (*scan != ' ' && *scan != '\\t' && *scan != '\\r'))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (*scan == '/') {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_FULLPATH;\n\t\t\tslash_count++;\n\t\t\tif (pattern == scan)\n\t\t\t\tpattern++;\n\t\t}\n\t\t/* remember if we see an unescaped wildcard in pattern */\n\t\telse if (git__iswildcard(*scan) &&\n\t\t\t(scan == pattern || (*(scan - 1) != '\\\\')))\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_HASWILD;\n\t}\n\n\t*base = scan;\n\n\tif ((spec->length = scan - pattern) == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/*\n\t * Remove one trailing \\r in case this is a CRLF delimited\n\t * file, in the case of Icon\\r\\r\\n, we still leave the first\n\t * \\r there to match against.\n\t */\n\tif (pattern[spec->length - 1] == '\\r')\n\t\tif (--spec->length == 0)\n\t\t\treturn GIT_ENOTFOUND;\n\n\tif (pattern[spec->length - 1] == '/') {\n\t\tspec->length--;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_DIRECTORY;\n\t\tif (--slash_count <= 0)\n\t\t\tspec->flags = spec->flags & ~GIT_ATTR_FNMATCH_FULLPATH;\n\t}\n\tif ((spec->flags & GIT_ATTR_FNMATCH_NOLEADINGDIR) == 0 &&\n\t\tspec->length >= 2 &&\n\t\tpattern[spec->length - 1] == '*' &&\n\t\tpattern[spec->length - 2] == '/') {\n\t\tspec->length -= 2;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\t/* leave FULLPATH match on, however */\n\t}\n\n\tif (context) {\n\t\tchar *slash = strrchr(context, '/');\n\t\tsize_t len;\n\t\tif (slash) {\n\t\t\t/* include the slash for easier matching */\n\t\t\tlen = slash - context + 1;\n\t\t\tspec->containing_dir = git_pool_strndup(pool, context, len);\n\t\t\tspec->containing_dir_length = len;\n\t\t}\n\t}\n\n\tspec->pattern = git_pool_strndup(pool, pattern, spec->length);\n\n\tif (!spec->pattern) {\n\t\t*base = git__next_line(pattern);\n\t\treturn -1;\n\t} else {\n\t\t/* strip '\\' that might have be used for internal whitespace */\n\t\tspec->length = git__unescape(spec->pattern);\n\t\t/* TODO: convert remaining '\\' into '/' for POSIX ??? */\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_attr_path__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "508-513",
    "snippet": "void git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&info->full"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}"
  },
  {
    "function_name": "git_attr_path__init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "457-506",
    "snippet": "int git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "info->full.ptr"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "info->path",
            "'/'"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_join_unrooted",
          "args": [
            "&info->full",
            "path",
            "base",
            "&root"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_join_unrooted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "279-307",
          "snippet": "int git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "&info->full",
            "0"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_attr_rule__lookup_assignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "443-455",
    "snippet": "git_attr_assignment *git_attr_rule__lookup_assignment(\n\tgit_attr_rule *rule, const char *name)\n{\n\tsize_t pos;\n\tgit_attr_name key;\n\tkey.name = name;\n\tkey.name_hash = git_attr_file__name_hash(name);\n\n\tif (git_vector_bsearch(&pos, &rule->assigns, &key))\n\t\treturn NULL;\n\n\treturn git_vector_get(&rule->assigns, pos);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void git_attr_rule__clear(git_attr_rule *rule);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&rule->assigns",
            "pos"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_bsearch",
          "args": [
            "&pos",
            "&rule->assigns",
            "&key"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "55-58",
          "snippet": "GIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__name_hash",
          "args": [
            "name"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "284-292",
          "snippet": "uint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nuint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\ngit_attr_assignment *git_attr_rule__lookup_assignment(\n\tgit_attr_rule *rule, const char *name)\n{\n\tsize_t pos;\n\tgit_attr_name key;\n\tkey.name = name;\n\tkey.name_hash = git_attr_file__name_hash(name);\n\n\tif (git_vector_bsearch(&pos, &rule->assigns, &key))\n\t\treturn NULL;\n\n\treturn git_vector_get(&rule->assigns, pos);\n}"
  },
  {
    "function_name": "git_attr_rule__match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "431-441",
    "snippet": "bool git_attr_rule__match(\n\tgit_attr_rule *rule,\n\tgit_attr_path *path)\n{\n\tbool matched = git_attr_fnmatch__match(&rule->match, path);\n\n\tif (rule->match.flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\tmatched = !matched;\n\n\treturn matched;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void git_attr_rule__clear(git_attr_rule *rule);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_fnmatch__match",
          "args": [
            "&rule->match",
            "path"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_fnmatch__match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "355-429",
          "snippet": "bool git_attr_fnmatch__match(\n\tgit_attr_fnmatch *match,\n\tgit_attr_path *path)\n{\n\tconst char *relpath = path->path;\n\tconst char *filename;\n\tint flags = 0;\n\n\t/*\n\t * If the rule was generated in a subdirectory, we must only\n\t * use it for paths inside that directory. We can thus return\n\t * a non-match if the prefixes don't match.\n\t */\n\tif (match->containing_dir) {\n\t\tif (match->flags & GIT_ATTR_FNMATCH_ICASE) {\n\t\t\tif (git__strncasecmp(path->path, match->containing_dir, match->containing_dir_length))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (git__prefixcmp(path->path, match->containing_dir))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trelpath += match->containing_dir_length;\n\t}\n\n\tif (match->flags & GIT_ATTR_FNMATCH_ICASE)\n\t\tflags |= FNM_CASEFOLD;\n\tif (match->flags & GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\tflags |= FNM_LEADING_DIR;\n\n\tif (match->flags & GIT_ATTR_FNMATCH_FULLPATH) {\n\t\tfilename = relpath;\n\t\tflags |= FNM_PATHNAME;\n\t} else {\n\t\tfilename = path->basename;\n\n\t\tif (path->is_dir)\n\t\t\tflags |= FNM_LEADING_DIR;\n\t}\n\n\tif ((match->flags & GIT_ATTR_FNMATCH_DIRECTORY) && !path->is_dir) {\n\t\tbool samename;\n\n\t\t/* for attribute checks or root ignore checks, fail match */\n\t\tif (!(match->flags & GIT_ATTR_FNMATCH_IGNORE) ||\n\t\t\tpath->basename == path->path)\n\t\t\treturn false;\n\n\t\tflags |= FNM_LEADING_DIR;\n\n\t\t/* fail match if this is a file with same name as ignored folder */\n\t\tsamename = (match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strcasecmp(match->pattern, relpath) :\n\t\t\t!strcmp(match->pattern, relpath);\n\n\t\tif (samename)\n\t\t\treturn false;\n\n\t\treturn (p_fnmatch(match->pattern, relpath, flags) != FNM_NOMATCH);\n\t}\n\n\t/* if path is a directory prefix of a negated pattern, then match */\n\tif ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) && path->is_dir) {\n\t\tsize_t pathlen = strlen(relpath);\n\t\tbool prefixed = (pathlen <= match->length) &&\n\t\t\t((match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strncasecmp(match->pattern, relpath, pathlen) :\n\t\t\t!strncmp(match->pattern, relpath, pathlen));\n\n\t\tif (prefixed && git_path_at_end_of_segment(&match->pattern[pathlen]))\n\t\t\treturn true;\n\t}\n\n\treturn (p_fnmatch(match->pattern, filename, flags) != FNM_NOMATCH);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);",
            "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nbool git_attr_fnmatch__match(\n\tgit_attr_fnmatch *match,\n\tgit_attr_path *path)\n{\n\tconst char *relpath = path->path;\n\tconst char *filename;\n\tint flags = 0;\n\n\t/*\n\t * If the rule was generated in a subdirectory, we must only\n\t * use it for paths inside that directory. We can thus return\n\t * a non-match if the prefixes don't match.\n\t */\n\tif (match->containing_dir) {\n\t\tif (match->flags & GIT_ATTR_FNMATCH_ICASE) {\n\t\t\tif (git__strncasecmp(path->path, match->containing_dir, match->containing_dir_length))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (git__prefixcmp(path->path, match->containing_dir))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trelpath += match->containing_dir_length;\n\t}\n\n\tif (match->flags & GIT_ATTR_FNMATCH_ICASE)\n\t\tflags |= FNM_CASEFOLD;\n\tif (match->flags & GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\tflags |= FNM_LEADING_DIR;\n\n\tif (match->flags & GIT_ATTR_FNMATCH_FULLPATH) {\n\t\tfilename = relpath;\n\t\tflags |= FNM_PATHNAME;\n\t} else {\n\t\tfilename = path->basename;\n\n\t\tif (path->is_dir)\n\t\t\tflags |= FNM_LEADING_DIR;\n\t}\n\n\tif ((match->flags & GIT_ATTR_FNMATCH_DIRECTORY) && !path->is_dir) {\n\t\tbool samename;\n\n\t\t/* for attribute checks or root ignore checks, fail match */\n\t\tif (!(match->flags & GIT_ATTR_FNMATCH_IGNORE) ||\n\t\t\tpath->basename == path->path)\n\t\t\treturn false;\n\n\t\tflags |= FNM_LEADING_DIR;\n\n\t\t/* fail match if this is a file with same name as ignored folder */\n\t\tsamename = (match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strcasecmp(match->pattern, relpath) :\n\t\t\t!strcmp(match->pattern, relpath);\n\n\t\tif (samename)\n\t\t\treturn false;\n\n\t\treturn (p_fnmatch(match->pattern, relpath, flags) != FNM_NOMATCH);\n\t}\n\n\t/* if path is a directory prefix of a negated pattern, then match */\n\tif ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) && path->is_dir) {\n\t\tsize_t pathlen = strlen(relpath);\n\t\tbool prefixed = (pathlen <= match->length) &&\n\t\t\t((match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strncasecmp(match->pattern, relpath, pathlen) :\n\t\t\t!strncmp(match->pattern, relpath, pathlen));\n\n\t\tif (prefixed && git_path_at_end_of_segment(&match->pattern[pathlen]))\n\t\t\treturn true;\n\t}\n\n\treturn (p_fnmatch(match->pattern, filename, flags) != FNM_NOMATCH);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nbool git_attr_rule__match(\n\tgit_attr_rule *rule,\n\tgit_attr_path *path)\n{\n\tbool matched = git_attr_fnmatch__match(&rule->match, path);\n\n\tif (rule->match.flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\tmatched = !matched;\n\n\treturn matched;\n}"
  },
  {
    "function_name": "git_attr_fnmatch__match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "355-429",
    "snippet": "bool git_attr_fnmatch__match(\n\tgit_attr_fnmatch *match,\n\tgit_attr_path *path)\n{\n\tconst char *relpath = path->path;\n\tconst char *filename;\n\tint flags = 0;\n\n\t/*\n\t * If the rule was generated in a subdirectory, we must only\n\t * use it for paths inside that directory. We can thus return\n\t * a non-match if the prefixes don't match.\n\t */\n\tif (match->containing_dir) {\n\t\tif (match->flags & GIT_ATTR_FNMATCH_ICASE) {\n\t\t\tif (git__strncasecmp(path->path, match->containing_dir, match->containing_dir_length))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (git__prefixcmp(path->path, match->containing_dir))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trelpath += match->containing_dir_length;\n\t}\n\n\tif (match->flags & GIT_ATTR_FNMATCH_ICASE)\n\t\tflags |= FNM_CASEFOLD;\n\tif (match->flags & GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\tflags |= FNM_LEADING_DIR;\n\n\tif (match->flags & GIT_ATTR_FNMATCH_FULLPATH) {\n\t\tfilename = relpath;\n\t\tflags |= FNM_PATHNAME;\n\t} else {\n\t\tfilename = path->basename;\n\n\t\tif (path->is_dir)\n\t\t\tflags |= FNM_LEADING_DIR;\n\t}\n\n\tif ((match->flags & GIT_ATTR_FNMATCH_DIRECTORY) && !path->is_dir) {\n\t\tbool samename;\n\n\t\t/* for attribute checks or root ignore checks, fail match */\n\t\tif (!(match->flags & GIT_ATTR_FNMATCH_IGNORE) ||\n\t\t\tpath->basename == path->path)\n\t\t\treturn false;\n\n\t\tflags |= FNM_LEADING_DIR;\n\n\t\t/* fail match if this is a file with same name as ignored folder */\n\t\tsamename = (match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strcasecmp(match->pattern, relpath) :\n\t\t\t!strcmp(match->pattern, relpath);\n\n\t\tif (samename)\n\t\t\treturn false;\n\n\t\treturn (p_fnmatch(match->pattern, relpath, flags) != FNM_NOMATCH);\n\t}\n\n\t/* if path is a directory prefix of a negated pattern, then match */\n\tif ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) && path->is_dir) {\n\t\tsize_t pathlen = strlen(relpath);\n\t\tbool prefixed = (pathlen <= match->length) &&\n\t\t\t((match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strncasecmp(match->pattern, relpath, pathlen) :\n\t\t\t!strncmp(match->pattern, relpath, pathlen));\n\n\t\tif (prefixed && git_path_at_end_of_segment(&match->pattern[pathlen]))\n\t\t\treturn true;\n\t}\n\n\treturn (p_fnmatch(match->pattern, filename, flags) != FNM_NOMATCH);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void git_attr_rule__clear(git_attr_rule *rule);",
      "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_fnmatch",
          "args": [
            "match->pattern",
            "filename",
            "flags"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "230-234",
          "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_at_end_of_segment",
          "args": [
            "&match->pattern[pathlen]"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_at_end_of_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "134-137",
          "snippet": "GIT_INLINE(int) git_path_at_end_of_segment(const char *p)\n{\n\treturn !*p || *p == '/';\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_path_at_end_of_segment(const char *p)\n{\n\treturn !*p || *p == '/';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "match->pattern",
            "relpath",
            "pathlen"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "match->pattern",
            "relpath",
            "pathlen"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncasecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "214-225",
          "snippet": "int git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "relpath"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "match->pattern",
            "relpath"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "match->pattern",
            "relpath"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "path->path",
            "match->containing_dir"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nbool git_attr_fnmatch__match(\n\tgit_attr_fnmatch *match,\n\tgit_attr_path *path)\n{\n\tconst char *relpath = path->path;\n\tconst char *filename;\n\tint flags = 0;\n\n\t/*\n\t * If the rule was generated in a subdirectory, we must only\n\t * use it for paths inside that directory. We can thus return\n\t * a non-match if the prefixes don't match.\n\t */\n\tif (match->containing_dir) {\n\t\tif (match->flags & GIT_ATTR_FNMATCH_ICASE) {\n\t\t\tif (git__strncasecmp(path->path, match->containing_dir, match->containing_dir_length))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (git__prefixcmp(path->path, match->containing_dir))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trelpath += match->containing_dir_length;\n\t}\n\n\tif (match->flags & GIT_ATTR_FNMATCH_ICASE)\n\t\tflags |= FNM_CASEFOLD;\n\tif (match->flags & GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\tflags |= FNM_LEADING_DIR;\n\n\tif (match->flags & GIT_ATTR_FNMATCH_FULLPATH) {\n\t\tfilename = relpath;\n\t\tflags |= FNM_PATHNAME;\n\t} else {\n\t\tfilename = path->basename;\n\n\t\tif (path->is_dir)\n\t\t\tflags |= FNM_LEADING_DIR;\n\t}\n\n\tif ((match->flags & GIT_ATTR_FNMATCH_DIRECTORY) && !path->is_dir) {\n\t\tbool samename;\n\n\t\t/* for attribute checks or root ignore checks, fail match */\n\t\tif (!(match->flags & GIT_ATTR_FNMATCH_IGNORE) ||\n\t\t\tpath->basename == path->path)\n\t\t\treturn false;\n\n\t\tflags |= FNM_LEADING_DIR;\n\n\t\t/* fail match if this is a file with same name as ignored folder */\n\t\tsamename = (match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strcasecmp(match->pattern, relpath) :\n\t\t\t!strcmp(match->pattern, relpath);\n\n\t\tif (samename)\n\t\t\treturn false;\n\n\t\treturn (p_fnmatch(match->pattern, relpath, flags) != FNM_NOMATCH);\n\t}\n\n\t/* if path is a directory prefix of a negated pattern, then match */\n\tif ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) && path->is_dir) {\n\t\tsize_t pathlen = strlen(relpath);\n\t\tbool prefixed = (pathlen <= match->length) &&\n\t\t\t((match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strncasecmp(match->pattern, relpath, pathlen) :\n\t\t\t!strncmp(match->pattern, relpath, pathlen));\n\n\t\tif (prefixed && git_path_at_end_of_segment(&match->pattern[pathlen]))\n\t\t\treturn true;\n\t}\n\n\treturn (p_fnmatch(match->pattern, filename, flags) != FNM_NOMATCH);\n}"
  },
  {
    "function_name": "git_attr_file__load_standalone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "322-353",
    "snippet": "int git_attr_file__load_standalone(git_attr_file **out, const char *path)\n{\n\tint error;\n\tgit_attr_file *file;\n\tgit_buf content = GIT_BUF_INIT;\n\n\terror = git_attr_file__new(&file, NULL, GIT_ATTR_FILE__FROM_FILE);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__alloc_file_entry(\n\t\t&file->entry, NULL, path, &file->pool);\n\tif (error < 0) {\n\t\tgit_attr_file__free(file);\n\t\treturn error;\n\t}\n\t/* because the cache entry is allocated from the file's own pool, we\n\t * don't have to free it - freeing file+pool will free cache entry, too.\n\t */\n\n\tif (!(error = git_futils_readbuffer(&content, path))) {\n\t\terror = git_attr_file__parse_buffer(NULL, file, content.ptr);\n\t\tgit_buf_free(&content);\n\t}\n\n\tif (error < 0)\n\t\tgit_attr_file__free(file);\n\telse\n\t\t*out = file;\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "file"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&content"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__parse_buffer",
          "args": [
            "NULL",
            "file",
            "content.ptr"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__parse_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "227-282",
          "snippet": "int git_attr_file__parse_buffer(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_rule *rule = NULL;\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_ATTR_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\t/* allocate rule if needed */\n\t\tif (!rule && !(rule = git__calloc(1, sizeof(*rule)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\trule->match.flags =\n\t\t\tGIT_ATTR_FNMATCH_ALLOWNEG | GIT_ATTR_FNMATCH_ALLOWMACRO;\n\n\t\t/* parse the next \"pattern attr attr attr\" line */\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\t\t&rule->match, &attrs->pool, context, &scan)) &&\n\t\t\t!(error = git_attr_assignment__parse(\n\t\t\t\trepo, &attrs->pool, &rule->assigns, &scan)))\n\t\t{\n\t\t\tif (rule->match.flags & GIT_ATTR_FNMATCH_MACRO)\n\t\t\t\t/* TODO: warning if macro found in file below repo root */\n\t\t\t\terror = git_attr_cache__insert_macro(repo, rule);\n\t\t\telse\n\t\t\t\terror = git_vector_insert(&attrs->rules, rule);\n\t\t}\n\n\t\t/* if the rule wasn't a pattern, on to the next */\n\t\tif (error < 0) {\n\t\t\tgit_attr_rule__clear(rule); /* reset rule contents */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\trule = NULL; /* vector now \"owns\" the rule */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit_attr_rule__free(rule);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);",
            "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nint git_attr_file__parse_buffer(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_rule *rule = NULL;\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_ATTR_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\t/* allocate rule if needed */\n\t\tif (!rule && !(rule = git__calloc(1, sizeof(*rule)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\trule->match.flags =\n\t\t\tGIT_ATTR_FNMATCH_ALLOWNEG | GIT_ATTR_FNMATCH_ALLOWMACRO;\n\n\t\t/* parse the next \"pattern attr attr attr\" line */\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\t\t&rule->match, &attrs->pool, context, &scan)) &&\n\t\t\t!(error = git_attr_assignment__parse(\n\t\t\t\trepo, &attrs->pool, &rule->assigns, &scan)))\n\t\t{\n\t\t\tif (rule->match.flags & GIT_ATTR_FNMATCH_MACRO)\n\t\t\t\t/* TODO: warning if macro found in file below repo root */\n\t\t\t\terror = git_attr_cache__insert_macro(repo, rule);\n\t\t\telse\n\t\t\t\terror = git_vector_insert(&attrs->rules, rule);\n\t\t}\n\n\t\t/* if the rule wasn't a pattern, on to the next */\n\t\tif (error < 0) {\n\t\t\tgit_attr_rule__clear(rule); /* reset rule contents */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\trule = NULL; /* vector now \"owns\" the rule */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit_attr_rule__free(rule);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "&content",
            "path"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__alloc_file_entry",
          "args": [
            "&file->entry",
            "NULL",
            "path",
            "&file->pool"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_cache__alloc_file_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attrcache.c",
          "lines": "38-71",
          "snippet": "int git_attr_cache__alloc_file_entry(\n\tgit_attr_file_entry **out,\n\tconst char *base,\n\tconst char *path,\n\tgit_pool *pool)\n{\n\tsize_t baselen = 0, pathlen = strlen(path);\n\tsize_t cachesize = sizeof(git_attr_file_entry) + pathlen + 1;\n\tgit_attr_file_entry *ce;\n\n\tif (base != NULL && git_path_root(path) < 0) {\n\t\tbaselen = strlen(base);\n\t\tcachesize += baselen;\n\n\t\tif (baselen && base[baselen - 1] != '/')\n\t\t\tcachesize++;\n\t}\n\n\tce = git_pool_mallocz(pool, (uint32_t)cachesize);\n\tGITERR_CHECK_ALLOC(ce);\n\n\tif (baselen) {\n\t\tmemcpy(ce->fullpath, base, baselen);\n\n\t\tif (base[baselen - 1] != '/')\n\t\t\tce->fullpath[baselen++] = '/';\n\t}\n\tmemcpy(&ce->fullpath[baselen], path, pathlen);\n\n\tce->path = &ce->fullpath[baselen];\n\t*out = ce;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"sysdir.h\"",
            "#include \"config.h\"",
            "#include \"attr_file.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"sysdir.h\"\n#include \"config.h\"\n#include \"attr_file.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_cache__alloc_file_entry(\n\tgit_attr_file_entry **out,\n\tconst char *base,\n\tconst char *path,\n\tgit_pool *pool)\n{\n\tsize_t baselen = 0, pathlen = strlen(path);\n\tsize_t cachesize = sizeof(git_attr_file_entry) + pathlen + 1;\n\tgit_attr_file_entry *ce;\n\n\tif (base != NULL && git_path_root(path) < 0) {\n\t\tbaselen = strlen(base);\n\t\tcachesize += baselen;\n\n\t\tif (baselen && base[baselen - 1] != '/')\n\t\t\tcachesize++;\n\t}\n\n\tce = git_pool_mallocz(pool, (uint32_t)cachesize);\n\tGITERR_CHECK_ALLOC(ce);\n\n\tif (baselen) {\n\t\tmemcpy(ce->fullpath, base, baselen);\n\n\t\tif (base[baselen - 1] != '/')\n\t\t\tce->fullpath[baselen++] = '/';\n\t}\n\tmemcpy(&ce->fullpath[baselen], path, pathlen);\n\n\tce->path = &ce->fullpath[baselen];\n\t*out = ce;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__new",
          "args": [
            "&file",
            "NULL",
            "GIT_ATTR_FILE__FROM_FILE"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "24-44",
          "snippet": "int git_attr_file__new(\n\tgit_attr_file **out,\n\tgit_attr_file_entry *entry,\n\tgit_attr_file_source source)\n{\n\tgit_attr_file *attrs = git__calloc(1, sizeof(git_attr_file));\n\tGITERR_CHECK_ALLOC(attrs);\n\n\tif (git_mutex_init(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgit__free(attrs);\n\t\treturn -1;\n\t}\n\n\tgit_pool_init(&attrs->pool, 1);\n\tGIT_REFCOUNT_INC(attrs);\n\tattrs->entry  = entry;\n\tattrs->source = source;\n\t*out = attrs;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_file__new(\n\tgit_attr_file **out,\n\tgit_attr_file_entry *entry,\n\tgit_attr_file_source source)\n{\n\tgit_attr_file *attrs = git__calloc(1, sizeof(git_attr_file));\n\tGITERR_CHECK_ALLOC(attrs);\n\n\tif (git_mutex_init(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgit__free(attrs);\n\t\treturn -1;\n\t}\n\n\tgit_pool_init(&attrs->pool, 1);\n\tGIT_REFCOUNT_INC(attrs);\n\tattrs->entry  = entry;\n\tattrs->source = source;\n\t*out = attrs;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_file__load_standalone(git_attr_file **out, const char *path)\n{\n\tint error;\n\tgit_attr_file *file;\n\tgit_buf content = GIT_BUF_INIT;\n\n\terror = git_attr_file__new(&file, NULL, GIT_ATTR_FILE__FROM_FILE);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__alloc_file_entry(\n\t\t&file->entry, NULL, path, &file->pool);\n\tif (error < 0) {\n\t\tgit_attr_file__free(file);\n\t\treturn error;\n\t}\n\t/* because the cache entry is allocated from the file's own pool, we\n\t * don't have to free it - freeing file+pool will free cache entry, too.\n\t */\n\n\tif (!(error = git_futils_readbuffer(&content, path))) {\n\t\terror = git_attr_file__parse_buffer(NULL, file, content.ptr);\n\t\tgit_buf_free(&content);\n\t}\n\n\tif (error < 0)\n\t\tgit_attr_file__free(file);\n\telse\n\t\t*out = file;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_attr_file__lookup_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "294-320",
    "snippet": "int git_attr_file__lookup_one(\n\tgit_attr_file *file,\n\tgit_attr_path *path,\n\tconst char *attr,\n\tconst char **value)\n{\n\tsize_t i;\n\tgit_attr_name name;\n\tgit_attr_rule *rule;\n\n\t*value = NULL;\n\n\tname.name = attr;\n\tname.name_hash = git_attr_file__name_hash(attr);\n\n\tgit_attr_file__foreach_matching_rule(file, path, i, rule) {\n\t\tsize_t pos;\n\n\t\tif (!git_vector_bsearch(&pos, &rule->assigns, &name)) {\n\t\t\t*value = ((git_attr_assignment *)\n\t\t\t\t\t  git_vector_get(&rule->assigns, pos))->value;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void git_attr_rule__clear(git_attr_rule *rule);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&rule->assigns",
            "pos"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_bsearch",
          "args": [
            "&pos",
            "&rule->assigns",
            "&name"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "55-58",
          "snippet": "GIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__foreach_matching_rule",
          "args": [
            "file",
            "path",
            "i",
            "rule"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_attr_file__name_hash",
          "args": [
            "attr"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "284-292",
          "snippet": "uint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nuint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nint git_attr_file__lookup_one(\n\tgit_attr_file *file,\n\tgit_attr_path *path,\n\tconst char *attr,\n\tconst char **value)\n{\n\tsize_t i;\n\tgit_attr_name name;\n\tgit_attr_rule *rule;\n\n\t*value = NULL;\n\n\tname.name = attr;\n\tname.name_hash = git_attr_file__name_hash(attr);\n\n\tgit_attr_file__foreach_matching_rule(file, path, i, rule) {\n\t\tsize_t pos;\n\n\t\tif (!git_vector_bsearch(&pos, &rule->assigns, &name)) {\n\t\t\t*value = ((git_attr_assignment *)\n\t\t\t\t\t  git_vector_get(&rule->assigns, pos))->value;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_attr_file__name_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "284-292",
    "snippet": "uint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nuint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}"
  },
  {
    "function_name": "git_attr_file__parse_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "227-282",
    "snippet": "int git_attr_file__parse_buffer(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_rule *rule = NULL;\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_ATTR_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\t/* allocate rule if needed */\n\t\tif (!rule && !(rule = git__calloc(1, sizeof(*rule)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\trule->match.flags =\n\t\t\tGIT_ATTR_FNMATCH_ALLOWNEG | GIT_ATTR_FNMATCH_ALLOWMACRO;\n\n\t\t/* parse the next \"pattern attr attr attr\" line */\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\t\t&rule->match, &attrs->pool, context, &scan)) &&\n\t\t\t!(error = git_attr_assignment__parse(\n\t\t\t\trepo, &attrs->pool, &rule->assigns, &scan)))\n\t\t{\n\t\t\tif (rule->match.flags & GIT_ATTR_FNMATCH_MACRO)\n\t\t\t\t/* TODO: warning if macro found in file below repo root */\n\t\t\t\terror = git_attr_cache__insert_macro(repo, rule);\n\t\t\telse\n\t\t\t\terror = git_vector_insert(&attrs->rules, rule);\n\t\t}\n\n\t\t/* if the rule wasn't a pattern, on to the next */\n\t\tif (error < 0) {\n\t\t\tgit_attr_rule__clear(rule); /* reset rule contents */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\trule = NULL; /* vector now \"owns\" the rule */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit_attr_rule__free(rule);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void git_attr_rule__clear(git_attr_rule *rule);",
      "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_rule__free",
          "args": [
            "rule"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_rule__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "842-846",
          "snippet": "void git_attr_rule__free(git_attr_rule *rule)\n{\n\tgit_attr_rule__clear(rule);\n\tgit__free(rule);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nvoid git_attr_rule__free(git_attr_rule *rule)\n{\n\tgit_attr_rule__clear(rule);\n\tgit__free(rule);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&attrs->lock"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_rule__clear",
          "args": [
            "rule"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_rule__clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "823-840",
          "snippet": "static void git_attr_rule__clear(git_attr_rule *rule)\n{\n\tunsigned int i;\n\tgit_attr_assignment *assign;\n\n\tif (!rule)\n\t\treturn;\n\n\tif (!(rule->match.flags & GIT_ATTR_FNMATCH_IGNORE)) {\n\t\tgit_vector_foreach(&rule->assigns, i, assign)\n\t\t\tGIT_REFCOUNT_DEC(assign, git_attr_assignment__free);\n\t\tgit_vector_free(&rule->assigns);\n\t}\n\n\t/* match.pattern is stored in a git_pool, so no need to free */\n\trule->match.pattern = NULL;\n\trule->match.length = 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);",
            "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nstatic void git_attr_rule__clear(git_attr_rule *rule)\n{\n\tunsigned int i;\n\tgit_attr_assignment *assign;\n\n\tif (!rule)\n\t\treturn;\n\n\tif (!(rule->match.flags & GIT_ATTR_FNMATCH_IGNORE)) {\n\t\tgit_vector_foreach(&rule->assigns, i, assign)\n\t\t\tGIT_REFCOUNT_DEC(assign, git_attr_assignment__free);\n\t\tgit_vector_free(&rule->assigns);\n\t}\n\n\t/* match.pattern is stored in a git_pool, so no need to free */\n\trule->match.pattern = NULL;\n\trule->match.length = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&attrs->rules",
            "rule"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__insert_macro",
          "args": [
            "repo",
            "rule"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_cache__insert_macro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attrcache.c",
          "lines": "422-441",
          "snippet": "int git_attr_cache__insert_macro(git_repository *repo, git_attr_rule *macro)\n{\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_strmap *macros = cache->macros;\n\tint error;\n\n\t/* TODO: generate warning log if (macro->assigns.length == 0) */\n\tif (macro->assigns.length == 0)\n\t\treturn 0;\n\n\tif (git_mutex_lock(&cache->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to get attr cache lock\");\n\t\terror = -1;\n\t} else {\n\t\tgit_strmap_insert(macros, macro->match.pattern, macro, error);\n\t\tgit_mutex_unlock(&cache->lock);\n\t}\n\n\treturn (error < 0) ? -1 : 0;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"sysdir.h\"",
            "#include \"config.h\"",
            "#include \"attr_file.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"sysdir.h\"\n#include \"config.h\"\n#include \"attr_file.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_cache__insert_macro(git_repository *repo, git_attr_rule *macro)\n{\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_strmap *macros = cache->macros;\n\tint error;\n\n\t/* TODO: generate warning log if (macro->assigns.length == 0) */\n\tif (macro->assigns.length == 0)\n\t\treturn 0;\n\n\tif (git_mutex_lock(&cache->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to get attr cache lock\");\n\t\terror = -1;\n\t} else {\n\t\tgit_strmap_insert(macros, macro->match.pattern, macro, error);\n\t\tgit_mutex_unlock(&cache->lock);\n\t}\n\n\treturn (error < 0) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_assignment__parse",
          "args": [
            "repo",
            "&attrs->pool",
            "&rule->assigns",
            "&scan"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_assignment__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "714-821",
          "snippet": "int git_attr_assignment__parse(\n\tgit_repository *repo,\n\tgit_pool *pool,\n\tgit_vector *assigns,\n\tconst char **base)\n{\n\tint error;\n\tconst char *scan = *base;\n\tgit_attr_assignment *assign = NULL;\n\n\tassert(assigns && !assigns->length);\n\n\tgit_vector_set_cmp(assigns, sort_by_hash_and_name);\n\n\twhile (*scan && *scan != '\\n') {\n\t\tconst char *name_start, *value_start;\n\n\t\t/* skip leading blanks */\n\t\twhile (git__isspace(*scan) && *scan != '\\n') scan++;\n\n\t\t/* allocate assign if needed */\n\t\tif (!assign) {\n\t\t\tassign = git__calloc(1, sizeof(git_attr_assignment));\n\t\t\tGITERR_CHECK_ALLOC(assign);\n\t\t\tGIT_REFCOUNT_INC(assign);\n\t\t}\n\n\t\tassign->name_hash = 5381;\n\t\tassign->value = git_attr__true;\n\n\t\t/* look for magic name prefixes */\n\t\tif (*scan == '-') {\n\t\t\tassign->value = git_attr__false;\n\t\t\tscan++;\n\t\t} else if (*scan == '!') {\n\t\t\tassign->value = git_attr__unset; /* explicit unspecified state */\n\t\t\tscan++;\n\t\t} else if (*scan == '#') /* comment rest of line */\n\t\t\tbreak;\n\n\t\t/* find the name */\n\t\tname_start = scan;\n\t\twhile (*scan && !git__isspace(*scan) && *scan != '=') {\n\t\t\tassign->name_hash =\n\t\t\t\t((assign->name_hash << 5) + assign->name_hash) + *scan;\n\t\t\tscan++;\n\t\t}\n\t\tif (scan == name_start) {\n\t\t\t/* must have found lone prefix (\" - \") or leading = (\"=foo\")\n\t\t\t * or end of buffer -- advance until whitespace and continue\n\t\t\t */\n\t\t\twhile (*scan && !git__isspace(*scan)) scan++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* allocate permanent storage for name */\n\t\tassign->name = git_pool_strndup(pool, name_start, scan - name_start);\n\t\tGITERR_CHECK_ALLOC(assign->name);\n\n\t\t/* if there is an equals sign, find the value */\n\t\tif (*scan == '=') {\n\t\t\tfor (value_start = ++scan; *scan && !git__isspace(*scan); ++scan);\n\n\t\t\t/* if we found a value, allocate permanent storage for it */\n\t\t\tif (scan > value_start) {\n\t\t\t\tassign->value = git_pool_strndup(pool, value_start, scan - value_start);\n\t\t\t\tGITERR_CHECK_ALLOC(assign->value);\n\t\t\t}\n\t\t}\n\n\t\t/* expand macros (if given a repo with a macro cache) */\n\t\tif (repo != NULL && assign->value == git_attr__true) {\n\t\t\tgit_attr_rule *macro =\n\t\t\t\tgit_attr_cache__lookup_macro(repo, assign->name);\n\n\t\t\tif (macro != NULL) {\n\t\t\t\tunsigned int i;\n\t\t\t\tgit_attr_assignment *massign;\n\n\t\t\t\tgit_vector_foreach(&macro->assigns, i, massign) {\n\t\t\t\t\tGIT_REFCOUNT_INC(massign);\n\n\t\t\t\t\terror = git_vector_insert_sorted(\n\t\t\t\t\t\tassigns, massign, &merge_assignments);\n\t\t\t\t\tif (error < 0 && error != GIT_EEXISTS) {\n\t\t\t\t\t\tgit_attr_assignment__free(assign);\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* insert allocated assign into vector */\n\t\terror = git_vector_insert_sorted(assigns, assign, &merge_assignments);\n\t\tif (error < 0 && error != GIT_EEXISTS)\n\t\t\treturn error;\n\n\t\t/* clear assign since it is now \"owned\" by the vector */\n\t\tassign = NULL;\n\t}\n\n\tif (assign != NULL)\n\t\tgit_attr_assignment__free(assign);\n\n\t*base = git__next_line(scan);\n\n\treturn (assigns->length == 0) ? GIT_ENOTFOUND : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_assignment__parse(\n\tgit_repository *repo,\n\tgit_pool *pool,\n\tgit_vector *assigns,\n\tconst char **base)\n{\n\tint error;\n\tconst char *scan = *base;\n\tgit_attr_assignment *assign = NULL;\n\n\tassert(assigns && !assigns->length);\n\n\tgit_vector_set_cmp(assigns, sort_by_hash_and_name);\n\n\twhile (*scan && *scan != '\\n') {\n\t\tconst char *name_start, *value_start;\n\n\t\t/* skip leading blanks */\n\t\twhile (git__isspace(*scan) && *scan != '\\n') scan++;\n\n\t\t/* allocate assign if needed */\n\t\tif (!assign) {\n\t\t\tassign = git__calloc(1, sizeof(git_attr_assignment));\n\t\t\tGITERR_CHECK_ALLOC(assign);\n\t\t\tGIT_REFCOUNT_INC(assign);\n\t\t}\n\n\t\tassign->name_hash = 5381;\n\t\tassign->value = git_attr__true;\n\n\t\t/* look for magic name prefixes */\n\t\tif (*scan == '-') {\n\t\t\tassign->value = git_attr__false;\n\t\t\tscan++;\n\t\t} else if (*scan == '!') {\n\t\t\tassign->value = git_attr__unset; /* explicit unspecified state */\n\t\t\tscan++;\n\t\t} else if (*scan == '#') /* comment rest of line */\n\t\t\tbreak;\n\n\t\t/* find the name */\n\t\tname_start = scan;\n\t\twhile (*scan && !git__isspace(*scan) && *scan != '=') {\n\t\t\tassign->name_hash =\n\t\t\t\t((assign->name_hash << 5) + assign->name_hash) + *scan;\n\t\t\tscan++;\n\t\t}\n\t\tif (scan == name_start) {\n\t\t\t/* must have found lone prefix (\" - \") or leading = (\"=foo\")\n\t\t\t * or end of buffer -- advance until whitespace and continue\n\t\t\t */\n\t\t\twhile (*scan && !git__isspace(*scan)) scan++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* allocate permanent storage for name */\n\t\tassign->name = git_pool_strndup(pool, name_start, scan - name_start);\n\t\tGITERR_CHECK_ALLOC(assign->name);\n\n\t\t/* if there is an equals sign, find the value */\n\t\tif (*scan == '=') {\n\t\t\tfor (value_start = ++scan; *scan && !git__isspace(*scan); ++scan);\n\n\t\t\t/* if we found a value, allocate permanent storage for it */\n\t\t\tif (scan > value_start) {\n\t\t\t\tassign->value = git_pool_strndup(pool, value_start, scan - value_start);\n\t\t\t\tGITERR_CHECK_ALLOC(assign->value);\n\t\t\t}\n\t\t}\n\n\t\t/* expand macros (if given a repo with a macro cache) */\n\t\tif (repo != NULL && assign->value == git_attr__true) {\n\t\t\tgit_attr_rule *macro =\n\t\t\t\tgit_attr_cache__lookup_macro(repo, assign->name);\n\n\t\t\tif (macro != NULL) {\n\t\t\t\tunsigned int i;\n\t\t\t\tgit_attr_assignment *massign;\n\n\t\t\t\tgit_vector_foreach(&macro->assigns, i, massign) {\n\t\t\t\t\tGIT_REFCOUNT_INC(massign);\n\n\t\t\t\t\terror = git_vector_insert_sorted(\n\t\t\t\t\t\tassigns, massign, &merge_assignments);\n\t\t\t\t\tif (error < 0 && error != GIT_EEXISTS) {\n\t\t\t\t\t\tgit_attr_assignment__free(assign);\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* insert allocated assign into vector */\n\t\terror = git_vector_insert_sorted(assigns, assign, &merge_assignments);\n\t\tif (error < 0 && error != GIT_EEXISTS)\n\t\t\treturn error;\n\n\t\t/* clear assign since it is now \"owned\" by the vector */\n\t\tassign = NULL;\n\t}\n\n\tif (assign != NULL)\n\t\tgit_attr_assignment__free(assign);\n\n\t*base = git__next_line(scan);\n\n\treturn (assigns->length == 0) ? GIT_ENOTFOUND : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_fnmatch__parse",
          "args": [
            "&rule->match",
            "&attrs->pool",
            "context",
            "&scan"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_fnmatch__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "552-663",
          "snippet": "int git_attr_fnmatch__parse(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *context,\n\tconst char **base)\n{\n\tconst char *pattern, *scan;\n\tint slash_count, allow_space;\n\n\tassert(spec && base && *base);\n\n\tif (parse_optimized_patterns(spec, pool, *base))\n\t\treturn 0;\n\n\tspec->flags = (spec->flags & GIT_ATTR_FNMATCH__INCOMING);\n\tallow_space = ((spec->flags & GIT_ATTR_FNMATCH_ALLOWSPACE) != 0);\n\n\tpattern = *base;\n\n\twhile (git__isspace(*pattern)) pattern++;\n\tif (!*pattern || *pattern == '#') {\n\t\t*base = git__next_line(pattern);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (*pattern == '[' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWMACRO) != 0) {\n\t\tif (strncmp(pattern, \"[attr]\", 6) == 0) {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_MACRO;\n\t\t\tpattern += 6;\n\t\t}\n\t\t/* else a character range like [a-e]* which is accepted */\n\t}\n\n\tif (*pattern == '!' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWNEG) != 0) {\n\t\tspec->flags = spec->flags |\n\t\t\tGIT_ATTR_FNMATCH_NEGATIVE | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\tpattern++;\n\t}\n\n\tslash_count = 0;\n\tfor (scan = pattern; *scan != '\\0'; ++scan) {\n\t\t/* scan until (non-escaped) white space */\n\t\tif (git__isspace(*scan) && *(scan - 1) != '\\\\') {\n\t\t\tif (!allow_space || (*scan != ' ' && *scan != '\\t' && *scan != '\\r'))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (*scan == '/') {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_FULLPATH;\n\t\t\tslash_count++;\n\t\t\tif (pattern == scan)\n\t\t\t\tpattern++;\n\t\t}\n\t\t/* remember if we see an unescaped wildcard in pattern */\n\t\telse if (git__iswildcard(*scan) &&\n\t\t\t(scan == pattern || (*(scan - 1) != '\\\\')))\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_HASWILD;\n\t}\n\n\t*base = scan;\n\n\tif ((spec->length = scan - pattern) == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/*\n\t * Remove one trailing \\r in case this is a CRLF delimited\n\t * file, in the case of Icon\\r\\r\\n, we still leave the first\n\t * \\r there to match against.\n\t */\n\tif (pattern[spec->length - 1] == '\\r')\n\t\tif (--spec->length == 0)\n\t\t\treturn GIT_ENOTFOUND;\n\n\tif (pattern[spec->length - 1] == '/') {\n\t\tspec->length--;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_DIRECTORY;\n\t\tif (--slash_count <= 0)\n\t\t\tspec->flags = spec->flags & ~GIT_ATTR_FNMATCH_FULLPATH;\n\t}\n\tif ((spec->flags & GIT_ATTR_FNMATCH_NOLEADINGDIR) == 0 &&\n\t\tspec->length >= 2 &&\n\t\tpattern[spec->length - 1] == '*' &&\n\t\tpattern[spec->length - 2] == '/') {\n\t\tspec->length -= 2;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\t/* leave FULLPATH match on, however */\n\t}\n\n\tif (context) {\n\t\tchar *slash = strrchr(context, '/');\n\t\tsize_t len;\n\t\tif (slash) {\n\t\t\t/* include the slash for easier matching */\n\t\t\tlen = slash - context + 1;\n\t\t\tspec->containing_dir = git_pool_strndup(pool, context, len);\n\t\t\tspec->containing_dir_length = len;\n\t\t}\n\t}\n\n\tspec->pattern = git_pool_strndup(pool, pattern, spec->length);\n\n\tif (!spec->pattern) {\n\t\t*base = git__next_line(pattern);\n\t\treturn -1;\n\t} else {\n\t\t/* strip '\\' that might have be used for internal whitespace */\n\t\tspec->length = git__unescape(spec->pattern);\n\t\t/* TODO: convert remaining '\\' into '/' for POSIX ??? */\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nint git_attr_fnmatch__parse(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *context,\n\tconst char **base)\n{\n\tconst char *pattern, *scan;\n\tint slash_count, allow_space;\n\n\tassert(spec && base && *base);\n\n\tif (parse_optimized_patterns(spec, pool, *base))\n\t\treturn 0;\n\n\tspec->flags = (spec->flags & GIT_ATTR_FNMATCH__INCOMING);\n\tallow_space = ((spec->flags & GIT_ATTR_FNMATCH_ALLOWSPACE) != 0);\n\n\tpattern = *base;\n\n\twhile (git__isspace(*pattern)) pattern++;\n\tif (!*pattern || *pattern == '#') {\n\t\t*base = git__next_line(pattern);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (*pattern == '[' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWMACRO) != 0) {\n\t\tif (strncmp(pattern, \"[attr]\", 6) == 0) {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_MACRO;\n\t\t\tpattern += 6;\n\t\t}\n\t\t/* else a character range like [a-e]* which is accepted */\n\t}\n\n\tif (*pattern == '!' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWNEG) != 0) {\n\t\tspec->flags = spec->flags |\n\t\t\tGIT_ATTR_FNMATCH_NEGATIVE | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\tpattern++;\n\t}\n\n\tslash_count = 0;\n\tfor (scan = pattern; *scan != '\\0'; ++scan) {\n\t\t/* scan until (non-escaped) white space */\n\t\tif (git__isspace(*scan) && *(scan - 1) != '\\\\') {\n\t\t\tif (!allow_space || (*scan != ' ' && *scan != '\\t' && *scan != '\\r'))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (*scan == '/') {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_FULLPATH;\n\t\t\tslash_count++;\n\t\t\tif (pattern == scan)\n\t\t\t\tpattern++;\n\t\t}\n\t\t/* remember if we see an unescaped wildcard in pattern */\n\t\telse if (git__iswildcard(*scan) &&\n\t\t\t(scan == pattern || (*(scan - 1) != '\\\\')))\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_HASWILD;\n\t}\n\n\t*base = scan;\n\n\tif ((spec->length = scan - pattern) == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/*\n\t * Remove one trailing \\r in case this is a CRLF delimited\n\t * file, in the case of Icon\\r\\r\\n, we still leave the first\n\t * \\r there to match against.\n\t */\n\tif (pattern[spec->length - 1] == '\\r')\n\t\tif (--spec->length == 0)\n\t\t\treturn GIT_ENOTFOUND;\n\n\tif (pattern[spec->length - 1] == '/') {\n\t\tspec->length--;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_DIRECTORY;\n\t\tif (--slash_count <= 0)\n\t\t\tspec->flags = spec->flags & ~GIT_ATTR_FNMATCH_FULLPATH;\n\t}\n\tif ((spec->flags & GIT_ATTR_FNMATCH_NOLEADINGDIR) == 0 &&\n\t\tspec->length >= 2 &&\n\t\tpattern[spec->length - 1] == '*' &&\n\t\tpattern[spec->length - 2] == '/') {\n\t\tspec->length -= 2;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\t/* leave FULLPATH match on, however */\n\t}\n\n\tif (context) {\n\t\tchar *slash = strrchr(context, '/');\n\t\tsize_t len;\n\t\tif (slash) {\n\t\t\t/* include the slash for easier matching */\n\t\t\tlen = slash - context + 1;\n\t\t\tspec->containing_dir = git_pool_strndup(pool, context, len);\n\t\t\tspec->containing_dir_length = len;\n\t\t}\n\t}\n\n\tspec->pattern = git_pool_strndup(pool, pattern, spec->length);\n\n\tif (!spec->pattern) {\n\t\t*base = git__next_line(pattern);\n\t\treturn -1;\n\t} else {\n\t\t/* strip '\\' that might have be used for internal whitespace */\n\t\tspec->length = git__unescape(spec->pattern);\n\t\t/* TODO: convert remaining '\\' into '/' for POSIX ??? */\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(*rule)"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to lock attribute file\""
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&attrs->lock"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "git__suffixcmp",
          "args": [
            "attrs->entry->path",
            "\"/\" GIT_ATTR_FILE"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "git__suffixcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "272-279",
          "snippet": "int git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "attrs->entry->path"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nint git_attr_file__parse_buffer(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_rule *rule = NULL;\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_ATTR_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\t/* allocate rule if needed */\n\t\tif (!rule && !(rule = git__calloc(1, sizeof(*rule)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\trule->match.flags =\n\t\t\tGIT_ATTR_FNMATCH_ALLOWNEG | GIT_ATTR_FNMATCH_ALLOWMACRO;\n\n\t\t/* parse the next \"pattern attr attr attr\" line */\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\t\t&rule->match, &attrs->pool, context, &scan)) &&\n\t\t\t!(error = git_attr_assignment__parse(\n\t\t\t\trepo, &attrs->pool, &rule->assigns, &scan)))\n\t\t{\n\t\t\tif (rule->match.flags & GIT_ATTR_FNMATCH_MACRO)\n\t\t\t\t/* TODO: warning if macro found in file below repo root */\n\t\t\t\terror = git_attr_cache__insert_macro(repo, rule);\n\t\t\telse\n\t\t\t\terror = git_vector_insert(&attrs->rules, rule);\n\t\t}\n\n\t\t/* if the rule wasn't a pattern, on to the next */\n\t\tif (error < 0) {\n\t\t\tgit_attr_rule__clear(rule); /* reset rule contents */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\trule = NULL; /* vector now \"owns\" the rule */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit_attr_rule__free(rule);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_attr_file__out_of_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "179-218",
    "snippet": "int git_attr_file__out_of_date(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file *file)\n{\n\tif (!file)\n\t\treturn 1;\n\n\t/* we are never out of date if we just created this data in the same\n\t * attr_session; otherwise, nonexistent files must be invalidated\n\t */\n\tif (attr_session && attr_session->key == file->session_key)\n\t\treturn 0;\n\telse if (file->nonexistent)\n\t\treturn 1;\n\n\tswitch (file->source) {\n\tcase GIT_ATTR_FILE__IN_MEMORY:\n\t\treturn 0;\n\n\tcase GIT_ATTR_FILE__FROM_FILE:\n\t\treturn git_futils_filestamp_check(\n\t\t\t&file->cache_data.stamp, file->entry->fullpath);\n\n\tcase GIT_ATTR_FILE__FROM_INDEX: {\n\t\tint error;\n\t\tgit_oid id;\n\n\t\tif ((error = attr_file_oid_from_index(\n\t\t\t\t&id, repo, file->entry->path)) < 0)\n\t\t\treturn error;\n\n\t\treturn (git_oid__cmp(&file->cache_data.oid, &id) != 0);\n\t}\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"Invalid file type %d\", file->source);\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Invalid file type %d\"",
            "file->source"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&file->cache_data.oid",
            "&id"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attr_file_oid_from_index",
          "args": [
            "&id",
            "repo",
            "file->entry->path"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "attr_file_oid_from_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "73-90",
          "snippet": "static int attr_file_oid_from_index(\n\tgit_oid *oid, git_repository *repo, const char *path)\n{\n\tint error;\n\tgit_index *idx;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = git_index__find_pos(&pos, idx, path, 0, 0)) < 0)\n\t\treturn error;\n\n\tif (!(entry = git_index_get_byindex(idx, pos)))\n\t\treturn GIT_ENOTFOUND;\n\n\t*oid = entry->id;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int attr_file_oid_from_index(\n\tgit_oid *oid, git_repository *repo, const char *path)\n{\n\tint error;\n\tgit_index *idx;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = git_index__find_pos(&pos, idx, path, 0, 0)) < 0)\n\t\treturn error;\n\n\tif (!(entry = git_index_get_byindex(idx, pos)))\n\t\treturn GIT_ENOTFOUND;\n\n\t*oid = entry->id;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_filestamp_check",
          "args": [
            "&file->cache_data.stamp",
            "file->entry->fullpath"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filestamp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "1033-1061",
          "snippet": "int git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_file__out_of_date(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file *file)\n{\n\tif (!file)\n\t\treturn 1;\n\n\t/* we are never out of date if we just created this data in the same\n\t * attr_session; otherwise, nonexistent files must be invalidated\n\t */\n\tif (attr_session && attr_session->key == file->session_key)\n\t\treturn 0;\n\telse if (file->nonexistent)\n\t\treturn 1;\n\n\tswitch (file->source) {\n\tcase GIT_ATTR_FILE__IN_MEMORY:\n\t\treturn 0;\n\n\tcase GIT_ATTR_FILE__FROM_FILE:\n\t\treturn git_futils_filestamp_check(\n\t\t\t&file->cache_data.stamp, file->entry->fullpath);\n\n\tcase GIT_ATTR_FILE__FROM_INDEX: {\n\t\tint error;\n\t\tgit_oid id;\n\n\t\tif ((error = attr_file_oid_from_index(\n\t\t\t\t&id, repo, file->entry->path)) < 0)\n\t\t\treturn error;\n\n\t\treturn (git_oid__cmp(&file->cache_data.oid, &id) != 0);\n\t}\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"Invalid file type %d\", file->source);\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "git_attr_file__load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "92-177",
    "snippet": "int git_attr_file__load(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_entry *entry,\n\tgit_attr_file_source source,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_blob *blob = NULL;\n\tgit_buf content = GIT_BUF_INIT;\n\tgit_attr_file *file;\n\tstruct stat st;\n\tbool nonexistent = false;\n\n\t*out = NULL;\n\n\tswitch (source) {\n\tcase GIT_ATTR_FILE__IN_MEMORY:\n\t\t/* in-memory attribute file doesn't need data */\n\t\tbreak;\n\tcase GIT_ATTR_FILE__FROM_INDEX: {\n\t\tgit_oid id;\n\n\t\tif ((error = attr_file_oid_from_index(&id, repo, entry->path)) < 0 ||\n\t\t\t(error = git_blob_lookup(&blob, repo, &id)) < 0)\n\t\t\treturn error;\n\n\t\t/* Do not assume that data straight from the ODB is NULL-terminated;\n\t\t * copy the contents of a file to a buffer to work on */\n\t\tgit_buf_put(&content, git_blob_rawcontent(blob), git_blob_rawsize(blob));\n\t\tbreak;\n\t}\n\tcase GIT_ATTR_FILE__FROM_FILE: {\n\t\tint fd = -1;\n\n\t\t/* For open or read errors, pretend that we got ENOTFOUND. */\n\t\t/* TODO: issue warning when warning API is available */\n\n\t\tif (p_stat(entry->fullpath, &st) < 0 ||\n\t\t\tS_ISDIR(st.st_mode) ||\n\t\t\t(fd = git_futils_open_ro(entry->fullpath)) < 0 ||\n\t\t\t(error = git_futils_readbuffer_fd(&content, fd, (size_t)st.st_size)) < 0)\n\t\t\tnonexistent = true;\n\n\t\tif (fd >= 0)\n\t\t\tp_close(fd);\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"Unknown file source %d\", source);\n\t\treturn -1;\n\t}\n\n\tif ((error = git_attr_file__new(&file, entry, source)) < 0)\n\t\tgoto cleanup;\n\n\t/* store the key of the attr_reader; don't bother with cache\n\t * invalidation during the same attr reader session.\n\t */\n\tif (attr_session)\n\t\tfile->session_key = attr_session->key;\n\n\tif (parser && (error = parser(repo, file, git_buf_cstr(&content))) < 0) {\n\t\tgit_attr_file__free(file);\n\t\tgoto cleanup;\n\t}\n\n\t/* write cache breakers */\n\tif (nonexistent)\n\t\tfile->nonexistent = 1;\n\telse if (source == GIT_ATTR_FILE__FROM_INDEX)\n\t\tgit_oid_cpy(&file->cache_data.oid, git_blob_id(blob));\n\telse if (source == GIT_ATTR_FILE__FROM_FILE)\n\t\tgit_futils_filestamp_set_from_stat(&file->cache_data.stamp, &st);\n\t/* else always cacheable */\n\n\t*out = file;\n\ncleanup:\n\tgit_blob_free(blob);\n\tgit_buf_free(&content);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&content"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_free",
          "args": [
            "blob"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "116-119",
          "snippet": "void git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_filestamp_set_from_stat",
          "args": [
            "&file->cache_data.stamp",
            "&st"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filestamp_set_from_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "1075-1090",
          "snippet": "void git_futils_filestamp_set_from_stat(\n\tgit_futils_filestamp *stamp, struct stat *st)\n{\n\tif (st) {\n\t\tstamp->mtime.tv_sec = st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec = st->st_mtime_nsec;\n#else\n\t\tstamp->mtime.tv_nsec = 0;\n#endif\n\t\tstamp->size  = (git_off_t)st->st_size;\n\t\tstamp->ino   = (unsigned int)st->st_ino;\n\t} else {\n\t\tmemset(stamp, 0, sizeof(*stamp));\n\t}\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_filestamp_set_from_stat(\n\tgit_futils_filestamp *stamp, struct stat *st)\n{\n\tif (st) {\n\t\tstamp->mtime.tv_sec = st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec = st->st_mtime_nsec;\n#else\n\t\tstamp->mtime.tv_nsec = 0;\n#endif\n\t\tstamp->size  = (git_off_t)st->st_size;\n\t\tstamp->ino   = (unsigned int)st->st_ino;\n\t} else {\n\t\tmemset(stamp, 0, sizeof(*stamp));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&file->cache_data.oid",
            "git_blob_id(blob)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_id",
          "args": [
            "blob"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "121-124",
          "snippet": "const git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "file"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser",
          "args": [
            "repo",
            "file",
            "git_buf_cstr(&content)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&content"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__new",
          "args": [
            "&file",
            "entry",
            "source"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "24-44",
          "snippet": "int git_attr_file__new(\n\tgit_attr_file **out,\n\tgit_attr_file_entry *entry,\n\tgit_attr_file_source source)\n{\n\tgit_attr_file *attrs = git__calloc(1, sizeof(git_attr_file));\n\tGITERR_CHECK_ALLOC(attrs);\n\n\tif (git_mutex_init(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgit__free(attrs);\n\t\treturn -1;\n\t}\n\n\tgit_pool_init(&attrs->pool, 1);\n\tGIT_REFCOUNT_INC(attrs);\n\tattrs->entry  = entry;\n\tattrs->source = source;\n\t*out = attrs;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_file__new(\n\tgit_attr_file **out,\n\tgit_attr_file_entry *entry,\n\tgit_attr_file_source source)\n{\n\tgit_attr_file *attrs = git__calloc(1, sizeof(git_attr_file));\n\tGITERR_CHECK_ALLOC(attrs);\n\n\tif (git_mutex_init(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgit__free(attrs);\n\t\treturn -1;\n\t}\n\n\tgit_pool_init(&attrs->pool, 1);\n\tGIT_REFCOUNT_INC(attrs);\n\tattrs->entry  = entry;\n\tattrs->source = source;\n\t*out = attrs;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Unknown file source %d\"",
            "source"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer_fd",
          "args": [
            "&content",
            "fd",
            "(size_t)st.st_size"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "124-153",
          "snippet": "int git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "entry->fullpath"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "entry->fullpath",
            "&st"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&content",
            "git_blob_rawcontent(blob)",
            "git_blob_rawsize(blob)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawsize",
          "args": [
            "blob"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "25-29",
          "snippet": "git_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\ngit_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawcontent",
          "args": [
            "blob"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawcontent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "19-23",
          "snippet": "const void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_lookup",
          "args": [
            "&blob",
            "repo",
            "&id"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "106-109",
          "snippet": "int git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attr_file_oid_from_index",
          "args": [
            "&id",
            "repo",
            "entry->path"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "attr_file_oid_from_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "73-90",
          "snippet": "static int attr_file_oid_from_index(\n\tgit_oid *oid, git_repository *repo, const char *path)\n{\n\tint error;\n\tgit_index *idx;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = git_index__find_pos(&pos, idx, path, 0, 0)) < 0)\n\t\treturn error;\n\n\tif (!(entry = git_index_get_byindex(idx, pos)))\n\t\treturn GIT_ENOTFOUND;\n\n\t*oid = entry->id;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int attr_file_oid_from_index(\n\tgit_oid *oid, git_repository *repo, const char *path)\n{\n\tint error;\n\tgit_index *idx;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = git_index__find_pos(&pos, idx, path, 0, 0)) < 0)\n\t\treturn error;\n\n\tif (!(entry = git_index_get_byindex(idx, pos)))\n\t\treturn GIT_ENOTFOUND;\n\n\t*oid = entry->id;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_file__load(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_entry *entry,\n\tgit_attr_file_source source,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_blob *blob = NULL;\n\tgit_buf content = GIT_BUF_INIT;\n\tgit_attr_file *file;\n\tstruct stat st;\n\tbool nonexistent = false;\n\n\t*out = NULL;\n\n\tswitch (source) {\n\tcase GIT_ATTR_FILE__IN_MEMORY:\n\t\t/* in-memory attribute file doesn't need data */\n\t\tbreak;\n\tcase GIT_ATTR_FILE__FROM_INDEX: {\n\t\tgit_oid id;\n\n\t\tif ((error = attr_file_oid_from_index(&id, repo, entry->path)) < 0 ||\n\t\t\t(error = git_blob_lookup(&blob, repo, &id)) < 0)\n\t\t\treturn error;\n\n\t\t/* Do not assume that data straight from the ODB is NULL-terminated;\n\t\t * copy the contents of a file to a buffer to work on */\n\t\tgit_buf_put(&content, git_blob_rawcontent(blob), git_blob_rawsize(blob));\n\t\tbreak;\n\t}\n\tcase GIT_ATTR_FILE__FROM_FILE: {\n\t\tint fd = -1;\n\n\t\t/* For open or read errors, pretend that we got ENOTFOUND. */\n\t\t/* TODO: issue warning when warning API is available */\n\n\t\tif (p_stat(entry->fullpath, &st) < 0 ||\n\t\t\tS_ISDIR(st.st_mode) ||\n\t\t\t(fd = git_futils_open_ro(entry->fullpath)) < 0 ||\n\t\t\t(error = git_futils_readbuffer_fd(&content, fd, (size_t)st.st_size)) < 0)\n\t\t\tnonexistent = true;\n\n\t\tif (fd >= 0)\n\t\t\tp_close(fd);\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"Unknown file source %d\", source);\n\t\treturn -1;\n\t}\n\n\tif ((error = git_attr_file__new(&file, entry, source)) < 0)\n\t\tgoto cleanup;\n\n\t/* store the key of the attr_reader; don't bother with cache\n\t * invalidation during the same attr reader session.\n\t */\n\tif (attr_session)\n\t\tfile->session_key = attr_session->key;\n\n\tif (parser && (error = parser(repo, file, git_buf_cstr(&content))) < 0) {\n\t\tgit_attr_file__free(file);\n\t\tgoto cleanup;\n\t}\n\n\t/* write cache breakers */\n\tif (nonexistent)\n\t\tfile->nonexistent = 1;\n\telse if (source == GIT_ATTR_FILE__FROM_INDEX)\n\t\tgit_oid_cpy(&file->cache_data.oid, git_blob_id(blob));\n\telse if (source == GIT_ATTR_FILE__FROM_FILE)\n\t\tgit_futils_filestamp_set_from_stat(&file->cache_data.stamp, &st);\n\t/* else always cacheable */\n\n\t*out = file;\n\ncleanup:\n\tgit_blob_free(blob);\n\tgit_buf_free(&content);\n\n\treturn error;\n}"
  },
  {
    "function_name": "attr_file_oid_from_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "73-90",
    "snippet": "static int attr_file_oid_from_index(\n\tgit_oid *oid, git_repository *repo, const char *path)\n{\n\tint error;\n\tgit_index *idx;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = git_index__find_pos(&pos, idx, path, 0, 0)) < 0)\n\t\treturn error;\n\n\tif (!(entry = git_index_get_byindex(idx, pos)))\n\t\treturn GIT_ENOTFOUND;\n\n\t*oid = entry->id;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_get_byindex",
          "args": [
            "idx",
            "pos"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_get_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "799-805",
          "snippet": "const git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index__find_pos",
          "args": [
            "&pos",
            "idx",
            "path",
            "0",
            "0"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "git_index__find_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1670-1675",
          "snippet": "int git_index__find_pos(\n\tsize_t *out, git_index *index, const char *path, size_t path_len, int stage)\n{\n\tassert(index && path);\n\treturn index_find(out, index, path, path_len, stage);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index__find_pos(\n\tsize_t *out, git_index *index, const char *path, size_t path_len, int stage)\n{\n\tassert(index && path);\n\treturn index_find(out, index, path, path_len, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&idx",
            "repo"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int attr_file_oid_from_index(\n\tgit_oid *oid, git_repository *repo, const char *path)\n{\n\tint error;\n\tgit_index *idx;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = git_index__find_pos(&pos, idx, path, 0, 0)) < 0)\n\t\treturn error;\n\n\tif (!(entry = git_index_get_byindex(idx, pos)))\n\t\treturn GIT_ENOTFOUND;\n\n\t*oid = entry->id;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_attr_file__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "66-71",
    "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_DEC",
          "args": [
            "file",
            "attr_file_free"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
  },
  {
    "function_name": "git_attr_file__clear_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "46-64",
    "snippet": "int git_attr_file__clear_rules(git_attr_file *file, bool need_lock)\n{\n\tunsigned int i;\n\tgit_attr_rule *rule;\n\n\tif (need_lock && git_mutex_lock(&file->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&file->rules, i, rule)\n\t\tgit_attr_rule__free(rule);\n\tgit_vector_free(&file->rules);\n\n\tif (need_lock)\n\t\tgit_mutex_unlock(&file->lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void git_attr_rule__clear(git_attr_rule *rule);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&file->lock"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&file->rules"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_rule__free",
          "args": [
            "rule"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_rule__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "842-846",
          "snippet": "void git_attr_rule__free(git_attr_rule *rule)\n{\n\tgit_attr_rule__clear(rule);\n\tgit__free(rule);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nvoid git_attr_rule__free(git_attr_rule *rule)\n{\n\tgit_attr_rule__clear(rule);\n\tgit__free(rule);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&file->rules",
            "i",
            "rule"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to lock attribute file\""
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&file->lock"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nint git_attr_file__clear_rules(git_attr_file *file, bool need_lock)\n{\n\tunsigned int i;\n\tgit_attr_rule *rule;\n\n\tif (need_lock && git_mutex_lock(&file->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&file->rules, i, rule)\n\t\tgit_attr_rule__free(rule);\n\tgit_vector_free(&file->rules);\n\n\tif (need_lock)\n\t\tgit_mutex_unlock(&file->lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_attr_file__new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "24-44",
    "snippet": "int git_attr_file__new(\n\tgit_attr_file **out,\n\tgit_attr_file_entry *entry,\n\tgit_attr_file_source source)\n{\n\tgit_attr_file *attrs = git__calloc(1, sizeof(git_attr_file));\n\tGITERR_CHECK_ALLOC(attrs);\n\n\tif (git_mutex_init(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgit__free(attrs);\n\t\treturn -1;\n\t}\n\n\tgit_pool_init(&attrs->pool, 1);\n\tGIT_REFCOUNT_INC(attrs);\n\tattrs->entry  = entry;\n\tattrs->source = source;\n\t*out = attrs;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "attrs"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_init",
          "args": [
            "&attrs->pool",
            "1"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "120-129",
          "snippet": "void git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "attrs"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to initialize lock\""
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_init",
          "args": [
            "&attrs->lock"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "140-141",
          "snippet": "GIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "attrs"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_attr_file)"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_file__new(\n\tgit_attr_file **out,\n\tgit_attr_file_entry *entry,\n\tgit_attr_file_source source)\n{\n\tgit_attr_file *attrs = git__calloc(1, sizeof(git_attr_file));\n\tGITERR_CHECK_ALLOC(attrs);\n\n\tif (git_mutex_init(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgit__free(attrs);\n\t\treturn -1;\n\t}\n\n\tgit_pool_init(&attrs->pool, 1);\n\tGIT_REFCOUNT_INC(attrs);\n\tattrs->entry  = entry;\n\tattrs->source = source;\n\t*out = attrs;\n\treturn 0;\n}"
  },
  {
    "function_name": "attr_file_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
    "lines": "11-22",
    "snippet": "static void attr_file_free(git_attr_file *file)\n{\n\tbool unlock = !git_mutex_lock(&file->lock);\n\tgit_attr_file__clear_rules(file, false);\n\tgit_pool_clear(&file->pool);\n\tif (unlock)\n\t\tgit_mutex_unlock(&file->lock);\n\tgit_mutex_free(&file->lock);\n\n\tgit__memzero(file, sizeof(*file));\n\tgit__free(file);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"index.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/blob.h\"",
      "#include \"attrcache.h\"",
      "#include \"attr_file.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "file"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__memzero",
          "args": [
            "file",
            "sizeof(*file)"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "git__memzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "521-531",
          "snippet": "GIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_free",
          "args": [
            "&file->lock"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "104-108",
          "snippet": "int git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&file->lock"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&file->pool"
          ],
          "line": 15
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__clear_rules",
          "args": [
            "file",
            "false"
          ],
          "line": 14
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__clear_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "46-64",
          "snippet": "int git_attr_file__clear_rules(git_attr_file *file, bool need_lock)\n{\n\tunsigned int i;\n\tgit_attr_rule *rule;\n\n\tif (need_lock && git_mutex_lock(&file->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&file->rules, i, rule)\n\t\tgit_attr_rule__free(rule);\n\tgit_vector_free(&file->rules);\n\n\tif (need_lock)\n\t\tgit_mutex_unlock(&file->lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nint git_attr_file__clear_rules(git_attr_file *file, bool need_lock)\n{\n\tunsigned int i;\n\tgit_attr_rule *rule;\n\n\tif (need_lock && git_mutex_lock(&file->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&file->rules, i, rule)\n\t\tgit_attr_rule__free(rule);\n\tgit_vector_free(&file->rules);\n\n\tif (need_lock)\n\t\tgit_mutex_unlock(&file->lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&file->lock"
          ],
          "line": 13
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void attr_file_free(git_attr_file *file)\n{\n\tbool unlock = !git_mutex_lock(&file->lock);\n\tgit_attr_file__clear_rules(file, false);\n\tgit_pool_clear(&file->pool);\n\tif (unlock)\n\t\tgit_mutex_unlock(&file->lock);\n\tgit_mutex_free(&file->lock);\n\n\tgit__memzero(file, sizeof(*file));\n\tgit__free(file);\n}"
  }
]