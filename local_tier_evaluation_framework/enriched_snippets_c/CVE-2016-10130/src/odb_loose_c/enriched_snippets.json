[
  {
    "function_name": "git_odb_backend_loose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "930-982",
    "snippet": "int git_odb_backend_loose(\n\tgit_odb_backend **backend_out,\n\tconst char *objects_dir,\n\tint compression_level,\n\tint do_fsync,\n\tunsigned int dir_mode,\n\tunsigned int file_mode)\n{\n\tloose_backend *backend;\n\tsize_t objects_dirlen, alloclen;\n\n\tassert(backend_out && objects_dir);\n\n\tobjects_dirlen = strlen(objects_dir);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(loose_backend), objects_dirlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 2);\n\tbackend = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->parent.version = GIT_ODB_BACKEND_VERSION;\n\tbackend->objects_dirlen = objects_dirlen;\n\tmemcpy(backend->objects_dir, objects_dir, objects_dirlen);\n\tif (backend->objects_dir[backend->objects_dirlen - 1] != '/')\n\t\tbackend->objects_dir[backend->objects_dirlen++] = '/';\n\n\tif (compression_level < 0)\n\t\tcompression_level = Z_BEST_SPEED;\n\n\tif (dir_mode == 0)\n\t\tdir_mode = GIT_OBJECT_DIR_MODE;\n\n\tif (file_mode == 0)\n\t\tfile_mode = GIT_OBJECT_FILE_MODE;\n\n\tbackend->object_zlib_level = compression_level;\n\tbackend->fsync_object_files = do_fsync;\n\tbackend->object_dir_mode = dir_mode;\n\tbackend->object_file_mode = file_mode;\n\n\tbackend->parent.read = &loose_backend__read;\n\tbackend->parent.write = &loose_backend__write;\n\tbackend->parent.read_prefix = &loose_backend__read_prefix;\n\tbackend->parent.read_header = &loose_backend__read_header;\n\tbackend->parent.writestream = &loose_backend__stream;\n\tbackend->parent.exists = &loose_backend__exists;\n\tbackend->parent.exists_prefix = &loose_backend__exists_prefix;\n\tbackend->parent.foreach = &loose_backend__foreach;\n\tbackend->parent.free = &loose_backend__free;\n\n\t*backend_out = (git_odb_backend *)backend;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "backend->objects_dir",
            "objects_dir",
            "objects_dirlen"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "backend"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "alloclen"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "alloclen",
            "2"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "sizeof(loose_backend)",
            "objects_dirlen"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "objects_dir"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend_out && objects_dir"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_backend_loose(\n\tgit_odb_backend **backend_out,\n\tconst char *objects_dir,\n\tint compression_level,\n\tint do_fsync,\n\tunsigned int dir_mode,\n\tunsigned int file_mode)\n{\n\tloose_backend *backend;\n\tsize_t objects_dirlen, alloclen;\n\n\tassert(backend_out && objects_dir);\n\n\tobjects_dirlen = strlen(objects_dir);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(loose_backend), objects_dirlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 2);\n\tbackend = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->parent.version = GIT_ODB_BACKEND_VERSION;\n\tbackend->objects_dirlen = objects_dirlen;\n\tmemcpy(backend->objects_dir, objects_dir, objects_dirlen);\n\tif (backend->objects_dir[backend->objects_dirlen - 1] != '/')\n\t\tbackend->objects_dir[backend->objects_dirlen++] = '/';\n\n\tif (compression_level < 0)\n\t\tcompression_level = Z_BEST_SPEED;\n\n\tif (dir_mode == 0)\n\t\tdir_mode = GIT_OBJECT_DIR_MODE;\n\n\tif (file_mode == 0)\n\t\tfile_mode = GIT_OBJECT_FILE_MODE;\n\n\tbackend->object_zlib_level = compression_level;\n\tbackend->fsync_object_files = do_fsync;\n\tbackend->object_dir_mode = dir_mode;\n\tbackend->object_file_mode = file_mode;\n\n\tbackend->parent.read = &loose_backend__read;\n\tbackend->parent.write = &loose_backend__write;\n\tbackend->parent.read_prefix = &loose_backend__read_prefix;\n\tbackend->parent.read_header = &loose_backend__read_header;\n\tbackend->parent.writestream = &loose_backend__stream;\n\tbackend->parent.exists = &loose_backend__exists;\n\tbackend->parent.exists_prefix = &loose_backend__exists_prefix;\n\tbackend->parent.foreach = &loose_backend__foreach;\n\tbackend->parent.free = &loose_backend__free;\n\n\t*backend_out = (git_odb_backend *)backend;\n\treturn 0;\n}"
  },
  {
    "function_name": "loose_backend__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "921-928",
    "snippet": "static void loose_backend__free(git_odb_backend *_backend)\n{\n\tloose_backend *backend;\n\tassert(_backend);\n\tbackend = (loose_backend *)_backend;\n\n\tgit__free(backend);\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "backend"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "_backend"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void loose_backend__free(git_odb_backend *_backend)\n{\n\tloose_backend *backend;\n\tassert(_backend);\n\tbackend = (loose_backend *)_backend;\n\n\tgit__free(backend);\n}"
  },
  {
    "function_name": "loose_backend__write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "883-919",
    "snippet": "static int loose_backend__write(git_odb_backend *_backend, const git_oid *oid, const void *data, size_t len, git_otype type)\n{\n\tint error = 0, header_len;\n\tgit_buf final_path = GIT_BUF_INIT;\n\tchar header[64];\n\tgit_filebuf fbuf = GIT_FILEBUF_INIT;\n\tloose_backend *backend;\n\n\tbackend = (loose_backend *)_backend;\n\n\t/* prepare the header for the file */\n\theader_len = git_odb__format_object_header(header, sizeof(header), len, type);\n\n\tif (git_buf_joinpath(&final_path, backend->objects_dir, \"tmp_object\") < 0 ||\n\t\tgit_filebuf_open(&fbuf, final_path.ptr,\n\t\t\tGIT_FILEBUF_TEMPORARY |\n\t\t\t(backend->object_zlib_level << GIT_FILEBUF_DEFLATE_SHIFT),\n\t\t\tbackend->object_file_mode) < 0)\n\t{\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tgit_filebuf_write(&fbuf, header, header_len);\n\tgit_filebuf_write(&fbuf, data, len);\n\n\tif (object_file_name(&final_path, backend, oid) < 0 ||\n\t\tobject_mkdir(&final_path, backend) < 0 ||\n\t\tgit_filebuf_commit_at(&fbuf, final_path.ptr) < 0)\n\t\terror = -1;\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&fbuf);\n\tgit_buf_free(&final_path);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&final_path"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&fbuf"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit_at",
          "args": [
            "&fbuf",
            "final_path.ptr"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "401-408",
          "snippet": "int git_filebuf_commit_at(git_filebuf *file, const char *path)\n{\n\tgit__free(file->path_original);\n\tfile->path_original = git__strdup(path);\n\tGITERR_CHECK_ALLOC(file->path_original);\n\n\treturn git_filebuf_commit(file);\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit_at(git_filebuf *file, const char *path)\n{\n\tgit__free(file->path_original);\n\tfile->path_original = git__strdup(path);\n\tGITERR_CHECK_ALLOC(file->path_original);\n\n\treturn git_filebuf_commit(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_mkdir",
          "args": [
            "&final_path",
            "backend"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "object_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "85-90",
          "snippet": "static int object_mkdir(const git_buf *name, const loose_backend *be)\n{\n\treturn git_futils_mkdir_relative(\n\t\tname->ptr + be->objects_dirlen, be->objects_dir, be->object_dir_mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR, NULL);\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int object_mkdir(const git_buf *name, const loose_backend *be)\n{\n\treturn git_futils_mkdir_relative(\n\t\tname->ptr + be->objects_dirlen, be->objects_dir, be->object_dir_mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_file_name",
          "args": [
            "&final_path",
            "backend",
            "oid"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "object_file_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "63-83",
          "snippet": "static int object_file_name(\n\tgit_buf *name, const loose_backend *be, const git_oid *id)\n{\n\tsize_t alloclen;\n\n\t/* expand length for object root + 40 hex sha1 chars + 2 * '/' + '\\0' */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, be->objects_dirlen, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 3);\n\tif (git_buf_grow(name, alloclen) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(name, be->objects_dir, be->objects_dirlen);\n\tgit_path_to_dir(name);\n\n\t/* loose object filename: aa/aaa... (41 bytes) */\n\tgit_oid_pathfmt(name->ptr + name->size, id);\n\tname->size += GIT_OID_HEXSZ + 1;\n\tname->ptr[name->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int object_file_name(\n\tgit_buf *name, const loose_backend *be, const git_oid *id)\n{\n\tsize_t alloclen;\n\n\t/* expand length for object root + 40 hex sha1 chars + 2 * '/' + '\\0' */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, be->objects_dirlen, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 3);\n\tif (git_buf_grow(name, alloclen) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(name, be->objects_dir, be->objects_dirlen);\n\tgit_path_to_dir(name);\n\n\t/* loose object filename: aa/aaa... (41 bytes) */\n\tgit_oid_pathfmt(name->ptr + name->size, id);\n\tname->size += GIT_OID_HEXSZ + 1;\n\tname->ptr[name->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "&fbuf",
            "data",
            "len"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&fbuf",
            "final_path.ptr",
            "GIT_FILEBUF_TEMPORARY |\n\t\t\t(backend->object_zlib_level << GIT_FILEBUF_DEFLATE_SHIFT)",
            "backend->object_file_mode"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&final_path",
            "backend->objects_dir",
            "\"tmp_object\""
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__format_object_header",
          "args": [
            "header",
            "sizeof(header)",
            "len",
            "type"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__format_object_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "53-59",
          "snippet": "int git_odb__format_object_header(char *hdr, size_t n, git_off_t obj_len, git_otype obj_type)\n{\n\tconst char *type_str = git_object_type2string(obj_type);\n\tint len = p_snprintf(hdr, n, \"%s %lld\", type_str, (long long)obj_len);\n\tassert(len > 0 && len <= (int)n);\n\treturn len+1;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__format_object_header(char *hdr, size_t n, git_off_t obj_len, git_otype obj_type)\n{\n\tconst char *type_str = git_object_type2string(obj_type);\n\tint len = p_snprintf(hdr, n, \"%s %lld\", type_str, (long long)obj_len);\n\tassert(len > 0 && len <= (int)n);\n\treturn len+1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__write(git_odb_backend *_backend, const git_oid *oid, const void *data, size_t len, git_otype type)\n{\n\tint error = 0, header_len;\n\tgit_buf final_path = GIT_BUF_INIT;\n\tchar header[64];\n\tgit_filebuf fbuf = GIT_FILEBUF_INIT;\n\tloose_backend *backend;\n\n\tbackend = (loose_backend *)_backend;\n\n\t/* prepare the header for the file */\n\theader_len = git_odb__format_object_header(header, sizeof(header), len, type);\n\n\tif (git_buf_joinpath(&final_path, backend->objects_dir, \"tmp_object\") < 0 ||\n\t\tgit_filebuf_open(&fbuf, final_path.ptr,\n\t\t\tGIT_FILEBUF_TEMPORARY |\n\t\t\t(backend->object_zlib_level << GIT_FILEBUF_DEFLATE_SHIFT),\n\t\t\tbackend->object_file_mode) < 0)\n\t{\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tgit_filebuf_write(&fbuf, header, header_len);\n\tgit_filebuf_write(&fbuf, data, len);\n\n\tif (object_file_name(&final_path, backend, oid) < 0 ||\n\t\tobject_mkdir(&final_path, backend) < 0 ||\n\t\tgit_filebuf_commit_at(&fbuf, final_path.ptr) < 0)\n\t\terror = -1;\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&fbuf);\n\tgit_buf_free(&final_path);\n\treturn error;\n}"
  },
  {
    "function_name": "loose_backend__stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "841-881",
    "snippet": "static int loose_backend__stream(git_odb_stream **stream_out, git_odb_backend *_backend, git_off_t length, git_otype type)\n{\n\tloose_backend *backend;\n\tloose_writestream *stream = NULL;\n\tchar hdr[64];\n\tgit_buf tmp_path = GIT_BUF_INIT;\n\tint hdrlen;\n\n\tassert(_backend && length >= 0);\n\n\tbackend = (loose_backend *)_backend;\n\t*stream_out = NULL;\n\n\thdrlen = git_odb__format_object_header(hdr, sizeof(hdr), length, type);\n\n\tstream = git__calloc(1, sizeof(loose_writestream));\n\tGITERR_CHECK_ALLOC(stream);\n\n\tstream->stream.backend = _backend;\n\tstream->stream.read = NULL; /* read only */\n\tstream->stream.write = &loose_backend__stream_write;\n\tstream->stream.finalize_write = &loose_backend__stream_fwrite;\n\tstream->stream.free = &loose_backend__stream_free;\n\tstream->stream.mode = GIT_STREAM_WRONLY;\n\n\tif (git_buf_joinpath(&tmp_path, backend->objects_dir, \"tmp_object\") < 0 ||\n\t\tgit_filebuf_open(&stream->fbuf, tmp_path.ptr,\n\t\t\tGIT_FILEBUF_TEMPORARY |\n\t\t\t(backend->object_zlib_level << GIT_FILEBUF_DEFLATE_SHIFT),\n\t\t\tbackend->object_file_mode) < 0 ||\n\t\tstream->stream.write((git_odb_stream *)stream, hdr, hdrlen) < 0)\n\t{\n\t\tgit_filebuf_cleanup(&stream->fbuf);\n\t\tgit__free(stream);\n\t\tstream = NULL;\n\t}\n\tgit_buf_free(&tmp_path);\n\t*stream_out = (git_odb_stream *)stream;\n\n\treturn !stream ? -1 : 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&tmp_path"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "stream"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&stream->fbuf"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stream->stream.write",
          "args": [
            "(git_odb_stream *)stream",
            "hdr",
            "hdrlen"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&stream->fbuf",
            "tmp_path.ptr",
            "GIT_FILEBUF_TEMPORARY |\n\t\t\t(backend->object_zlib_level << GIT_FILEBUF_DEFLATE_SHIFT)",
            "backend->object_file_mode"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&tmp_path",
            "backend->objects_dir",
            "\"tmp_object\""
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "stream"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(loose_writestream)"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__format_object_header",
          "args": [
            "hdr",
            "sizeof(hdr)",
            "length",
            "type"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__format_object_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "53-59",
          "snippet": "int git_odb__format_object_header(char *hdr, size_t n, git_off_t obj_len, git_otype obj_type)\n{\n\tconst char *type_str = git_object_type2string(obj_type);\n\tint len = p_snprintf(hdr, n, \"%s %lld\", type_str, (long long)obj_len);\n\tassert(len > 0 && len <= (int)n);\n\treturn len+1;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__format_object_header(char *hdr, size_t n, git_off_t obj_len, git_otype obj_type)\n{\n\tconst char *type_str = git_object_type2string(obj_type);\n\tint len = p_snprintf(hdr, n, \"%s %lld\", type_str, (long long)obj_len);\n\tassert(len > 0 && len <= (int)n);\n\treturn len+1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "_backend && length >= 0"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__stream(git_odb_stream **stream_out, git_odb_backend *_backend, git_off_t length, git_otype type)\n{\n\tloose_backend *backend;\n\tloose_writestream *stream = NULL;\n\tchar hdr[64];\n\tgit_buf tmp_path = GIT_BUF_INIT;\n\tint hdrlen;\n\n\tassert(_backend && length >= 0);\n\n\tbackend = (loose_backend *)_backend;\n\t*stream_out = NULL;\n\n\thdrlen = git_odb__format_object_header(hdr, sizeof(hdr), length, type);\n\n\tstream = git__calloc(1, sizeof(loose_writestream));\n\tGITERR_CHECK_ALLOC(stream);\n\n\tstream->stream.backend = _backend;\n\tstream->stream.read = NULL; /* read only */\n\tstream->stream.write = &loose_backend__stream_write;\n\tstream->stream.finalize_write = &loose_backend__stream_fwrite;\n\tstream->stream.free = &loose_backend__stream_free;\n\tstream->stream.mode = GIT_STREAM_WRONLY;\n\n\tif (git_buf_joinpath(&tmp_path, backend->objects_dir, \"tmp_object\") < 0 ||\n\t\tgit_filebuf_open(&stream->fbuf, tmp_path.ptr,\n\t\t\tGIT_FILEBUF_TEMPORARY |\n\t\t\t(backend->object_zlib_level << GIT_FILEBUF_DEFLATE_SHIFT),\n\t\t\tbackend->object_file_mode) < 0 ||\n\t\tstream->stream.write((git_odb_stream *)stream, hdr, hdrlen) < 0)\n\t{\n\t\tgit_filebuf_cleanup(&stream->fbuf);\n\t\tgit__free(stream);\n\t\tstream = NULL;\n\t}\n\tgit_buf_free(&tmp_path);\n\t*stream_out = (git_odb_stream *)stream;\n\n\treturn !stream ? -1 : 0;\n}"
  },
  {
    "function_name": "loose_backend__stream_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "833-839",
    "snippet": "static void loose_backend__stream_free(git_odb_stream *_stream)\n{\n\tloose_writestream *stream = (loose_writestream *)_stream;\n\n\tgit_filebuf_cleanup(&stream->fbuf);\n\tgit__free(stream);\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "stream"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&stream->fbuf"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void loose_backend__stream_free(git_odb_stream *_stream)\n{\n\tloose_writestream *stream = (loose_writestream *)_stream;\n\n\tgit_filebuf_cleanup(&stream->fbuf);\n\tgit__free(stream);\n}"
  },
  {
    "function_name": "loose_backend__stream_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "827-831",
    "snippet": "static int loose_backend__stream_write(git_odb_stream *_stream, const char *data, size_t len)\n{\n\tloose_writestream *stream = (loose_writestream *)_stream;\n\treturn git_filebuf_write(&stream->fbuf, data, len);\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "&stream->fbuf",
            "data",
            "len"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__stream_write(git_odb_stream *_stream, const char *data, size_t len)\n{\n\tloose_writestream *stream = (loose_writestream *)_stream;\n\treturn git_filebuf_write(&stream->fbuf, data, len);\n}"
  },
  {
    "function_name": "loose_backend__stream_fwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "808-825",
    "snippet": "static int loose_backend__stream_fwrite(git_odb_stream *_stream, const git_oid *oid)\n{\n\tloose_writestream *stream = (loose_writestream *)_stream;\n\tloose_backend *backend = (loose_backend *)_stream->backend;\n\tgit_buf final_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (object_file_name(&final_path, backend, oid) < 0 ||\n\t\tobject_mkdir(&final_path, backend) < 0)\n\t\terror = -1;\n\telse\n\t\terror = git_filebuf_commit_at(\n\t\t\t&stream->fbuf, final_path.ptr);\n\n\tgit_buf_free(&final_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&final_path"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit_at",
          "args": [
            "&stream->fbuf",
            "final_path.ptr"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "401-408",
          "snippet": "int git_filebuf_commit_at(git_filebuf *file, const char *path)\n{\n\tgit__free(file->path_original);\n\tfile->path_original = git__strdup(path);\n\tGITERR_CHECK_ALLOC(file->path_original);\n\n\treturn git_filebuf_commit(file);\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit_at(git_filebuf *file, const char *path)\n{\n\tgit__free(file->path_original);\n\tfile->path_original = git__strdup(path);\n\tGITERR_CHECK_ALLOC(file->path_original);\n\n\treturn git_filebuf_commit(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_mkdir",
          "args": [
            "&final_path",
            "backend"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "object_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "85-90",
          "snippet": "static int object_mkdir(const git_buf *name, const loose_backend *be)\n{\n\treturn git_futils_mkdir_relative(\n\t\tname->ptr + be->objects_dirlen, be->objects_dir, be->object_dir_mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR, NULL);\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int object_mkdir(const git_buf *name, const loose_backend *be)\n{\n\treturn git_futils_mkdir_relative(\n\t\tname->ptr + be->objects_dirlen, be->objects_dir, be->object_dir_mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_file_name",
          "args": [
            "&final_path",
            "backend",
            "oid"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "object_file_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "63-83",
          "snippet": "static int object_file_name(\n\tgit_buf *name, const loose_backend *be, const git_oid *id)\n{\n\tsize_t alloclen;\n\n\t/* expand length for object root + 40 hex sha1 chars + 2 * '/' + '\\0' */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, be->objects_dirlen, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 3);\n\tif (git_buf_grow(name, alloclen) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(name, be->objects_dir, be->objects_dirlen);\n\tgit_path_to_dir(name);\n\n\t/* loose object filename: aa/aaa... (41 bytes) */\n\tgit_oid_pathfmt(name->ptr + name->size, id);\n\tname->size += GIT_OID_HEXSZ + 1;\n\tname->ptr[name->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int object_file_name(\n\tgit_buf *name, const loose_backend *be, const git_oid *id)\n{\n\tsize_t alloclen;\n\n\t/* expand length for object root + 40 hex sha1 chars + 2 * '/' + '\\0' */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, be->objects_dirlen, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 3);\n\tif (git_buf_grow(name, alloclen) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(name, be->objects_dir, be->objects_dirlen);\n\tgit_path_to_dir(name);\n\n\t/* loose object filename: aa/aaa... (41 bytes) */\n\tgit_oid_pathfmt(name->ptr + name->size, id);\n\tname->size += GIT_OID_HEXSZ + 1;\n\tname->ptr[name->size] = '\\0';\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__stream_fwrite(git_odb_stream *_stream, const git_oid *oid)\n{\n\tloose_writestream *stream = (loose_writestream *)_stream;\n\tloose_backend *backend = (loose_backend *)_stream->backend;\n\tgit_buf final_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (object_file_name(&final_path, backend, oid) < 0 ||\n\t\tobject_mkdir(&final_path, backend) < 0)\n\t\terror = -1;\n\telse\n\t\terror = git_filebuf_commit_at(\n\t\t\t&stream->fbuf, final_path.ptr);\n\n\tgit_buf_free(&final_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "loose_backend__foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "779-806",
    "snippet": "static int loose_backend__foreach(git_odb_backend *_backend, git_odb_foreach_cb cb, void *data)\n{\n\tchar *objects_dir;\n\tint error;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct foreach_state state;\n\tloose_backend *backend = (loose_backend *) _backend;\n\n\tassert(backend && cb);\n\n\tobjects_dir = backend->objects_dir;\n\n\tgit_buf_sets(&buf, objects_dir);\n\tgit_path_to_dir(&buf);\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.cb = cb;\n\tstate.data = data;\n\tstate.dir_len = git_buf_len(&buf);\n\n\terror = git_path_direach(&buf, 0, foreach_cb, &state);\n\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_direach",
          "args": [
            "&buf",
            "0",
            "foreach_cb",
            "&state"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_direach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1023-1094",
          "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&buf"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&state",
            "0",
            "sizeof(state)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&buf"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "&buf"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&buf",
            "objects_dir"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend && cb"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__foreach(git_odb_backend *_backend, git_odb_foreach_cb cb, void *data)\n{\n\tchar *objects_dir;\n\tint error;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct foreach_state state;\n\tloose_backend *backend = (loose_backend *) _backend;\n\n\tassert(backend && cb);\n\n\tobjects_dir = backend->objects_dir;\n\n\tgit_buf_sets(&buf, objects_dir);\n\tgit_path_to_dir(&buf);\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.cb = cb;\n\tstate.data = data;\n\tstate.dir_len = git_buf_len(&buf);\n\n\terror = git_path_direach(&buf, 0, foreach_cb, &state);\n\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
  },
  {
    "function_name": "foreach_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "768-777",
    "snippet": "static int foreach_cb(void *_state, git_buf *path)\n{\n\tstruct foreach_state *state = (struct foreach_state *) _state;\n\n\t/* non-dir is some stray file, ignore it */\n\tif (!git_path_isdir(git_buf_cstr(path)))\n\t\treturn 0;\n\n\treturn git_path_direach(path, 0, foreach_object_dir_cb, state);\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_direach",
          "args": [
            "path",
            "0",
            "foreach_object_dir_cb",
            "state"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_direach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1023-1094",
          "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "git_buf_cstr(path)"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "path"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int foreach_cb(void *_state, git_buf *path)\n{\n\tstruct foreach_state *state = (struct foreach_state *) _state;\n\n\t/* non-dir is some stray file, ignore it */\n\tif (!git_path_isdir(git_buf_cstr(path)))\n\t\treturn 0;\n\n\treturn git_path_direach(path, 0, foreach_object_dir_cb, state);\n}"
  },
  {
    "function_name": "foreach_object_dir_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "756-766",
    "snippet": "static int foreach_object_dir_cb(void *_state, git_buf *path)\n{\n\tgit_oid oid;\n\tstruct foreach_state *state = (struct foreach_state *) _state;\n\n\tif (filename_to_oid(&oid, path->ptr + state->dir_len) < 0)\n\t\treturn 0;\n\n\treturn giterr_set_after_callback_function(\n\t\tstate->cb(&oid, state->data), \"git_odb_foreach\");\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set_after_callback_function",
          "args": [
            "state->cb(&oid, state->data)",
            "\"git_odb_foreach\""
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "state->cb",
          "args": [
            "&oid",
            "state->data"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename_to_oid",
          "args": [
            "&oid",
            "path->ptr + state->dir_len"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "filename_to_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "728-754",
          "snippet": "GIT_INLINE(int) filename_to_oid(git_oid *oid, const char *ptr)\n{\n\tint v, i = 0;\n\tif (strlen(ptr) != GIT_OID_HEXSZ+1)\n\t\treturn -1;\n\n\tif (ptr[2] != '/') {\n\t\treturn -1;\n\t}\n\n\tv = (git__fromhex(ptr[i]) << 4) | git__fromhex(ptr[i+1]);\n\tif (v < 0)\n\t\treturn -1;\n\n\toid->id[0] = (unsigned char) v;\n\n\tptr += 3;\n\tfor (i = 0; i < 38; i += 2) {\n\t\tv = (git__fromhex(ptr[i]) << 4) | git__fromhex(ptr[i + 1]);\n\t\tif (v < 0)\n\t\t\treturn -1;\n\n\t\toid->id[1 + i/2] = (unsigned char) v;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nGIT_INLINE(int) filename_to_oid(git_oid *oid, const char *ptr)\n{\n\tint v, i = 0;\n\tif (strlen(ptr) != GIT_OID_HEXSZ+1)\n\t\treturn -1;\n\n\tif (ptr[2] != '/') {\n\t\treturn -1;\n\t}\n\n\tv = (git__fromhex(ptr[i]) << 4) | git__fromhex(ptr[i+1]);\n\tif (v < 0)\n\t\treturn -1;\n\n\toid->id[0] = (unsigned char) v;\n\n\tptr += 3;\n\tfor (i = 0; i < 38; i += 2) {\n\t\tv = (git__fromhex(ptr[i]) << 4) | git__fromhex(ptr[i + 1]);\n\t\tif (v < 0)\n\t\t\treturn -1;\n\n\t\toid->id[1 + i/2] = (unsigned char) v;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int foreach_object_dir_cb(void *_state, git_buf *path)\n{\n\tgit_oid oid;\n\tstruct foreach_state *state = (struct foreach_state *) _state;\n\n\tif (filename_to_oid(&oid, path->ptr + state->dir_len) < 0)\n\t\treturn 0;\n\n\treturn giterr_set_after_callback_function(\n\t\tstate->cb(&oid, state->data), \"git_odb_foreach\");\n}"
  },
  {
    "function_name": "filename_to_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "728-754",
    "snippet": "GIT_INLINE(int) filename_to_oid(git_oid *oid, const char *ptr)\n{\n\tint v, i = 0;\n\tif (strlen(ptr) != GIT_OID_HEXSZ+1)\n\t\treturn -1;\n\n\tif (ptr[2] != '/') {\n\t\treturn -1;\n\t}\n\n\tv = (git__fromhex(ptr[i]) << 4) | git__fromhex(ptr[i+1]);\n\tif (v < 0)\n\t\treturn -1;\n\n\toid->id[0] = (unsigned char) v;\n\n\tptr += 3;\n\tfor (i = 0; i < 38; i += 2) {\n\t\tv = (git__fromhex(ptr[i]) << 4) | git__fromhex(ptr[i + 1]);\n\t\tif (v < 0)\n\t\t\treturn -1;\n\n\t\toid->id[1 + i/2] = (unsigned char) v;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__fromhex",
          "args": [
            "ptr[i + 1]"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "git__fromhex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "408-411",
          "snippet": "GIT_INLINE(int) git__fromhex(char h)\n{\n\treturn from_hex[(unsigned char) h];\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(int) git__fromhex(char h)\n{\n\treturn from_hex[(unsigned char) h];\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nGIT_INLINE(int) filename_to_oid(git_oid *oid, const char *ptr)\n{\n\tint v, i = 0;\n\tif (strlen(ptr) != GIT_OID_HEXSZ+1)\n\t\treturn -1;\n\n\tif (ptr[2] != '/') {\n\t\treturn -1;\n\t}\n\n\tv = (git__fromhex(ptr[i]) << 4) | git__fromhex(ptr[i+1]);\n\tif (v < 0)\n\t\treturn -1;\n\n\toid->id[0] = (unsigned char) v;\n\n\tptr += 3;\n\tfor (i = 0; i < 38; i += 2) {\n\t\tv = (git__fromhex(ptr[i]) << 4) | git__fromhex(ptr[i + 1]);\n\t\tif (v < 0)\n\t\t\treturn -1;\n\n\t\toid->id[1 + i/2] = (unsigned char) v;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "loose_backend__exists_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "706-720",
    "snippet": "static int loose_backend__exists_prefix(\n\tgit_oid *out, git_odb_backend *backend, const git_oid *short_id, size_t len)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tint error;\n\n\tassert(backend && out && short_id && len >= GIT_OID_MINPREFIXLEN);\n\n\terror = locate_object_short_oid(\n\t\t&object_path, out, (loose_backend *)backend, short_id, len);\n\n\tgit_buf_free(&object_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&object_path"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locate_object_short_oid",
          "args": [
            "&object_path",
            "out",
            "(loose_backend *)backend",
            "short_id",
            "len"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "locate_object_short_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "516-589",
          "snippet": "static int locate_object_short_oid(\n\tgit_buf *object_location,\n\tgit_oid *res_oid,\n\tloose_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tchar *objects_dir = backend->objects_dir;\n\tsize_t dir_len = strlen(objects_dir), alloc_len;\n\tloose_locate_object_state state;\n\tint error;\n\n\t/* prealloc memory for OBJ_DIR/xx/xx..38x..xx */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 3);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(object_location, objects_dir, dir_len);\n\tgit_path_to_dir(object_location);\n\n\t/* save adjusted position at end of dir so it can be restored later */\n\tdir_len = git_buf_len(object_location);\n\n\t/* Convert raw oid to hex formatted oid */\n\tgit_oid_fmt((char *)state.short_oid, short_oid);\n\n\t/* Explore OBJ_DIR/xx/ where xx is the beginning of hex formatted short oid */\n\tif (git_buf_put(object_location, (char *)state.short_oid, 3) < 0)\n\t\treturn -1;\n\tobject_location->ptr[object_location->size - 1] = '/';\n\n\t/* Check that directory exists */\n\tif (git_path_isdir(object_location->ptr) == false)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tstate.dir_len = git_buf_len(object_location);\n\tstate.short_oid_len = len;\n\tstate.found = 0;\n\n\t/* Explore directory to find a unique object matching short_oid */\n\terror = git_path_direach(\n\t\tobject_location, 0, fn_locate_object_short_oid, &state);\n\tif (error < 0 && error != GIT_EAMBIGUOUS)\n\t\treturn error;\n\n\tif (!state.found)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tif (state.found > 1)\n\t\treturn git_odb__error_ambiguous(\"multiple matches in loose objects\");\n\n\t/* Convert obtained hex formatted oid to raw */\n\terror = git_oid_fromstr(res_oid, (char *)state.res_oid);\n\tif (error)\n\t\treturn error;\n\n\t/* Update the location according to the oid obtained */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_truncate(object_location, dir_len);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_oid_pathfmt(object_location->ptr + dir_len, res_oid);\n\n\tobject_location->size += GIT_OID_HEXSZ + 1;\n\tobject_location->ptr[object_location->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int locate_object_short_oid(\n\tgit_buf *object_location,\n\tgit_oid *res_oid,\n\tloose_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tchar *objects_dir = backend->objects_dir;\n\tsize_t dir_len = strlen(objects_dir), alloc_len;\n\tloose_locate_object_state state;\n\tint error;\n\n\t/* prealloc memory for OBJ_DIR/xx/xx..38x..xx */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 3);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(object_location, objects_dir, dir_len);\n\tgit_path_to_dir(object_location);\n\n\t/* save adjusted position at end of dir so it can be restored later */\n\tdir_len = git_buf_len(object_location);\n\n\t/* Convert raw oid to hex formatted oid */\n\tgit_oid_fmt((char *)state.short_oid, short_oid);\n\n\t/* Explore OBJ_DIR/xx/ where xx is the beginning of hex formatted short oid */\n\tif (git_buf_put(object_location, (char *)state.short_oid, 3) < 0)\n\t\treturn -1;\n\tobject_location->ptr[object_location->size - 1] = '/';\n\n\t/* Check that directory exists */\n\tif (git_path_isdir(object_location->ptr) == false)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tstate.dir_len = git_buf_len(object_location);\n\tstate.short_oid_len = len;\n\tstate.found = 0;\n\n\t/* Explore directory to find a unique object matching short_oid */\n\terror = git_path_direach(\n\t\tobject_location, 0, fn_locate_object_short_oid, &state);\n\tif (error < 0 && error != GIT_EAMBIGUOUS)\n\t\treturn error;\n\n\tif (!state.found)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tif (state.found > 1)\n\t\treturn git_odb__error_ambiguous(\"multiple matches in loose objects\");\n\n\t/* Convert obtained hex formatted oid to raw */\n\terror = git_oid_fromstr(res_oid, (char *)state.res_oid);\n\tif (error)\n\t\treturn error;\n\n\t/* Update the location according to the oid obtained */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_truncate(object_location, dir_len);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_oid_pathfmt(object_location->ptr + dir_len, res_oid);\n\n\tobject_location->size += GIT_OID_HEXSZ + 1;\n\tobject_location->ptr[object_location->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend && out && short_id && len >= GIT_OID_MINPREFIXLEN"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__exists_prefix(\n\tgit_oid *out, git_odb_backend *backend, const git_oid *short_id, size_t len)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tint error;\n\n\tassert(backend && out && short_id && len >= GIT_OID_MINPREFIXLEN);\n\n\terror = locate_object_short_oid(\n\t\t&object_path, out, (loose_backend *)backend, short_id, len);\n\n\tgit_buf_free(&object_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "loose_backend__exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "692-704",
    "snippet": "static int loose_backend__exists(git_odb_backend *backend, const git_oid *oid)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tint error;\n\n\tassert(backend && oid);\n\n\terror = locate_object(&object_path, (loose_backend *)backend, oid);\n\n\tgit_buf_free(&object_path);\n\n\treturn !error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&object_path"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locate_object",
          "args": [
            "&object_path",
            "(loose_backend *)backend",
            "oid"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "locate_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "471-482",
          "snippet": "static int locate_object(\n\tgit_buf *object_location,\n\tloose_backend *backend,\n\tconst git_oid *oid)\n{\n\tint error = object_file_name(object_location, backend, oid);\n\n\tif (!error && !git_path_exists(object_location->ptr))\n\t\treturn GIT_ENOTFOUND;\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int locate_object(\n\tgit_buf *object_location,\n\tloose_backend *backend,\n\tconst git_oid *oid)\n{\n\tint error = object_file_name(object_location, backend, oid);\n\n\tif (!error && !git_path_exists(object_location->ptr))\n\t\treturn GIT_ENOTFOUND;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend && oid"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__exists(git_odb_backend *backend, const git_oid *oid)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tint error;\n\n\tassert(backend && oid);\n\n\terror = locate_object(&object_path, (loose_backend *)backend, oid);\n\n\tgit_buf_free(&object_path);\n\n\treturn !error;\n}"
  },
  {
    "function_name": "loose_backend__read_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "653-690",
    "snippet": "static int loose_backend__read_prefix(\n\tgit_oid *out_oid,\n\tvoid **buffer_p,\n\tsize_t *len_p,\n\tgit_otype *type_p,\n\tgit_odb_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error = 0;\n\n\tassert(len >= GIT_OID_MINPREFIXLEN && len <= GIT_OID_HEXSZ);\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\t/* We can fall back to regular read method */\n\t\terror = loose_backend__read(buffer_p, len_p, type_p, backend, short_oid);\n\t\tif (!error)\n\t\t\tgit_oid_cpy(out_oid, short_oid);\n\t} else {\n\t\tgit_buf object_path = GIT_BUF_INIT;\n\t\tgit_rawobj raw;\n\n\t\tassert(backend && short_oid);\n\n\t\tif ((error = locate_object_short_oid(&object_path, out_oid,\n\t\t\t\t(loose_backend *)backend, short_oid, len)) == 0 &&\n\t\t\t(error = read_loose(&raw, &object_path)) == 0)\n\t\t{\n\t\t\t*buffer_p = raw.data;\n\t\t\t*len_p = raw.len;\n\t\t\t*type_p = raw.type;\n\t\t}\n\n\t\tgit_buf_free(&object_path);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&object_path"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_loose",
          "args": [
            "&raw",
            "&object_path"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "read_loose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "402-422",
          "snippet": "static int read_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error;\n\tgit_buf obj = GIT_BUF_INIT;\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\tout->len = 0;\n\tout->type = GIT_OBJ_BAD;\n\n\tif (!(error = git_futils_readbuffer(&obj, loc->ptr)))\n\t\terror = inflate_disk_obj(out, &obj);\n\n\tgit_buf_free(&obj);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int read_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error;\n\tgit_buf obj = GIT_BUF_INIT;\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\tout->len = 0;\n\tout->type = GIT_OBJ_BAD;\n\n\tif (!(error = git_futils_readbuffer(&obj, loc->ptr)))\n\t\terror = inflate_disk_obj(out, &obj);\n\n\tgit_buf_free(&obj);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locate_object_short_oid",
          "args": [
            "&object_path",
            "out_oid",
            "(loose_backend *)backend",
            "short_oid",
            "len"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "locate_object_short_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "516-589",
          "snippet": "static int locate_object_short_oid(\n\tgit_buf *object_location,\n\tgit_oid *res_oid,\n\tloose_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tchar *objects_dir = backend->objects_dir;\n\tsize_t dir_len = strlen(objects_dir), alloc_len;\n\tloose_locate_object_state state;\n\tint error;\n\n\t/* prealloc memory for OBJ_DIR/xx/xx..38x..xx */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 3);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(object_location, objects_dir, dir_len);\n\tgit_path_to_dir(object_location);\n\n\t/* save adjusted position at end of dir so it can be restored later */\n\tdir_len = git_buf_len(object_location);\n\n\t/* Convert raw oid to hex formatted oid */\n\tgit_oid_fmt((char *)state.short_oid, short_oid);\n\n\t/* Explore OBJ_DIR/xx/ where xx is the beginning of hex formatted short oid */\n\tif (git_buf_put(object_location, (char *)state.short_oid, 3) < 0)\n\t\treturn -1;\n\tobject_location->ptr[object_location->size - 1] = '/';\n\n\t/* Check that directory exists */\n\tif (git_path_isdir(object_location->ptr) == false)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tstate.dir_len = git_buf_len(object_location);\n\tstate.short_oid_len = len;\n\tstate.found = 0;\n\n\t/* Explore directory to find a unique object matching short_oid */\n\terror = git_path_direach(\n\t\tobject_location, 0, fn_locate_object_short_oid, &state);\n\tif (error < 0 && error != GIT_EAMBIGUOUS)\n\t\treturn error;\n\n\tif (!state.found)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tif (state.found > 1)\n\t\treturn git_odb__error_ambiguous(\"multiple matches in loose objects\");\n\n\t/* Convert obtained hex formatted oid to raw */\n\terror = git_oid_fromstr(res_oid, (char *)state.res_oid);\n\tif (error)\n\t\treturn error;\n\n\t/* Update the location according to the oid obtained */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_truncate(object_location, dir_len);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_oid_pathfmt(object_location->ptr + dir_len, res_oid);\n\n\tobject_location->size += GIT_OID_HEXSZ + 1;\n\tobject_location->ptr[object_location->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int locate_object_short_oid(\n\tgit_buf *object_location,\n\tgit_oid *res_oid,\n\tloose_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tchar *objects_dir = backend->objects_dir;\n\tsize_t dir_len = strlen(objects_dir), alloc_len;\n\tloose_locate_object_state state;\n\tint error;\n\n\t/* prealloc memory for OBJ_DIR/xx/xx..38x..xx */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 3);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(object_location, objects_dir, dir_len);\n\tgit_path_to_dir(object_location);\n\n\t/* save adjusted position at end of dir so it can be restored later */\n\tdir_len = git_buf_len(object_location);\n\n\t/* Convert raw oid to hex formatted oid */\n\tgit_oid_fmt((char *)state.short_oid, short_oid);\n\n\t/* Explore OBJ_DIR/xx/ where xx is the beginning of hex formatted short oid */\n\tif (git_buf_put(object_location, (char *)state.short_oid, 3) < 0)\n\t\treturn -1;\n\tobject_location->ptr[object_location->size - 1] = '/';\n\n\t/* Check that directory exists */\n\tif (git_path_isdir(object_location->ptr) == false)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tstate.dir_len = git_buf_len(object_location);\n\tstate.short_oid_len = len;\n\tstate.found = 0;\n\n\t/* Explore directory to find a unique object matching short_oid */\n\terror = git_path_direach(\n\t\tobject_location, 0, fn_locate_object_short_oid, &state);\n\tif (error < 0 && error != GIT_EAMBIGUOUS)\n\t\treturn error;\n\n\tif (!state.found)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tif (state.found > 1)\n\t\treturn git_odb__error_ambiguous(\"multiple matches in loose objects\");\n\n\t/* Convert obtained hex formatted oid to raw */\n\terror = git_oid_fromstr(res_oid, (char *)state.res_oid);\n\tif (error)\n\t\treturn error;\n\n\t/* Update the location according to the oid obtained */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_truncate(object_location, dir_len);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_oid_pathfmt(object_location->ptr + dir_len, res_oid);\n\n\tobject_location->size += GIT_OID_HEXSZ + 1;\n\tobject_location->ptr[object_location->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend && short_oid"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "out_oid",
            "short_oid"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_backend__read",
          "args": [
            "buffer_p",
            "len_p",
            "type_p",
            "backend",
            "short_oid"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "loose_backend__read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "631-651",
          "snippet": "static int loose_backend__read(void **buffer_p, size_t *len_p, git_otype *type_p, git_odb_backend *backend, const git_oid *oid)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tgit_rawobj raw;\n\tint error = 0;\n\n\tassert(backend && oid);\n\n\tif (locate_object(&object_path, (loose_backend *)backend, oid) < 0) {\n\t\terror = git_odb__error_notfound(\"no matching loose object\",\n\t\t\toid, GIT_OID_HEXSZ);\n\t} else if ((error = read_loose(&raw, &object_path)) == 0) {\n\t\t*buffer_p = raw.data;\n\t\t*len_p = raw.len;\n\t\t*type_p = raw.type;\n\t}\n\n\tgit_buf_free(&object_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__read(void **buffer_p, size_t *len_p, git_otype *type_p, git_odb_backend *backend, const git_oid *oid)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tgit_rawobj raw;\n\tint error = 0;\n\n\tassert(backend && oid);\n\n\tif (locate_object(&object_path, (loose_backend *)backend, oid) < 0) {\n\t\terror = git_odb__error_notfound(\"no matching loose object\",\n\t\t\toid, GIT_OID_HEXSZ);\n\t} else if ((error = read_loose(&raw, &object_path)) == 0) {\n\t\t*buffer_p = raw.data;\n\t\t*len_p = raw.len;\n\t\t*type_p = raw.type;\n\t}\n\n\tgit_buf_free(&object_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len >= GIT_OID_MINPREFIXLEN && len <= GIT_OID_HEXSZ"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__read_prefix(\n\tgit_oid *out_oid,\n\tvoid **buffer_p,\n\tsize_t *len_p,\n\tgit_otype *type_p,\n\tgit_odb_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error = 0;\n\n\tassert(len >= GIT_OID_MINPREFIXLEN && len <= GIT_OID_HEXSZ);\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\t/* We can fall back to regular read method */\n\t\terror = loose_backend__read(buffer_p, len_p, type_p, backend, short_oid);\n\t\tif (!error)\n\t\t\tgit_oid_cpy(out_oid, short_oid);\n\t} else {\n\t\tgit_buf object_path = GIT_BUF_INIT;\n\t\tgit_rawobj raw;\n\n\t\tassert(backend && short_oid);\n\n\t\tif ((error = locate_object_short_oid(&object_path, out_oid,\n\t\t\t\t(loose_backend *)backend, short_oid, len)) == 0 &&\n\t\t\t(error = read_loose(&raw, &object_path)) == 0)\n\t\t{\n\t\t\t*buffer_p = raw.data;\n\t\t\t*len_p = raw.len;\n\t\t\t*type_p = raw.type;\n\t\t}\n\n\t\tgit_buf_free(&object_path);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "loose_backend__read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "631-651",
    "snippet": "static int loose_backend__read(void **buffer_p, size_t *len_p, git_otype *type_p, git_odb_backend *backend, const git_oid *oid)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tgit_rawobj raw;\n\tint error = 0;\n\n\tassert(backend && oid);\n\n\tif (locate_object(&object_path, (loose_backend *)backend, oid) < 0) {\n\t\terror = git_odb__error_notfound(\"no matching loose object\",\n\t\t\toid, GIT_OID_HEXSZ);\n\t} else if ((error = read_loose(&raw, &object_path)) == 0) {\n\t\t*buffer_p = raw.data;\n\t\t*len_p = raw.len;\n\t\t*type_p = raw.type;\n\t}\n\n\tgit_buf_free(&object_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&object_path"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_loose",
          "args": [
            "&raw",
            "&object_path"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "read_loose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "402-422",
          "snippet": "static int read_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error;\n\tgit_buf obj = GIT_BUF_INIT;\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\tout->len = 0;\n\tout->type = GIT_OBJ_BAD;\n\n\tif (!(error = git_futils_readbuffer(&obj, loc->ptr)))\n\t\terror = inflate_disk_obj(out, &obj);\n\n\tgit_buf_free(&obj);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int read_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error;\n\tgit_buf obj = GIT_BUF_INIT;\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\tout->len = 0;\n\tout->type = GIT_OBJ_BAD;\n\n\tif (!(error = git_futils_readbuffer(&obj, loc->ptr)))\n\t\terror = inflate_disk_obj(out, &obj);\n\n\tgit_buf_free(&obj);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"no matching loose object\"",
            "oid",
            "GIT_OID_HEXSZ"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locate_object",
          "args": [
            "&object_path",
            "(loose_backend *)backend",
            "oid"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "locate_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "471-482",
          "snippet": "static int locate_object(\n\tgit_buf *object_location,\n\tloose_backend *backend,\n\tconst git_oid *oid)\n{\n\tint error = object_file_name(object_location, backend, oid);\n\n\tif (!error && !git_path_exists(object_location->ptr))\n\t\treturn GIT_ENOTFOUND;\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int locate_object(\n\tgit_buf *object_location,\n\tloose_backend *backend,\n\tconst git_oid *oid)\n{\n\tint error = object_file_name(object_location, backend, oid);\n\n\tif (!error && !git_path_exists(object_location->ptr))\n\t\treturn GIT_ENOTFOUND;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend && oid"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__read(void **buffer_p, size_t *len_p, git_otype *type_p, git_odb_backend *backend, const git_oid *oid)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tgit_rawobj raw;\n\tint error = 0;\n\n\tassert(backend && oid);\n\n\tif (locate_object(&object_path, (loose_backend *)backend, oid) < 0) {\n\t\terror = git_odb__error_notfound(\"no matching loose object\",\n\t\t\toid, GIT_OID_HEXSZ);\n\t} else if ((error = read_loose(&raw, &object_path)) == 0) {\n\t\t*buffer_p = raw.data;\n\t\t*len_p = raw.len;\n\t\t*type_p = raw.type;\n\t}\n\n\tgit_buf_free(&object_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "loose_backend__read_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "607-629",
    "snippet": "static int loose_backend__read_header(size_t *len_p, git_otype *type_p, git_odb_backend *backend, const git_oid *oid)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tgit_rawobj raw;\n\tint error;\n\n\tassert(backend && oid);\n\n\traw.len = 0;\n\traw.type = GIT_OBJ_BAD;\n\n\tif (locate_object(&object_path, (loose_backend *)backend, oid) < 0) {\n\t\terror = git_odb__error_notfound(\"no matching loose object\",\n\t\t\toid, GIT_OID_HEXSZ);\n\t} else if ((error = read_header_loose(&raw, &object_path)) == 0) {\n\t\t*len_p = raw.len;\n\t\t*type_p = raw.type;\n\t}\n\n\tgit_buf_free(&object_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&object_path"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_header_loose",
          "args": [
            "&raw",
            "&object_path"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "read_header_loose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "424-469",
          "snippet": "static int read_header_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error = 0, z_return = Z_ERRNO, read_bytes;\n\tgit_file fd;\n\tz_stream zs;\n\tobj_hdr header_obj;\n\tunsigned char raw_buffer[16], inflated_buffer[64];\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\n\tif ((fd = git_futils_open_ro(loc->ptr)) < 0)\n\t\treturn fd;\n\n\tinit_stream(&zs, inflated_buffer, sizeof(inflated_buffer));\n\n\tz_return = inflateInit(&zs);\n\n\twhile (z_return == Z_OK) {\n\t\tif ((read_bytes = p_read(fd, raw_buffer, sizeof(raw_buffer))) > 0) {\n\t\t\tset_stream_input(&zs, raw_buffer, read_bytes);\n\t\t\tz_return = inflate(&zs, 0);\n\t\t} else\n\t\t\tz_return = Z_STREAM_END;\n\t}\n\n\tif ((z_return != Z_STREAM_END && z_return != Z_BUF_ERROR)\n\t\t|| get_object_header(&header_obj, inflated_buffer) == 0\n\t\t|| git_object_typeisloose(header_obj.type) == 0)\n\t{\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to read loose object header\");\n\t\terror = -1;\n\t} else {\n\t\tout->len = header_obj.size;\n\t\tout->type = header_obj.type;\n\t}\n\n\tfinish_inflate(&zs);\n\tp_close(fd);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int read_header_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error = 0, z_return = Z_ERRNO, read_bytes;\n\tgit_file fd;\n\tz_stream zs;\n\tobj_hdr header_obj;\n\tunsigned char raw_buffer[16], inflated_buffer[64];\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\n\tif ((fd = git_futils_open_ro(loc->ptr)) < 0)\n\t\treturn fd;\n\n\tinit_stream(&zs, inflated_buffer, sizeof(inflated_buffer));\n\n\tz_return = inflateInit(&zs);\n\n\twhile (z_return == Z_OK) {\n\t\tif ((read_bytes = p_read(fd, raw_buffer, sizeof(raw_buffer))) > 0) {\n\t\t\tset_stream_input(&zs, raw_buffer, read_bytes);\n\t\t\tz_return = inflate(&zs, 0);\n\t\t} else\n\t\t\tz_return = Z_STREAM_END;\n\t}\n\n\tif ((z_return != Z_STREAM_END && z_return != Z_BUF_ERROR)\n\t\t|| get_object_header(&header_obj, inflated_buffer) == 0\n\t\t|| git_object_typeisloose(header_obj.type) == 0)\n\t{\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to read loose object header\");\n\t\terror = -1;\n\t} else {\n\t\tout->len = header_obj.size;\n\t\tout->type = header_obj.type;\n\t}\n\n\tfinish_inflate(&zs);\n\tp_close(fd);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"no matching loose object\"",
            "oid",
            "GIT_OID_HEXSZ"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locate_object",
          "args": [
            "&object_path",
            "(loose_backend *)backend",
            "oid"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "locate_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "471-482",
          "snippet": "static int locate_object(\n\tgit_buf *object_location,\n\tloose_backend *backend,\n\tconst git_oid *oid)\n{\n\tint error = object_file_name(object_location, backend, oid);\n\n\tif (!error && !git_path_exists(object_location->ptr))\n\t\treturn GIT_ENOTFOUND;\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int locate_object(\n\tgit_buf *object_location,\n\tloose_backend *backend,\n\tconst git_oid *oid)\n{\n\tint error = object_file_name(object_location, backend, oid);\n\n\tif (!error && !git_path_exists(object_location->ptr))\n\t\treturn GIT_ENOTFOUND;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend && oid"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int loose_backend__read_header(size_t *len_p, git_otype *type_p, git_odb_backend *backend, const git_oid *oid)\n{\n\tgit_buf object_path = GIT_BUF_INIT;\n\tgit_rawobj raw;\n\tint error;\n\n\tassert(backend && oid);\n\n\traw.len = 0;\n\traw.type = GIT_OBJ_BAD;\n\n\tif (locate_object(&object_path, (loose_backend *)backend, oid) < 0) {\n\t\terror = git_odb__error_notfound(\"no matching loose object\",\n\t\t\toid, GIT_OID_HEXSZ);\n\t} else if ((error = read_header_loose(&raw, &object_path)) == 0) {\n\t\t*len_p = raw.len;\n\t\t*type_p = raw.type;\n\t}\n\n\tgit_buf_free(&object_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "locate_object_short_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "516-589",
    "snippet": "static int locate_object_short_oid(\n\tgit_buf *object_location,\n\tgit_oid *res_oid,\n\tloose_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tchar *objects_dir = backend->objects_dir;\n\tsize_t dir_len = strlen(objects_dir), alloc_len;\n\tloose_locate_object_state state;\n\tint error;\n\n\t/* prealloc memory for OBJ_DIR/xx/xx..38x..xx */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 3);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(object_location, objects_dir, dir_len);\n\tgit_path_to_dir(object_location);\n\n\t/* save adjusted position at end of dir so it can be restored later */\n\tdir_len = git_buf_len(object_location);\n\n\t/* Convert raw oid to hex formatted oid */\n\tgit_oid_fmt((char *)state.short_oid, short_oid);\n\n\t/* Explore OBJ_DIR/xx/ where xx is the beginning of hex formatted short oid */\n\tif (git_buf_put(object_location, (char *)state.short_oid, 3) < 0)\n\t\treturn -1;\n\tobject_location->ptr[object_location->size - 1] = '/';\n\n\t/* Check that directory exists */\n\tif (git_path_isdir(object_location->ptr) == false)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tstate.dir_len = git_buf_len(object_location);\n\tstate.short_oid_len = len;\n\tstate.found = 0;\n\n\t/* Explore directory to find a unique object matching short_oid */\n\terror = git_path_direach(\n\t\tobject_location, 0, fn_locate_object_short_oid, &state);\n\tif (error < 0 && error != GIT_EAMBIGUOUS)\n\t\treturn error;\n\n\tif (!state.found)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tif (state.found > 1)\n\t\treturn git_odb__error_ambiguous(\"multiple matches in loose objects\");\n\n\t/* Convert obtained hex formatted oid to raw */\n\terror = git_oid_fromstr(res_oid, (char *)state.res_oid);\n\tif (error)\n\t\treturn error;\n\n\t/* Update the location according to the oid obtained */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_truncate(object_location, dir_len);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_oid_pathfmt(object_location->ptr + dir_len, res_oid);\n\n\tobject_location->size += GIT_OID_HEXSZ + 1;\n\tobject_location->ptr[object_location->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_pathfmt",
          "args": [
            "object_location->ptr + dir_len",
            "res_oid"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_pathfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "93-101",
          "snippet": "void git_oid_pathfmt(char *str, const git_oid *oid)\n{\n\tsize_t i;\n\n\tstr = fmt_one(str, oid->id[0]);\n\t*str++ = '/';\n\tfor (i = 1; i < sizeof(oid->id); i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_pathfmt(char *str, const git_oid *oid)\n{\n\tsize_t i;\n\n\tstr = fmt_one(str, oid->id[0]);\n\t*str++ = '/';\n\tfor (i = 1; i < sizeof(oid->id); i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "object_location",
            "alloc_len"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "object_location",
            "dir_len"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "alloc_len",
            "2"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "dir_len",
            "GIT_OID_HEXSZ"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_fromstr",
          "args": [
            "res_oid",
            "(char *)state.res_oid"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "54-57",
          "snippet": "int git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_ambiguous",
          "args": [
            "\"multiple matches in loose objects\""
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_ambiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1234-1238",
          "snippet": "int git_odb__error_ambiguous(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Ambiguous SHA1 prefix - %s\", message);\n\treturn GIT_EAMBIGUOUS;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_ambiguous(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Ambiguous SHA1 prefix - %s\", message);\n\treturn GIT_EAMBIGUOUS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"no matching loose object for prefix\"",
            "short_oid",
            "len"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_direach",
          "args": [
            "object_location",
            "0",
            "fn_locate_object_short_oid",
            "&state"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_direach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1023-1094",
          "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "object_location"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "object_location->ptr"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "object_location",
            "(char *)state.short_oid",
            "3"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fmt",
          "args": [
            "(char *)state.short_oid",
            "short_oid"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "88-91",
          "snippet": "void git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "object_location"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "object_location",
            "objects_dir",
            "dir_len"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "alloc_len",
            "3"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "dir_len",
            "GIT_OID_HEXSZ"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "objects_dir"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int locate_object_short_oid(\n\tgit_buf *object_location,\n\tgit_oid *res_oid,\n\tloose_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tchar *objects_dir = backend->objects_dir;\n\tsize_t dir_len = strlen(objects_dir), alloc_len;\n\tloose_locate_object_state state;\n\tint error;\n\n\t/* prealloc memory for OBJ_DIR/xx/xx..38x..xx */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 3);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(object_location, objects_dir, dir_len);\n\tgit_path_to_dir(object_location);\n\n\t/* save adjusted position at end of dir so it can be restored later */\n\tdir_len = git_buf_len(object_location);\n\n\t/* Convert raw oid to hex formatted oid */\n\tgit_oid_fmt((char *)state.short_oid, short_oid);\n\n\t/* Explore OBJ_DIR/xx/ where xx is the beginning of hex formatted short oid */\n\tif (git_buf_put(object_location, (char *)state.short_oid, 3) < 0)\n\t\treturn -1;\n\tobject_location->ptr[object_location->size - 1] = '/';\n\n\t/* Check that directory exists */\n\tif (git_path_isdir(object_location->ptr) == false)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tstate.dir_len = git_buf_len(object_location);\n\tstate.short_oid_len = len;\n\tstate.found = 0;\n\n\t/* Explore directory to find a unique object matching short_oid */\n\terror = git_path_direach(\n\t\tobject_location, 0, fn_locate_object_short_oid, &state);\n\tif (error < 0 && error != GIT_EAMBIGUOUS)\n\t\treturn error;\n\n\tif (!state.found)\n\t\treturn git_odb__error_notfound(\"no matching loose object for prefix\",\n\t\t\tshort_oid, len);\n\n\tif (state.found > 1)\n\t\treturn git_odb__error_ambiguous(\"multiple matches in loose objects\");\n\n\t/* Convert obtained hex formatted oid to raw */\n\terror = git_oid_fromstr(res_oid, (char *)state.res_oid);\n\tif (error)\n\t\treturn error;\n\n\t/* Update the location according to the oid obtained */\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, dir_len, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_truncate(object_location, dir_len);\n\tif (git_buf_grow(object_location, alloc_len) < 0)\n\t\treturn -1;\n\n\tgit_oid_pathfmt(object_location->ptr + dir_len, res_oid);\n\n\tobject_location->size += GIT_OID_HEXSZ + 1;\n\tobject_location->ptr[object_location->size] = '\\0';\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fn_locate_object_short_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "485-513",
    "snippet": "static int fn_locate_object_short_oid(void *state, git_buf *pathbuf) {\n\tloose_locate_object_state *sstate = (loose_locate_object_state *)state;\n\n\tif (git_buf_len(pathbuf) - sstate->dir_len != GIT_OID_HEXSZ - 2) {\n\t\t/* Entry cannot be an object. Continue to next entry */\n\t\treturn 0;\n\t}\n\n\tif (git_path_isdir(pathbuf->ptr) == false) {\n\t\t/* We are already in the directory matching the 2 first hex characters,\n\t\t * compare the first ncmp characters of the oids */\n\t\tif (!memcmp(sstate->short_oid + 2,\n\t\t\t(unsigned char *)pathbuf->ptr + sstate->dir_len,\n\t\t\tsstate->short_oid_len - 2)) {\n\n\t\t\tif (!sstate->found) {\n\t\t\t\tsstate->res_oid[0] = sstate->short_oid[0];\n\t\t\t\tsstate->res_oid[1] = sstate->short_oid[1];\n\t\t\t\tmemcpy(sstate->res_oid+2, pathbuf->ptr+sstate->dir_len, GIT_OID_HEXSZ-2);\n\t\t\t}\n\t\t\tsstate->found++;\n\t\t}\n\t}\n\n\tif (sstate->found > 1)\n\t\treturn GIT_EAMBIGUOUS;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sstate->res_oid+2",
            "pathbuf->ptr+sstate->dir_len",
            "GIT_OID_HEXSZ-2"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sstate->short_oid + 2",
            "(unsigned char *)pathbuf->ptr + sstate->dir_len",
            "sstate->short_oid_len - 2"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "pathbuf->ptr"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "pathbuf"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int fn_locate_object_short_oid(void *state, git_buf *pathbuf) {\n\tloose_locate_object_state *sstate = (loose_locate_object_state *)state;\n\n\tif (git_buf_len(pathbuf) - sstate->dir_len != GIT_OID_HEXSZ - 2) {\n\t\t/* Entry cannot be an object. Continue to next entry */\n\t\treturn 0;\n\t}\n\n\tif (git_path_isdir(pathbuf->ptr) == false) {\n\t\t/* We are already in the directory matching the 2 first hex characters,\n\t\t * compare the first ncmp characters of the oids */\n\t\tif (!memcmp(sstate->short_oid + 2,\n\t\t\t(unsigned char *)pathbuf->ptr + sstate->dir_len,\n\t\t\tsstate->short_oid_len - 2)) {\n\n\t\t\tif (!sstate->found) {\n\t\t\t\tsstate->res_oid[0] = sstate->short_oid[0];\n\t\t\t\tsstate->res_oid[1] = sstate->short_oid[1];\n\t\t\t\tmemcpy(sstate->res_oid+2, pathbuf->ptr+sstate->dir_len, GIT_OID_HEXSZ-2);\n\t\t\t}\n\t\t\tsstate->found++;\n\t\t}\n\t}\n\n\tif (sstate->found > 1)\n\t\treturn GIT_EAMBIGUOUS;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "locate_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "471-482",
    "snippet": "static int locate_object(\n\tgit_buf *object_location,\n\tloose_backend *backend,\n\tconst git_oid *oid)\n{\n\tint error = object_file_name(object_location, backend, oid);\n\n\tif (!error && !git_path_exists(object_location->ptr))\n\t\treturn GIT_ENOTFOUND;\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "object_location->ptr"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_file_name",
          "args": [
            "object_location",
            "backend",
            "oid"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "object_file_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "63-83",
          "snippet": "static int object_file_name(\n\tgit_buf *name, const loose_backend *be, const git_oid *id)\n{\n\tsize_t alloclen;\n\n\t/* expand length for object root + 40 hex sha1 chars + 2 * '/' + '\\0' */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, be->objects_dirlen, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 3);\n\tif (git_buf_grow(name, alloclen) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(name, be->objects_dir, be->objects_dirlen);\n\tgit_path_to_dir(name);\n\n\t/* loose object filename: aa/aaa... (41 bytes) */\n\tgit_oid_pathfmt(name->ptr + name->size, id);\n\tname->size += GIT_OID_HEXSZ + 1;\n\tname->ptr[name->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int object_file_name(\n\tgit_buf *name, const loose_backend *be, const git_oid *id)\n{\n\tsize_t alloclen;\n\n\t/* expand length for object root + 40 hex sha1 chars + 2 * '/' + '\\0' */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, be->objects_dirlen, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 3);\n\tif (git_buf_grow(name, alloclen) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(name, be->objects_dir, be->objects_dirlen);\n\tgit_path_to_dir(name);\n\n\t/* loose object filename: aa/aaa... (41 bytes) */\n\tgit_oid_pathfmt(name->ptr + name->size, id);\n\tname->size += GIT_OID_HEXSZ + 1;\n\tname->ptr[name->size] = '\\0';\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int locate_object(\n\tgit_buf *object_location,\n\tloose_backend *backend,\n\tconst git_oid *oid)\n{\n\tint error = object_file_name(object_location, backend, oid);\n\n\tif (!error && !git_path_exists(object_location->ptr))\n\t\treturn GIT_ENOTFOUND;\n\n\treturn error;\n}"
  },
  {
    "function_name": "read_header_loose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "424-469",
    "snippet": "static int read_header_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error = 0, z_return = Z_ERRNO, read_bytes;\n\tgit_file fd;\n\tz_stream zs;\n\tobj_hdr header_obj;\n\tunsigned char raw_buffer[16], inflated_buffer[64];\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\n\tif ((fd = git_futils_open_ro(loc->ptr)) < 0)\n\t\treturn fd;\n\n\tinit_stream(&zs, inflated_buffer, sizeof(inflated_buffer));\n\n\tz_return = inflateInit(&zs);\n\n\twhile (z_return == Z_OK) {\n\t\tif ((read_bytes = p_read(fd, raw_buffer, sizeof(raw_buffer))) > 0) {\n\t\t\tset_stream_input(&zs, raw_buffer, read_bytes);\n\t\t\tz_return = inflate(&zs, 0);\n\t\t} else\n\t\t\tz_return = Z_STREAM_END;\n\t}\n\n\tif ((z_return != Z_STREAM_END && z_return != Z_BUF_ERROR)\n\t\t|| get_object_header(&header_obj, inflated_buffer) == 0\n\t\t|| git_object_typeisloose(header_obj.type) == 0)\n\t{\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to read loose object header\");\n\t\terror = -1;\n\t} else {\n\t\tout->len = header_obj.size;\n\t\tout->type = header_obj.type;\n\t}\n\n\tfinish_inflate(&zs);\n\tp_close(fd);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_inflate",
          "args": [
            "&zs"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "finish_inflate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "207-222",
          "snippet": "static int finish_inflate(z_stream *s)\n{\n\tint status = Z_OK;\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(s, Z_FINISH);\n\n\tinflateEnd(s);\n\n\tif ((status != Z_STREAM_END) || (s->avail_in != 0)) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to finish ZLib inflation. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int finish_inflate(z_stream *s)\n{\n\tint status = Z_OK;\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(s, Z_FINISH);\n\n\tinflateEnd(s);\n\n\tif ((status != Z_STREAM_END) || (s->avail_in != 0)) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to finish ZLib inflation. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ZLIB",
            "\"Failed to read loose object header\""
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_typeisloose",
          "args": [
            "header_obj.type"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_object_header",
          "args": [
            "&header_obj",
            "inflated_buffer"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "get_object_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "120-164",
          "snippet": "static size_t get_object_header(obj_hdr *hdr, unsigned char *data)\n{\n\tchar c, typename[10];\n\tsize_t size, used = 0;\n\n\t/*\n\t * type name string followed by space.\n\t */\n\twhile ((c = data[used]) != ' ') {\n\t\ttypename[used++] = c;\n\t\tif (used >= sizeof(typename))\n\t\t\treturn 0;\n\t}\n\ttypename[used] = 0;\n\tif (used == 0)\n\t\treturn 0;\n\thdr->type = git_object_string2type(typename);\n\tused++; /* consume the space */\n\n\t/*\n\t * length follows immediately in decimal (without\n\t * leading zeros).\n\t */\n\tsize = data[used++] - '0';\n\tif (size > 9)\n\t\treturn 0;\n\tif (size) {\n\t\twhile ((c = data[used]) != '\\0') {\n\t\t\tsize_t d = c - '0';\n\t\t\tif (d > 9)\n\t\t\t\tbreak;\n\t\t\tused++;\n\t\t\tsize = size * 10 + d;\n\t\t}\n\t}\n\thdr->size = size;\n\n\t/*\n\t * the length must be followed by a zero byte\n\t */\n\tif (data[used++] != '\\0')\n\t\treturn 0;\n\n\treturn used;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic size_t get_object_header(obj_hdr *hdr, unsigned char *data)\n{\n\tchar c, typename[10];\n\tsize_t size, used = 0;\n\n\t/*\n\t * type name string followed by space.\n\t */\n\twhile ((c = data[used]) != ' ') {\n\t\ttypename[used++] = c;\n\t\tif (used >= sizeof(typename))\n\t\t\treturn 0;\n\t}\n\ttypename[used] = 0;\n\tif (used == 0)\n\t\treturn 0;\n\thdr->type = git_object_string2type(typename);\n\tused++; /* consume the space */\n\n\t/*\n\t * length follows immediately in decimal (without\n\t * leading zeros).\n\t */\n\tsize = data[used++] - '0';\n\tif (size > 9)\n\t\treturn 0;\n\tif (size) {\n\t\twhile ((c = data[used]) != '\\0') {\n\t\t\tsize_t d = c - '0';\n\t\t\tif (d > 9)\n\t\t\t\tbreak;\n\t\t\tused++;\n\t\t\tsize = size * 10 + d;\n\t\t}\n\t}\n\thdr->size = size;\n\n\t/*\n\t * the length must be followed by a zero byte\n\t */\n\tif (data[used++] != '\\0')\n\t\treturn 0;\n\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflate",
          "args": [
            "&zs",
            "0"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_disk_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "348-386",
          "snippet": "static int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_stream_input",
          "args": [
            "&zs",
            "raw_buffer",
            "read_bytes"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "set_stream_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "181-185",
          "snippet": "static void set_stream_input(z_stream *s, void *in, size_t len)\n{\n\ts->next_in = in;\n\ts->avail_in = (uInt)len;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void set_stream_input(z_stream *s, void *in, size_t len)\n{\n\ts->next_in = in;\n\ts->avail_in = (uInt)len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_read",
          "args": [
            "fd",
            "raw_buffer",
            "sizeof(raw_buffer)"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "p_readdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.h",
          "lines": "126-131",
          "snippet": "GIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <netdb.h>",
            "#include \"strnlen.h\"",
            "#\tinclude \"unix/posix.h\"",
            "#\tinclude \"win32/posix.h\"",
            "#include \"fnmatch.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <netdb.h>\n#include \"strnlen.h\"\n#\tinclude \"unix/posix.h\"\n#\tinclude \"win32/posix.h\"\n#include \"fnmatch.h\"\n#include <time.h>\n#include <fcntl.h>\n#include \"common.h\"\n\nGIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflateInit",
          "args": [
            "&zs"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_stream",
          "args": [
            "&zs",
            "inflated_buffer",
            "sizeof(inflated_buffer)"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "init_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "174-179",
          "snippet": "static void init_stream(z_stream *s, void *out, size_t len)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void init_stream(z_stream *s, void *out, size_t len)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "loc->ptr"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "loc"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && loc"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int read_header_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error = 0, z_return = Z_ERRNO, read_bytes;\n\tgit_file fd;\n\tz_stream zs;\n\tobj_hdr header_obj;\n\tunsigned char raw_buffer[16], inflated_buffer[64];\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\n\tif ((fd = git_futils_open_ro(loc->ptr)) < 0)\n\t\treturn fd;\n\n\tinit_stream(&zs, inflated_buffer, sizeof(inflated_buffer));\n\n\tz_return = inflateInit(&zs);\n\n\twhile (z_return == Z_OK) {\n\t\tif ((read_bytes = p_read(fd, raw_buffer, sizeof(raw_buffer))) > 0) {\n\t\t\tset_stream_input(&zs, raw_buffer, read_bytes);\n\t\t\tz_return = inflate(&zs, 0);\n\t\t} else\n\t\t\tz_return = Z_STREAM_END;\n\t}\n\n\tif ((z_return != Z_STREAM_END && z_return != Z_BUF_ERROR)\n\t\t|| get_object_header(&header_obj, inflated_buffer) == 0\n\t\t|| git_object_typeisloose(header_obj.type) == 0)\n\t{\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to read loose object header\");\n\t\terror = -1;\n\t} else {\n\t\tout->len = header_obj.size;\n\t\tout->type = header_obj.type;\n\t}\n\n\tfinish_inflate(&zs);\n\tp_close(fd);\n\n\treturn error;\n}"
  },
  {
    "function_name": "read_loose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "402-422",
    "snippet": "static int read_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error;\n\tgit_buf obj = GIT_BUF_INIT;\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\tout->len = 0;\n\tout->type = GIT_OBJ_BAD;\n\n\tif (!(error = git_futils_readbuffer(&obj, loc->ptr)))\n\t\terror = inflate_disk_obj(out, &obj);\n\n\tgit_buf_free(&obj);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&obj"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflate_disk_obj",
          "args": [
            "out",
            "&obj"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_disk_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "348-386",
          "snippet": "static int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "&obj",
            "loc->ptr"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "loc"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && loc"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int read_loose(git_rawobj *out, git_buf *loc)\n{\n\tint error;\n\tgit_buf obj = GIT_BUF_INIT;\n\n\tassert(out && loc);\n\n\tif (git_buf_oom(loc))\n\t\treturn -1;\n\n\tout->data = NULL;\n\tout->len = 0;\n\tout->type = GIT_OBJ_BAD;\n\n\tif (!(error = git_futils_readbuffer(&obj, loc->ptr)))\n\t\terror = inflate_disk_obj(out, &obj);\n\n\tgit_buf_free(&obj);\n\n\treturn error;\n}"
  },
  {
    "function_name": "inflate_disk_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "348-386",
    "snippet": "static int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inflate_tail",
          "args": [
            "&zs",
            "head",
            "used",
            "&hdr"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "265-302",
          "snippet": "static void *inflate_tail(z_stream *s, void *hb, size_t used, obj_hdr *hdr)\n{\n\tunsigned char *buf, *head = hb;\n\tsize_t tail, alloc_size;\n\n\t/*\n\t * allocate a buffer to hold the inflated data and copy the\n\t * initial sequence of inflated data from the tail of the\n\t * head buffer, if any.\n\t */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, hdr->size, 1) ||\n\t\t(buf = git__malloc(alloc_size)) == NULL) {\n\t\tinflateEnd(s);\n\t\treturn NULL;\n\t}\n\ttail = s->total_out - used;\n\tif (used > 0 && tail > 0) {\n\t\tif (tail > hdr->size)\n\t\t\ttail = hdr->size;\n\t\tmemcpy(buf, head + used, tail);\n\t}\n\tused = tail;\n\n\t/*\n\t * inflate the remainder of the object data, if any\n\t */\n\tif (hdr->size < used)\n\t\tinflateEnd(s);\n\telse {\n\t\tset_stream_output(s, buf + used, hdr->size - used);\n\t\tif (finish_inflate(s)) {\n\t\t\tgit__free(buf);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void *inflate_tail(z_stream *s, void *hb, size_t used, obj_hdr *hdr)\n{\n\tunsigned char *buf, *head = hb;\n\tsize_t tail, alloc_size;\n\n\t/*\n\t * allocate a buffer to hold the inflated data and copy the\n\t * initial sequence of inflated data from the tail of the\n\t * head buffer, if any.\n\t */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, hdr->size, 1) ||\n\t\t(buf = git__malloc(alloc_size)) == NULL) {\n\t\tinflateEnd(s);\n\t\treturn NULL;\n\t}\n\ttail = s->total_out - used;\n\tif (used > 0 && tail > 0) {\n\t\tif (tail > hdr->size)\n\t\t\ttail = hdr->size;\n\t\tmemcpy(buf, head + used, tail);\n\t}\n\tused = tail;\n\n\t/*\n\t * inflate the remainder of the object data, if any\n\t */\n\tif (hdr->size < used)\n\t\tinflateEnd(s);\n\telse {\n\t\tset_stream_output(s, buf + used, hdr->size - used);\n\t\tif (finish_inflate(s)) {\n\t\t\tgit__free(buf);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ODB",
            "\"Failed to inflate disk object.\""
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_typeisloose",
          "args": [
            "hdr.type"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_object_header",
          "args": [
            "&hdr",
            "head"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "get_object_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "120-164",
          "snippet": "static size_t get_object_header(obj_hdr *hdr, unsigned char *data)\n{\n\tchar c, typename[10];\n\tsize_t size, used = 0;\n\n\t/*\n\t * type name string followed by space.\n\t */\n\twhile ((c = data[used]) != ' ') {\n\t\ttypename[used++] = c;\n\t\tif (used >= sizeof(typename))\n\t\t\treturn 0;\n\t}\n\ttypename[used] = 0;\n\tif (used == 0)\n\t\treturn 0;\n\thdr->type = git_object_string2type(typename);\n\tused++; /* consume the space */\n\n\t/*\n\t * length follows immediately in decimal (without\n\t * leading zeros).\n\t */\n\tsize = data[used++] - '0';\n\tif (size > 9)\n\t\treturn 0;\n\tif (size) {\n\t\twhile ((c = data[used]) != '\\0') {\n\t\t\tsize_t d = c - '0';\n\t\t\tif (d > 9)\n\t\t\t\tbreak;\n\t\t\tused++;\n\t\t\tsize = size * 10 + d;\n\t\t}\n\t}\n\thdr->size = size;\n\n\t/*\n\t * the length must be followed by a zero byte\n\t */\n\tif (data[used++] != '\\0')\n\t\treturn 0;\n\n\treturn used;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic size_t get_object_header(obj_hdr *hdr, unsigned char *data)\n{\n\tchar c, typename[10];\n\tsize_t size, used = 0;\n\n\t/*\n\t * type name string followed by space.\n\t */\n\twhile ((c = data[used]) != ' ') {\n\t\ttypename[used++] = c;\n\t\tif (used >= sizeof(typename))\n\t\t\treturn 0;\n\t}\n\ttypename[used] = 0;\n\tif (used == 0)\n\t\treturn 0;\n\thdr->type = git_object_string2type(typename);\n\tused++; /* consume the space */\n\n\t/*\n\t * length follows immediately in decimal (without\n\t * leading zeros).\n\t */\n\tsize = data[used++] - '0';\n\tif (size > 9)\n\t\treturn 0;\n\tif (size) {\n\t\twhile ((c = data[used]) != '\\0') {\n\t\t\tsize_t d = c - '0';\n\t\t\tif (d > 9)\n\t\t\t\tbreak;\n\t\t\tused++;\n\t\t\tsize = size * 10 + d;\n\t\t}\n\t}\n\thdr->size = size;\n\n\t/*\n\t * the length must be followed by a zero byte\n\t */\n\tif (data[used++] != '\\0')\n\t\treturn 0;\n\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_inflate",
          "args": [
            "&zs",
            "obj",
            "head",
            "sizeof(head)"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "start_inflate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "194-205",
          "snippet": "static int start_inflate(z_stream *s, git_buf *obj, void *out, size_t len)\n{\n\tint status;\n\n\tinit_stream(s, out, len);\n\tset_stream_input(s, obj->ptr, git_buf_len(obj));\n\n\tif ((status = inflateInit(s)) < Z_OK)\n\t\treturn status;\n\n\treturn inflate(s, 0);\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int start_inflate(z_stream *s, git_buf *obj, void *out, size_t len)\n{\n\tint status;\n\n\tinit_stream(s, out, len);\n\tset_stream_input(s, obj->ptr, git_buf_len(obj));\n\n\tif ((status = inflateInit(s)) < Z_OK)\n\t\treturn status;\n\n\treturn inflate(s, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflate_packlike_loose_disk_obj",
          "args": [
            "out",
            "obj"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_packlike_loose_disk_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "310-346",
          "snippet": "static int inflate_packlike_loose_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char *in, *buf;\n\tobj_hdr hdr;\n\tsize_t len, used, alloclen;\n\n\t/*\n\t * read the object header, which is an (uncompressed)\n\t * binary encoding of the object type and size.\n\t */\n\tif ((used = get_binary_object_header(&hdr, obj)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type)) {\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate loose object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the data into it\n\t */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, hdr.size, 1);\n\tbuf = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(buf);\n\n\tin = ((unsigned char *)obj->ptr) + used;\n\tlen = obj->size - used;\n\tif (inflate_buffer(in, len, buf, hdr.size) < 0) {\n\t\tgit__free(buf);\n\t\treturn -1;\n\t}\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_packlike_loose_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char *in, *buf;\n\tobj_hdr hdr;\n\tsize_t len, used, alloclen;\n\n\t/*\n\t * read the object header, which is an (uncompressed)\n\t * binary encoding of the object type and size.\n\t */\n\tif ((used = get_binary_object_header(&hdr, obj)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type)) {\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate loose object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the data into it\n\t */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, hdr.size, 1);\n\tbuf = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(buf);\n\n\tin = ((unsigned char *)obj->ptr) + used;\n\tlen = obj->size - used;\n\tif (inflate_buffer(in, len, buf, hdr.size) < 0) {\n\t\tgit__free(buf);\n\t\treturn -1;\n\t}\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zlib_compressed_data",
          "args": [
            "(unsigned char *)obj->ptr"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "is_zlib_compressed_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "224-230",
          "snippet": "static int is_zlib_compressed_data(unsigned char *data)\n{\n\tunsigned int w;\n\n\tw = ((unsigned int)(data[0]) << 8) + data[1];\n\treturn (data[0] & 0x8F) == 0x08 && !(w % 31);\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int is_zlib_compressed_data(unsigned char *data)\n{\n\tunsigned int w;\n\n\tw = ((unsigned int)(data[0]) << 8) + data[1];\n\treturn (data[0] & 0x8F) == 0x08 && !(w % 31);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "inflate_packlike_loose_disk_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "310-346",
    "snippet": "static int inflate_packlike_loose_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char *in, *buf;\n\tobj_hdr hdr;\n\tsize_t len, used, alloclen;\n\n\t/*\n\t * read the object header, which is an (uncompressed)\n\t * binary encoding of the object type and size.\n\t */\n\tif ((used = get_binary_object_header(&hdr, obj)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type)) {\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate loose object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the data into it\n\t */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, hdr.size, 1);\n\tbuf = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(buf);\n\n\tin = ((unsigned char *)obj->ptr) + used;\n\tlen = obj->size - used;\n\tif (inflate_buffer(in, len, buf, hdr.size) < 0) {\n\t\tgit__free(buf);\n\t\treturn -1;\n\t}\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "buf"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflate_buffer",
          "args": [
            "in",
            "len",
            "buf",
            "hdr.size"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "232-263",
          "snippet": "static int inflate_buffer(void *in, size_t inlen, void *out, size_t outlen)\n{\n\tz_stream zs;\n\tint status = Z_OK;\n\n\tmemset(&zs, 0x0, sizeof(zs));\n\n\tzs.next_out = out;\n\tzs.avail_out = (uInt)outlen;\n\n\tzs.next_in = in;\n\tzs.avail_in = (uInt)inlen;\n\n\tif (inflateInit(&zs) < Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to inflate buffer\");\n\t\treturn -1;\n\t}\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(&zs, Z_FINISH);\n\n\tinflateEnd(&zs);\n\n\tif (status != Z_STREAM_END /* || zs.avail_in != 0 */ ||\n\t\tzs.total_out != outlen)\n\t{\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to inflate buffer. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_buffer(void *in, size_t inlen, void *out, size_t outlen)\n{\n\tz_stream zs;\n\tint status = Z_OK;\n\n\tmemset(&zs, 0x0, sizeof(zs));\n\n\tzs.next_out = out;\n\tzs.avail_out = (uInt)outlen;\n\n\tzs.next_in = in;\n\tzs.avail_in = (uInt)inlen;\n\n\tif (inflateInit(&zs) < Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to inflate buffer\");\n\t\treturn -1;\n\t}\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(&zs, Z_FINISH);\n\n\tinflateEnd(&zs);\n\n\tif (status != Z_STREAM_END /* || zs.avail_in != 0 */ ||\n\t\tzs.total_out != outlen)\n\t{\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to inflate buffer. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "buf"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloclen"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "hdr.size",
            "1"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ODB",
            "\"Failed to inflate loose object.\""
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_typeisloose",
          "args": [
            "hdr.type"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_binary_object_header",
          "args": [
            "&hdr",
            "obj"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "get_binary_object_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "92-118",
          "snippet": "static size_t get_binary_object_header(obj_hdr *hdr, git_buf *obj)\n{\n\tunsigned long c;\n\tunsigned char *data = (unsigned char *)obj->ptr;\n\tsize_t shift, size, used = 0;\n\n\tif (git_buf_len(obj) == 0)\n\t\treturn 0;\n\n\tc = data[used++];\n\thdr->type = (c >> 4) & 7;\n\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (git_buf_len(obj) <= used)\n\t\t\treturn 0;\n\t\tif (sizeof(size_t) * 8 <= shift)\n\t\t\treturn 0;\n\t\tc = data[used++];\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\thdr->size = size;\n\n\treturn used;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic size_t get_binary_object_header(obj_hdr *hdr, git_buf *obj)\n{\n\tunsigned long c;\n\tunsigned char *data = (unsigned char *)obj->ptr;\n\tsize_t shift, size, used = 0;\n\n\tif (git_buf_len(obj) == 0)\n\t\treturn 0;\n\n\tc = data[used++];\n\thdr->type = (c >> 4) & 7;\n\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (git_buf_len(obj) <= used)\n\t\t\treturn 0;\n\t\tif (sizeof(size_t) * 8 <= shift)\n\t\t\treturn 0;\n\t\tc = data[used++];\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\thdr->size = size;\n\n\treturn used;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_packlike_loose_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char *in, *buf;\n\tobj_hdr hdr;\n\tsize_t len, used, alloclen;\n\n\t/*\n\t * read the object header, which is an (uncompressed)\n\t * binary encoding of the object type and size.\n\t */\n\tif ((used = get_binary_object_header(&hdr, obj)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type)) {\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate loose object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the data into it\n\t */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, hdr.size, 1);\n\tbuf = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(buf);\n\n\tin = ((unsigned char *)obj->ptr) + used;\n\tlen = obj->size - used;\n\tif (inflate_buffer(in, len, buf, hdr.size) < 0) {\n\t\tgit__free(buf);\n\t\treturn -1;\n\t}\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "inflate_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "265-302",
    "snippet": "static void *inflate_tail(z_stream *s, void *hb, size_t used, obj_hdr *hdr)\n{\n\tunsigned char *buf, *head = hb;\n\tsize_t tail, alloc_size;\n\n\t/*\n\t * allocate a buffer to hold the inflated data and copy the\n\t * initial sequence of inflated data from the tail of the\n\t * head buffer, if any.\n\t */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, hdr->size, 1) ||\n\t\t(buf = git__malloc(alloc_size)) == NULL) {\n\t\tinflateEnd(s);\n\t\treturn NULL;\n\t}\n\ttail = s->total_out - used;\n\tif (used > 0 && tail > 0) {\n\t\tif (tail > hdr->size)\n\t\t\ttail = hdr->size;\n\t\tmemcpy(buf, head + used, tail);\n\t}\n\tused = tail;\n\n\t/*\n\t * inflate the remainder of the object data, if any\n\t */\n\tif (hdr->size < used)\n\t\tinflateEnd(s);\n\telse {\n\t\tset_stream_output(s, buf + used, hdr->size - used);\n\t\tif (finish_inflate(s)) {\n\t\t\tgit__free(buf);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn buf;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "buf"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_inflate",
          "args": [
            "s"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "finish_inflate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "207-222",
          "snippet": "static int finish_inflate(z_stream *s)\n{\n\tint status = Z_OK;\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(s, Z_FINISH);\n\n\tinflateEnd(s);\n\n\tif ((status != Z_STREAM_END) || (s->avail_in != 0)) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to finish ZLib inflation. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int finish_inflate(z_stream *s)\n{\n\tint status = Z_OK;\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(s, Z_FINISH);\n\n\tinflateEnd(s);\n\n\tif ((status != Z_STREAM_END) || (s->avail_in != 0)) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to finish ZLib inflation. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_stream_output",
          "args": [
            "s",
            "buf + used",
            "hdr->size - used"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "set_stream_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "187-191",
          "snippet": "static void set_stream_output(z_stream *s, void *out, size_t len)\n{\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void set_stream_output(z_stream *s, void *out, size_t len)\n{\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflateEnd",
          "args": [
            "s"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "head + used",
            "tail"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inflateEnd",
          "args": [
            "s"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloc_size"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloc_size",
            "hdr->size",
            "1"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void *inflate_tail(z_stream *s, void *hb, size_t used, obj_hdr *hdr)\n{\n\tunsigned char *buf, *head = hb;\n\tsize_t tail, alloc_size;\n\n\t/*\n\t * allocate a buffer to hold the inflated data and copy the\n\t * initial sequence of inflated data from the tail of the\n\t * head buffer, if any.\n\t */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, hdr->size, 1) ||\n\t\t(buf = git__malloc(alloc_size)) == NULL) {\n\t\tinflateEnd(s);\n\t\treturn NULL;\n\t}\n\ttail = s->total_out - used;\n\tif (used > 0 && tail > 0) {\n\t\tif (tail > hdr->size)\n\t\t\ttail = hdr->size;\n\t\tmemcpy(buf, head + used, tail);\n\t}\n\tused = tail;\n\n\t/*\n\t * inflate the remainder of the object data, if any\n\t */\n\tif (hdr->size < used)\n\t\tinflateEnd(s);\n\telse {\n\t\tset_stream_output(s, buf + used, hdr->size - used);\n\t\tif (finish_inflate(s)) {\n\t\t\tgit__free(buf);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn buf;\n}"
  },
  {
    "function_name": "inflate_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "232-263",
    "snippet": "static int inflate_buffer(void *in, size_t inlen, void *out, size_t outlen)\n{\n\tz_stream zs;\n\tint status = Z_OK;\n\n\tmemset(&zs, 0x0, sizeof(zs));\n\n\tzs.next_out = out;\n\tzs.avail_out = (uInt)outlen;\n\n\tzs.next_in = in;\n\tzs.avail_in = (uInt)inlen;\n\n\tif (inflateInit(&zs) < Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to inflate buffer\");\n\t\treturn -1;\n\t}\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(&zs, Z_FINISH);\n\n\tinflateEnd(&zs);\n\n\tif (status != Z_STREAM_END /* || zs.avail_in != 0 */ ||\n\t\tzs.total_out != outlen)\n\t{\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to inflate buffer. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ZLIB",
            "\"Failed to inflate buffer. Stream aborted prematurely\""
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflateEnd",
          "args": [
            "&zs"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inflate",
          "args": [
            "&zs",
            "Z_FINISH"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_disk_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "348-386",
          "snippet": "static int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflateInit",
          "args": [
            "&zs"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&zs",
            "0x0",
            "sizeof(zs)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_buffer(void *in, size_t inlen, void *out, size_t outlen)\n{\n\tz_stream zs;\n\tint status = Z_OK;\n\n\tmemset(&zs, 0x0, sizeof(zs));\n\n\tzs.next_out = out;\n\tzs.avail_out = (uInt)outlen;\n\n\tzs.next_in = in;\n\tzs.avail_in = (uInt)inlen;\n\n\tif (inflateInit(&zs) < Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to inflate buffer\");\n\t\treturn -1;\n\t}\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(&zs, Z_FINISH);\n\n\tinflateEnd(&zs);\n\n\tif (status != Z_STREAM_END /* || zs.avail_in != 0 */ ||\n\t\tzs.total_out != outlen)\n\t{\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to inflate buffer. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_zlib_compressed_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "224-230",
    "snippet": "static int is_zlib_compressed_data(unsigned char *data)\n{\n\tunsigned int w;\n\n\tw = ((unsigned int)(data[0]) << 8) + data[1];\n\treturn (data[0] & 0x8F) == 0x08 && !(w % 31);\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int is_zlib_compressed_data(unsigned char *data)\n{\n\tunsigned int w;\n\n\tw = ((unsigned int)(data[0]) << 8) + data[1];\n\treturn (data[0] & 0x8F) == 0x08 && !(w % 31);\n}"
  },
  {
    "function_name": "finish_inflate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "207-222",
    "snippet": "static int finish_inflate(z_stream *s)\n{\n\tint status = Z_OK;\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(s, Z_FINISH);\n\n\tinflateEnd(s);\n\n\tif ((status != Z_STREAM_END) || (s->avail_in != 0)) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to finish ZLib inflation. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ZLIB",
            "\"Failed to finish ZLib inflation. Stream aborted prematurely\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflateEnd",
          "args": [
            "s"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inflate",
          "args": [
            "s",
            "Z_FINISH"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_disk_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "348-386",
          "snippet": "static int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int finish_inflate(z_stream *s)\n{\n\tint status = Z_OK;\n\n\twhile (status == Z_OK)\n\t\tstatus = inflate(s, Z_FINISH);\n\n\tinflateEnd(s);\n\n\tif ((status != Z_STREAM_END) || (s->avail_in != 0)) {\n\t\tgiterr_set(GITERR_ZLIB, \"Failed to finish ZLib inflation. Stream aborted prematurely\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "start_inflate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "194-205",
    "snippet": "static int start_inflate(z_stream *s, git_buf *obj, void *out, size_t len)\n{\n\tint status;\n\n\tinit_stream(s, out, len);\n\tset_stream_input(s, obj->ptr, git_buf_len(obj));\n\n\tif ((status = inflateInit(s)) < Z_OK)\n\t\treturn status;\n\n\treturn inflate(s, 0);\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inflate",
          "args": [
            "s",
            "0"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_disk_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "348-386",
          "snippet": "static int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflateInit",
          "args": [
            "s"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_stream_input",
          "args": [
            "s",
            "obj->ptr",
            "git_buf_len(obj)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "set_stream_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "181-185",
          "snippet": "static void set_stream_input(z_stream *s, void *in, size_t len)\n{\n\ts->next_in = in;\n\ts->avail_in = (uInt)len;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void set_stream_input(z_stream *s, void *in, size_t len)\n{\n\ts->next_in = in;\n\ts->avail_in = (uInt)len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "obj"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_stream",
          "args": [
            "s",
            "out",
            "len"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "init_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "174-179",
          "snippet": "static void init_stream(z_stream *s, void *out, size_t len)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void init_stream(z_stream *s, void *out, size_t len)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int start_inflate(z_stream *s, git_buf *obj, void *out, size_t len)\n{\n\tint status;\n\n\tinit_stream(s, out, len);\n\tset_stream_input(s, obj->ptr, git_buf_len(obj));\n\n\tif ((status = inflateInit(s)) < Z_OK)\n\t\treturn status;\n\n\treturn inflate(s, 0);\n}"
  },
  {
    "function_name": "set_stream_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "187-191",
    "snippet": "static void set_stream_output(z_stream *s, void *out, size_t len)\n{\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void set_stream_output(z_stream *s, void *out, size_t len)\n{\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}"
  },
  {
    "function_name": "set_stream_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "181-185",
    "snippet": "static void set_stream_input(z_stream *s, void *in, size_t len)\n{\n\ts->next_in = in;\n\ts->avail_in = (uInt)len;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void set_stream_input(z_stream *s, void *in, size_t len)\n{\n\ts->next_in = in;\n\ts->avail_in = (uInt)len;\n}"
  },
  {
    "function_name": "init_stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "174-179",
    "snippet": "static void init_stream(z_stream *s, void *out, size_t len)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "s",
            "0",
            "sizeof(*s)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void init_stream(z_stream *s, void *out, size_t len)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->next_out = out;\n\ts->avail_out = (uInt)len;\n}"
  },
  {
    "function_name": "get_object_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "120-164",
    "snippet": "static size_t get_object_header(obj_hdr *hdr, unsigned char *data)\n{\n\tchar c, typename[10];\n\tsize_t size, used = 0;\n\n\t/*\n\t * type name string followed by space.\n\t */\n\twhile ((c = data[used]) != ' ') {\n\t\ttypename[used++] = c;\n\t\tif (used >= sizeof(typename))\n\t\t\treturn 0;\n\t}\n\ttypename[used] = 0;\n\tif (used == 0)\n\t\treturn 0;\n\thdr->type = git_object_string2type(typename);\n\tused++; /* consume the space */\n\n\t/*\n\t * length follows immediately in decimal (without\n\t * leading zeros).\n\t */\n\tsize = data[used++] - '0';\n\tif (size > 9)\n\t\treturn 0;\n\tif (size) {\n\t\twhile ((c = data[used]) != '\\0') {\n\t\t\tsize_t d = c - '0';\n\t\t\tif (d > 9)\n\t\t\t\tbreak;\n\t\t\tused++;\n\t\t\tsize = size * 10 + d;\n\t\t}\n\t}\n\thdr->size = size;\n\n\t/*\n\t * the length must be followed by a zero byte\n\t */\n\tif (data[used++] != '\\0')\n\t\treturn 0;\n\n\treturn used;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_string2type",
          "args": [
            "typename"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_string2type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "235-247",
          "snippet": "git_otype git_object_string2type(const char *str)\n{\n\tsize_t i;\n\n\tif (!str || !*str)\n\t\treturn GIT_OBJ_BAD;\n\n\tfor (i = 0; i < ARRAY_SIZE(git_objects_table); i++)\n\t\tif (!strcmp(str, git_objects_table[i].str))\n\t\t\treturn (git_otype)i;\n\n\treturn GIT_OBJ_BAD;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\ngit_otype git_object_string2type(const char *str)\n{\n\tsize_t i;\n\n\tif (!str || !*str)\n\t\treturn GIT_OBJ_BAD;\n\n\tfor (i = 0; i < ARRAY_SIZE(git_objects_table); i++)\n\t\tif (!strcmp(str, git_objects_table[i].str))\n\t\t\treturn (git_otype)i;\n\n\treturn GIT_OBJ_BAD;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic size_t get_object_header(obj_hdr *hdr, unsigned char *data)\n{\n\tchar c, typename[10];\n\tsize_t size, used = 0;\n\n\t/*\n\t * type name string followed by space.\n\t */\n\twhile ((c = data[used]) != ' ') {\n\t\ttypename[used++] = c;\n\t\tif (used >= sizeof(typename))\n\t\t\treturn 0;\n\t}\n\ttypename[used] = 0;\n\tif (used == 0)\n\t\treturn 0;\n\thdr->type = git_object_string2type(typename);\n\tused++; /* consume the space */\n\n\t/*\n\t * length follows immediately in decimal (without\n\t * leading zeros).\n\t */\n\tsize = data[used++] - '0';\n\tif (size > 9)\n\t\treturn 0;\n\tif (size) {\n\t\twhile ((c = data[used]) != '\\0') {\n\t\t\tsize_t d = c - '0';\n\t\t\tif (d > 9)\n\t\t\t\tbreak;\n\t\t\tused++;\n\t\t\tsize = size * 10 + d;\n\t\t}\n\t}\n\thdr->size = size;\n\n\t/*\n\t * the length must be followed by a zero byte\n\t */\n\tif (data[used++] != '\\0')\n\t\treturn 0;\n\n\treturn used;\n}"
  },
  {
    "function_name": "get_binary_object_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "92-118",
    "snippet": "static size_t get_binary_object_header(obj_hdr *hdr, git_buf *obj)\n{\n\tunsigned long c;\n\tunsigned char *data = (unsigned char *)obj->ptr;\n\tsize_t shift, size, used = 0;\n\n\tif (git_buf_len(obj) == 0)\n\t\treturn 0;\n\n\tc = data[used++];\n\thdr->type = (c >> 4) & 7;\n\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (git_buf_len(obj) <= used)\n\t\t\treturn 0;\n\t\tif (sizeof(size_t) * 8 <= shift)\n\t\t\treturn 0;\n\t\tc = data[used++];\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\thdr->size = size;\n\n\treturn used;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "obj"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic size_t get_binary_object_header(obj_hdr *hdr, git_buf *obj)\n{\n\tunsigned long c;\n\tunsigned char *data = (unsigned char *)obj->ptr;\n\tsize_t shift, size, used = 0;\n\n\tif (git_buf_len(obj) == 0)\n\t\treturn 0;\n\n\tc = data[used++];\n\thdr->type = (c >> 4) & 7;\n\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (git_buf_len(obj) <= used)\n\t\t\treturn 0;\n\t\tif (sizeof(size_t) * 8 <= shift)\n\t\t\treturn 0;\n\t\tc = data[used++];\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\thdr->size = size;\n\n\treturn used;\n}"
  },
  {
    "function_name": "object_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "85-90",
    "snippet": "static int object_mkdir(const git_buf *name, const loose_backend *be)\n{\n\treturn git_futils_mkdir_relative(\n\t\tname->ptr + be->objects_dirlen, be->objects_dir, be->object_dir_mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR, NULL);\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_mkdir_relative",
          "args": [
            "name->ptr + be->objects_dirlen",
            "be->objects_dir",
            "be->object_dir_mode",
            "GIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR",
            "NULL"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkdir_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "498-625",
          "snippet": "int git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int object_mkdir(const git_buf *name, const loose_backend *be)\n{\n\treturn git_futils_mkdir_relative(\n\t\tname->ptr + be->objects_dirlen, be->objects_dir, be->object_dir_mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR, NULL);\n}"
  },
  {
    "function_name": "object_file_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
    "lines": "63-83",
    "snippet": "static int object_file_name(\n\tgit_buf *name, const loose_backend *be, const git_oid *id)\n{\n\tsize_t alloclen;\n\n\t/* expand length for object root + 40 hex sha1 chars + 2 * '/' + '\\0' */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, be->objects_dirlen, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 3);\n\tif (git_buf_grow(name, alloclen) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(name, be->objects_dir, be->objects_dirlen);\n\tgit_path_to_dir(name);\n\n\t/* loose object filename: aa/aaa... (41 bytes) */\n\tgit_oid_pathfmt(name->ptr + name->size, id);\n\tname->size += GIT_OID_HEXSZ + 1;\n\tname->ptr[name->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/types.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"filebuf.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/object.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_pathfmt",
          "args": [
            "name->ptr + name->size",
            "id"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_pathfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "93-101",
          "snippet": "void git_oid_pathfmt(char *str, const git_oid *oid)\n{\n\tsize_t i;\n\n\tstr = fmt_one(str, oid->id[0]);\n\t*str++ = '/';\n\tfor (i = 1; i < sizeof(oid->id); i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_pathfmt(char *str, const git_oid *oid)\n{\n\tsize_t i;\n\n\tstr = fmt_one(str, oid->id[0]);\n\t*str++ = '/';\n\tfor (i = 1; i < sizeof(oid->id); i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "name"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "name",
            "be->objects_dir",
            "be->objects_dirlen"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "name",
            "alloclen"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "alloclen",
            "3"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "be->objects_dirlen",
            "GIT_OID_HEXSZ"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int object_file_name(\n\tgit_buf *name, const loose_backend *be, const git_oid *id)\n{\n\tsize_t alloclen;\n\n\t/* expand length for object root + 40 hex sha1 chars + 2 * '/' + '\\0' */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, be->objects_dirlen, GIT_OID_HEXSZ);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 3);\n\tif (git_buf_grow(name, alloclen) < 0)\n\t\treturn -1;\n\n\tgit_buf_set(name, be->objects_dir, be->objects_dirlen);\n\tgit_path_to_dir(name);\n\n\t/* loose object filename: aa/aaa... (41 bytes) */\n\tgit_oid_pathfmt(name->ptr + name->size, id);\n\tname->size += GIT_OID_HEXSZ + 1;\n\tname->ptr[name->size] = '\\0';\n\n\treturn 0;\n}"
  }
]