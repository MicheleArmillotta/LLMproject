[
  {
    "function_name": "xdl_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "586-618",
    "snippet": "int xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb) {\n\txdchange_t *xscr;\n\txdfenv_t xe;\n\temit_func_t ef = xecfg->hunk_func ? xdl_call_hunk_func : xdl_emit_diff;\n\n\tif (xdl_do_diff(mf1, mf2, xpp, &xe) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe, &xscr) < 0) {\n\n\t\txdl_free_env(&xe);\n\t\treturn -1;\n\t}\n\tif (xscr) {\n\t\tif (xpp->flags & XDF_IGNORE_BLANK_LINES)\n\t\t\txdl_mark_ignorable(xscr, &xe, xpp->flags);\n\n\t\tif (ef(&xe, xscr, ecb, xecfg) < 0) {\n\n\t\t\txdl_free_script(xscr);\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\txdl_free_script(xscr);\n\t}\n\txdl_free_env(&xe);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free_env",
          "args": [
            "&xe"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_free_script",
          "args": [
            "xscr"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "537-544",
          "snippet": "void xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nvoid xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef",
          "args": [
            "&xe",
            "xscr",
            "ecb",
            "xecfg"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_refine_conflicts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "316-383",
          "snippet": "static int xdl_refine_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m,\n\t\txpparam_t const *xpp)\n{\n\tfor (; m; m = m->next) {\n\t\tmmfile_t t1, t2;\n\t\txdfenv_t xe;\n\t\txdchange_t *xscr, *x;\n\t\tint i1 = m->i1, i2 = m->i2;\n\n\t\t/* let's handle just the conflicts */\n\t\tif (m->mode)\n\t\t\tcontinue;\n\n\t\t/* no sense refining a conflict when one side is empty */\n\t\tif (m->chg1 == 0 || m->chg2 == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This probably does not work outside git, since\n\t\t * we have a very simple mmfile structure.\n\t\t */\n\t\tt1.ptr = (char *)xe1->xdf2.recs[m->i1]->ptr;\n\t\tt1.size = xe1->xdf2.recs[m->i1 + m->chg1 - 1]->ptr\n\t\t\t+ xe1->xdf2.recs[m->i1 + m->chg1 - 1]->size - t1.ptr;\n\t\tt2.ptr = (char *)xe2->xdf2.recs[m->i2]->ptr;\n\t\tt2.size = xe2->xdf2.recs[m->i2 + m->chg2 - 1]->ptr\n\t\t\t+ xe2->xdf2.recs[m->i2 + m->chg2 - 1]->size - t2.ptr;\n\t\tif (xdl_do_diff(&t1, &t2, xpp, &xe) < 0)\n\t\t\treturn -1;\n\t\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t\t    xdl_build_script(&xe, &xscr) < 0) {\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!xscr) {\n\t\t\t/* If this happens, the changes are identical. */\n\t\t\txdl_free_env(&xe);\n\t\t\tm->mode = 4;\n\t\t\tcontinue;\n\t\t}\n\t\tx = xscr;\n\t\tm->i1 = xscr->i1 + i1;\n\t\tm->chg1 = xscr->chg1;\n\t\tm->i2 = xscr->i2 + i2;\n\t\tm->chg2 = xscr->chg2;\n\t\twhile (xscr->next) {\n\t\t\txdmerge_t *m2 = xdl_malloc(sizeof(xdmerge_t));\n\t\t\tif (!m2) {\n\t\t\t\txdl_free_env(&xe);\n\t\t\t\txdl_free_script(x);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr = xscr->next;\n\t\t\tm2->next = m->next;\n\t\t\tm->next = m2;\n\t\t\tm = m2;\n\t\t\tm->mode = 0;\n\t\t\tm->i1 = xscr->i1 + i1;\n\t\t\tm->chg1 = xscr->chg1;\n\t\t\tm->i2 = xscr->i2 + i2;\n\t\t\tm->chg2 = xscr->chg2;\n\t\t}\n\t\txdl_free_env(&xe);\n\t\txdl_free_script(x);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_refine_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m,\n\t\txpparam_t const *xpp)\n{\n\tfor (; m; m = m->next) {\n\t\tmmfile_t t1, t2;\n\t\txdfenv_t xe;\n\t\txdchange_t *xscr, *x;\n\t\tint i1 = m->i1, i2 = m->i2;\n\n\t\t/* let's handle just the conflicts */\n\t\tif (m->mode)\n\t\t\tcontinue;\n\n\t\t/* no sense refining a conflict when one side is empty */\n\t\tif (m->chg1 == 0 || m->chg2 == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This probably does not work outside git, since\n\t\t * we have a very simple mmfile structure.\n\t\t */\n\t\tt1.ptr = (char *)xe1->xdf2.recs[m->i1]->ptr;\n\t\tt1.size = xe1->xdf2.recs[m->i1 + m->chg1 - 1]->ptr\n\t\t\t+ xe1->xdf2.recs[m->i1 + m->chg1 - 1]->size - t1.ptr;\n\t\tt2.ptr = (char *)xe2->xdf2.recs[m->i2]->ptr;\n\t\tt2.size = xe2->xdf2.recs[m->i2 + m->chg2 - 1]->ptr\n\t\t\t+ xe2->xdf2.recs[m->i2 + m->chg2 - 1]->size - t2.ptr;\n\t\tif (xdl_do_diff(&t1, &t2, xpp, &xe) < 0)\n\t\t\treturn -1;\n\t\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t\t    xdl_build_script(&xe, &xscr) < 0) {\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!xscr) {\n\t\t\t/* If this happens, the changes are identical. */\n\t\t\txdl_free_env(&xe);\n\t\t\tm->mode = 4;\n\t\t\tcontinue;\n\t\t}\n\t\tx = xscr;\n\t\tm->i1 = xscr->i1 + i1;\n\t\tm->chg1 = xscr->chg1;\n\t\tm->i2 = xscr->i2 + i2;\n\t\tm->chg2 = xscr->chg2;\n\t\twhile (xscr->next) {\n\t\t\txdmerge_t *m2 = xdl_malloc(sizeof(xdmerge_t));\n\t\t\tif (!m2) {\n\t\t\t\txdl_free_env(&xe);\n\t\t\t\txdl_free_script(x);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr = xscr->next;\n\t\t\tm2->next = m->next;\n\t\t\tm->next = m2;\n\t\t\tm = m2;\n\t\t\tm->mode = 0;\n\t\t\tm->i1 = xscr->i1 + i1;\n\t\t\tm->chg1 = xscr->chg1;\n\t\t\tm->i2 = xscr->i2 + i2;\n\t\t\tm->chg2 = xscr->chg2;\n\t\t}\n\t\txdl_free_env(&xe);\n\t\txdl_free_script(x);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_mark_ignorable",
          "args": [
            "xscr",
            "&xe",
            "xpp->flags"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_mark_ignorable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "565-584",
          "snippet": "static void xdl_mark_ignorable(xdchange_t *xscr, xdfenv_t *xe, long flags)\n{\n\txdchange_t *xch;\n\n\tfor (xch = xscr; xch; xch = xch->next) {\n\t\tint ignore = 1;\n\t\txrecord_t **rec;\n\t\tlong i;\n\n\t\trec = &xe->xdf1.recs[xch->i1];\n\t\tfor (i = 0; i < xch->chg1 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\trec = &xe->xdf2.recs[xch->i2];\n\t\tfor (i = 0; i < xch->chg2 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\txch->ignore = ignore;\n\t}\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);\n\nstatic void xdl_mark_ignorable(xdchange_t *xscr, xdfenv_t *xe, long flags)\n{\n\txdchange_t *xch;\n\n\tfor (xch = xscr; xch; xch = xch->next) {\n\t\tint ignore = 1;\n\t\txrecord_t **rec;\n\t\tlong i;\n\n\t\trec = &xe->xdf1.recs[xch->i1];\n\t\tfor (i = 0; i < xch->chg1 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\trec = &xe->xdf2.recs[xch->i2];\n\t\tfor (i = 0; i < xch->chg2 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\txch->ignore = ignore;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_build_script",
          "args": [
            "&xe",
            "&xscr"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_build_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "511-534",
          "snippet": "int xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_change_compact",
          "args": [
            "&xe.xdf2",
            "&xe.xdf1",
            "xpp->flags"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_change_compact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "407-508",
          "snippet": "int xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tlong ix, ixo, ixs, ixref, grpsiz, nrec = xdf->nrec;\n\tchar *rchg = xdf->rchg, *rchgo = xdfo->rchg;\n\txrecord_t **recs = xdf->recs;\n\n\t/*\n\t * This is the same of what GNU diff does. Move back and forward\n\t * change groups for a consistent and pretty diff output. This also\n\t * helps in finding joinable change groups and reduce the diff size.\n\t */\n\tfor (ix = ixo = 0;;) {\n\t\t/*\n\t\t * Find the first changed line in the to-be-compacted file.\n\t\t * We need to keep track of both indexes, so if we find a\n\t\t * changed lines group on the other file, while scanning the\n\t\t * to-be-compacted file, we need to skip it properly. Note\n\t\t * that loops that are testing for changed lines on rchg* do\n\t\t * not need index bounding since the array is prepared with\n\t\t * a zero at position -1 and N.\n\t\t */\n\t\tfor (; ix < nrec && !rchg[ix]; ix++)\n\t\t\twhile (rchgo[ixo++]);\n\t\tif (ix == nrec)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record the start of a changed-group in the to-be-compacted file\n\t\t * and find the end of it, on both to-be-compacted and other file\n\t\t * indexes (ix and ixo).\n\t\t */\n\t\tixs = ix;\n\t\tfor (ix++; rchg[ix]; ix++);\n\t\tfor (; rchgo[ixo]; ixo++);\n\n\t\tdo {\n\t\t\tgrpsiz = ix - ixs;\n\n\t\t\t/*\n\t\t\t * If the line before the current change group, is equal to\n\t\t\t * the last line of the current change group, shift backward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ixs > 0 && recs[ixs - 1]->ha == recs[ix - 1]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs - 1]->ptr, recs[ixs - 1]->size, recs[ix - 1]->ptr, recs[ix - 1]->size, flags)) {\n\t\t\t\trchg[--ixs] = 1;\n\t\t\t\trchg[--ix] = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index).\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ixs - 1]; ixs--);\n\t\t\t\twhile (rchgo[--ixo]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Record the end-of-group position in case we are matched\n\t\t\t * with a group of changes in the other file (that is, the\n\t\t\t * change record before the end-of-group index in the other\n\t\t\t * file is set).\n\t\t\t */\n\t\t\tixref = rchgo[ixo - 1] ? ix: nrec;\n\n\t\t\t/*\n\t\t\t * If the first line of the current change group, is equal to\n\t\t\t * the line next of the current change group, shift forward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ix < nrec && recs[ixs]->ha == recs[ix]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs]->ptr, recs[ixs]->size, recs[ix]->ptr, recs[ix]->size, flags)) {\n\t\t\t\trchg[ixs++] = 0;\n\t\t\t\trchg[ix++] = 1;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index). Keep tracking the reference\n\t\t\t\t * index in case we are shifting together with a\n\t\t\t\t * corresponding group of changes in the other file.\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ix]; ix++);\n\t\t\t\twhile (rchgo[++ixo])\n\t\t\t\t\tixref = ix;\n\t\t\t}\n\t\t} while (grpsiz != ix - ixs);\n\n\t\t/*\n\t\t * Try to move back the possibly merged group of changes, to match\n\t\t * the recorded position in the other file.\n\t\t */\n\t\twhile (ixref < ix) {\n\t\t\trchg[--ixs] = 1;\n\t\t\trchg[--ix] = 0;\n\t\t\twhile (rchgo[--ixo]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tlong ix, ixo, ixs, ixref, grpsiz, nrec = xdf->nrec;\n\tchar *rchg = xdf->rchg, *rchgo = xdfo->rchg;\n\txrecord_t **recs = xdf->recs;\n\n\t/*\n\t * This is the same of what GNU diff does. Move back and forward\n\t * change groups for a consistent and pretty diff output. This also\n\t * helps in finding joinable change groups and reduce the diff size.\n\t */\n\tfor (ix = ixo = 0;;) {\n\t\t/*\n\t\t * Find the first changed line in the to-be-compacted file.\n\t\t * We need to keep track of both indexes, so if we find a\n\t\t * changed lines group on the other file, while scanning the\n\t\t * to-be-compacted file, we need to skip it properly. Note\n\t\t * that loops that are testing for changed lines on rchg* do\n\t\t * not need index bounding since the array is prepared with\n\t\t * a zero at position -1 and N.\n\t\t */\n\t\tfor (; ix < nrec && !rchg[ix]; ix++)\n\t\t\twhile (rchgo[ixo++]);\n\t\tif (ix == nrec)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record the start of a changed-group in the to-be-compacted file\n\t\t * and find the end of it, on both to-be-compacted and other file\n\t\t * indexes (ix and ixo).\n\t\t */\n\t\tixs = ix;\n\t\tfor (ix++; rchg[ix]; ix++);\n\t\tfor (; rchgo[ixo]; ixo++);\n\n\t\tdo {\n\t\t\tgrpsiz = ix - ixs;\n\n\t\t\t/*\n\t\t\t * If the line before the current change group, is equal to\n\t\t\t * the last line of the current change group, shift backward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ixs > 0 && recs[ixs - 1]->ha == recs[ix - 1]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs - 1]->ptr, recs[ixs - 1]->size, recs[ix - 1]->ptr, recs[ix - 1]->size, flags)) {\n\t\t\t\trchg[--ixs] = 1;\n\t\t\t\trchg[--ix] = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index).\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ixs - 1]; ixs--);\n\t\t\t\twhile (rchgo[--ixo]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Record the end-of-group position in case we are matched\n\t\t\t * with a group of changes in the other file (that is, the\n\t\t\t * change record before the end-of-group index in the other\n\t\t\t * file is set).\n\t\t\t */\n\t\t\tixref = rchgo[ixo - 1] ? ix: nrec;\n\n\t\t\t/*\n\t\t\t * If the first line of the current change group, is equal to\n\t\t\t * the line next of the current change group, shift forward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ix < nrec && recs[ixs]->ha == recs[ix]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs]->ptr, recs[ixs]->size, recs[ix]->ptr, recs[ix]->size, flags)) {\n\t\t\t\trchg[ixs++] = 0;\n\t\t\t\trchg[ix++] = 1;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index). Keep tracking the reference\n\t\t\t\t * index in case we are shifting together with a\n\t\t\t\t * corresponding group of changes in the other file.\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ix]; ix++);\n\t\t\t\twhile (rchgo[++ixo])\n\t\t\t\t\tixref = ix;\n\t\t\t}\n\t\t} while (grpsiz != ix - ixs);\n\n\t\t/*\n\t\t * Try to move back the possibly merged group of changes, to match\n\t\t * the recorded position in the other file.\n\t\t */\n\t\twhile (ixref < ix) {\n\t\t\trchg[--ixs] = 1;\n\t\t\trchg[--ix] = 0;\n\t\t\twhile (rchgo[--ixo]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_do_diff",
          "args": [
            "mf1",
            "mf2",
            "xpp",
            "&xe"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_do_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "325-387",
          "snippet": "int xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_SNAKE_CNT 20",
            "#define XDL_HEUR_MIN_COST 256",
            "#define XDL_MAX_COST_MIN 256"
          ],
          "globals_used": [
            "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\n#define XDL_SNAKE_CNT 20\n#define XDL_HEUR_MIN_COST 256\n#define XDL_MAX_COST_MIN 256\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);\n\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb) {\n\txdchange_t *xscr;\n\txdfenv_t xe;\n\temit_func_t ef = xecfg->hunk_func ? xdl_call_hunk_func : xdl_emit_diff;\n\n\tif (xdl_do_diff(mf1, mf2, xpp, &xe) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe, &xscr) < 0) {\n\n\t\txdl_free_env(&xe);\n\t\treturn -1;\n\t}\n\tif (xscr) {\n\t\tif (xpp->flags & XDF_IGNORE_BLANK_LINES)\n\t\t\txdl_mark_ignorable(xscr, &xe, xpp->flags);\n\n\t\tif (ef(&xe, xscr, ecb, xecfg) < 0) {\n\n\t\t\txdl_free_script(xscr);\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\txdl_free_script(xscr);\n\t}\n\txdl_free_env(&xe);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_mark_ignorable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "565-584",
    "snippet": "static void xdl_mark_ignorable(xdchange_t *xscr, xdfenv_t *xe, long flags)\n{\n\txdchange_t *xch;\n\n\tfor (xch = xscr; xch; xch = xch->next) {\n\t\tint ignore = 1;\n\t\txrecord_t **rec;\n\t\tlong i;\n\n\t\trec = &xe->xdf1.recs[xch->i1];\n\t\tfor (i = 0; i < xch->chg1 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\trec = &xe->xdf2.recs[xch->i2];\n\t\tfor (i = 0; i < xch->chg2 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\txch->ignore = ignore;\n\t}\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_blankline",
          "args": [
            "rec[i]->ptr",
            "rec[i]->size",
            "flags"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_blankline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "144-155",
          "snippet": "int xdl_blankline(const char *line, long size, long flags)\n{\n\tlong i;\n\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn (size <= 1);\n\n\tfor (i = 0; i < size && XDL_ISSPACE(line[i]); i++)\n\t\t;\n\n\treturn (i == size);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_blankline(const char *line, long size, long flags)\n{\n\tlong i;\n\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn (size <= 1);\n\n\tfor (i = 0; i < size && XDL_ISSPACE(line[i]); i++)\n\t\t;\n\n\treturn (i == size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);\n\nstatic void xdl_mark_ignorable(xdchange_t *xscr, xdfenv_t *xe, long flags)\n{\n\txdchange_t *xch;\n\n\tfor (xch = xscr; xch; xch = xch->next) {\n\t\tint ignore = 1;\n\t\txrecord_t **rec;\n\t\tlong i;\n\n\t\trec = &xe->xdf1.recs[xch->i1];\n\t\tfor (i = 0; i < xch->chg1 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\trec = &xe->xdf2.recs[xch->i2];\n\t\tfor (i = 0; i < xch->chg2 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\txch->ignore = ignore;\n\t}\n}"
  },
  {
    "function_name": "xdl_call_hunk_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "546-563",
    "snippet": "static int xdl_call_hunk_func(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t\t      xdemitconf_t const *xecfg)\n{\n\txdchange_t *xch, *xche;\n\n\t(void)xe;\n\n\tfor (xch = xscr; xch; xch = xche->next) {\n\t\txche = xdl_get_hunk(&xch, xecfg);\n\t\tif (!xch)\n\t\t\tbreak;\n\t\tif (xecfg->hunk_func(xch->i1, xche->i1 + xche->chg1 - xch->i1,\n\t\t\t\t     xch->i2, xche->i2 + xche->chg2 - xch->i2,\n\t\t\t\t     ecb->priv) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xecfg->hunk_func",
          "args": [
            "xch->i1",
            "xche->i1 + xche->chg1 - xch->i1",
            "xch->i2",
            "xche->i2 + xche->chg2 - xch->i2",
            "ecb->priv"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_get_hunk",
          "args": [
            "&xch",
            "xecfg"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_get_hunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xemit.c",
          "lines": "61-104",
          "snippet": "xdchange_t *xdl_get_hunk(xdchange_t **xscr, xdemitconf_t const *xecfg)\n{\n\txdchange_t *xch, *xchp, *lxch;\n\tlong max_common = 2 * xecfg->ctxlen + xecfg->interhunkctxlen;\n\tlong max_ignorable = xecfg->ctxlen;\n\tunsigned long ignored = 0; /* number of ignored blank lines */\n\n\t/* remove ignorable changes that are too far before other changes */\n\tfor (xchp = *xscr; xchp && xchp->ignore; xchp = xchp->next) {\n\t\txch = xchp->next;\n\n\t\tif (xch == NULL ||\n\t\t    xch->i1 - (xchp->i1 + xchp->chg1) >= max_ignorable)\n\t\t\t*xscr = xch;\n\t}\n\n\tif (*xscr == NULL)\n\t\treturn NULL;\n\n\tlxch = *xscr;\n\n\tfor (xchp = *xscr, xch = xchp->next; xch; xchp = xch, xch = xch->next) {\n\t\tlong distance = xch->i1 - (xchp->i1 + xchp->chg1);\n\t\tif (distance > max_common)\n\t\t\tbreak;\n\n\t\tif (distance < max_ignorable && (!xch->ignore || lxch == xchp)) {\n\t\t\tlxch = xch;\n\t\t\tignored = 0;\n\t\t} else if (distance < max_ignorable && xch->ignore) {\n\t\t\tignored += xch->chg2;\n\t\t} else if (lxch != xchp &&\n\t\t\t   xch->i1 + ignored - (lxch->i1 + lxch->chg1) > (unsigned long)max_common) {\n\t\t\tbreak;\n\t\t} else if (!xch->ignore) {\n\t\t\tlxch = xch;\n\t\t\tignored = 0;\n\t\t} else {\n\t\t\tignored += xch->chg2;\n\t\t}\n\t}\n\n\treturn lxch;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nxdchange_t *xdl_get_hunk(xdchange_t **xscr, xdemitconf_t const *xecfg)\n{\n\txdchange_t *xch, *xchp, *lxch;\n\tlong max_common = 2 * xecfg->ctxlen + xecfg->interhunkctxlen;\n\tlong max_ignorable = xecfg->ctxlen;\n\tunsigned long ignored = 0; /* number of ignored blank lines */\n\n\t/* remove ignorable changes that are too far before other changes */\n\tfor (xchp = *xscr; xchp && xchp->ignore; xchp = xchp->next) {\n\t\txch = xchp->next;\n\n\t\tif (xch == NULL ||\n\t\t    xch->i1 - (xchp->i1 + xchp->chg1) >= max_ignorable)\n\t\t\t*xscr = xch;\n\t}\n\n\tif (*xscr == NULL)\n\t\treturn NULL;\n\n\tlxch = *xscr;\n\n\tfor (xchp = *xscr, xch = xchp->next; xch; xchp = xch, xch = xch->next) {\n\t\tlong distance = xch->i1 - (xchp->i1 + xchp->chg1);\n\t\tif (distance > max_common)\n\t\t\tbreak;\n\n\t\tif (distance < max_ignorable && (!xch->ignore || lxch == xchp)) {\n\t\t\tlxch = xch;\n\t\t\tignored = 0;\n\t\t} else if (distance < max_ignorable && xch->ignore) {\n\t\t\tignored += xch->chg2;\n\t\t} else if (lxch != xchp &&\n\t\t\t   xch->i1 + ignored - (lxch->i1 + lxch->chg1) > (unsigned long)max_common) {\n\t\t\tbreak;\n\t\t} else if (!xch->ignore) {\n\t\t\tlxch = xch;\n\t\t\tignored = 0;\n\t\t} else {\n\t\t\tignored += xch->chg2;\n\t\t}\n\t}\n\n\treturn lxch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);\n\nstatic int xdl_call_hunk_func(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t\t      xdemitconf_t const *xecfg)\n{\n\txdchange_t *xch, *xche;\n\n\t(void)xe;\n\n\tfor (xch = xscr; xch; xch = xche->next) {\n\t\txche = xdl_get_hunk(&xch, xecfg);\n\t\tif (!xch)\n\t\t\tbreak;\n\t\tif (xecfg->hunk_func(xch->i1, xche->i1 + xche->chg1 - xch->i1,\n\t\t\t\t     xch->i2, xche->i2 + xche->chg2 - xch->i2,\n\t\t\t\t     ecb->priv) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_free_script",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "537-544",
    "snippet": "void xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "xch"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "537-544",
          "snippet": "void xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nvoid xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}"
  },
  {
    "function_name": "xdl_build_script",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "511-534",
    "snippet": "int xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free_script",
          "args": [
            "cscr"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "537-544",
          "snippet": "void xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nvoid xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_add_change",
          "args": [
            "cscr",
            "i1",
            "i2",
            "l1 - i1",
            "l2 - i2"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_add_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "390-404",
          "snippet": "static xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2) {\n\txdchange_t *xch;\n\n\tif (!(xch = (xdchange_t *) xdl_malloc(sizeof(xdchange_t))))\n\t\treturn NULL;\n\n\txch->next = xscr;\n\txch->i1 = i1;\n\txch->i2 = i2;\n\txch->chg1 = chg1;\n\txch->chg2 = chg2;\n\txch->ignore = 0;\n\n\treturn xch;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2) {\n\txdchange_t *xch;\n\n\tif (!(xch = (xdchange_t *) xdl_malloc(sizeof(xdchange_t))))\n\t\treturn NULL;\n\n\txch->next = xscr;\n\txch->i1 = i1;\n\txch->i2 = i2;\n\txch->chg1 = chg1;\n\txch->chg2 = chg2;\n\txch->ignore = 0;\n\n\treturn xch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_change_compact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "407-508",
    "snippet": "int xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tlong ix, ixo, ixs, ixref, grpsiz, nrec = xdf->nrec;\n\tchar *rchg = xdf->rchg, *rchgo = xdfo->rchg;\n\txrecord_t **recs = xdf->recs;\n\n\t/*\n\t * This is the same of what GNU diff does. Move back and forward\n\t * change groups for a consistent and pretty diff output. This also\n\t * helps in finding joinable change groups and reduce the diff size.\n\t */\n\tfor (ix = ixo = 0;;) {\n\t\t/*\n\t\t * Find the first changed line in the to-be-compacted file.\n\t\t * We need to keep track of both indexes, so if we find a\n\t\t * changed lines group on the other file, while scanning the\n\t\t * to-be-compacted file, we need to skip it properly. Note\n\t\t * that loops that are testing for changed lines on rchg* do\n\t\t * not need index bounding since the array is prepared with\n\t\t * a zero at position -1 and N.\n\t\t */\n\t\tfor (; ix < nrec && !rchg[ix]; ix++)\n\t\t\twhile (rchgo[ixo++]);\n\t\tif (ix == nrec)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record the start of a changed-group in the to-be-compacted file\n\t\t * and find the end of it, on both to-be-compacted and other file\n\t\t * indexes (ix and ixo).\n\t\t */\n\t\tixs = ix;\n\t\tfor (ix++; rchg[ix]; ix++);\n\t\tfor (; rchgo[ixo]; ixo++);\n\n\t\tdo {\n\t\t\tgrpsiz = ix - ixs;\n\n\t\t\t/*\n\t\t\t * If the line before the current change group, is equal to\n\t\t\t * the last line of the current change group, shift backward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ixs > 0 && recs[ixs - 1]->ha == recs[ix - 1]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs - 1]->ptr, recs[ixs - 1]->size, recs[ix - 1]->ptr, recs[ix - 1]->size, flags)) {\n\t\t\t\trchg[--ixs] = 1;\n\t\t\t\trchg[--ix] = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index).\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ixs - 1]; ixs--);\n\t\t\t\twhile (rchgo[--ixo]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Record the end-of-group position in case we are matched\n\t\t\t * with a group of changes in the other file (that is, the\n\t\t\t * change record before the end-of-group index in the other\n\t\t\t * file is set).\n\t\t\t */\n\t\t\tixref = rchgo[ixo - 1] ? ix: nrec;\n\n\t\t\t/*\n\t\t\t * If the first line of the current change group, is equal to\n\t\t\t * the line next of the current change group, shift forward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ix < nrec && recs[ixs]->ha == recs[ix]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs]->ptr, recs[ixs]->size, recs[ix]->ptr, recs[ix]->size, flags)) {\n\t\t\t\trchg[ixs++] = 0;\n\t\t\t\trchg[ix++] = 1;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index). Keep tracking the reference\n\t\t\t\t * index in case we are shifting together with a\n\t\t\t\t * corresponding group of changes in the other file.\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ix]; ix++);\n\t\t\t\twhile (rchgo[++ixo])\n\t\t\t\t\tixref = ix;\n\t\t\t}\n\t\t} while (grpsiz != ix - ixs);\n\n\t\t/*\n\t\t * Try to move back the possibly merged group of changes, to match\n\t\t * the recorded position in the other file.\n\t\t */\n\t\twhile (ixref < ix) {\n\t\t\trchg[--ixs] = 1;\n\t\t\trchg[--ix] = 0;\n\t\t\twhile (rchgo[--ixo]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_recmatch",
          "args": [
            "recs[ixs]->ptr",
            "recs[ixs]->size",
            "recs[ix]->ptr",
            "recs[ix]->size",
            "flags"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "157-223",
          "snippet": "int xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tlong ix, ixo, ixs, ixref, grpsiz, nrec = xdf->nrec;\n\tchar *rchg = xdf->rchg, *rchgo = xdfo->rchg;\n\txrecord_t **recs = xdf->recs;\n\n\t/*\n\t * This is the same of what GNU diff does. Move back and forward\n\t * change groups for a consistent and pretty diff output. This also\n\t * helps in finding joinable change groups and reduce the diff size.\n\t */\n\tfor (ix = ixo = 0;;) {\n\t\t/*\n\t\t * Find the first changed line in the to-be-compacted file.\n\t\t * We need to keep track of both indexes, so if we find a\n\t\t * changed lines group on the other file, while scanning the\n\t\t * to-be-compacted file, we need to skip it properly. Note\n\t\t * that loops that are testing for changed lines on rchg* do\n\t\t * not need index bounding since the array is prepared with\n\t\t * a zero at position -1 and N.\n\t\t */\n\t\tfor (; ix < nrec && !rchg[ix]; ix++)\n\t\t\twhile (rchgo[ixo++]);\n\t\tif (ix == nrec)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record the start of a changed-group in the to-be-compacted file\n\t\t * and find the end of it, on both to-be-compacted and other file\n\t\t * indexes (ix and ixo).\n\t\t */\n\t\tixs = ix;\n\t\tfor (ix++; rchg[ix]; ix++);\n\t\tfor (; rchgo[ixo]; ixo++);\n\n\t\tdo {\n\t\t\tgrpsiz = ix - ixs;\n\n\t\t\t/*\n\t\t\t * If the line before the current change group, is equal to\n\t\t\t * the last line of the current change group, shift backward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ixs > 0 && recs[ixs - 1]->ha == recs[ix - 1]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs - 1]->ptr, recs[ixs - 1]->size, recs[ix - 1]->ptr, recs[ix - 1]->size, flags)) {\n\t\t\t\trchg[--ixs] = 1;\n\t\t\t\trchg[--ix] = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index).\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ixs - 1]; ixs--);\n\t\t\t\twhile (rchgo[--ixo]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Record the end-of-group position in case we are matched\n\t\t\t * with a group of changes in the other file (that is, the\n\t\t\t * change record before the end-of-group index in the other\n\t\t\t * file is set).\n\t\t\t */\n\t\t\tixref = rchgo[ixo - 1] ? ix: nrec;\n\n\t\t\t/*\n\t\t\t * If the first line of the current change group, is equal to\n\t\t\t * the line next of the current change group, shift forward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ix < nrec && recs[ixs]->ha == recs[ix]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs]->ptr, recs[ixs]->size, recs[ix]->ptr, recs[ix]->size, flags)) {\n\t\t\t\trchg[ixs++] = 0;\n\t\t\t\trchg[ix++] = 1;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index). Keep tracking the reference\n\t\t\t\t * index in case we are shifting together with a\n\t\t\t\t * corresponding group of changes in the other file.\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ix]; ix++);\n\t\t\t\twhile (rchgo[++ixo])\n\t\t\t\t\tixref = ix;\n\t\t\t}\n\t\t} while (grpsiz != ix - ixs);\n\n\t\t/*\n\t\t * Try to move back the possibly merged group of changes, to match\n\t\t * the recorded position in the other file.\n\t\t */\n\t\twhile (ixref < ix) {\n\t\t\trchg[--ixs] = 1;\n\t\t\trchg[--ix] = 0;\n\t\t\twhile (rchgo[--ixo]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_add_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "390-404",
    "snippet": "static xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2) {\n\txdchange_t *xch;\n\n\tif (!(xch = (xdchange_t *) xdl_malloc(sizeof(xdchange_t))))\n\t\treturn NULL;\n\n\txch->next = xscr;\n\txch->i1 = i1;\n\txch->i2 = i2;\n\txch->chg1 = chg1;\n\txch->chg2 = chg2;\n\txch->ignore = 0;\n\n\treturn xch;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "sizeof(xdchange_t)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2);\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2) {\n\txdchange_t *xch;\n\n\tif (!(xch = (xdchange_t *) xdl_malloc(sizeof(xdchange_t))))\n\t\treturn NULL;\n\n\txch->next = xscr;\n\txch->i1 = i1;\n\txch->i2 = i2;\n\txch->chg1 = chg1;\n\txch->chg2 = chg2;\n\txch->ignore = 0;\n\n\treturn xch;\n}"
  },
  {
    "function_name": "xdl_do_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "325-387",
    "snippet": "int xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [
      "#define XDL_SNAKE_CNT 20",
      "#define XDL_HEUR_MIN_COST 256",
      "#define XDL_MAX_COST_MIN 256"
    ],
    "globals_used": [
      "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "kvd"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "537-544",
          "snippet": "void xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nvoid xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_free_env",
          "args": [
            "xe"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_recs_cmp",
          "args": [
            "&dd1",
            "0",
            "dd1.nrec",
            "&dd2",
            "0",
            "dd2.nrec",
            "kvdf",
            "kvdb",
            "(xpp->flags & XDF_NEED_MINIMAL) != 0",
            "&xenv"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recs_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "269-322",
          "snippet": "int xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv) {\n\tunsigned long const *ha1 = dd1->ha, *ha2 = dd2->ha;\n\n\t/*\n\t * Shrink the box by walking through each diagonal snake (SW and NE).\n\t */\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[off1] == ha2[off2]; off1++, off2++);\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[lim1 - 1] == ha2[lim2 - 1]; lim1--, lim2--);\n\n\t/*\n\t * If one dimension is empty, then all records on the other one must\n\t * be obviously changed.\n\t */\n\tif (off1 == lim1) {\n\t\tchar *rchg2 = dd2->rchg;\n\t\tlong *rindex2 = dd2->rindex;\n\n\t\tfor (; off2 < lim2; off2++)\n\t\t\trchg2[rindex2[off2]] = 1;\n\t} else if (off2 == lim2) {\n\t\tchar *rchg1 = dd1->rchg;\n\t\tlong *rindex1 = dd1->rindex;\n\n\t\tfor (; off1 < lim1; off1++)\n\t\t\trchg1[rindex1[off1]] = 1;\n\t} else {\n\t\txdpsplit_t spl;\n\t\tspl.i1 = spl.i2 = 0;\n\n\t\t/*\n\t\t * Divide ...\n\t\t */\n\t\tif (xdl_split(ha1, off1, lim1, ha2, off2, lim2, kvdf, kvdb,\n\t\t\t      need_min, &spl, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * ... et Impera.\n\t\t */\n\t\tif (xdl_recs_cmp(dd1, off1, spl.i1, dd2, off2, spl.i2,\n\t\t\t\t kvdf, kvdb, spl.min_lo, xenv) < 0 ||\n\t\t    xdl_recs_cmp(dd1, spl.i1, lim1, dd2, spl.i2, lim2,\n\t\t\t\t kvdf, kvdb, spl.min_hi, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);\n\nint xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv) {\n\tunsigned long const *ha1 = dd1->ha, *ha2 = dd2->ha;\n\n\t/*\n\t * Shrink the box by walking through each diagonal snake (SW and NE).\n\t */\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[off1] == ha2[off2]; off1++, off2++);\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[lim1 - 1] == ha2[lim2 - 1]; lim1--, lim2--);\n\n\t/*\n\t * If one dimension is empty, then all records on the other one must\n\t * be obviously changed.\n\t */\n\tif (off1 == lim1) {\n\t\tchar *rchg2 = dd2->rchg;\n\t\tlong *rindex2 = dd2->rindex;\n\n\t\tfor (; off2 < lim2; off2++)\n\t\t\trchg2[rindex2[off2]] = 1;\n\t} else if (off2 == lim2) {\n\t\tchar *rchg1 = dd1->rchg;\n\t\tlong *rindex1 = dd1->rindex;\n\n\t\tfor (; off1 < lim1; off1++)\n\t\t\trchg1[rindex1[off1]] = 1;\n\t} else {\n\t\txdpsplit_t spl;\n\t\tspl.i1 = spl.i2 = 0;\n\n\t\t/*\n\t\t * Divide ...\n\t\t */\n\t\tif (xdl_split(ha1, off1, lim1, ha2, off2, lim2, kvdf, kvdb,\n\t\t\t      need_min, &spl, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * ... et Impera.\n\t\t */\n\t\tif (xdl_recs_cmp(dd1, off1, spl.i1, dd2, off2, spl.i2,\n\t\t\t\t kvdf, kvdb, spl.min_lo, xenv) < 0 ||\n\t\t    xdl_recs_cmp(dd1, spl.i1, lim1, dd2, spl.i2, lim2,\n\t\t\t\t kvdf, kvdb, spl.min_hi, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_bogosqrt",
          "args": [
            "ndiags"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_bogosqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "28-38",
          "snippet": "long xdl_bogosqrt(long n) {\n\tlong i;\n\n\t/*\n\t * Classical integer square root approximation using shifts.\n\t */\n\tfor (i = 1; n > 0; n >>= 2)\n\t\ti <<= 1;\n\n\treturn i;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nlong xdl_bogosqrt(long n) {\n\tlong i;\n\n\t/*\n\t * Classical integer square root approximation using shifts.\n\t */\n\tfor (i = 1; n > 0; n >>= 2)\n\t\ti <<= 1;\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "allocsize"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&allocsize",
            "allocsize",
            "sizeof(long)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&allocsize",
            "allocsize",
            "2"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&allocsize",
            "ndiags",
            "2"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD3",
          "args": [
            "&ndiags",
            "xe->xdf1.nreff",
            "xe->xdf2.nreff",
            "3"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_prepare_env",
          "args": [
            "mf1",
            "mf2",
            "xpp",
            "xe"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_prepare_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "262-312",
          "snippet": "int xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF &&\n\t    xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)\n\t\txdl_free_classifier(&cf);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_GUESS_NLINES2 20",
            "#define XDL_GUESS_NLINES1 256"
          ],
          "globals_used": [
            "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
            "static void xdl_free_classifier(xdlclassifier_t *cf);",
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\n#define XDL_GUESS_NLINES2 20\n#define XDL_GUESS_NLINES1 256\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nint xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF &&\n\t    xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)\n\t\txdl_free_classifier(&cf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_do_histogram_diff",
          "args": [
            "mf1",
            "mf2",
            "xpp",
            "xe"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_do_histogram_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
          "lines": "364-373",
          "snippet": "int xdl_do_histogram_diff(mmfile_t *file1, mmfile_t *file2,\n\txpparam_t const *xpp, xdfenv_t *env)\n{\n\tif (xdl_prepare_env(file1, file2, xpp, env) < 0)\n\t\treturn -1;\n\n\treturn histogram_diff(xpp, env,\n\t\tenv->xdf1.dstart + 1, env->xdf1.dend - env->xdf1.dstart + 1,\n\t\tenv->xdf2.dstart + 1, env->xdf2.dend - env->xdf2.dstart + 1);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nint xdl_do_histogram_diff(mmfile_t *file1, mmfile_t *file2,\n\txpparam_t const *xpp, xdfenv_t *env)\n{\n\tif (xdl_prepare_env(file1, file2, xpp, env) < 0)\n\t\treturn -1;\n\n\treturn histogram_diff(xpp, env,\n\t\tenv->xdf1.dstart + 1, env->xdf1.dend - env->xdf1.dstart + 1,\n\t\tenv->xdf2.dstart + 1, env->xdf2.dend - env->xdf2.dstart + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDF_DIFF_ALG",
          "args": [
            "xpp->flags"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_do_patience_diff",
          "args": [
            "mf1",
            "mf2",
            "xpp",
            "xe"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_do_patience_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "349-358",
          "snippet": "int xdl_do_patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env)\n{\n\tif (xdl_prepare_env(file1, file2, xpp, env) < 0)\n\t\treturn -1;\n\n\t/* environment is cleaned up in xdl_diff() */\n\treturn patience_diff(file1, file2, xpp, env,\n\t\t\t1, env->xdf1.nrec, 1, env->xdf2.nrec);\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nint xdl_do_patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env)\n{\n\tif (xdl_prepare_env(file1, file2, xpp, env) < 0)\n\t\treturn -1;\n\n\t/* environment is cleaned up in xdl_diff() */\n\treturn patience_diff(file1, file2, xpp, env,\n\t\t\t1, env->xdf1.nrec, 1, env->xdf2.nrec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDF_DIFF_ALG",
          "args": [
            "xpp->flags"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\n#define XDL_SNAKE_CNT 20\n#define XDL_HEUR_MIN_COST 256\n#define XDL_MAX_COST_MIN 256\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);\n\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_recs_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "269-322",
    "snippet": "int xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv) {\n\tunsigned long const *ha1 = dd1->ha, *ha2 = dd2->ha;\n\n\t/*\n\t * Shrink the box by walking through each diagonal snake (SW and NE).\n\t */\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[off1] == ha2[off2]; off1++, off2++);\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[lim1 - 1] == ha2[lim2 - 1]; lim1--, lim2--);\n\n\t/*\n\t * If one dimension is empty, then all records on the other one must\n\t * be obviously changed.\n\t */\n\tif (off1 == lim1) {\n\t\tchar *rchg2 = dd2->rchg;\n\t\tlong *rindex2 = dd2->rindex;\n\n\t\tfor (; off2 < lim2; off2++)\n\t\t\trchg2[rindex2[off2]] = 1;\n\t} else if (off2 == lim2) {\n\t\tchar *rchg1 = dd1->rchg;\n\t\tlong *rindex1 = dd1->rindex;\n\n\t\tfor (; off1 < lim1; off1++)\n\t\t\trchg1[rindex1[off1]] = 1;\n\t} else {\n\t\txdpsplit_t spl;\n\t\tspl.i1 = spl.i2 = 0;\n\n\t\t/*\n\t\t * Divide ...\n\t\t */\n\t\tif (xdl_split(ha1, off1, lim1, ha2, off2, lim2, kvdf, kvdb,\n\t\t\t      need_min, &spl, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * ... et Impera.\n\t\t */\n\t\tif (xdl_recs_cmp(dd1, off1, spl.i1, dd2, off2, spl.i2,\n\t\t\t\t kvdf, kvdb, spl.min_lo, xenv) < 0 ||\n\t\t    xdl_recs_cmp(dd1, spl.i1, lim1, dd2, spl.i2, lim2,\n\t\t\t\t kvdf, kvdb, spl.min_hi, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_recs_cmp",
          "args": [
            "dd1",
            "spl.i1",
            "lim1",
            "dd2",
            "spl.i2",
            "lim2",
            "kvdf",
            "kvdb",
            "spl.min_hi",
            "xenv"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recs_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "269-322",
          "snippet": "int xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv) {\n\tunsigned long const *ha1 = dd1->ha, *ha2 = dd2->ha;\n\n\t/*\n\t * Shrink the box by walking through each diagonal snake (SW and NE).\n\t */\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[off1] == ha2[off2]; off1++, off2++);\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[lim1 - 1] == ha2[lim2 - 1]; lim1--, lim2--);\n\n\t/*\n\t * If one dimension is empty, then all records on the other one must\n\t * be obviously changed.\n\t */\n\tif (off1 == lim1) {\n\t\tchar *rchg2 = dd2->rchg;\n\t\tlong *rindex2 = dd2->rindex;\n\n\t\tfor (; off2 < lim2; off2++)\n\t\t\trchg2[rindex2[off2]] = 1;\n\t} else if (off2 == lim2) {\n\t\tchar *rchg1 = dd1->rchg;\n\t\tlong *rindex1 = dd1->rindex;\n\n\t\tfor (; off1 < lim1; off1++)\n\t\t\trchg1[rindex1[off1]] = 1;\n\t} else {\n\t\txdpsplit_t spl;\n\t\tspl.i1 = spl.i2 = 0;\n\n\t\t/*\n\t\t * Divide ...\n\t\t */\n\t\tif (xdl_split(ha1, off1, lim1, ha2, off2, lim2, kvdf, kvdb,\n\t\t\t      need_min, &spl, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * ... et Impera.\n\t\t */\n\t\tif (xdl_recs_cmp(dd1, off1, spl.i1, dd2, off2, spl.i2,\n\t\t\t\t kvdf, kvdb, spl.min_lo, xenv) < 0 ||\n\t\t    xdl_recs_cmp(dd1, spl.i1, lim1, dd2, spl.i2, lim2,\n\t\t\t\t kvdf, kvdb, spl.min_hi, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "xdl_split",
          "args": [
            "ha1",
            "off1",
            "lim1",
            "ha2",
            "off2",
            "lim2",
            "kvdf",
            "kvdb",
            "need_min",
            "&spl",
            "xenv"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "63-261",
          "snippet": "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv) {\n\tlong dmin = off1 - lim2, dmax = lim1 - off2;\n\tlong fmid = off1 - off2, bmid = lim1 - lim2;\n\tlong odd = (fmid - bmid) & 1;\n\tlong fmin = fmid, fmax = fmid;\n\tlong bmin = bmid, bmax = bmid;\n\tlong ec, d, i1, i2, prev1, best, dd, v, k;\n\n\t/*\n\t * Set initial diagonal values for both forward and backward path.\n\t */\n\tkvdf[fmid] = off1;\n\tkvdb[bmid] = lim1;\n\n\tfor (ec = 1;; ec++) {\n\t\tint got_snake = 0;\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (fmin > dmin)\n\t\t\tkvdf[--fmin - 1] = -1;\n\t\telse\n\t\t\t++fmin;\n\t\tif (fmax < dmax)\n\t\t\tkvdf[++fmax + 1] = -1;\n\t\telse\n\t\t\t--fmax;\n\n\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\tif (kvdf[d - 1] >= kvdf[d + 1])\n\t\t\t\ti1 = kvdf[d - 1] + 1;\n\t\t\telse\n\t\t\t\ti1 = kvdf[d + 1];\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 < lim1 && i2 < lim2 && ha1[i1] == ha2[i2]; i1++, i2++);\n\t\t\tif (i1 - prev1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdf[d] = i1;\n\t\t\tif (odd && bmin <= d && d <= bmax && kvdb[d] <= i1) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (bmin > dmin)\n\t\t\tkvdb[--bmin - 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t++bmin;\n\t\tif (bmax < dmax)\n\t\t\tkvdb[++bmax + 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t--bmax;\n\n\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\tif (kvdb[d - 1] < kvdb[d + 1])\n\t\t\t\ti1 = kvdb[d - 1];\n\t\t\telse\n\t\t\t\ti1 = kvdb[d + 1] - 1;\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 > off1 && i2 > off2 && ha1[i1 - 1] == ha2[i2 - 1]; i1--, i2--);\n\t\t\tif (prev1 - i1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdb[d] = i1;\n\t\t\tif (!odd && fmin <= d && d <= fmax && i1 <= kvdf[d]) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\tif (need_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the edit cost is above the heuristic trigger and if\n\t\t * we got a good snake, we sample current diagonals to see\n\t\t * if some of the, have reached an \"interesting\" path. Our\n\t\t * measure is a function of the distance from the diagonal\n\t\t * corner (i1 + i2) penalized with the distance from the\n\t\t * mid diagonal itself. If this value is above the current\n\t\t * edit cost times a magic factor (XDL_K_HEUR) we consider\n\t\t * it interesting.\n\t\t */\n\t\tif (got_snake && ec > xenv->heur_min) {\n\t\t\tfor (best = 0, d = fmax; d >= fmin; d -= 2) {\n\t\t\t\tdd = d > fmid ? d - fmid: fmid - d;\n\t\t\t\ti1 = kvdf[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (i1 - off1) + (i2 - off2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 + xenv->snake_cnt <= i1 && i1 < lim1 &&\n\t\t\t\t    off2 + xenv->snake_cnt <= i2 && i2 < lim2) {\n\t\t\t\t\tfor (k = 1; ha1[i1 - k] == ha2[i2 - k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t\treturn ec;\n\t\t\t}\n\n\t\t\tfor (best = 0, d = bmax; d >= bmin; d -= 2) {\n\t\t\t\tdd = d > bmid ? d - bmid: bmid - d;\n\t\t\t\ti1 = kvdb[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (lim1 - i1) + (lim2 - i2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 < i1 && i1 <= lim1 - xenv->snake_cnt &&\n\t\t\t\t    off2 < i2 && i2 <= lim2 - xenv->snake_cnt) {\n\t\t\t\t\tfor (k = 0; ha1[i1 + k] == ha2[i2 + k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt - 1) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Enough is enough. We spent too much time here and now we collect\n\t\t * the furthest reaching path using the (i1 + i2) measure.\n\t\t */\n\t\tif (ec >= xenv->mxcost) {\n\t\t\tlong fbest, fbest1, bbest, bbest1;\n\n\t\t\tfbest = fbest1 = -1;\n\t\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\t\ti1 = XDL_MIN(kvdf[d], lim1);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (lim2 < i2)\n\t\t\t\t\ti1 = lim2 + d, i2 = lim2;\n\t\t\t\tif (fbest < i1 + i2) {\n\t\t\t\t\tfbest = i1 + i2;\n\t\t\t\t\tfbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbbest = bbest1 = XDL_LINE_MAX;\n\t\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\t\ti1 = XDL_MAX(off1, kvdb[d]);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (i2 < off2)\n\t\t\t\t\ti1 = off2 + d, i2 = off2;\n\t\t\t\tif (i1 + i2 < bbest) {\n\t\t\t\t\tbbest = i1 + i2;\n\t\t\t\t\tbbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((lim1 + lim2) - bbest < fbest - (off1 + off2)) {\n\t\t\t\tspl->i1 = fbest1;\n\t\t\t\tspl->i2 = fbest - fbest1;\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t} else {\n\t\t\t\tspl->i1 = bbest1;\n\t\t\t\tspl->i2 = bbest - bbest1;\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t}\n\t\t\treturn ec;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_K_HEUR 4",
            "#define XDL_LINE_MAX (long)((1UL << (CHAR_BIT * sizeof(long) - 1)) - 1)"
          ],
          "globals_used": [
            "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\n#define XDL_K_HEUR 4\n#define XDL_LINE_MAX (long)((1UL << (CHAR_BIT * sizeof(long) - 1)) - 1)\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv) {\n\tlong dmin = off1 - lim2, dmax = lim1 - off2;\n\tlong fmid = off1 - off2, bmid = lim1 - lim2;\n\tlong odd = (fmid - bmid) & 1;\n\tlong fmin = fmid, fmax = fmid;\n\tlong bmin = bmid, bmax = bmid;\n\tlong ec, d, i1, i2, prev1, best, dd, v, k;\n\n\t/*\n\t * Set initial diagonal values for both forward and backward path.\n\t */\n\tkvdf[fmid] = off1;\n\tkvdb[bmid] = lim1;\n\n\tfor (ec = 1;; ec++) {\n\t\tint got_snake = 0;\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (fmin > dmin)\n\t\t\tkvdf[--fmin - 1] = -1;\n\t\telse\n\t\t\t++fmin;\n\t\tif (fmax < dmax)\n\t\t\tkvdf[++fmax + 1] = -1;\n\t\telse\n\t\t\t--fmax;\n\n\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\tif (kvdf[d - 1] >= kvdf[d + 1])\n\t\t\t\ti1 = kvdf[d - 1] + 1;\n\t\t\telse\n\t\t\t\ti1 = kvdf[d + 1];\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 < lim1 && i2 < lim2 && ha1[i1] == ha2[i2]; i1++, i2++);\n\t\t\tif (i1 - prev1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdf[d] = i1;\n\t\t\tif (odd && bmin <= d && d <= bmax && kvdb[d] <= i1) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (bmin > dmin)\n\t\t\tkvdb[--bmin - 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t++bmin;\n\t\tif (bmax < dmax)\n\t\t\tkvdb[++bmax + 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t--bmax;\n\n\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\tif (kvdb[d - 1] < kvdb[d + 1])\n\t\t\t\ti1 = kvdb[d - 1];\n\t\t\telse\n\t\t\t\ti1 = kvdb[d + 1] - 1;\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 > off1 && i2 > off2 && ha1[i1 - 1] == ha2[i2 - 1]; i1--, i2--);\n\t\t\tif (prev1 - i1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdb[d] = i1;\n\t\t\tif (!odd && fmin <= d && d <= fmax && i1 <= kvdf[d]) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\tif (need_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the edit cost is above the heuristic trigger and if\n\t\t * we got a good snake, we sample current diagonals to see\n\t\t * if some of the, have reached an \"interesting\" path. Our\n\t\t * measure is a function of the distance from the diagonal\n\t\t * corner (i1 + i2) penalized with the distance from the\n\t\t * mid diagonal itself. If this value is above the current\n\t\t * edit cost times a magic factor (XDL_K_HEUR) we consider\n\t\t * it interesting.\n\t\t */\n\t\tif (got_snake && ec > xenv->heur_min) {\n\t\t\tfor (best = 0, d = fmax; d >= fmin; d -= 2) {\n\t\t\t\tdd = d > fmid ? d - fmid: fmid - d;\n\t\t\t\ti1 = kvdf[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (i1 - off1) + (i2 - off2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 + xenv->snake_cnt <= i1 && i1 < lim1 &&\n\t\t\t\t    off2 + xenv->snake_cnt <= i2 && i2 < lim2) {\n\t\t\t\t\tfor (k = 1; ha1[i1 - k] == ha2[i2 - k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t\treturn ec;\n\t\t\t}\n\n\t\t\tfor (best = 0, d = bmax; d >= bmin; d -= 2) {\n\t\t\t\tdd = d > bmid ? d - bmid: bmid - d;\n\t\t\t\ti1 = kvdb[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (lim1 - i1) + (lim2 - i2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 < i1 && i1 <= lim1 - xenv->snake_cnt &&\n\t\t\t\t    off2 < i2 && i2 <= lim2 - xenv->snake_cnt) {\n\t\t\t\t\tfor (k = 0; ha1[i1 + k] == ha2[i2 + k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt - 1) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Enough is enough. We spent too much time here and now we collect\n\t\t * the furthest reaching path using the (i1 + i2) measure.\n\t\t */\n\t\tif (ec >= xenv->mxcost) {\n\t\t\tlong fbest, fbest1, bbest, bbest1;\n\n\t\t\tfbest = fbest1 = -1;\n\t\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\t\ti1 = XDL_MIN(kvdf[d], lim1);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (lim2 < i2)\n\t\t\t\t\ti1 = lim2 + d, i2 = lim2;\n\t\t\t\tif (fbest < i1 + i2) {\n\t\t\t\t\tfbest = i1 + i2;\n\t\t\t\t\tfbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbbest = bbest1 = XDL_LINE_MAX;\n\t\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\t\ti1 = XDL_MAX(off1, kvdb[d]);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (i2 < off2)\n\t\t\t\t\ti1 = off2 + d, i2 = off2;\n\t\t\t\tif (i1 + i2 < bbest) {\n\t\t\t\t\tbbest = i1 + i2;\n\t\t\t\t\tbbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((lim1 + lim2) - bbest < fbest - (off1 + off2)) {\n\t\t\t\tspl->i1 = fbest1;\n\t\t\t\tspl->i2 = fbest - fbest1;\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t} else {\n\t\t\t\tspl->i1 = bbest1;\n\t\t\t\tspl->i2 = bbest - bbest1;\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t}\n\t\t\treturn ec;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);\n\nint xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv) {\n\tunsigned long const *ha1 = dd1->ha, *ha2 = dd2->ha;\n\n\t/*\n\t * Shrink the box by walking through each diagonal snake (SW and NE).\n\t */\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[off1] == ha2[off2]; off1++, off2++);\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[lim1 - 1] == ha2[lim2 - 1]; lim1--, lim2--);\n\n\t/*\n\t * If one dimension is empty, then all records on the other one must\n\t * be obviously changed.\n\t */\n\tif (off1 == lim1) {\n\t\tchar *rchg2 = dd2->rchg;\n\t\tlong *rindex2 = dd2->rindex;\n\n\t\tfor (; off2 < lim2; off2++)\n\t\t\trchg2[rindex2[off2]] = 1;\n\t} else if (off2 == lim2) {\n\t\tchar *rchg1 = dd1->rchg;\n\t\tlong *rindex1 = dd1->rindex;\n\n\t\tfor (; off1 < lim1; off1++)\n\t\t\trchg1[rindex1[off1]] = 1;\n\t} else {\n\t\txdpsplit_t spl;\n\t\tspl.i1 = spl.i2 = 0;\n\n\t\t/*\n\t\t * Divide ...\n\t\t */\n\t\tif (xdl_split(ha1, off1, lim1, ha2, off2, lim2, kvdf, kvdb,\n\t\t\t      need_min, &spl, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * ... et Impera.\n\t\t */\n\t\tif (xdl_recs_cmp(dd1, off1, spl.i1, dd2, off2, spl.i2,\n\t\t\t\t kvdf, kvdb, spl.min_lo, xenv) < 0 ||\n\t\t    xdl_recs_cmp(dd1, spl.i1, lim1, dd2, spl.i2, lim2,\n\t\t\t\t kvdf, kvdb, spl.min_hi, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
    "lines": "63-261",
    "snippet": "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv) {\n\tlong dmin = off1 - lim2, dmax = lim1 - off2;\n\tlong fmid = off1 - off2, bmid = lim1 - lim2;\n\tlong odd = (fmid - bmid) & 1;\n\tlong fmin = fmid, fmax = fmid;\n\tlong bmin = bmid, bmax = bmid;\n\tlong ec, d, i1, i2, prev1, best, dd, v, k;\n\n\t/*\n\t * Set initial diagonal values for both forward and backward path.\n\t */\n\tkvdf[fmid] = off1;\n\tkvdb[bmid] = lim1;\n\n\tfor (ec = 1;; ec++) {\n\t\tint got_snake = 0;\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (fmin > dmin)\n\t\t\tkvdf[--fmin - 1] = -1;\n\t\telse\n\t\t\t++fmin;\n\t\tif (fmax < dmax)\n\t\t\tkvdf[++fmax + 1] = -1;\n\t\telse\n\t\t\t--fmax;\n\n\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\tif (kvdf[d - 1] >= kvdf[d + 1])\n\t\t\t\ti1 = kvdf[d - 1] + 1;\n\t\t\telse\n\t\t\t\ti1 = kvdf[d + 1];\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 < lim1 && i2 < lim2 && ha1[i1] == ha2[i2]; i1++, i2++);\n\t\t\tif (i1 - prev1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdf[d] = i1;\n\t\t\tif (odd && bmin <= d && d <= bmax && kvdb[d] <= i1) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (bmin > dmin)\n\t\t\tkvdb[--bmin - 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t++bmin;\n\t\tif (bmax < dmax)\n\t\t\tkvdb[++bmax + 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t--bmax;\n\n\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\tif (kvdb[d - 1] < kvdb[d + 1])\n\t\t\t\ti1 = kvdb[d - 1];\n\t\t\telse\n\t\t\t\ti1 = kvdb[d + 1] - 1;\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 > off1 && i2 > off2 && ha1[i1 - 1] == ha2[i2 - 1]; i1--, i2--);\n\t\t\tif (prev1 - i1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdb[d] = i1;\n\t\t\tif (!odd && fmin <= d && d <= fmax && i1 <= kvdf[d]) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\tif (need_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the edit cost is above the heuristic trigger and if\n\t\t * we got a good snake, we sample current diagonals to see\n\t\t * if some of the, have reached an \"interesting\" path. Our\n\t\t * measure is a function of the distance from the diagonal\n\t\t * corner (i1 + i2) penalized with the distance from the\n\t\t * mid diagonal itself. If this value is above the current\n\t\t * edit cost times a magic factor (XDL_K_HEUR) we consider\n\t\t * it interesting.\n\t\t */\n\t\tif (got_snake && ec > xenv->heur_min) {\n\t\t\tfor (best = 0, d = fmax; d >= fmin; d -= 2) {\n\t\t\t\tdd = d > fmid ? d - fmid: fmid - d;\n\t\t\t\ti1 = kvdf[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (i1 - off1) + (i2 - off2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 + xenv->snake_cnt <= i1 && i1 < lim1 &&\n\t\t\t\t    off2 + xenv->snake_cnt <= i2 && i2 < lim2) {\n\t\t\t\t\tfor (k = 1; ha1[i1 - k] == ha2[i2 - k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t\treturn ec;\n\t\t\t}\n\n\t\t\tfor (best = 0, d = bmax; d >= bmin; d -= 2) {\n\t\t\t\tdd = d > bmid ? d - bmid: bmid - d;\n\t\t\t\ti1 = kvdb[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (lim1 - i1) + (lim2 - i2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 < i1 && i1 <= lim1 - xenv->snake_cnt &&\n\t\t\t\t    off2 < i2 && i2 <= lim2 - xenv->snake_cnt) {\n\t\t\t\t\tfor (k = 0; ha1[i1 + k] == ha2[i2 + k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt - 1) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Enough is enough. We spent too much time here and now we collect\n\t\t * the furthest reaching path using the (i1 + i2) measure.\n\t\t */\n\t\tif (ec >= xenv->mxcost) {\n\t\t\tlong fbest, fbest1, bbest, bbest1;\n\n\t\t\tfbest = fbest1 = -1;\n\t\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\t\ti1 = XDL_MIN(kvdf[d], lim1);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (lim2 < i2)\n\t\t\t\t\ti1 = lim2 + d, i2 = lim2;\n\t\t\t\tif (fbest < i1 + i2) {\n\t\t\t\t\tfbest = i1 + i2;\n\t\t\t\t\tfbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbbest = bbest1 = XDL_LINE_MAX;\n\t\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\t\ti1 = XDL_MAX(off1, kvdb[d]);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (i2 < off2)\n\t\t\t\t\ti1 = off2 + d, i2 = off2;\n\t\t\t\tif (i1 + i2 < bbest) {\n\t\t\t\t\tbbest = i1 + i2;\n\t\t\t\t\tbbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((lim1 + lim2) - bbest < fbest - (off1 + off2)) {\n\t\t\t\tspl->i1 = fbest1;\n\t\t\t\tspl->i2 = fbest - fbest1;\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t} else {\n\t\t\t\tspl->i1 = bbest1;\n\t\t\t\tspl->i2 = bbest - bbest1;\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t}\n\t\t\treturn ec;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [
      "#define XDL_K_HEUR 4",
      "#define XDL_LINE_MAX (long)((1UL << (CHAR_BIT * sizeof(long) - 1)) - 1)"
    ],
    "globals_used": [
      "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDL_MAX",
          "args": [
            "off1",
            "kvdb[d]"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_MIN",
          "args": [
            "kvdf[d]",
            "lim1"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\n#define XDL_K_HEUR 4\n#define XDL_LINE_MAX (long)((1UL << (CHAR_BIT * sizeof(long) - 1)) - 1)\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv) {\n\tlong dmin = off1 - lim2, dmax = lim1 - off2;\n\tlong fmid = off1 - off2, bmid = lim1 - lim2;\n\tlong odd = (fmid - bmid) & 1;\n\tlong fmin = fmid, fmax = fmid;\n\tlong bmin = bmid, bmax = bmid;\n\tlong ec, d, i1, i2, prev1, best, dd, v, k;\n\n\t/*\n\t * Set initial diagonal values for both forward and backward path.\n\t */\n\tkvdf[fmid] = off1;\n\tkvdb[bmid] = lim1;\n\n\tfor (ec = 1;; ec++) {\n\t\tint got_snake = 0;\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (fmin > dmin)\n\t\t\tkvdf[--fmin - 1] = -1;\n\t\telse\n\t\t\t++fmin;\n\t\tif (fmax < dmax)\n\t\t\tkvdf[++fmax + 1] = -1;\n\t\telse\n\t\t\t--fmax;\n\n\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\tif (kvdf[d - 1] >= kvdf[d + 1])\n\t\t\t\ti1 = kvdf[d - 1] + 1;\n\t\t\telse\n\t\t\t\ti1 = kvdf[d + 1];\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 < lim1 && i2 < lim2 && ha1[i1] == ha2[i2]; i1++, i2++);\n\t\t\tif (i1 - prev1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdf[d] = i1;\n\t\t\tif (odd && bmin <= d && d <= bmax && kvdb[d] <= i1) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (bmin > dmin)\n\t\t\tkvdb[--bmin - 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t++bmin;\n\t\tif (bmax < dmax)\n\t\t\tkvdb[++bmax + 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t--bmax;\n\n\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\tif (kvdb[d - 1] < kvdb[d + 1])\n\t\t\t\ti1 = kvdb[d - 1];\n\t\t\telse\n\t\t\t\ti1 = kvdb[d + 1] - 1;\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 > off1 && i2 > off2 && ha1[i1 - 1] == ha2[i2 - 1]; i1--, i2--);\n\t\t\tif (prev1 - i1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdb[d] = i1;\n\t\t\tif (!odd && fmin <= d && d <= fmax && i1 <= kvdf[d]) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\tif (need_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the edit cost is above the heuristic trigger and if\n\t\t * we got a good snake, we sample current diagonals to see\n\t\t * if some of the, have reached an \"interesting\" path. Our\n\t\t * measure is a function of the distance from the diagonal\n\t\t * corner (i1 + i2) penalized with the distance from the\n\t\t * mid diagonal itself. If this value is above the current\n\t\t * edit cost times a magic factor (XDL_K_HEUR) we consider\n\t\t * it interesting.\n\t\t */\n\t\tif (got_snake && ec > xenv->heur_min) {\n\t\t\tfor (best = 0, d = fmax; d >= fmin; d -= 2) {\n\t\t\t\tdd = d > fmid ? d - fmid: fmid - d;\n\t\t\t\ti1 = kvdf[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (i1 - off1) + (i2 - off2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 + xenv->snake_cnt <= i1 && i1 < lim1 &&\n\t\t\t\t    off2 + xenv->snake_cnt <= i2 && i2 < lim2) {\n\t\t\t\t\tfor (k = 1; ha1[i1 - k] == ha2[i2 - k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t\treturn ec;\n\t\t\t}\n\n\t\t\tfor (best = 0, d = bmax; d >= bmin; d -= 2) {\n\t\t\t\tdd = d > bmid ? d - bmid: bmid - d;\n\t\t\t\ti1 = kvdb[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (lim1 - i1) + (lim2 - i2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 < i1 && i1 <= lim1 - xenv->snake_cnt &&\n\t\t\t\t    off2 < i2 && i2 <= lim2 - xenv->snake_cnt) {\n\t\t\t\t\tfor (k = 0; ha1[i1 + k] == ha2[i2 + k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt - 1) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Enough is enough. We spent too much time here and now we collect\n\t\t * the furthest reaching path using the (i1 + i2) measure.\n\t\t */\n\t\tif (ec >= xenv->mxcost) {\n\t\t\tlong fbest, fbest1, bbest, bbest1;\n\n\t\t\tfbest = fbest1 = -1;\n\t\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\t\ti1 = XDL_MIN(kvdf[d], lim1);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (lim2 < i2)\n\t\t\t\t\ti1 = lim2 + d, i2 = lim2;\n\t\t\t\tif (fbest < i1 + i2) {\n\t\t\t\t\tfbest = i1 + i2;\n\t\t\t\t\tfbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbbest = bbest1 = XDL_LINE_MAX;\n\t\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\t\ti1 = XDL_MAX(off1, kvdb[d]);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (i2 < off2)\n\t\t\t\t\ti1 = off2 + d, i2 = off2;\n\t\t\t\tif (i1 + i2 < bbest) {\n\t\t\t\t\tbbest = i1 + i2;\n\t\t\t\t\tbbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((lim1 + lim2) - bbest < fbest - (off1 + off2)) {\n\t\t\t\tspl->i1 = fbest1;\n\t\t\t\tspl->i2 = fbest - fbest1;\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t} else {\n\t\t\t\tspl->i1 = bbest1;\n\t\t\t\tspl->i2 = bbest - bbest1;\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t}\n\t\t\treturn ec;\n\t\t}\n\t}\n}"
  }
]