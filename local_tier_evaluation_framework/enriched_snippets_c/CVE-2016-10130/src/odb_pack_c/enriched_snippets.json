[
  {
    "function_name": "git_odb_backend_pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "588-614",
    "snippet": "int git_odb_backend_pack(git_odb_backend **backend_out, const char *objects_dir)\n{\n\tint error = 0;\n\tstruct pack_backend *backend = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (pack_backend__alloc(&backend, 8) < 0)\n\t\treturn -1;\n\n\tif (!(error = git_buf_joinpath(&path, objects_dir, \"pack\")) &&\n\t\tgit_path_isdir(git_buf_cstr(&path)))\n\t{\n\t\tbackend->pack_folder = git_buf_detach(&path);\n\t\terror = pack_backend__refresh((git_odb_backend *)backend);\n\t}\n\n\tif (error < 0) {\n\t\tpack_backend__free((git_odb_backend *)backend);\n\t\tbackend = NULL;\n\t}\n\n\t*backend_out = (git_odb_backend *)backend;\n\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_load__cb(void *_data, git_buf *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_backend__free",
          "args": [
            "(git_odb_backend *)backend"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "pack_backend__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "524-541",
          "snippet": "static void pack_backend__free(git_odb_backend *_backend)\n{\n\tstruct pack_backend *backend;\n\tsize_t i;\n\n\tassert(_backend);\n\n\tbackend = (struct pack_backend *)_backend;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\t\tgit_mwindow_put_pack(p);\n\t}\n\n\tgit_vector_free(&backend->packs);\n\tgit__free(backend->pack_folder);\n\tgit__free(backend);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void pack_backend__free(git_odb_backend *_backend)\n{\n\tstruct pack_backend *backend;\n\tsize_t i;\n\n\tassert(_backend);\n\n\tbackend = (struct pack_backend *)_backend;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\t\tgit_mwindow_put_pack(p);\n\t}\n\n\tgit_vector_free(&backend->packs);\n\tgit__free(backend->pack_folder);\n\tgit__free(backend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_backend__refresh",
          "args": [
            "(git_odb_backend *)backend"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "pack_backend__refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "327-349",
          "snippet": "static int pack_backend__refresh(git_odb_backend *backend_)\n{\n\tint error;\n\tstruct stat st;\n\tgit_buf path = GIT_BUF_INIT;\n\tstruct pack_backend *backend = (struct pack_backend *)backend_;\n\n\tif (backend->pack_folder == NULL)\n\t\treturn 0;\n\n\tif (p_stat(backend->pack_folder, &st) < 0 || !S_ISDIR(st.st_mode))\n\t\treturn git_odb__error_notfound(\"failed to refresh packfiles\", NULL, 0);\n\n\tgit_buf_sets(&path, backend->pack_folder);\n\n\t/* reload all packs */\n\terror = git_path_direach(&path, 0, packfile_load__cb, backend);\n\n\tgit_buf_free(&path);\n\tgit_vector_sort(&backend->packs);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_load__cb(void *_data, git_buf *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_load__cb(void *_data, git_buf *path);\n\nstatic int pack_backend__refresh(git_odb_backend *backend_)\n{\n\tint error;\n\tstruct stat st;\n\tgit_buf path = GIT_BUF_INIT;\n\tstruct pack_backend *backend = (struct pack_backend *)backend_;\n\n\tif (backend->pack_folder == NULL)\n\t\treturn 0;\n\n\tif (p_stat(backend->pack_folder, &st) < 0 || !S_ISDIR(st.st_mode))\n\t\treturn git_odb__error_notfound(\"failed to refresh packfiles\", NULL, 0);\n\n\tgit_buf_sets(&path, backend->pack_folder);\n\n\t/* reload all packs */\n\terror = git_path_direach(&path, 0, packfile_load__cb, backend);\n\n\tgit_buf_free(&path);\n\tgit_vector_sort(&backend->packs);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&path"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "git_buf_cstr(&path)"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&path"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "objects_dir",
            "\"pack\""
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_backend__alloc",
          "args": [
            "&backend",
            "8"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "pack_backend__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "543-567",
          "snippet": "static int pack_backend__alloc(struct pack_backend **out, size_t initial_size)\n{\n\tstruct pack_backend *backend = git__calloc(1, sizeof(struct pack_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tif (git_vector_init(&backend->packs, initial_size, packfile_sort__cb) < 0) {\n\t\tgit__free(backend);\n\t\treturn -1;\n\t}\n\n\tbackend->parent.version = GIT_ODB_BACKEND_VERSION;\n\n\tbackend->parent.read = &pack_backend__read;\n\tbackend->parent.read_prefix = &pack_backend__read_prefix;\n\tbackend->parent.read_header = &pack_backend__read_header;\n\tbackend->parent.exists = &pack_backend__exists;\n\tbackend->parent.exists_prefix = &pack_backend__exists_prefix;\n\tbackend->parent.refresh = &pack_backend__refresh;\n\tbackend->parent.foreach = &pack_backend__foreach;\n\tbackend->parent.writepack = &pack_backend__writepack;\n\tbackend->parent.free = &pack_backend__free;\n\n\t*out = backend;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_backend__alloc(struct pack_backend **out, size_t initial_size)\n{\n\tstruct pack_backend *backend = git__calloc(1, sizeof(struct pack_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tif (git_vector_init(&backend->packs, initial_size, packfile_sort__cb) < 0) {\n\t\tgit__free(backend);\n\t\treturn -1;\n\t}\n\n\tbackend->parent.version = GIT_ODB_BACKEND_VERSION;\n\n\tbackend->parent.read = &pack_backend__read;\n\tbackend->parent.read_prefix = &pack_backend__read_prefix;\n\tbackend->parent.read_header = &pack_backend__read_header;\n\tbackend->parent.exists = &pack_backend__exists;\n\tbackend->parent.exists_prefix = &pack_backend__exists_prefix;\n\tbackend->parent.refresh = &pack_backend__refresh;\n\tbackend->parent.foreach = &pack_backend__foreach;\n\tbackend->parent.writepack = &pack_backend__writepack;\n\tbackend->parent.free = &pack_backend__free;\n\n\t*out = backend;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_load__cb(void *_data, git_buf *path);\n\nint git_odb_backend_pack(git_odb_backend **backend_out, const char *objects_dir)\n{\n\tint error = 0;\n\tstruct pack_backend *backend = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (pack_backend__alloc(&backend, 8) < 0)\n\t\treturn -1;\n\n\tif (!(error = git_buf_joinpath(&path, objects_dir, \"pack\")) &&\n\t\tgit_path_isdir(git_buf_cstr(&path)))\n\t{\n\t\tbackend->pack_folder = git_buf_detach(&path);\n\t\terror = pack_backend__refresh((git_odb_backend *)backend);\n\t}\n\n\tif (error < 0) {\n\t\tpack_backend__free((git_odb_backend *)backend);\n\t\tbackend = NULL;\n\t}\n\n\t*backend_out = (git_odb_backend *)backend;\n\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_odb_backend_one_pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "569-586",
    "snippet": "int git_odb_backend_one_pack(git_odb_backend **backend_out, const char *idx)\n{\n\tstruct pack_backend *backend = NULL;\n\tstruct git_pack_file *packfile = NULL;\n\n\tif (pack_backend__alloc(&backend, 1) < 0)\n\t\treturn -1;\n\n\tif (git_mwindow_get_pack(&packfile, idx) < 0 ||\n\t\tgit_vector_insert(&backend->packs, packfile) < 0)\n\t{\n\t\tpack_backend__free((git_odb_backend *)backend);\n\t\treturn -1;\n\t}\n\n\t*backend_out = (git_odb_backend *)backend;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pack_backend__free",
          "args": [
            "(git_odb_backend *)backend"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "pack_backend__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "524-541",
          "snippet": "static void pack_backend__free(git_odb_backend *_backend)\n{\n\tstruct pack_backend *backend;\n\tsize_t i;\n\n\tassert(_backend);\n\n\tbackend = (struct pack_backend *)_backend;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\t\tgit_mwindow_put_pack(p);\n\t}\n\n\tgit_vector_free(&backend->packs);\n\tgit__free(backend->pack_folder);\n\tgit__free(backend);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void pack_backend__free(git_odb_backend *_backend)\n{\n\tstruct pack_backend *backend;\n\tsize_t i;\n\n\tassert(_backend);\n\n\tbackend = (struct pack_backend *)_backend;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\t\tgit_mwindow_put_pack(p);\n\t}\n\n\tgit_vector_free(&backend->packs);\n\tgit__free(backend->pack_folder);\n\tgit__free(backend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&backend->packs",
            "packfile"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_get_pack",
          "args": [
            "&packfile",
            "idx"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_get_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "52-97",
          "snippet": "int git_mwindow_get_pack(struct git_pack_file **out, const char *path)\n{\n\tint error;\n\tchar *packname;\n\tgit_strmap_iter pos;\n\tstruct git_pack_file *pack;\n\n\tif ((error = git_packfile__name(&packname, path)) < 0)\n\t\treturn error;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tpos = git_strmap_lookup_index(git__pack_cache, packname);\n\tgit__free(packname);\n\n\tif (git_strmap_valid_index(git__pack_cache, pos)) {\n\t\tpack = git_strmap_value_at(git__pack_cache, pos);\n\t\tgit_atomic_inc(&pack->refcount);\n\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*out = pack;\n\t\treturn 0;\n\t}\n\n\t/* If we didn't find it, we need to create it */\n\tif ((error = git_packfile_alloc(&pack, path)) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn error;\n\t}\n\n\tgit_atomic_inc(&pack->refcount);\n\n\tgit_strmap_insert(git__pack_cache, pack->pack_name, pack, error);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\tif (error < 0) {\n\t\tgit_packfile_free(pack);\n\t\treturn -1;\n\t}\n\n\t*out = pack;\n\treturn 0;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "git_strmap *git__pack_cache = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\ngit_strmap *git__pack_cache = NULL;\n\nint git_mwindow_get_pack(struct git_pack_file **out, const char *path)\n{\n\tint error;\n\tchar *packname;\n\tgit_strmap_iter pos;\n\tstruct git_pack_file *pack;\n\n\tif ((error = git_packfile__name(&packname, path)) < 0)\n\t\treturn error;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tpos = git_strmap_lookup_index(git__pack_cache, packname);\n\tgit__free(packname);\n\n\tif (git_strmap_valid_index(git__pack_cache, pos)) {\n\t\tpack = git_strmap_value_at(git__pack_cache, pos);\n\t\tgit_atomic_inc(&pack->refcount);\n\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*out = pack;\n\t\treturn 0;\n\t}\n\n\t/* If we didn't find it, we need to create it */\n\tif ((error = git_packfile_alloc(&pack, path)) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn error;\n\t}\n\n\tgit_atomic_inc(&pack->refcount);\n\n\tgit_strmap_insert(git__pack_cache, pack->pack_name, pack, error);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\tif (error < 0) {\n\t\tgit_packfile_free(pack);\n\t\treturn -1;\n\t}\n\n\t*out = pack;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_backend__alloc",
          "args": [
            "&backend",
            "1"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "pack_backend__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "543-567",
          "snippet": "static int pack_backend__alloc(struct pack_backend **out, size_t initial_size)\n{\n\tstruct pack_backend *backend = git__calloc(1, sizeof(struct pack_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tif (git_vector_init(&backend->packs, initial_size, packfile_sort__cb) < 0) {\n\t\tgit__free(backend);\n\t\treturn -1;\n\t}\n\n\tbackend->parent.version = GIT_ODB_BACKEND_VERSION;\n\n\tbackend->parent.read = &pack_backend__read;\n\tbackend->parent.read_prefix = &pack_backend__read_prefix;\n\tbackend->parent.read_header = &pack_backend__read_header;\n\tbackend->parent.exists = &pack_backend__exists;\n\tbackend->parent.exists_prefix = &pack_backend__exists_prefix;\n\tbackend->parent.refresh = &pack_backend__refresh;\n\tbackend->parent.foreach = &pack_backend__foreach;\n\tbackend->parent.writepack = &pack_backend__writepack;\n\tbackend->parent.free = &pack_backend__free;\n\n\t*out = backend;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_backend__alloc(struct pack_backend **out, size_t initial_size)\n{\n\tstruct pack_backend *backend = git__calloc(1, sizeof(struct pack_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tif (git_vector_init(&backend->packs, initial_size, packfile_sort__cb) < 0) {\n\t\tgit__free(backend);\n\t\treturn -1;\n\t}\n\n\tbackend->parent.version = GIT_ODB_BACKEND_VERSION;\n\n\tbackend->parent.read = &pack_backend__read;\n\tbackend->parent.read_prefix = &pack_backend__read_prefix;\n\tbackend->parent.read_header = &pack_backend__read_header;\n\tbackend->parent.exists = &pack_backend__exists;\n\tbackend->parent.exists_prefix = &pack_backend__exists_prefix;\n\tbackend->parent.refresh = &pack_backend__refresh;\n\tbackend->parent.foreach = &pack_backend__foreach;\n\tbackend->parent.writepack = &pack_backend__writepack;\n\tbackend->parent.free = &pack_backend__free;\n\n\t*out = backend;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_backend_one_pack(git_odb_backend **backend_out, const char *idx)\n{\n\tstruct pack_backend *backend = NULL;\n\tstruct git_pack_file *packfile = NULL;\n\n\tif (pack_backend__alloc(&backend, 1) < 0)\n\t\treturn -1;\n\n\tif (git_mwindow_get_pack(&packfile, idx) < 0 ||\n\t\tgit_vector_insert(&backend->packs, packfile) < 0)\n\t{\n\t\tpack_backend__free((git_odb_backend *)backend);\n\t\treturn -1;\n\t}\n\n\t*backend_out = (git_odb_backend *)backend;\n\treturn 0;\n}"
  },
  {
    "function_name": "pack_backend__alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "543-567",
    "snippet": "static int pack_backend__alloc(struct pack_backend **out, size_t initial_size)\n{\n\tstruct pack_backend *backend = git__calloc(1, sizeof(struct pack_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tif (git_vector_init(&backend->packs, initial_size, packfile_sort__cb) < 0) {\n\t\tgit__free(backend);\n\t\treturn -1;\n\t}\n\n\tbackend->parent.version = GIT_ODB_BACKEND_VERSION;\n\n\tbackend->parent.read = &pack_backend__read;\n\tbackend->parent.read_prefix = &pack_backend__read_prefix;\n\tbackend->parent.read_header = &pack_backend__read_header;\n\tbackend->parent.exists = &pack_backend__exists;\n\tbackend->parent.exists_prefix = &pack_backend__exists_prefix;\n\tbackend->parent.refresh = &pack_backend__refresh;\n\tbackend->parent.foreach = &pack_backend__foreach;\n\tbackend->parent.writepack = &pack_backend__writepack;\n\tbackend->parent.free = &pack_backend__free;\n\n\t*out = backend;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "backend"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&backend->packs",
            "initial_size",
            "packfile_sort__cb"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "backend"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(struct pack_backend)"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_backend__alloc(struct pack_backend **out, size_t initial_size)\n{\n\tstruct pack_backend *backend = git__calloc(1, sizeof(struct pack_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tif (git_vector_init(&backend->packs, initial_size, packfile_sort__cb) < 0) {\n\t\tgit__free(backend);\n\t\treturn -1;\n\t}\n\n\tbackend->parent.version = GIT_ODB_BACKEND_VERSION;\n\n\tbackend->parent.read = &pack_backend__read;\n\tbackend->parent.read_prefix = &pack_backend__read_prefix;\n\tbackend->parent.read_header = &pack_backend__read_header;\n\tbackend->parent.exists = &pack_backend__exists;\n\tbackend->parent.exists_prefix = &pack_backend__exists_prefix;\n\tbackend->parent.refresh = &pack_backend__refresh;\n\tbackend->parent.foreach = &pack_backend__foreach;\n\tbackend->parent.writepack = &pack_backend__writepack;\n\tbackend->parent.free = &pack_backend__free;\n\n\t*out = backend;\n\treturn 0;\n}"
  },
  {
    "function_name": "pack_backend__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "524-541",
    "snippet": "static void pack_backend__free(git_odb_backend *_backend)\n{\n\tstruct pack_backend *backend;\n\tsize_t i;\n\n\tassert(_backend);\n\n\tbackend = (struct pack_backend *)_backend;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\t\tgit_mwindow_put_pack(p);\n\t}\n\n\tgit_vector_free(&backend->packs);\n\tgit__free(backend->pack_folder);\n\tgit__free(backend);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "backend"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&backend->packs"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_put_pack",
          "args": [
            "p"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_put_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "99-122",
          "snippet": "void git_mwindow_put_pack(struct git_pack_file *pack)\n{\n\tint count;\n\tgit_strmap_iter pos;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0)\n\t\treturn;\n\n\t/* put before get would be a corrupted state */\n\tassert(git__pack_cache);\n\n\tpos = git_strmap_lookup_index(git__pack_cache, pack->pack_name);\n\t/* if we cannot find it, the state is corrupted */\n\tassert(git_strmap_valid_index(git__pack_cache, pos));\n\n\tcount = git_atomic_dec(&pack->refcount);\n\tif (count == 0) {\n\t\tgit_strmap_delete_at(git__pack_cache, pos);\n\t\tgit_packfile_free(pack);\n\t}\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "git_strmap *git__pack_cache = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\ngit_strmap *git__pack_cache = NULL;\n\nvoid git_mwindow_put_pack(struct git_pack_file *pack)\n{\n\tint count;\n\tgit_strmap_iter pos;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0)\n\t\treturn;\n\n\t/* put before get would be a corrupted state */\n\tassert(git__pack_cache);\n\n\tpos = git_strmap_lookup_index(git__pack_cache, pack->pack_name);\n\t/* if we cannot find it, the state is corrupted */\n\tassert(git_strmap_valid_index(git__pack_cache, pos));\n\n\tcount = git_atomic_dec(&pack->refcount);\n\tif (count == 0) {\n\t\tgit_strmap_delete_at(git__pack_cache, pos);\n\t\tgit_packfile_free(pack);\n\t}\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&backend->packs",
            "i"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "_backend"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void pack_backend__free(git_odb_backend *_backend)\n{\n\tstruct pack_backend *backend;\n\tsize_t i;\n\n\tassert(_backend);\n\n\tbackend = (struct pack_backend *)_backend;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\t\tgit_mwindow_put_pack(p);\n\t}\n\n\tgit_vector_free(&backend->packs);\n\tgit__free(backend->pack_folder);\n\tgit__free(backend);\n}"
  },
  {
    "function_name": "pack_backend__writepack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "490-522",
    "snippet": "static int pack_backend__writepack(struct git_odb_writepack **out,\n\tgit_odb_backend *_backend,\n        git_odb *odb,\n\tgit_transfer_progress_cb progress_cb,\n\tvoid *progress_payload)\n{\n\tstruct pack_backend *backend;\n\tstruct pack_writepack *writepack;\n\n\tassert(out && _backend);\n\n\t*out = NULL;\n\n\tbackend = (struct pack_backend *)_backend;\n\n\twritepack = git__calloc(1, sizeof(struct pack_writepack));\n\tGITERR_CHECK_ALLOC(writepack);\n\n\tif (git_indexer_new(&writepack->indexer,\n\t\tbackend->pack_folder, 0, odb, progress_cb, progress_payload) < 0) {\n\t\tgit__free(writepack);\n\t\treturn -1;\n\t}\n\n\twritepack->parent.backend = _backend;\n\twritepack->parent.append = pack_backend__writepack_append;\n\twritepack->parent.commit = pack_backend__writepack_commit;\n\twritepack->parent.free = pack_backend__writepack_free;\n\n\t*out = (git_odb_writepack *)writepack;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "writepack"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexer_new",
          "args": [
            "&writepack->indexer",
            "backend->pack_folder",
            "0",
            "odb",
            "progress_cb",
            "progress_payload"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexer_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "106-158",
          "snippet": "int git_indexer_new(\n\t\tgit_indexer **out,\n\t\tconst char *prefix,\n\t\tunsigned int mode,\n\t\tgit_odb *odb,\n\t\tgit_transfer_progress_cb progress_cb,\n\t\tvoid *progress_payload)\n{\n\tgit_indexer *idx;\n\tgit_buf path = GIT_BUF_INIT, tmp_path = GIT_BUF_INIT;\n\tstatic const char suff[] = \"/pack\";\n\tint error, fd = -1;\n\n\tidx = git__calloc(1, sizeof(git_indexer));\n\tGITERR_CHECK_ALLOC(idx);\n\tidx->odb = odb;\n\tidx->progress_cb = progress_cb;\n\tidx->progress_payload = progress_payload;\n\tidx->mode = mode ? mode : GIT_PACK_FILE_MODE;\n\tgit_hash_ctx_init(&idx->hash_ctx);\n\tgit_hash_ctx_init(&idx->trailer);\n\n\terror = git_buf_joinpath(&path, prefix, suff);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tfd = git_futils_mktmp(&tmp_path, git_buf_cstr(&path), idx->mode);\n\tgit_buf_free(&path);\n\tif (fd < 0)\n\t\tgoto cleanup;\n\n\terror = git_packfile_alloc(&idx->pack, git_buf_cstr(&tmp_path));\n\tgit_buf_free(&tmp_path);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.fd = fd;\n\tif ((error = git_mwindow_file_register(&idx->pack->mwf)) < 0)\n\t\tgoto cleanup;\n\n\t*out = idx;\n\treturn 0;\n\ncleanup:\n\tif (fd != -1)\n\t\tp_close(fd);\n\n\tgit_buf_free(&path);\n\tgit_buf_free(&tmp_path);\n\tgit__free(idx);\n\treturn -1;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nint git_indexer_new(\n\t\tgit_indexer **out,\n\t\tconst char *prefix,\n\t\tunsigned int mode,\n\t\tgit_odb *odb,\n\t\tgit_transfer_progress_cb progress_cb,\n\t\tvoid *progress_payload)\n{\n\tgit_indexer *idx;\n\tgit_buf path = GIT_BUF_INIT, tmp_path = GIT_BUF_INIT;\n\tstatic const char suff[] = \"/pack\";\n\tint error, fd = -1;\n\n\tidx = git__calloc(1, sizeof(git_indexer));\n\tGITERR_CHECK_ALLOC(idx);\n\tidx->odb = odb;\n\tidx->progress_cb = progress_cb;\n\tidx->progress_payload = progress_payload;\n\tidx->mode = mode ? mode : GIT_PACK_FILE_MODE;\n\tgit_hash_ctx_init(&idx->hash_ctx);\n\tgit_hash_ctx_init(&idx->trailer);\n\n\terror = git_buf_joinpath(&path, prefix, suff);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tfd = git_futils_mktmp(&tmp_path, git_buf_cstr(&path), idx->mode);\n\tgit_buf_free(&path);\n\tif (fd < 0)\n\t\tgoto cleanup;\n\n\terror = git_packfile_alloc(&idx->pack, git_buf_cstr(&tmp_path));\n\tgit_buf_free(&tmp_path);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tidx->pack->mwf.fd = fd;\n\tif ((error = git_mwindow_file_register(&idx->pack->mwf)) < 0)\n\t\tgoto cleanup;\n\n\t*out = idx;\n\treturn 0;\n\ncleanup:\n\tif (fd != -1)\n\t\tp_close(fd);\n\n\tgit_buf_free(&path);\n\tgit_buf_free(&tmp_path);\n\tgit__free(idx);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "writepack"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(struct pack_writepack)"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && _backend"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_backend__writepack(struct git_odb_writepack **out,\n\tgit_odb_backend *_backend,\n        git_odb *odb,\n\tgit_transfer_progress_cb progress_cb,\n\tvoid *progress_payload)\n{\n\tstruct pack_backend *backend;\n\tstruct pack_writepack *writepack;\n\n\tassert(out && _backend);\n\n\t*out = NULL;\n\n\tbackend = (struct pack_backend *)_backend;\n\n\twritepack = git__calloc(1, sizeof(struct pack_writepack));\n\tGITERR_CHECK_ALLOC(writepack);\n\n\tif (git_indexer_new(&writepack->indexer,\n\t\tbackend->pack_folder, 0, odb, progress_cb, progress_payload) < 0) {\n\t\tgit__free(writepack);\n\t\treturn -1;\n\t}\n\n\twritepack->parent.backend = _backend;\n\twritepack->parent.append = pack_backend__writepack_append;\n\twritepack->parent.commit = pack_backend__writepack_commit;\n\twritepack->parent.free = pack_backend__writepack_free;\n\n\t*out = (git_odb_writepack *)writepack;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pack_backend__writepack_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "480-488",
    "snippet": "static void pack_backend__writepack_free(struct git_odb_writepack *_writepack)\n{\n\tstruct pack_writepack *writepack = (struct pack_writepack *)_writepack;\n\n\tassert(writepack);\n\n\tgit_indexer_free(writepack->indexer);\n\tgit__free(writepack);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "writepack"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexer_free",
          "args": [
            "writepack->indexer"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexer_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "1070-1095",
          "snippet": "void git_indexer_free(git_indexer *idx)\n{\n\tif (idx == NULL)\n\t\treturn;\n\n\tgit_vector_free_deep(&idx->objects);\n\n\tif (idx->pack && idx->pack->idx_cache) {\n\t\tstruct git_pack_entry *pentry;\n\t\tkh_foreach_value(\n\t\t\tidx->pack->idx_cache, pentry, { git__free(pentry); });\n\n\t\tgit_oidmap_free(idx->pack->idx_cache);\n\t}\n\n\tgit_vector_free_deep(&idx->deltas);\n\n\tif (!git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgit_packfile_free(idx->pack);\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t}\n\n\tgit_hash_ctx_cleanup(&idx->trailer);\n\tgit_hash_ctx_cleanup(&idx->hash_ctx);\n\tgit__free(idx);\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "GIT__USE_OIDMAP\n\nextern git_mutex git__mwindow_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nGIT__USE_OIDMAP\n\nextern git_mutex git__mwindow_mutex;\n\nvoid git_indexer_free(git_indexer *idx)\n{\n\tif (idx == NULL)\n\t\treturn;\n\n\tgit_vector_free_deep(&idx->objects);\n\n\tif (idx->pack && idx->pack->idx_cache) {\n\t\tstruct git_pack_entry *pentry;\n\t\tkh_foreach_value(\n\t\t\tidx->pack->idx_cache, pentry, { git__free(pentry); });\n\n\t\tgit_oidmap_free(idx->pack->idx_cache);\n\t}\n\n\tgit_vector_free_deep(&idx->deltas);\n\n\tif (!git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgit_packfile_free(idx->pack);\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t}\n\n\tgit_hash_ctx_cleanup(&idx->trailer);\n\tgit_hash_ctx_cleanup(&idx->hash_ctx);\n\tgit__free(idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "writepack"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic void pack_backend__writepack_free(struct git_odb_writepack *_writepack)\n{\n\tstruct pack_writepack *writepack = (struct pack_writepack *)_writepack;\n\n\tassert(writepack);\n\n\tgit_indexer_free(writepack->indexer);\n\tgit__free(writepack);\n}"
  },
  {
    "function_name": "pack_backend__writepack_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "471-478",
    "snippet": "static int pack_backend__writepack_commit(struct git_odb_writepack *_writepack, git_transfer_progress *stats)\n{\n\tstruct pack_writepack *writepack = (struct pack_writepack *)_writepack;\n\n\tassert(writepack);\n\n\treturn git_indexer_commit(writepack->indexer, stats);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_indexer_commit",
          "args": [
            "writepack->indexer",
            "stats"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexer_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "903-1068",
          "snippet": "int git_indexer_commit(git_indexer *idx, git_transfer_progress *stats)\n{\n\tgit_mwindow *w = NULL;\n\tunsigned int i, long_offsets = 0, left;\n\tint error;\n\tstruct git_pack_idx_header hdr;\n\tgit_buf filename = GIT_BUF_INIT;\n\tstruct entry *entry;\n\tgit_oid trailer_hash, file_hash;\n\tgit_hash_ctx ctx;\n\tgit_filebuf index_file = {0};\n\tvoid *packfile_trailer;\n\n\tif (!idx->parsed_header) {\n\t\tgiterr_set(GITERR_INDEXER, \"incomplete pack header\");\n\t\treturn -1;\n\t}\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\t/* Test for this before resolve_deltas(), as it plays with idx->off */\n\tif (idx->off + 20 < idx->pack->mwf.size) {\n\t\tgiterr_set(GITERR_INDEXER, \"unexpected data at the end of the pack\");\n\t\treturn -1;\n\t}\n\n\tpackfile_trailer = git_mwindow_open(&idx->pack->mwf, &w, idx->pack->mwf.size - GIT_OID_RAWSZ, GIT_OID_RAWSZ, &left);\n\tif (packfile_trailer == NULL) {\n\t\tgit_mwindow_close(&w);\n\t\tgoto on_error;\n\t}\n\n\t/* Compare the packfile trailer as it was sent to us and what we calculated */\n\tgit_oid_fromraw(&file_hash, packfile_trailer);\n\tgit_mwindow_close(&w);\n\n\tgit_hash_final(&trailer_hash, &idx->trailer);\n\tif (git_oid_cmp(&file_hash, &trailer_hash)) {\n\t\tgiterr_set(GITERR_INDEXER, \"packfile trailer mismatch\");\n\t\treturn -1;\n\t}\n\n\t/* Freeze the number of deltas */\n\tstats->total_deltas = stats->total_objects - stats->indexed_objects;\n\n\tif ((error = resolve_deltas(idx, stats)) < 0)\n\t\treturn error;\n\n\tif (stats->indexed_objects != stats->total_objects) {\n\t\tgiterr_set(GITERR_INDEXER, \"early EOF\");\n\t\treturn -1;\n\t}\n\n\tif (stats->local_objects > 0) {\n\t\tif (update_header_and_rehash(idx, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgit_hash_final(&trailer_hash, &idx->trailer);\n\t\twrite_at(idx, &trailer_hash, idx->pack->mwf.size - GIT_OID_RAWSZ, GIT_OID_RAWSZ);\n\t}\n\n\tgit_vector_sort(&idx->objects);\n\n\tgit_buf_sets(&filename, idx->pack->pack_name);\n\tgit_buf_shorten(&filename, strlen(\"pack\"));\n\tgit_buf_puts(&filename, \"idx\");\n\tif (git_buf_oom(&filename))\n\t\treturn -1;\n\n\tif (git_filebuf_open(&index_file, filename.ptr,\n\t\tGIT_FILEBUF_HASH_CONTENTS, idx->mode) < 0)\n\t\tgoto on_error;\n\n\t/* Write out the header */\n\thdr.idx_signature = htonl(PACK_IDX_SIGNATURE);\n\thdr.idx_version = htonl(2);\n\tgit_filebuf_write(&index_file, &hdr, sizeof(hdr));\n\n\t/* Write out the fanout table */\n\tfor (i = 0; i < 256; ++i) {\n\t\tuint32_t n = htonl(idx->fanout[i]);\n\t\tgit_filebuf_write(&index_file, &n, sizeof(n));\n\t}\n\n\t/* Write out the object names (SHA-1 hashes) */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tgit_filebuf_write(&index_file, &entry->oid, sizeof(git_oid));\n\t\tgit_hash_update(&ctx, &entry->oid, GIT_OID_RAWSZ);\n\t}\n\tgit_hash_final(&idx->hash, &ctx);\n\n\t/* Write out the CRC32 values */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tgit_filebuf_write(&index_file, &entry->crc, sizeof(uint32_t));\n\t}\n\n\t/* Write out the offsets */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tuint32_t n;\n\n\t\tif (entry->offset == UINT32_MAX)\n\t\t\tn = htonl(0x80000000 | long_offsets++);\n\t\telse\n\t\t\tn = htonl(entry->offset);\n\n\t\tgit_filebuf_write(&index_file, &n, sizeof(uint32_t));\n\t}\n\n\t/* Write out the long offsets */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tuint32_t split[2];\n\n\t\tif (entry->offset != UINT32_MAX)\n\t\t\tcontinue;\n\n\t\tsplit[0] = htonl(entry->offset_long >> 32);\n\t\tsplit[1] = htonl(entry->offset_long & 0xffffffff);\n\n\t\tgit_filebuf_write(&index_file, &split, sizeof(uint32_t) * 2);\n\t}\n\n\t/* Write out the packfile trailer to the index */\n\tif (git_filebuf_write(&index_file, &trailer_hash, GIT_OID_RAWSZ) < 0)\n\t\tgoto on_error;\n\n\t/* Write out the hash of the idx */\n\tif (git_filebuf_hash(&trailer_hash, &index_file) < 0)\n\t\tgoto on_error;\n\n\tgit_filebuf_write(&index_file, &trailer_hash, sizeof(git_oid));\n\n\t/* Figure out what the final name should be */\n\tif (index_path(&filename, idx, \".idx\") < 0)\n\t\tgoto on_error;\n\n\t/* Commit file */\n\tif (git_filebuf_commit_at(&index_file, filename.ptr) < 0)\n\t\tgoto on_error;\n\n\tgit_mwindow_free_all(&idx->pack->mwf);\n\t/* We need to close the descriptor here so Windows doesn't choke on commit_at */\n\tif (p_close(idx->pack->mwf.fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to close packfile\");\n\t\tgoto on_error;\n\t}\n\n\tidx->pack->mwf.fd = -1;\n\n\tif (index_path(&filename, idx, \".pack\") < 0)\n\t\tgoto on_error;\n\n\t/* And don't forget to rename the packfile to its new place. */\n\tp_rename(idx->pack->pack_name, git_buf_cstr(&filename));\n\n\tgit_buf_free(&filename);\n\tgit_hash_ctx_cleanup(&ctx);\n\treturn 0;\n\non_error:\n\tgit_mwindow_free_all(&idx->pack->mwf);\n\tgit_filebuf_cleanup(&index_file);\n\tgit_buf_free(&filename);\n\tgit_hash_ctx_cleanup(&ctx);\n\treturn -1;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nint git_indexer_commit(git_indexer *idx, git_transfer_progress *stats)\n{\n\tgit_mwindow *w = NULL;\n\tunsigned int i, long_offsets = 0, left;\n\tint error;\n\tstruct git_pack_idx_header hdr;\n\tgit_buf filename = GIT_BUF_INIT;\n\tstruct entry *entry;\n\tgit_oid trailer_hash, file_hash;\n\tgit_hash_ctx ctx;\n\tgit_filebuf index_file = {0};\n\tvoid *packfile_trailer;\n\n\tif (!idx->parsed_header) {\n\t\tgiterr_set(GITERR_INDEXER, \"incomplete pack header\");\n\t\treturn -1;\n\t}\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\t/* Test for this before resolve_deltas(), as it plays with idx->off */\n\tif (idx->off + 20 < idx->pack->mwf.size) {\n\t\tgiterr_set(GITERR_INDEXER, \"unexpected data at the end of the pack\");\n\t\treturn -1;\n\t}\n\n\tpackfile_trailer = git_mwindow_open(&idx->pack->mwf, &w, idx->pack->mwf.size - GIT_OID_RAWSZ, GIT_OID_RAWSZ, &left);\n\tif (packfile_trailer == NULL) {\n\t\tgit_mwindow_close(&w);\n\t\tgoto on_error;\n\t}\n\n\t/* Compare the packfile trailer as it was sent to us and what we calculated */\n\tgit_oid_fromraw(&file_hash, packfile_trailer);\n\tgit_mwindow_close(&w);\n\n\tgit_hash_final(&trailer_hash, &idx->trailer);\n\tif (git_oid_cmp(&file_hash, &trailer_hash)) {\n\t\tgiterr_set(GITERR_INDEXER, \"packfile trailer mismatch\");\n\t\treturn -1;\n\t}\n\n\t/* Freeze the number of deltas */\n\tstats->total_deltas = stats->total_objects - stats->indexed_objects;\n\n\tif ((error = resolve_deltas(idx, stats)) < 0)\n\t\treturn error;\n\n\tif (stats->indexed_objects != stats->total_objects) {\n\t\tgiterr_set(GITERR_INDEXER, \"early EOF\");\n\t\treturn -1;\n\t}\n\n\tif (stats->local_objects > 0) {\n\t\tif (update_header_and_rehash(idx, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgit_hash_final(&trailer_hash, &idx->trailer);\n\t\twrite_at(idx, &trailer_hash, idx->pack->mwf.size - GIT_OID_RAWSZ, GIT_OID_RAWSZ);\n\t}\n\n\tgit_vector_sort(&idx->objects);\n\n\tgit_buf_sets(&filename, idx->pack->pack_name);\n\tgit_buf_shorten(&filename, strlen(\"pack\"));\n\tgit_buf_puts(&filename, \"idx\");\n\tif (git_buf_oom(&filename))\n\t\treturn -1;\n\n\tif (git_filebuf_open(&index_file, filename.ptr,\n\t\tGIT_FILEBUF_HASH_CONTENTS, idx->mode) < 0)\n\t\tgoto on_error;\n\n\t/* Write out the header */\n\thdr.idx_signature = htonl(PACK_IDX_SIGNATURE);\n\thdr.idx_version = htonl(2);\n\tgit_filebuf_write(&index_file, &hdr, sizeof(hdr));\n\n\t/* Write out the fanout table */\n\tfor (i = 0; i < 256; ++i) {\n\t\tuint32_t n = htonl(idx->fanout[i]);\n\t\tgit_filebuf_write(&index_file, &n, sizeof(n));\n\t}\n\n\t/* Write out the object names (SHA-1 hashes) */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tgit_filebuf_write(&index_file, &entry->oid, sizeof(git_oid));\n\t\tgit_hash_update(&ctx, &entry->oid, GIT_OID_RAWSZ);\n\t}\n\tgit_hash_final(&idx->hash, &ctx);\n\n\t/* Write out the CRC32 values */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tgit_filebuf_write(&index_file, &entry->crc, sizeof(uint32_t));\n\t}\n\n\t/* Write out the offsets */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tuint32_t n;\n\n\t\tif (entry->offset == UINT32_MAX)\n\t\t\tn = htonl(0x80000000 | long_offsets++);\n\t\telse\n\t\t\tn = htonl(entry->offset);\n\n\t\tgit_filebuf_write(&index_file, &n, sizeof(uint32_t));\n\t}\n\n\t/* Write out the long offsets */\n\tgit_vector_foreach(&idx->objects, i, entry) {\n\t\tuint32_t split[2];\n\n\t\tif (entry->offset != UINT32_MAX)\n\t\t\tcontinue;\n\n\t\tsplit[0] = htonl(entry->offset_long >> 32);\n\t\tsplit[1] = htonl(entry->offset_long & 0xffffffff);\n\n\t\tgit_filebuf_write(&index_file, &split, sizeof(uint32_t) * 2);\n\t}\n\n\t/* Write out the packfile trailer to the index */\n\tif (git_filebuf_write(&index_file, &trailer_hash, GIT_OID_RAWSZ) < 0)\n\t\tgoto on_error;\n\n\t/* Write out the hash of the idx */\n\tif (git_filebuf_hash(&trailer_hash, &index_file) < 0)\n\t\tgoto on_error;\n\n\tgit_filebuf_write(&index_file, &trailer_hash, sizeof(git_oid));\n\n\t/* Figure out what the final name should be */\n\tif (index_path(&filename, idx, \".idx\") < 0)\n\t\tgoto on_error;\n\n\t/* Commit file */\n\tif (git_filebuf_commit_at(&index_file, filename.ptr) < 0)\n\t\tgoto on_error;\n\n\tgit_mwindow_free_all(&idx->pack->mwf);\n\t/* We need to close the descriptor here so Windows doesn't choke on commit_at */\n\tif (p_close(idx->pack->mwf.fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to close packfile\");\n\t\tgoto on_error;\n\t}\n\n\tidx->pack->mwf.fd = -1;\n\n\tif (index_path(&filename, idx, \".pack\") < 0)\n\t\tgoto on_error;\n\n\t/* And don't forget to rename the packfile to its new place. */\n\tp_rename(idx->pack->pack_name, git_buf_cstr(&filename));\n\n\tgit_buf_free(&filename);\n\tgit_hash_ctx_cleanup(&ctx);\n\treturn 0;\n\non_error:\n\tgit_mwindow_free_all(&idx->pack->mwf);\n\tgit_filebuf_cleanup(&index_file);\n\tgit_buf_free(&filename);\n\tgit_hash_ctx_cleanup(&ctx);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "writepack"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_backend__writepack_commit(struct git_odb_writepack *_writepack, git_transfer_progress *stats)\n{\n\tstruct pack_writepack *writepack = (struct pack_writepack *)_writepack;\n\n\tassert(writepack);\n\n\treturn git_indexer_commit(writepack->indexer, stats);\n}"
  },
  {
    "function_name": "pack_backend__writepack_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "462-469",
    "snippet": "static int pack_backend__writepack_append(struct git_odb_writepack *_writepack, const void *data, size_t size, git_transfer_progress *stats)\n{\n\tstruct pack_writepack *writepack = (struct pack_writepack *)_writepack;\n\n\tassert(writepack);\n\n\treturn git_indexer_append(writepack->indexer, data, size, stats);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_indexer_append",
          "args": [
            "writepack->indexer",
            "data",
            "size",
            "stats"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/indexer.c",
          "lines": "495-645",
          "snippet": "int git_indexer_append(git_indexer *idx, const void *data, size_t size, git_transfer_progress *stats)\n{\n\tint error = -1;\n\tsize_t processed;\n\tstruct git_pack_header *hdr = &idx->hdr;\n\tgit_mwindow_file *mwf = &idx->pack->mwf;\n\n\tassert(idx && data && stats);\n\n\tprocessed = stats->indexed_objects;\n\n\tif ((error = append_to_pack(idx, data, size)) < 0)\n\t\treturn error;\n\n\thash_partially(idx, data, (int)size);\n\n\t/* Make sure we set the new size of the pack */\n\tidx->pack->mwf.size += size;\n\n\tif (!idx->parsed_header) {\n\t\tunsigned int total_objects;\n\n\t\tif ((unsigned)idx->pack->mwf.size < sizeof(struct git_pack_header))\n\t\t\treturn 0;\n\n\t\tif ((error = parse_header(&idx->hdr, idx->pack)) < 0)\n\t\t\treturn error;\n\n\t\tidx->parsed_header = 1;\n\t\tidx->nr_objects = ntohl(hdr->hdr_entries);\n\t\tidx->off = sizeof(struct git_pack_header);\n\n\t\t/* for now, limit to 2^32 objects */\n\t\tassert(idx->nr_objects == (size_t)((unsigned int)idx->nr_objects));\n\t\tif (idx->nr_objects == (size_t)((unsigned int)idx->nr_objects))\n\t\t\ttotal_objects = (unsigned int)idx->nr_objects;\n\t\telse\n\t\t\ttotal_objects = UINT_MAX;\n\n\t\tidx->pack->idx_cache = git_oidmap_alloc();\n\t\tGITERR_CHECK_ALLOC(idx->pack->idx_cache);\n\n\t\tidx->pack->has_cache = 1;\n\t\tif (git_vector_init(&idx->objects, total_objects, objects_cmp) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_vector_init(&idx->deltas, total_objects / 2, NULL) < 0)\n\t\t\treturn -1;\n\n\t\tstats->received_objects = 0;\n\t\tstats->local_objects = 0;\n\t\tstats->total_deltas = 0;\n\t\tstats->indexed_deltas = 0;\n\t\tprocessed = stats->indexed_objects = 0;\n\t\tstats->total_objects = total_objects;\n\n\t\tif ((error = do_progress_callback(idx, stats)) != 0)\n\t\t\treturn error;\n\t}\n\n\t/* Now that we have data in the pack, let's try to parse it */\n\n\t/* As the file grows any windows we try to use will be out of date */\n\tgit_mwindow_free_all(mwf);\n\n\twhile (processed < idx->nr_objects) {\n\t\tgit_packfile_stream *stream = &idx->stream;\n\t\tgit_off_t entry_start = idx->off;\n\t\tsize_t entry_size;\n\t\tgit_otype type;\n\t\tgit_mwindow *w = NULL;\n\n\t\tif (idx->pack->mwf.size <= idx->off + 20)\n\t\t\treturn 0;\n\n\t\tif (!idx->have_stream) {\n\t\t\terror = git_packfile_unpack_header(&entry_size, &type, mwf, &w, &idx->off);\n\t\t\tif (error == GIT_EBUFS) {\n\t\t\t\tidx->off = entry_start;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_mwindow_close(&w);\n\t\t\tidx->entry_start = entry_start;\n\t\t\tgit_hash_init(&idx->hash_ctx);\n\n\t\t\tif (type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA) {\n\t\t\t\terror = advance_delta_offset(idx, type);\n\t\t\t\tif (error == GIT_EBUFS) {\n\t\t\t\t\tidx->off = entry_start;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto on_error;\n\n\t\t\t\tidx->have_delta = 1;\n\t\t\t} else {\n\t\t\t\tidx->have_delta = 0;\n\t\t\t\thash_header(&idx->hash_ctx, entry_size, type);\n\t\t\t}\n\n\t\t\tidx->have_stream = 1;\n\n\t\t\terror = git_packfile_stream_open(stream, idx->pack, idx->off);\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (idx->have_delta) {\n\t\t\terror = read_object_stream(idx, stream);\n\t\t} else {\n\t\t\terror = hash_object_stream(idx, stream);\n\t\t}\n\n\t\tidx->off = stream->curpos;\n\t\tif (error == GIT_EBUFS)\n\t\t\treturn 0;\n\n\t\t/* We want to free the stream reasorces no matter what here */\n\t\tidx->have_stream = 0;\n\t\tgit_packfile_stream_free(stream);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tif (idx->have_delta) {\n\t\t\terror = store_delta(idx);\n\t\t} else {\n\t\t\terror = store_object(idx);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!idx->have_delta) {\n\t\t\tstats->indexed_objects = (unsigned int)++processed;\n\t\t}\n\t\tstats->received_objects++;\n\n\t\tif ((error = do_progress_callback(idx, stats)) != 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_mwindow_free_all(mwf);\n\treturn error;\n}",
          "includes": [
            "#include \"zstream.h\"",
            "#include \"oidmap.h\"",
            "#include \"oid.h\"",
            "#include \"filebuf.h\"",
            "#include \"pack.h\"",
            "#include \"posix.h\"",
            "#include \"mwindow.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/indexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zstream.h\"\n#include \"oidmap.h\"\n#include \"oid.h\"\n#include \"filebuf.h\"\n#include \"pack.h\"\n#include \"posix.h\"\n#include \"mwindow.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n#include \"git2/indexer.h\"\n\nint git_indexer_append(git_indexer *idx, const void *data, size_t size, git_transfer_progress *stats)\n{\n\tint error = -1;\n\tsize_t processed;\n\tstruct git_pack_header *hdr = &idx->hdr;\n\tgit_mwindow_file *mwf = &idx->pack->mwf;\n\n\tassert(idx && data && stats);\n\n\tprocessed = stats->indexed_objects;\n\n\tif ((error = append_to_pack(idx, data, size)) < 0)\n\t\treturn error;\n\n\thash_partially(idx, data, (int)size);\n\n\t/* Make sure we set the new size of the pack */\n\tidx->pack->mwf.size += size;\n\n\tif (!idx->parsed_header) {\n\t\tunsigned int total_objects;\n\n\t\tif ((unsigned)idx->pack->mwf.size < sizeof(struct git_pack_header))\n\t\t\treturn 0;\n\n\t\tif ((error = parse_header(&idx->hdr, idx->pack)) < 0)\n\t\t\treturn error;\n\n\t\tidx->parsed_header = 1;\n\t\tidx->nr_objects = ntohl(hdr->hdr_entries);\n\t\tidx->off = sizeof(struct git_pack_header);\n\n\t\t/* for now, limit to 2^32 objects */\n\t\tassert(idx->nr_objects == (size_t)((unsigned int)idx->nr_objects));\n\t\tif (idx->nr_objects == (size_t)((unsigned int)idx->nr_objects))\n\t\t\ttotal_objects = (unsigned int)idx->nr_objects;\n\t\telse\n\t\t\ttotal_objects = UINT_MAX;\n\n\t\tidx->pack->idx_cache = git_oidmap_alloc();\n\t\tGITERR_CHECK_ALLOC(idx->pack->idx_cache);\n\n\t\tidx->pack->has_cache = 1;\n\t\tif (git_vector_init(&idx->objects, total_objects, objects_cmp) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_vector_init(&idx->deltas, total_objects / 2, NULL) < 0)\n\t\t\treturn -1;\n\n\t\tstats->received_objects = 0;\n\t\tstats->local_objects = 0;\n\t\tstats->total_deltas = 0;\n\t\tstats->indexed_deltas = 0;\n\t\tprocessed = stats->indexed_objects = 0;\n\t\tstats->total_objects = total_objects;\n\n\t\tif ((error = do_progress_callback(idx, stats)) != 0)\n\t\t\treturn error;\n\t}\n\n\t/* Now that we have data in the pack, let's try to parse it */\n\n\t/* As the file grows any windows we try to use will be out of date */\n\tgit_mwindow_free_all(mwf);\n\n\twhile (processed < idx->nr_objects) {\n\t\tgit_packfile_stream *stream = &idx->stream;\n\t\tgit_off_t entry_start = idx->off;\n\t\tsize_t entry_size;\n\t\tgit_otype type;\n\t\tgit_mwindow *w = NULL;\n\n\t\tif (idx->pack->mwf.size <= idx->off + 20)\n\t\t\treturn 0;\n\n\t\tif (!idx->have_stream) {\n\t\t\terror = git_packfile_unpack_header(&entry_size, &type, mwf, &w, &idx->off);\n\t\t\tif (error == GIT_EBUFS) {\n\t\t\t\tidx->off = entry_start;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_mwindow_close(&w);\n\t\t\tidx->entry_start = entry_start;\n\t\t\tgit_hash_init(&idx->hash_ctx);\n\n\t\t\tif (type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA) {\n\t\t\t\terror = advance_delta_offset(idx, type);\n\t\t\t\tif (error == GIT_EBUFS) {\n\t\t\t\t\tidx->off = entry_start;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto on_error;\n\n\t\t\t\tidx->have_delta = 1;\n\t\t\t} else {\n\t\t\t\tidx->have_delta = 0;\n\t\t\t\thash_header(&idx->hash_ctx, entry_size, type);\n\t\t\t}\n\n\t\t\tidx->have_stream = 1;\n\n\t\t\terror = git_packfile_stream_open(stream, idx->pack, idx->off);\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (idx->have_delta) {\n\t\t\terror = read_object_stream(idx, stream);\n\t\t} else {\n\t\t\terror = hash_object_stream(idx, stream);\n\t\t}\n\n\t\tidx->off = stream->curpos;\n\t\tif (error == GIT_EBUFS)\n\t\t\treturn 0;\n\n\t\t/* We want to free the stream reasorces no matter what here */\n\t\tidx->have_stream = 0;\n\t\tgit_packfile_stream_free(stream);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tif (idx->have_delta) {\n\t\t\terror = store_delta(idx);\n\t\t} else {\n\t\t\terror = store_object(idx);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!idx->have_delta) {\n\t\t\tstats->indexed_objects = (unsigned int)++processed;\n\t\t}\n\t\tstats->received_objects++;\n\n\t\tif ((error = do_progress_callback(idx, stats)) != 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_mwindow_free_all(mwf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "writepack"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_backend__writepack_append(struct git_odb_writepack *_writepack, const void *data, size_t size, git_transfer_progress *stats)\n{\n\tstruct pack_writepack *writepack = (struct pack_writepack *)_writepack;\n\n\tassert(writepack);\n\n\treturn git_indexer_append(writepack->indexer, data, size, stats);\n}"
  },
  {
    "function_name": "pack_backend__foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "440-460",
    "snippet": "static int pack_backend__foreach(git_odb_backend *_backend, git_odb_foreach_cb cb, void *data)\n{\n\tint error;\n\tstruct git_pack_file *p;\n\tstruct pack_backend *backend;\n\tunsigned int i;\n\n\tassert(_backend && cb);\n\tbackend = (struct pack_backend *)_backend;\n\n\t/* Make sure we know about the packfiles */\n\tif ((error = pack_backend__refresh(_backend)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&backend->packs, i, p) {\n\t\tif ((error = git_pack_foreach_entry(p, cb, data)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pack_foreach_entry",
          "args": [
            "p",
            "cb",
            "data"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "git_pack_foreach_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1204-1261",
          "snippet": "int git_pack_foreach_entry(\n\tstruct git_pack_file *p,\n\tgit_odb_foreach_cb cb,\n\tvoid *data)\n{\n\tconst unsigned char *index = p->index_map.data, *current;\n\tuint32_t i;\n\tint error = 0;\n\n\tif (index == NULL) {\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\n\tif (p->oids == NULL) {\n\t\tgit_vector offsets, oids;\n\n\t\tif ((error = git_vector_init(&oids, p->num_objects, NULL)))\n\t\t\treturn error;\n\n\t\tif ((error = git_vector_init(&offsets, p->num_objects, git__memcmp4)))\n\t\t\treturn error;\n\n\t\tif (p->index_version > 1) {\n\t\t\tconst unsigned char *off = index + 24 * p->num_objects;\n\t\t\tfor (i = 0; i < p->num_objects; i++)\n\t\t\t\tgit_vector_insert(&offsets, (void*)&off[4 * i]);\n\t\t\tgit_vector_sort(&offsets);\n\t\t\tgit_vector_foreach(&offsets, i, current)\n\t\t\t\tgit_vector_insert(&oids, (void*)&index[5 * (current - off)]);\n\t\t} else {\n\t\t\tfor (i = 0; i < p->num_objects; i++)\n\t\t\t\tgit_vector_insert(&offsets, (void*)&index[24 * i]);\n\t\t\tgit_vector_sort(&offsets);\n\t\t\tgit_vector_foreach(&offsets, i, current)\n\t\t\t\tgit_vector_insert(&oids, (void*)&current[4]);\n\t\t}\n\n\t\tgit_vector_free(&offsets);\n\t\tp->oids = (git_oid **)git_vector_detach(NULL, NULL, &oids);\n\t}\n\n\tfor (i = 0; i < p->num_objects; i++)\n\t\tif ((error = cb(p->oids[i], data)) != 0)\n\t\t\treturn giterr_set_after_callback(error);\n\n\treturn error;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_pack_foreach_entry(\n\tstruct git_pack_file *p,\n\tgit_odb_foreach_cb cb,\n\tvoid *data)\n{\n\tconst unsigned char *index = p->index_map.data, *current;\n\tuint32_t i;\n\tint error = 0;\n\n\tif (index == NULL) {\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\n\tif (p->oids == NULL) {\n\t\tgit_vector offsets, oids;\n\n\t\tif ((error = git_vector_init(&oids, p->num_objects, NULL)))\n\t\t\treturn error;\n\n\t\tif ((error = git_vector_init(&offsets, p->num_objects, git__memcmp4)))\n\t\t\treturn error;\n\n\t\tif (p->index_version > 1) {\n\t\t\tconst unsigned char *off = index + 24 * p->num_objects;\n\t\t\tfor (i = 0; i < p->num_objects; i++)\n\t\t\t\tgit_vector_insert(&offsets, (void*)&off[4 * i]);\n\t\t\tgit_vector_sort(&offsets);\n\t\t\tgit_vector_foreach(&offsets, i, current)\n\t\t\t\tgit_vector_insert(&oids, (void*)&index[5 * (current - off)]);\n\t\t} else {\n\t\t\tfor (i = 0; i < p->num_objects; i++)\n\t\t\t\tgit_vector_insert(&offsets, (void*)&index[24 * i]);\n\t\t\tgit_vector_sort(&offsets);\n\t\t\tgit_vector_foreach(&offsets, i, current)\n\t\t\t\tgit_vector_insert(&oids, (void*)&current[4]);\n\t\t}\n\n\t\tgit_vector_free(&offsets);\n\t\tp->oids = (git_oid **)git_vector_detach(NULL, NULL, &oids);\n\t}\n\n\tfor (i = 0; i < p->num_objects; i++)\n\t\tif ((error = cb(p->oids[i], data)) != 0)\n\t\t\treturn giterr_set_after_callback(error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&backend->packs",
            "i",
            "p"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pack_backend__refresh",
          "args": [
            "_backend"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "pack_backend__refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "327-349",
          "snippet": "static int pack_backend__refresh(git_odb_backend *backend_)\n{\n\tint error;\n\tstruct stat st;\n\tgit_buf path = GIT_BUF_INIT;\n\tstruct pack_backend *backend = (struct pack_backend *)backend_;\n\n\tif (backend->pack_folder == NULL)\n\t\treturn 0;\n\n\tif (p_stat(backend->pack_folder, &st) < 0 || !S_ISDIR(st.st_mode))\n\t\treturn git_odb__error_notfound(\"failed to refresh packfiles\", NULL, 0);\n\n\tgit_buf_sets(&path, backend->pack_folder);\n\n\t/* reload all packs */\n\terror = git_path_direach(&path, 0, packfile_load__cb, backend);\n\n\tgit_buf_free(&path);\n\tgit_vector_sort(&backend->packs);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_load__cb(void *_data, git_buf *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_load__cb(void *_data, git_buf *path);\n\nstatic int pack_backend__refresh(git_odb_backend *backend_)\n{\n\tint error;\n\tstruct stat st;\n\tgit_buf path = GIT_BUF_INIT;\n\tstruct pack_backend *backend = (struct pack_backend *)backend_;\n\n\tif (backend->pack_folder == NULL)\n\t\treturn 0;\n\n\tif (p_stat(backend->pack_folder, &st) < 0 || !S_ISDIR(st.st_mode))\n\t\treturn git_odb__error_notfound(\"failed to refresh packfiles\", NULL, 0);\n\n\tgit_buf_sets(&path, backend->pack_folder);\n\n\t/* reload all packs */\n\terror = git_path_direach(&path, 0, packfile_load__cb, backend);\n\n\tgit_buf_free(&path);\n\tgit_vector_sort(&backend->packs);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "_backend && cb"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_backend__foreach(git_odb_backend *_backend, git_odb_foreach_cb cb, void *data)\n{\n\tint error;\n\tstruct git_pack_file *p;\n\tstruct pack_backend *backend;\n\tunsigned int i;\n\n\tassert(_backend && cb);\n\tbackend = (struct pack_backend *)_backend;\n\n\t/* Make sure we know about the packfiles */\n\tif ((error = pack_backend__refresh(_backend)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&backend->packs, i, p) {\n\t\tif ((error = git_pack_foreach_entry(p, cb, data)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pack_backend__exists_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "428-438",
    "snippet": "static int pack_backend__exists_prefix(\n\tgit_oid *out, git_odb_backend *backend, const git_oid *short_id, size_t len)\n{\n\tint error;\n\tstruct pack_backend *pb = (struct pack_backend *)backend;\n\tstruct git_pack_entry e = {0};\n\n\terror = pack_entry_find_prefix(&e, pb, short_id, len);\n\tgit_oid_cpy(out, &e.sha1);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "out",
            "&e.sha1"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_entry_find_prefix",
          "args": [
            "&e",
            "pb",
            "short_id",
            "len"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "pack_entry_find_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "271-317",
          "snippet": "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error;\n\tsize_t i;\n\tgit_oid found_full_oid = {{0}};\n\tbool found = false;\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (last_found) {\n\t\terror = git_pack_entry_find(e, last_found, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\terror = git_pack_entry_find(e, p, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tif (found && git_oid_cmp(&e->sha1, &found_full_oid))\n\t\t\t\treturn git_odb__error_ambiguous(\"found multiple pack entries\");\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t\tbackend->last_found = p;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"no matching pack entry for prefix\",\n\t\t\tshort_oid, len);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);\n\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error;\n\tsize_t i;\n\tgit_oid found_full_oid = {{0}};\n\tbool found = false;\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (last_found) {\n\t\terror = git_pack_entry_find(e, last_found, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\terror = git_pack_entry_find(e, p, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tif (found && git_oid_cmp(&e->sha1, &found_full_oid))\n\t\t\t\treturn git_odb__error_ambiguous(\"found multiple pack entries\");\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t\tbackend->last_found = p;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"no matching pack entry for prefix\",\n\t\t\tshort_oid, len);\n\telse\n\t\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);\n\nstatic int pack_backend__exists_prefix(\n\tgit_oid *out, git_odb_backend *backend, const git_oid *short_id, size_t len)\n{\n\tint error;\n\tstruct pack_backend *pb = (struct pack_backend *)backend;\n\tstruct git_pack_entry e = {0};\n\n\terror = pack_entry_find_prefix(&e, pb, short_id, len);\n\tgit_oid_cpy(out, &e.sha1);\n\treturn error;\n}"
  },
  {
    "function_name": "pack_backend__exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "422-426",
    "snippet": "static int pack_backend__exists(git_odb_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_entry e;\n\treturn pack_entry_find(&e, (struct pack_backend *)backend, oid) == 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pack_entry_find",
          "args": [
            "&e",
            "(struct pack_backend *)backend",
            "oid"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "pack_entry_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "256-269",
          "snippet": "static int pack_entry_find(struct git_pack_entry *e, struct pack_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (backend->last_found &&\n\t\tgit_pack_entry_find(e, backend->last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tif (!pack_entry_find_inner(e, backend, oid, last_found))\n\t\treturn 0;\n\n\treturn git_odb__error_notfound(\n\t\t\"failed to find pack entry\", oid, GIT_OID_HEXSZ);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\n\nstatic int pack_entry_find(struct git_pack_entry *e, struct pack_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (backend->last_found &&\n\t\tgit_pack_entry_find(e, backend->last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tif (!pack_entry_find_inner(e, backend, oid, last_found))\n\t\treturn 0;\n\n\treturn git_odb__error_notfound(\n\t\t\"failed to find pack entry\", oid, GIT_OID_HEXSZ);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\n\nstatic int pack_backend__exists(git_odb_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_entry e;\n\treturn pack_entry_find(&e, (struct pack_backend *)backend, oid) == 0;\n}"
  },
  {
    "function_name": "pack_backend__read_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "385-420",
    "snippet": "static int pack_backend__read_prefix(\n\tgit_oid *out_oid,\n\tvoid **buffer_p,\n\tsize_t *len_p,\n\tgit_otype *type_p,\n\tgit_odb_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error = 0;\n\n\tif (len < GIT_OID_MINPREFIXLEN)\n\t\terror = git_odb__error_ambiguous(\"prefix length too short\");\n\n\telse if (len >= GIT_OID_HEXSZ) {\n\t\t/* We can fall back to regular read method */\n\t\terror = pack_backend__read(buffer_p, len_p, type_p, backend, short_oid);\n\t\tif (!error)\n\t\t\tgit_oid_cpy(out_oid, short_oid);\n\t} else {\n\t\tstruct git_pack_entry e;\n\t\tgit_rawobj raw;\n\n\t\tif ((error = pack_entry_find_prefix(\n\t\t\t\t&e, (struct pack_backend *)backend, short_oid, len)) == 0 &&\n\t\t\t(error = git_packfile_unpack(&raw, e.p, &e.offset)) == 0)\n\t\t{\n\t\t\t*buffer_p = raw.data;\n\t\t\t*len_p = raw.len;\n\t\t\t*type_p = raw.type;\n\t\t\tgit_oid_cpy(out_oid, &e.sha1);\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "out_oid",
            "&e.sha1"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_unpack",
          "args": [
            "&raw",
            "e.p",
            "&e.offset"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "627-767",
          "snippet": "int git_packfile_unpack(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_off_t *obj_offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = *obj_offset;\n\tint error, free_base = 0;\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tstruct pack_chain_elem *elem = NULL, *stack;\n\tgit_pack_cache_entry *cached = NULL;\n\tstruct pack_chain_elem small_stack[SMALL_STACK_SIZE];\n\tsize_t stack_size = 0, elem_pos, alloclen;\n\tgit_otype base_type;\n\n\t/*\n\t * TODO: optionally check the CRC on the packfile\n\t */\n\n\terror = pack_dependency_chain(&chain, &cached, obj_offset, small_stack, &stack_size, p, *obj_offset);\n\tif (error < 0)\n\t\treturn error;\n\n\tobj->data = NULL;\n\tobj->len = 0;\n\tobj->type = GIT_OBJ_BAD;\n\n\t/* let's point to the right stack */\n\tstack = chain.ptr ? chain.ptr : small_stack;\n\n\telem_pos = stack_size;\n\tif (cached) {\n\t\tmemcpy(obj, &cached->raw, sizeof(git_rawobj));\n\t\tbase_type = obj->type;\n\t\telem_pos--;\t/* stack_size includes the base, which isn't actually there */\n\t} else {\n\t\telem = &stack[--elem_pos];\n\t\tbase_type = elem->type;\n\t}\n\n\tswitch (base_type) {\n\tcase GIT_OBJ_COMMIT:\n\tcase GIT_OBJ_TREE:\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TAG:\n\t\tif (!cached) {\n\t\t\tcurpos = elem->offset;\n\t\t\terror = packfile_unpack_compressed(obj, p, &w_curs, &curpos, elem->size, elem->type);\n\t\t\tgit_mwindow_close(&w_curs);\n\t\t\tbase_type = elem->type;\n\t\t}\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase GIT_OBJ_OFS_DELTA:\n\tcase GIT_OBJ_REF_DELTA:\n\t\terror = packfile_error(\"dependency chain ends in a delta\");\n\t\tgoto cleanup;\n\tdefault:\n\t\terror = packfile_error(\"invalid packfile type in header\");\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Finding the object we want a cached base element is\n\t * problematic, as we need to make sure we don't accidentally\n\t * give the caller the cached object, which it would then feel\n\t * free to free, so we need to copy the data.\n\t */\n\tif (cached && stack_size == 1) {\n\t\tvoid *data = obj->data;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, obj->len, 1);\n\t\tobj->data = git__malloc(alloclen);\n\t\tGITERR_CHECK_ALLOC(obj->data);\n\n\t\tmemcpy(obj->data, data, obj->len + 1);\n\t\tgit_atomic_dec(&cached->refcount);\n\t\tgoto cleanup;\n\t}\n\n\t/* we now apply each consecutive delta until we run out */\n\twhile (elem_pos > 0 && !error) {\n\t\tgit_rawobj base, delta;\n\n\t\t/*\n\t\t * We can now try to add the base to the cache, as\n\t\t * long as it's not already the cached one.\n\t\t */\n\t\tif (!cached)\n\t\t\tfree_base = !!cache_add(&cached, &p->bases, obj, elem->base_key);\n\n\t\telem = &stack[elem_pos - 1];\n\t\tcurpos = elem->offset;\n\t\terror = packfile_unpack_compressed(&delta, p, &w_curs, &curpos, elem->size, elem->type);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\t/* the current object becomes the new base, on which we apply the delta */\n\t\tbase = *obj;\n\t\tobj->data = NULL;\n\t\tobj->len = 0;\n\t\tobj->type = GIT_OBJ_BAD;\n\n\t\terror = git__delta_apply(obj, base.data, base.len, delta.data, delta.len);\n\t\tobj->type = base_type;\n\t\t/*\n\t\t * We usually don't want to free the base at this\n\t\t * point, as we put it into the cache in the previous\n\t\t * iteration. free_base lets us know that we got the\n\t\t * base object directly from the packfile, so we can free it.\n\t\t */\n\t\tgit__free(delta.data);\n\t\tif (free_base) {\n\t\t\tfree_base = 0;\n\t\t\tgit__free(base.data);\n\t\t}\n\n\t\tif (cached) {\n\t\t\tgit_atomic_dec(&cached->refcount);\n\t\t\tcached = NULL;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\telem_pos--;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit__free(obj->data);\n\n\tif (elem)\n\t\t*obj_offset = curpos;\n\n\tgit_array_clear(chain);\n\treturn error;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define SMALL_STACK_SIZE 64"
          ],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\n#define SMALL_STACK_SIZE 64\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nint git_packfile_unpack(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_off_t *obj_offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = *obj_offset;\n\tint error, free_base = 0;\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tstruct pack_chain_elem *elem = NULL, *stack;\n\tgit_pack_cache_entry *cached = NULL;\n\tstruct pack_chain_elem small_stack[SMALL_STACK_SIZE];\n\tsize_t stack_size = 0, elem_pos, alloclen;\n\tgit_otype base_type;\n\n\t/*\n\t * TODO: optionally check the CRC on the packfile\n\t */\n\n\terror = pack_dependency_chain(&chain, &cached, obj_offset, small_stack, &stack_size, p, *obj_offset);\n\tif (error < 0)\n\t\treturn error;\n\n\tobj->data = NULL;\n\tobj->len = 0;\n\tobj->type = GIT_OBJ_BAD;\n\n\t/* let's point to the right stack */\n\tstack = chain.ptr ? chain.ptr : small_stack;\n\n\telem_pos = stack_size;\n\tif (cached) {\n\t\tmemcpy(obj, &cached->raw, sizeof(git_rawobj));\n\t\tbase_type = obj->type;\n\t\telem_pos--;\t/* stack_size includes the base, which isn't actually there */\n\t} else {\n\t\telem = &stack[--elem_pos];\n\t\tbase_type = elem->type;\n\t}\n\n\tswitch (base_type) {\n\tcase GIT_OBJ_COMMIT:\n\tcase GIT_OBJ_TREE:\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TAG:\n\t\tif (!cached) {\n\t\t\tcurpos = elem->offset;\n\t\t\terror = packfile_unpack_compressed(obj, p, &w_curs, &curpos, elem->size, elem->type);\n\t\t\tgit_mwindow_close(&w_curs);\n\t\t\tbase_type = elem->type;\n\t\t}\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase GIT_OBJ_OFS_DELTA:\n\tcase GIT_OBJ_REF_DELTA:\n\t\terror = packfile_error(\"dependency chain ends in a delta\");\n\t\tgoto cleanup;\n\tdefault:\n\t\terror = packfile_error(\"invalid packfile type in header\");\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Finding the object we want a cached base element is\n\t * problematic, as we need to make sure we don't accidentally\n\t * give the caller the cached object, which it would then feel\n\t * free to free, so we need to copy the data.\n\t */\n\tif (cached && stack_size == 1) {\n\t\tvoid *data = obj->data;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, obj->len, 1);\n\t\tobj->data = git__malloc(alloclen);\n\t\tGITERR_CHECK_ALLOC(obj->data);\n\n\t\tmemcpy(obj->data, data, obj->len + 1);\n\t\tgit_atomic_dec(&cached->refcount);\n\t\tgoto cleanup;\n\t}\n\n\t/* we now apply each consecutive delta until we run out */\n\twhile (elem_pos > 0 && !error) {\n\t\tgit_rawobj base, delta;\n\n\t\t/*\n\t\t * We can now try to add the base to the cache, as\n\t\t * long as it's not already the cached one.\n\t\t */\n\t\tif (!cached)\n\t\t\tfree_base = !!cache_add(&cached, &p->bases, obj, elem->base_key);\n\n\t\telem = &stack[elem_pos - 1];\n\t\tcurpos = elem->offset;\n\t\terror = packfile_unpack_compressed(&delta, p, &w_curs, &curpos, elem->size, elem->type);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\t/* the current object becomes the new base, on which we apply the delta */\n\t\tbase = *obj;\n\t\tobj->data = NULL;\n\t\tobj->len = 0;\n\t\tobj->type = GIT_OBJ_BAD;\n\n\t\terror = git__delta_apply(obj, base.data, base.len, delta.data, delta.len);\n\t\tobj->type = base_type;\n\t\t/*\n\t\t * We usually don't want to free the base at this\n\t\t * point, as we put it into the cache in the previous\n\t\t * iteration. free_base lets us know that we got the\n\t\t * base object directly from the packfile, so we can free it.\n\t\t */\n\t\tgit__free(delta.data);\n\t\tif (free_base) {\n\t\t\tfree_base = 0;\n\t\t\tgit__free(base.data);\n\t\t}\n\n\t\tif (cached) {\n\t\t\tgit_atomic_dec(&cached->refcount);\n\t\t\tcached = NULL;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\telem_pos--;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit__free(obj->data);\n\n\tif (elem)\n\t\t*obj_offset = curpos;\n\n\tgit_array_clear(chain);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_entry_find_prefix",
          "args": [
            "&e",
            "(struct pack_backend *)backend",
            "short_oid",
            "len"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "pack_entry_find_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "271-317",
          "snippet": "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error;\n\tsize_t i;\n\tgit_oid found_full_oid = {{0}};\n\tbool found = false;\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (last_found) {\n\t\terror = git_pack_entry_find(e, last_found, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\terror = git_pack_entry_find(e, p, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tif (found && git_oid_cmp(&e->sha1, &found_full_oid))\n\t\t\t\treturn git_odb__error_ambiguous(\"found multiple pack entries\");\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t\tbackend->last_found = p;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"no matching pack entry for prefix\",\n\t\t\tshort_oid, len);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);\n\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error;\n\tsize_t i;\n\tgit_oid found_full_oid = {{0}};\n\tbool found = false;\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (last_found) {\n\t\terror = git_pack_entry_find(e, last_found, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\terror = git_pack_entry_find(e, p, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tif (found && git_oid_cmp(&e->sha1, &found_full_oid))\n\t\t\t\treturn git_odb__error_ambiguous(\"found multiple pack entries\");\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t\tbackend->last_found = p;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"no matching pack entry for prefix\",\n\t\t\tshort_oid, len);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_backend__read",
          "args": [
            "buffer_p",
            "len_p",
            "type_p",
            "backend",
            "short_oid"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "pack_backend__read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "366-383",
          "snippet": "static int pack_backend__read(\n\tvoid **buffer_p, size_t *len_p, git_otype *type_p,\n\tgit_odb_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_entry e;\n\tgit_rawobj raw = {NULL};\n\tint error;\n\n\tif ((error = pack_entry_find(&e, (struct pack_backend *)backend, oid)) < 0 ||\n\t\t(error = git_packfile_unpack(&raw, e.p, &e.offset)) < 0)\n\t\treturn error;\n\n\t*buffer_p = raw.data;\n\t*len_p = raw.len;\n\t*type_p = raw.type;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);",
            "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);\n\nstatic int pack_backend__read(\n\tvoid **buffer_p, size_t *len_p, git_otype *type_p,\n\tgit_odb_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_entry e;\n\tgit_rawobj raw = {NULL};\n\tint error;\n\n\tif ((error = pack_entry_find(&e, (struct pack_backend *)backend, oid)) < 0 ||\n\t\t(error = git_packfile_unpack(&raw, e.p, &e.offset)) < 0)\n\t\treturn error;\n\n\t*buffer_p = raw.data;\n\t*len_p = raw.len;\n\t*type_p = raw.type;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_ambiguous",
          "args": [
            "\"prefix length too short\""
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_ambiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1234-1238",
          "snippet": "int git_odb__error_ambiguous(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Ambiguous SHA1 prefix - %s\", message);\n\treturn GIT_EAMBIGUOUS;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_ambiguous(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Ambiguous SHA1 prefix - %s\", message);\n\treturn GIT_EAMBIGUOUS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);\n\nstatic int pack_backend__read_prefix(\n\tgit_oid *out_oid,\n\tvoid **buffer_p,\n\tsize_t *len_p,\n\tgit_otype *type_p,\n\tgit_odb_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error = 0;\n\n\tif (len < GIT_OID_MINPREFIXLEN)\n\t\terror = git_odb__error_ambiguous(\"prefix length too short\");\n\n\telse if (len >= GIT_OID_HEXSZ) {\n\t\t/* We can fall back to regular read method */\n\t\terror = pack_backend__read(buffer_p, len_p, type_p, backend, short_oid);\n\t\tif (!error)\n\t\t\tgit_oid_cpy(out_oid, short_oid);\n\t} else {\n\t\tstruct git_pack_entry e;\n\t\tgit_rawobj raw;\n\n\t\tif ((error = pack_entry_find_prefix(\n\t\t\t\t&e, (struct pack_backend *)backend, short_oid, len)) == 0 &&\n\t\t\t(error = git_packfile_unpack(&raw, e.p, &e.offset)) == 0)\n\t\t{\n\t\t\t*buffer_p = raw.data;\n\t\t\t*len_p = raw.len;\n\t\t\t*type_p = raw.type;\n\t\t\tgit_oid_cpy(out_oid, &e.sha1);\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "pack_backend__read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "366-383",
    "snippet": "static int pack_backend__read(\n\tvoid **buffer_p, size_t *len_p, git_otype *type_p,\n\tgit_odb_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_entry e;\n\tgit_rawobj raw = {NULL};\n\tint error;\n\n\tif ((error = pack_entry_find(&e, (struct pack_backend *)backend, oid)) < 0 ||\n\t\t(error = git_packfile_unpack(&raw, e.p, &e.offset)) < 0)\n\t\treturn error;\n\n\t*buffer_p = raw.data;\n\t*len_p = raw.len;\n\t*type_p = raw.type;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);",
      "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_packfile_unpack",
          "args": [
            "&raw",
            "e.p",
            "&e.offset"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "627-767",
          "snippet": "int git_packfile_unpack(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_off_t *obj_offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = *obj_offset;\n\tint error, free_base = 0;\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tstruct pack_chain_elem *elem = NULL, *stack;\n\tgit_pack_cache_entry *cached = NULL;\n\tstruct pack_chain_elem small_stack[SMALL_STACK_SIZE];\n\tsize_t stack_size = 0, elem_pos, alloclen;\n\tgit_otype base_type;\n\n\t/*\n\t * TODO: optionally check the CRC on the packfile\n\t */\n\n\terror = pack_dependency_chain(&chain, &cached, obj_offset, small_stack, &stack_size, p, *obj_offset);\n\tif (error < 0)\n\t\treturn error;\n\n\tobj->data = NULL;\n\tobj->len = 0;\n\tobj->type = GIT_OBJ_BAD;\n\n\t/* let's point to the right stack */\n\tstack = chain.ptr ? chain.ptr : small_stack;\n\n\telem_pos = stack_size;\n\tif (cached) {\n\t\tmemcpy(obj, &cached->raw, sizeof(git_rawobj));\n\t\tbase_type = obj->type;\n\t\telem_pos--;\t/* stack_size includes the base, which isn't actually there */\n\t} else {\n\t\telem = &stack[--elem_pos];\n\t\tbase_type = elem->type;\n\t}\n\n\tswitch (base_type) {\n\tcase GIT_OBJ_COMMIT:\n\tcase GIT_OBJ_TREE:\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TAG:\n\t\tif (!cached) {\n\t\t\tcurpos = elem->offset;\n\t\t\terror = packfile_unpack_compressed(obj, p, &w_curs, &curpos, elem->size, elem->type);\n\t\t\tgit_mwindow_close(&w_curs);\n\t\t\tbase_type = elem->type;\n\t\t}\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase GIT_OBJ_OFS_DELTA:\n\tcase GIT_OBJ_REF_DELTA:\n\t\terror = packfile_error(\"dependency chain ends in a delta\");\n\t\tgoto cleanup;\n\tdefault:\n\t\terror = packfile_error(\"invalid packfile type in header\");\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Finding the object we want a cached base element is\n\t * problematic, as we need to make sure we don't accidentally\n\t * give the caller the cached object, which it would then feel\n\t * free to free, so we need to copy the data.\n\t */\n\tif (cached && stack_size == 1) {\n\t\tvoid *data = obj->data;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, obj->len, 1);\n\t\tobj->data = git__malloc(alloclen);\n\t\tGITERR_CHECK_ALLOC(obj->data);\n\n\t\tmemcpy(obj->data, data, obj->len + 1);\n\t\tgit_atomic_dec(&cached->refcount);\n\t\tgoto cleanup;\n\t}\n\n\t/* we now apply each consecutive delta until we run out */\n\twhile (elem_pos > 0 && !error) {\n\t\tgit_rawobj base, delta;\n\n\t\t/*\n\t\t * We can now try to add the base to the cache, as\n\t\t * long as it's not already the cached one.\n\t\t */\n\t\tif (!cached)\n\t\t\tfree_base = !!cache_add(&cached, &p->bases, obj, elem->base_key);\n\n\t\telem = &stack[elem_pos - 1];\n\t\tcurpos = elem->offset;\n\t\terror = packfile_unpack_compressed(&delta, p, &w_curs, &curpos, elem->size, elem->type);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\t/* the current object becomes the new base, on which we apply the delta */\n\t\tbase = *obj;\n\t\tobj->data = NULL;\n\t\tobj->len = 0;\n\t\tobj->type = GIT_OBJ_BAD;\n\n\t\terror = git__delta_apply(obj, base.data, base.len, delta.data, delta.len);\n\t\tobj->type = base_type;\n\t\t/*\n\t\t * We usually don't want to free the base at this\n\t\t * point, as we put it into the cache in the previous\n\t\t * iteration. free_base lets us know that we got the\n\t\t * base object directly from the packfile, so we can free it.\n\t\t */\n\t\tgit__free(delta.data);\n\t\tif (free_base) {\n\t\t\tfree_base = 0;\n\t\t\tgit__free(base.data);\n\t\t}\n\n\t\tif (cached) {\n\t\t\tgit_atomic_dec(&cached->refcount);\n\t\t\tcached = NULL;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\telem_pos--;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit__free(obj->data);\n\n\tif (elem)\n\t\t*obj_offset = curpos;\n\n\tgit_array_clear(chain);\n\treturn error;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define SMALL_STACK_SIZE 64"
          ],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\n#define SMALL_STACK_SIZE 64\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nint git_packfile_unpack(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_off_t *obj_offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = *obj_offset;\n\tint error, free_base = 0;\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tstruct pack_chain_elem *elem = NULL, *stack;\n\tgit_pack_cache_entry *cached = NULL;\n\tstruct pack_chain_elem small_stack[SMALL_STACK_SIZE];\n\tsize_t stack_size = 0, elem_pos, alloclen;\n\tgit_otype base_type;\n\n\t/*\n\t * TODO: optionally check the CRC on the packfile\n\t */\n\n\terror = pack_dependency_chain(&chain, &cached, obj_offset, small_stack, &stack_size, p, *obj_offset);\n\tif (error < 0)\n\t\treturn error;\n\n\tobj->data = NULL;\n\tobj->len = 0;\n\tobj->type = GIT_OBJ_BAD;\n\n\t/* let's point to the right stack */\n\tstack = chain.ptr ? chain.ptr : small_stack;\n\n\telem_pos = stack_size;\n\tif (cached) {\n\t\tmemcpy(obj, &cached->raw, sizeof(git_rawobj));\n\t\tbase_type = obj->type;\n\t\telem_pos--;\t/* stack_size includes the base, which isn't actually there */\n\t} else {\n\t\telem = &stack[--elem_pos];\n\t\tbase_type = elem->type;\n\t}\n\n\tswitch (base_type) {\n\tcase GIT_OBJ_COMMIT:\n\tcase GIT_OBJ_TREE:\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TAG:\n\t\tif (!cached) {\n\t\t\tcurpos = elem->offset;\n\t\t\terror = packfile_unpack_compressed(obj, p, &w_curs, &curpos, elem->size, elem->type);\n\t\t\tgit_mwindow_close(&w_curs);\n\t\t\tbase_type = elem->type;\n\t\t}\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase GIT_OBJ_OFS_DELTA:\n\tcase GIT_OBJ_REF_DELTA:\n\t\terror = packfile_error(\"dependency chain ends in a delta\");\n\t\tgoto cleanup;\n\tdefault:\n\t\terror = packfile_error(\"invalid packfile type in header\");\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Finding the object we want a cached base element is\n\t * problematic, as we need to make sure we don't accidentally\n\t * give the caller the cached object, which it would then feel\n\t * free to free, so we need to copy the data.\n\t */\n\tif (cached && stack_size == 1) {\n\t\tvoid *data = obj->data;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, obj->len, 1);\n\t\tobj->data = git__malloc(alloclen);\n\t\tGITERR_CHECK_ALLOC(obj->data);\n\n\t\tmemcpy(obj->data, data, obj->len + 1);\n\t\tgit_atomic_dec(&cached->refcount);\n\t\tgoto cleanup;\n\t}\n\n\t/* we now apply each consecutive delta until we run out */\n\twhile (elem_pos > 0 && !error) {\n\t\tgit_rawobj base, delta;\n\n\t\t/*\n\t\t * We can now try to add the base to the cache, as\n\t\t * long as it's not already the cached one.\n\t\t */\n\t\tif (!cached)\n\t\t\tfree_base = !!cache_add(&cached, &p->bases, obj, elem->base_key);\n\n\t\telem = &stack[elem_pos - 1];\n\t\tcurpos = elem->offset;\n\t\terror = packfile_unpack_compressed(&delta, p, &w_curs, &curpos, elem->size, elem->type);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\t/* the current object becomes the new base, on which we apply the delta */\n\t\tbase = *obj;\n\t\tobj->data = NULL;\n\t\tobj->len = 0;\n\t\tobj->type = GIT_OBJ_BAD;\n\n\t\terror = git__delta_apply(obj, base.data, base.len, delta.data, delta.len);\n\t\tobj->type = base_type;\n\t\t/*\n\t\t * We usually don't want to free the base at this\n\t\t * point, as we put it into the cache in the previous\n\t\t * iteration. free_base lets us know that we got the\n\t\t * base object directly from the packfile, so we can free it.\n\t\t */\n\t\tgit__free(delta.data);\n\t\tif (free_base) {\n\t\t\tfree_base = 0;\n\t\t\tgit__free(base.data);\n\t\t}\n\n\t\tif (cached) {\n\t\t\tgit_atomic_dec(&cached->refcount);\n\t\t\tcached = NULL;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\telem_pos--;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit__free(obj->data);\n\n\tif (elem)\n\t\t*obj_offset = curpos;\n\n\tgit_array_clear(chain);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_entry_find",
          "args": [
            "&e",
            "(struct pack_backend *)backend",
            "oid"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "pack_entry_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "256-269",
          "snippet": "static int pack_entry_find(struct git_pack_entry *e, struct pack_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (backend->last_found &&\n\t\tgit_pack_entry_find(e, backend->last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tif (!pack_entry_find_inner(e, backend, oid, last_found))\n\t\treturn 0;\n\n\treturn git_odb__error_notfound(\n\t\t\"failed to find pack entry\", oid, GIT_OID_HEXSZ);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\n\nstatic int pack_entry_find(struct git_pack_entry *e, struct pack_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (backend->last_found &&\n\t\tgit_pack_entry_find(e, backend->last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tif (!pack_entry_find_inner(e, backend, oid, last_found))\n\t\treturn 0;\n\n\treturn git_odb__error_notfound(\n\t\t\"failed to find pack entry\", oid, GIT_OID_HEXSZ);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);\n\nstatic int pack_backend__read(\n\tvoid **buffer_p, size_t *len_p, git_otype *type_p,\n\tgit_odb_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_entry e;\n\tgit_rawobj raw = {NULL};\n\tint error;\n\n\tif ((error = pack_entry_find(&e, (struct pack_backend *)backend, oid)) < 0 ||\n\t\t(error = git_packfile_unpack(&raw, e.p, &e.offset)) < 0)\n\t\treturn error;\n\n\t*buffer_p = raw.data;\n\t*len_p = raw.len;\n\t*type_p = raw.type;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pack_backend__read_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "351-364",
    "snippet": "static int pack_backend__read_header(\n\tsize_t *len_p, git_otype *type_p,\n\tstruct git_odb_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_entry e;\n\tint error;\n\n\tassert(len_p && type_p && backend && oid);\n\n\tif ((error = pack_entry_find(&e, (struct pack_backend *)backend, oid)) < 0)\n\t\treturn error;\n\n\treturn git_packfile_resolve_header(len_p, type_p, e.p, e.offset);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_packfile_resolve_header",
          "args": [
            "len_p",
            "type_p",
            "e.p",
            "e.offset"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_resolve_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "483-528",
          "snippet": "int git_packfile_resolve_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tstruct git_pack_file *p,\n\t\tgit_off_t offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = offset;\n\tsize_t size;\n\tgit_otype type;\n\tgit_off_t base_offset;\n\tint error;\n\n\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (type == GIT_OBJ_OFS_DELTA || type == GIT_OBJ_REF_DELTA) {\n\t\tsize_t base_size;\n\t\tgit_packfile_stream stream;\n\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, offset);\n\t\tgit_mwindow_close(&w_curs);\n\t\tif ((error = git_packfile_stream_open(&stream, p, curpos)) < 0)\n\t\t\treturn error;\n\t\terror = git__delta_read_header_fromstream(&base_size, size_p, &stream);\n\t\tgit_packfile_stream_free(&stream);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\t*size_p = size;\n\n\twhile (type == GIT_OBJ_OFS_DELTA || type == GIT_OBJ_REF_DELTA) {\n\t\tcurpos = base_offset;\n\t\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (type != GIT_OBJ_OFS_DELTA && type != GIT_OBJ_REF_DELTA)\n\t\t\tbreak;\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, base_offset);\n\t\tgit_mwindow_close(&w_curs);\n\t}\n\t*type_p = type;\n\n\treturn error;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\nint git_packfile_resolve_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tstruct git_pack_file *p,\n\t\tgit_off_t offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = offset;\n\tsize_t size;\n\tgit_otype type;\n\tgit_off_t base_offset;\n\tint error;\n\n\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (type == GIT_OBJ_OFS_DELTA || type == GIT_OBJ_REF_DELTA) {\n\t\tsize_t base_size;\n\t\tgit_packfile_stream stream;\n\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, offset);\n\t\tgit_mwindow_close(&w_curs);\n\t\tif ((error = git_packfile_stream_open(&stream, p, curpos)) < 0)\n\t\t\treturn error;\n\t\terror = git__delta_read_header_fromstream(&base_size, size_p, &stream);\n\t\tgit_packfile_stream_free(&stream);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\t*size_p = size;\n\n\twhile (type == GIT_OBJ_OFS_DELTA || type == GIT_OBJ_REF_DELTA) {\n\t\tcurpos = base_offset;\n\t\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (type != GIT_OBJ_OFS_DELTA && type != GIT_OBJ_REF_DELTA)\n\t\t\tbreak;\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, base_offset);\n\t\tgit_mwindow_close(&w_curs);\n\t}\n\t*type_p = type;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_entry_find",
          "args": [
            "&e",
            "(struct pack_backend *)backend",
            "oid"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "pack_entry_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "256-269",
          "snippet": "static int pack_entry_find(struct git_pack_entry *e, struct pack_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (backend->last_found &&\n\t\tgit_pack_entry_find(e, backend->last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tif (!pack_entry_find_inner(e, backend, oid, last_found))\n\t\treturn 0;\n\n\treturn git_odb__error_notfound(\n\t\t\"failed to find pack entry\", oid, GIT_OID_HEXSZ);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\n\nstatic int pack_entry_find(struct git_pack_entry *e, struct pack_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (backend->last_found &&\n\t\tgit_pack_entry_find(e, backend->last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tif (!pack_entry_find_inner(e, backend, oid, last_found))\n\t\treturn 0;\n\n\treturn git_odb__error_notfound(\n\t\t\"failed to find pack entry\", oid, GIT_OID_HEXSZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len_p && type_p && backend && oid"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\n\nstatic int pack_backend__read_header(\n\tsize_t *len_p, git_otype *type_p,\n\tstruct git_odb_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_entry e;\n\tint error;\n\n\tassert(len_p && type_p && backend && oid);\n\n\tif ((error = pack_entry_find(&e, (struct pack_backend *)backend, oid)) < 0)\n\t\treturn error;\n\n\treturn git_packfile_resolve_header(len_p, type_p, e.p, e.offset);\n}"
  },
  {
    "function_name": "pack_backend__refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "327-349",
    "snippet": "static int pack_backend__refresh(git_odb_backend *backend_)\n{\n\tint error;\n\tstruct stat st;\n\tgit_buf path = GIT_BUF_INIT;\n\tstruct pack_backend *backend = (struct pack_backend *)backend_;\n\n\tif (backend->pack_folder == NULL)\n\t\treturn 0;\n\n\tif (p_stat(backend->pack_folder, &st) < 0 || !S_ISDIR(st.st_mode))\n\t\treturn git_odb__error_notfound(\"failed to refresh packfiles\", NULL, 0);\n\n\tgit_buf_sets(&path, backend->pack_folder);\n\n\t/* reload all packs */\n\terror = git_path_direach(&path, 0, packfile_load__cb, backend);\n\n\tgit_buf_free(&path);\n\tgit_vector_sort(&backend->packs);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_load__cb(void *_data, git_buf *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&backend->packs"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_direach",
          "args": [
            "&path",
            "0",
            "packfile_load__cb",
            "backend"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_direach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1023-1094",
          "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&path",
            "backend->pack_folder"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"failed to refresh packfiles\"",
            "NULL",
            "0"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "backend->pack_folder",
            "&st"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_load__cb(void *_data, git_buf *path);\n\nstatic int pack_backend__refresh(git_odb_backend *backend_)\n{\n\tint error;\n\tstruct stat st;\n\tgit_buf path = GIT_BUF_INIT;\n\tstruct pack_backend *backend = (struct pack_backend *)backend_;\n\n\tif (backend->pack_folder == NULL)\n\t\treturn 0;\n\n\tif (p_stat(backend->pack_folder, &st) < 0 || !S_ISDIR(st.st_mode))\n\t\treturn git_odb__error_notfound(\"failed to refresh packfiles\", NULL, 0);\n\n\tgit_buf_sets(&path, backend->pack_folder);\n\n\t/* reload all packs */\n\terror = git_path_direach(&path, 0, packfile_load__cb, backend);\n\n\tgit_buf_free(&path);\n\tgit_vector_sort(&backend->packs);\n\n\treturn error;\n}"
  },
  {
    "function_name": "pack_entry_find_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "271-317",
    "snippet": "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error;\n\tsize_t i;\n\tgit_oid found_full_oid = {{0}};\n\tbool found = false;\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (last_found) {\n\t\terror = git_pack_entry_find(e, last_found, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\terror = git_pack_entry_find(e, p, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tif (found && git_oid_cmp(&e->sha1, &found_full_oid))\n\t\t\t\treturn git_odb__error_ambiguous(\"found multiple pack entries\");\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t\tbackend->last_found = p;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"no matching pack entry for prefix\",\n\t\t\tshort_oid, len);\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"no matching pack entry for prefix\"",
            "short_oid",
            "len"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&found_full_oid",
            "&e->sha1"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_ambiguous",
          "args": [
            "\"found multiple pack entries\""
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_ambiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1234-1238",
          "snippet": "int git_odb__error_ambiguous(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Ambiguous SHA1 prefix - %s\", message);\n\treturn GIT_EAMBIGUOUS;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_ambiguous(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Ambiguous SHA1 prefix - %s\", message);\n\treturn GIT_EAMBIGUOUS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "&e->sha1",
            "&found_full_oid"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pack_entry_find",
          "args": [
            "e",
            "p",
            "short_oid",
            "len"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git_pack_entry_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1367-1401",
          "snippet": "int git_pack_entry_find(\n\t\tstruct git_pack_entry *e,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len)\n{\n\tgit_off_t offset;\n\tgit_oid found_oid;\n\tint error;\n\n\tassert(p);\n\n\tif (len == GIT_OID_HEXSZ && p->num_bad_objects) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\tif (git_oid__cmp(short_oid, &p->bad_object_sha1[i]) == 0)\n\t\t\t\treturn packfile_error(\"bad object found in packfile\");\n\t}\n\n\terror = pack_entry_find_offset(&offset, &found_oid, p, short_oid, len);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* we found a unique entry in the index;\n\t * make sure the packfile backing the index\n\t * still exists on disk */\n\tif (p->mwf.fd == -1 && (error = packfile_open(p)) < 0)\n\t\treturn error;\n\n\te->offset = offset;\n\te->p = p;\n\n\tgit_oid_cpy(&e->sha1, &found_oid);\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nint git_pack_entry_find(\n\t\tstruct git_pack_entry *e,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len)\n{\n\tgit_off_t offset;\n\tgit_oid found_oid;\n\tint error;\n\n\tassert(p);\n\n\tif (len == GIT_OID_HEXSZ && p->num_bad_objects) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\tif (git_oid__cmp(short_oid, &p->bad_object_sha1[i]) == 0)\n\t\t\t\treturn packfile_error(\"bad object found in packfile\");\n\t}\n\n\terror = pack_entry_find_offset(&offset, &found_oid, p, short_oid, len);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* we found a unique entry in the index;\n\t * make sure the packfile backing the index\n\t * still exists on disk */\n\tif (p->mwf.fd == -1 && (error = packfile_open(p)) < 0)\n\t\treturn error;\n\n\te->offset = offset;\n\te->p = p;\n\n\tgit_oid_cpy(&e->sha1, &found_oid);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&backend->packs",
            "i"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len);\n\nstatic int pack_entry_find_prefix(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tint error;\n\tsize_t i;\n\tgit_oid found_full_oid = {{0}};\n\tbool found = false;\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (last_found) {\n\t\terror = git_pack_entry_find(e, last_found, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\terror = git_pack_entry_find(e, p, short_oid, len);\n\t\tif (error == GIT_EAMBIGUOUS)\n\t\t\treturn error;\n\t\tif (!error) {\n\t\t\tif (found && git_oid_cmp(&e->sha1, &found_full_oid))\n\t\t\t\treturn git_odb__error_ambiguous(\"found multiple pack entries\");\n\t\t\tgit_oid_cpy(&found_full_oid, &e->sha1);\n\t\t\tfound = true;\n\t\t\tbackend->last_found = p;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"no matching pack entry for prefix\",\n\t\t\tshort_oid, len);\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "pack_entry_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "256-269",
    "snippet": "static int pack_entry_find(struct git_pack_entry *e, struct pack_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (backend->last_found &&\n\t\tgit_pack_entry_find(e, backend->last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tif (!pack_entry_find_inner(e, backend, oid, last_found))\n\t\treturn 0;\n\n\treturn git_odb__error_notfound(\n\t\t\"failed to find pack entry\", oid, GIT_OID_HEXSZ);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"failed to find pack entry\"",
            "oid",
            "GIT_OID_HEXSZ"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_entry_find_inner",
          "args": [
            "e",
            "backend",
            "oid",
            "last_found"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "pack_entry_find_inner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "228-254",
          "snippet": "static int pack_entry_find_inner(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *oid,\n\tstruct git_pack_file *last_found)\n{\n\tsize_t i;\n\n\tif (last_found &&\n\t\tgit_pack_entry_find(e, last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\tif (git_pack_entry_find(e, p, oid, GIT_OID_HEXSZ) == 0) {\n\t\t\tbackend->last_found = p;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\n\nstatic int pack_entry_find_inner(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *oid,\n\tstruct git_pack_file *last_found)\n{\n\tsize_t i;\n\n\tif (last_found &&\n\t\tgit_pack_entry_find(e, last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\tif (git_pack_entry_find(e, p, oid, GIT_OID_HEXSZ) == 0) {\n\t\t\tbackend->last_found = p;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pack_entry_find",
          "args": [
            "e",
            "backend->last_found",
            "oid",
            "GIT_OID_HEXSZ"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "git_pack_entry_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1367-1401",
          "snippet": "int git_pack_entry_find(\n\t\tstruct git_pack_entry *e,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len)\n{\n\tgit_off_t offset;\n\tgit_oid found_oid;\n\tint error;\n\n\tassert(p);\n\n\tif (len == GIT_OID_HEXSZ && p->num_bad_objects) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\tif (git_oid__cmp(short_oid, &p->bad_object_sha1[i]) == 0)\n\t\t\t\treturn packfile_error(\"bad object found in packfile\");\n\t}\n\n\terror = pack_entry_find_offset(&offset, &found_oid, p, short_oid, len);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* we found a unique entry in the index;\n\t * make sure the packfile backing the index\n\t * still exists on disk */\n\tif (p->mwf.fd == -1 && (error = packfile_open(p)) < 0)\n\t\treturn error;\n\n\te->offset = offset;\n\te->p = p;\n\n\tgit_oid_cpy(&e->sha1, &found_oid);\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nint git_pack_entry_find(\n\t\tstruct git_pack_entry *e,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len)\n{\n\tgit_off_t offset;\n\tgit_oid found_oid;\n\tint error;\n\n\tassert(p);\n\n\tif (len == GIT_OID_HEXSZ && p->num_bad_objects) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\tif (git_oid__cmp(short_oid, &p->bad_object_sha1[i]) == 0)\n\t\t\t\treturn packfile_error(\"bad object found in packfile\");\n\t}\n\n\terror = pack_entry_find_offset(&offset, &found_oid, p, short_oid, len);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* we found a unique entry in the index;\n\t * make sure the packfile backing the index\n\t * still exists on disk */\n\tif (p->mwf.fd == -1 && (error = packfile_open(p)) < 0)\n\t\treturn error;\n\n\te->offset = offset;\n\te->p = p;\n\n\tgit_oid_cpy(&e->sha1, &found_oid);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\n\nstatic int pack_entry_find(struct git_pack_entry *e, struct pack_backend *backend, const git_oid *oid)\n{\n\tstruct git_pack_file *last_found = backend->last_found;\n\n\tif (backend->last_found &&\n\t\tgit_pack_entry_find(e, backend->last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tif (!pack_entry_find_inner(e, backend, oid, last_found))\n\t\treturn 0;\n\n\treturn git_odb__error_notfound(\n\t\t\"failed to find pack entry\", oid, GIT_OID_HEXSZ);\n}"
  },
  {
    "function_name": "pack_entry_find_inner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "228-254",
    "snippet": "static int pack_entry_find_inner(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *oid,\n\tstruct git_pack_file *last_found)\n{\n\tsize_t i;\n\n\tif (last_found &&\n\t\tgit_pack_entry_find(e, last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\tif (git_pack_entry_find(e, p, oid, GIT_OID_HEXSZ) == 0) {\n\t\t\tbackend->last_found = p;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pack_entry_find",
          "args": [
            "e",
            "p",
            "oid",
            "GIT_OID_HEXSZ"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git_pack_entry_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1367-1401",
          "snippet": "int git_pack_entry_find(\n\t\tstruct git_pack_entry *e,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len)\n{\n\tgit_off_t offset;\n\tgit_oid found_oid;\n\tint error;\n\n\tassert(p);\n\n\tif (len == GIT_OID_HEXSZ && p->num_bad_objects) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\tif (git_oid__cmp(short_oid, &p->bad_object_sha1[i]) == 0)\n\t\t\t\treturn packfile_error(\"bad object found in packfile\");\n\t}\n\n\terror = pack_entry_find_offset(&offset, &found_oid, p, short_oid, len);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* we found a unique entry in the index;\n\t * make sure the packfile backing the index\n\t * still exists on disk */\n\tif (p->mwf.fd == -1 && (error = packfile_open(p)) < 0)\n\t\treturn error;\n\n\te->offset = offset;\n\te->p = p;\n\n\tgit_oid_cpy(&e->sha1, &found_oid);\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nint git_pack_entry_find(\n\t\tstruct git_pack_entry *e,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len)\n{\n\tgit_off_t offset;\n\tgit_oid found_oid;\n\tint error;\n\n\tassert(p);\n\n\tif (len == GIT_OID_HEXSZ && p->num_bad_objects) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\tif (git_oid__cmp(short_oid, &p->bad_object_sha1[i]) == 0)\n\t\t\t\treturn packfile_error(\"bad object found in packfile\");\n\t}\n\n\terror = pack_entry_find_offset(&offset, &found_oid, p, short_oid, len);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* we found a unique entry in the index;\n\t * make sure the packfile backing the index\n\t * still exists on disk */\n\tif (p->mwf.fd == -1 && (error = packfile_open(p)) < 0)\n\t\treturn error;\n\n\te->offset = offset;\n\te->p = p;\n\n\tgit_oid_cpy(&e->sha1, &found_oid);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&backend->packs",
            "i"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int pack_entry_find(struct git_pack_entry *e,\n\tstruct pack_backend *backend, const git_oid *oid);\n\nstatic int pack_entry_find_inner(\n\tstruct git_pack_entry *e,\n\tstruct pack_backend *backend,\n\tconst git_oid *oid,\n\tstruct git_pack_file *last_found)\n{\n\tsize_t i;\n\n\tif (last_found &&\n\t\tgit_pack_entry_find(e, last_found, oid, GIT_OID_HEXSZ) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p;\n\n\t\tp = git_vector_get(&backend->packs, i);\n\t\tif (p == last_found)\n\t\t\tcontinue;\n\n\t\tif (git_pack_entry_find(e, p, oid, GIT_OID_HEXSZ) == 0) {\n\t\t\tbackend->last_found = p;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "packfile_load__cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "193-226",
    "snippet": "static int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_load__cb(void *_data, git_buf *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&backend->packs",
            "pack"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_get_pack",
          "args": [
            "&pack",
            "path->ptr"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_get_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "52-97",
          "snippet": "int git_mwindow_get_pack(struct git_pack_file **out, const char *path)\n{\n\tint error;\n\tchar *packname;\n\tgit_strmap_iter pos;\n\tstruct git_pack_file *pack;\n\n\tif ((error = git_packfile__name(&packname, path)) < 0)\n\t\treturn error;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tpos = git_strmap_lookup_index(git__pack_cache, packname);\n\tgit__free(packname);\n\n\tif (git_strmap_valid_index(git__pack_cache, pos)) {\n\t\tpack = git_strmap_value_at(git__pack_cache, pos);\n\t\tgit_atomic_inc(&pack->refcount);\n\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*out = pack;\n\t\treturn 0;\n\t}\n\n\t/* If we didn't find it, we need to create it */\n\tif ((error = git_packfile_alloc(&pack, path)) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn error;\n\t}\n\n\tgit_atomic_inc(&pack->refcount);\n\n\tgit_strmap_insert(git__pack_cache, pack->pack_name, pack, error);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\tif (error < 0) {\n\t\tgit_packfile_free(pack);\n\t\treturn -1;\n\t}\n\n\t*out = pack;\n\treturn 0;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "git_strmap *git__pack_cache = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\ngit_strmap *git__pack_cache = NULL;\n\nint git_mwindow_get_pack(struct git_pack_file **out, const char *path)\n{\n\tint error;\n\tchar *packname;\n\tgit_strmap_iter pos;\n\tstruct git_pack_file *pack;\n\n\tif ((error = git_packfile__name(&packname, path)) < 0)\n\t\treturn error;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tpos = git_strmap_lookup_index(git__pack_cache, packname);\n\tgit__free(packname);\n\n\tif (git_strmap_valid_index(git__pack_cache, pos)) {\n\t\tpack = git_strmap_value_at(git__pack_cache, pos);\n\t\tgit_atomic_inc(&pack->refcount);\n\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*out = pack;\n\t\treturn 0;\n\t}\n\n\t/* If we didn't find it, we need to create it */\n\tif ((error = git_packfile_alloc(&pack, path)) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn error;\n\t}\n\n\tgit_atomic_inc(&pack->refcount);\n\n\tgit_strmap_insert(git__pack_cache, pack->pack_name, pack, error);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\tif (error < 0) {\n\t\tgit_packfile_free(pack);\n\t\treturn -1;\n\t}\n\n\t*out = pack;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "p->pack_name",
            "path_str",
            "cmp_len"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&backend->packs",
            "i"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".idx\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__suffixcmp",
          "args": [
            "path_str",
            "\".idx\""
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "git__suffixcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "272-279",
          "snippet": "int git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".idx\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "path"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "path"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_load__cb(void *_data, git_buf *path);\n\nstatic int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}"
  },
  {
    "function_name": "packfile_sort__cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
    "lines": "163-190",
    "snippet": "static int packfile_sort__cb(const void *a_, const void *b_)\n{\n\tconst struct git_pack_file *a = a_;\n\tconst struct git_pack_file *b = b_;\n\tint st;\n\n\t/*\n\t * Local packs tend to contain objects specific to our\n\t * variant of the project than remote ones. In addition,\n\t * remote ones could be on a network mounted filesystem.\n\t * Favor local ones for these reasons.\n\t */\n\tst = a->pack_local - b->pack_local;\n\tif (st)\n\t\treturn -st;\n\n\t/*\n\t * Younger packs tend to contain more recent objects,\n\t * and more recent objects tend to get accessed more\n\t * often.\n\t */\n\tif (a->mtime < b->mtime)\n\t\treturn 1;\n\telse if (a->mtime == b->mtime)\n\t\treturn 0;\n\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"pack.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"odb.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/odb_backend.h\"",
      "#include \"git2/indexer.h\"",
      "#include \"git2/repository.h\"",
      "#include <zlib.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_sort__cb(const void *a_, const void *b_);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_sort__cb(const void *a_, const void *b_);\n\nstatic int packfile_sort__cb(const void *a_, const void *b_)\n{\n\tconst struct git_pack_file *a = a_;\n\tconst struct git_pack_file *b = b_;\n\tint st;\n\n\t/*\n\t * Local packs tend to contain objects specific to our\n\t * variant of the project than remote ones. In addition,\n\t * remote ones could be on a network mounted filesystem.\n\t * Favor local ones for these reasons.\n\t */\n\tst = a->pack_local - b->pack_local;\n\tif (st)\n\t\treturn -st;\n\n\t/*\n\t * Younger packs tend to contain more recent objects,\n\t * and more recent objects tend to get accessed more\n\t * often.\n\t */\n\tif (a->mtime < b->mtime)\n\t\treturn 1;\n\telse if (a->mtime == b->mtime)\n\t\treturn 0;\n\n\treturn -1;\n}"
  }
]