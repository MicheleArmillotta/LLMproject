[
  {
    "function_name": "git_branch_is_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "631-658",
    "snippet": "int git_branch_is_head(\n\t\tconst git_reference *branch)\n{\n\tgit_reference *head;\n\tbool is_same = false;\n\tint error;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn false;\n\n\terror = git_repository_head(&head, git_reference_owner(branch));\n\n\tif (error == GIT_EUNBORNBRANCH || error == GIT_ENOTFOUND)\n\t\treturn false;\n\n\tif (error < 0)\n\t\treturn -1;\n\n\tis_same = strcmp(\n\t\tgit_reference_name(branch),\n\t\tgit_reference_name(head)) == 0;\n\n\tgit_reference_free(head);\n\n\treturn is_same;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "head"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "git_reference_name(branch)",
            "git_reference_name(head)"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "head"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head",
          "args": [
            "&head",
            "git_reference_owner(branch)"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_owner",
          "args": [
            "branch"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "315-319",
          "snippet": "git_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_branch",
          "args": [
            "branch"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1177-1181",
          "snippet": "int git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "branch"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_is_head(\n\t\tconst git_reference *branch)\n{\n\tgit_reference *head;\n\tbool is_same = false;\n\tint error;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn false;\n\n\terror = git_repository_head(&head, git_reference_owner(branch));\n\n\tif (error == GIT_EUNBORNBRANCH || error == GIT_ENOTFOUND)\n\t\treturn false;\n\n\tif (error < 0)\n\t\treturn -1;\n\n\tis_same = strcmp(\n\t\tgit_reference_name(branch),\n\t\tgit_reference_name(head)) == 0;\n\n\tgit_reference_free(head);\n\n\treturn is_same;\n}"
  },
  {
    "function_name": "git_branch_set_upstream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "535-629",
    "snippet": "int git_branch_set_upstream(git_reference *branch, const char *upstream_name)\n{\n\tgit_buf key = GIT_BUF_INIT, value = GIT_BUF_INIT;\n\tgit_reference *upstream;\n\tgit_repository *repo;\n\tgit_remote *remote = NULL;\n\tgit_config *config;\n\tconst char *name, *shortname;\n\tint local, error;\n\tconst git_refspec *fetchspec;\n\n\tname = git_reference_name(branch);\n\tif (!git_reference__is_branch(name))\n\t\treturn not_a_local_branch(name);\n\n\tif (git_repository_config__weakptr(&config, git_reference_owner(branch)) < 0)\n\t\treturn -1;\n\n\tshortname = name + strlen(GIT_REFS_HEADS_DIR);\n\n\tif (upstream_name == NULL)\n\t\treturn unset_upstream(config, shortname);\n\n\trepo = git_reference_owner(branch);\n\n\t/* First we need to figure out whether it's a branch or remote-tracking */\n\tif (git_branch_lookup(&upstream, repo, upstream_name, GIT_BRANCH_LOCAL) == 0)\n\t\tlocal = 1;\n\telse if (git_branch_lookup(&upstream, repo, upstream_name, GIT_BRANCH_REMOTE) == 0)\n\t\tlocal = 0;\n\telse {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot set upstream for branch '%s'\", shortname);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/*\n\t * If it's local, the remote is \".\" and the branch name is\n\t * simply the refname. Otherwise we need to figure out what\n\t * the remote-tracking branch's name on the remote is and use\n\t * that.\n\t */\n\tif (local)\n\t\terror = git_buf_puts(&value, \".\");\n\telse\n\t\terror = git_branch_remote_name(&value, repo, git_reference_name(upstream));\n\n\tif (error < 0)\n\t\tgoto on_error;\n\n\tif (git_buf_printf(&key, \"branch.%s.remote\", shortname) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_set_string(config, git_buf_cstr(&key), git_buf_cstr(&value)) < 0)\n\t\tgoto on_error;\n\n\tif (local) {\n\t\tgit_buf_clear(&value);\n\t\tif (git_buf_puts(&value, git_reference_name(upstream)) < 0)\n\t\t\tgoto on_error;\n\t} else {\n\t\t/* Get the remoe-tracking branch's refname in its repo */\n\t\tif (git_remote_lookup(&remote, repo, git_buf_cstr(&value)) < 0)\n\t\t\tgoto on_error;\n\n\t\tfetchspec = git_remote__matching_dst_refspec(remote, git_reference_name(upstream));\n\t\tgit_buf_clear(&value);\n\t\tif (!fetchspec || git_refspec_rtransform(&value, fetchspec, git_reference_name(upstream)) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_remote_free(remote);\n\t\tremote = NULL;\n\t}\n\n\tgit_buf_clear(&key);\n\tif (git_buf_printf(&key, \"branch.%s.merge\", shortname) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_set_string(config, git_buf_cstr(&key), git_buf_cstr(&value)) < 0)\n\t\tgoto on_error;\n\n\tgit_reference_free(upstream);\n\tgit_buf_free(&key);\n\tgit_buf_free(&value);\n\n\treturn 0;\n\non_error:\n\tgit_reference_free(upstream);\n\tgit_buf_free(&key);\n\tgit_buf_free(&value);\n\tgit_remote_free(remote);\n\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&value"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "upstream"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_set_string",
          "args": [
            "config",
            "git_buf_cstr(&key)",
            "git_buf_cstr(&value)"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "616-638",
          "snippet": "int git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&value"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&key",
            "\"branch.%s.merge\"",
            "shortname"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&key"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_rtransform",
          "args": [
            "&value",
            "fetchspec",
            "git_reference_name(upstream)"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_rtransform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "260-274",
          "snippet": "int git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_dst_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the destination\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->src);\n\n\treturn refspec_transform(out, spec->dst, spec->src, name);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_dst_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the destination\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->src);\n\n\treturn refspec_transform(out, spec->dst, spec->src, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "upstream"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__matching_dst_refspec",
          "args": [
            "remote",
            "git_reference_name(upstream)"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__matching_dst_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2071-2085",
          "snippet": "git_refspec *git_remote__matching_dst_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_dst_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_refspec *git_remote__matching_dst_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_dst_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_lookup",
          "args": [
            "&remote",
            "repo",
            "git_buf_cstr(&value)"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "420-524",
          "snippet": "int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&value",
            "git_reference_name(upstream)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_remote_name",
          "args": [
            "&value",
            "repo",
            "git_reference_name(upstream)"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_remote_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "422-488",
          "snippet": "int git_branch_remote_name(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tgit_strarray remote_list = {0};\n\tsize_t i;\n\tgit_remote *remote;\n\tconst git_refspec *fetchspec;\n\tint error = 0;\n\tchar *remote_name = NULL;\n\n\tassert(buf && repo && refname);\n\n\tgit_buf_sanitize(buf);\n\n\t/* Verify that this is a remote branch */\n\tif (!git_reference__is_remote(refname)) {\n\t\tgiterr_set(GITERR_INVALID, \"Reference '%s' is not a remote branch.\",\n\t\t\trefname);\n\t\terror = GIT_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\t/* Get the remotes */\n\tif ((error = git_remote_list(&remote_list, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* Find matching remotes */\n\tfor (i = 0; i < remote_list.count; i++) {\n\t\tif ((error = git_remote_lookup(&remote, repo, remote_list.strings[i])) < 0)\n\t\t\tcontinue;\n\n\t\tfetchspec = git_remote__matching_dst_refspec(remote, refname);\n\t\tif (fetchspec) {\n\t\t\t/* If we have not already set out yet, then set\n\t\t\t * it to the matching remote name. Otherwise\n\t\t\t * multiple remotes match this reference, and it\n\t\t\t * is ambiguous. */\n\t\t\tif (!remote_name) {\n\t\t\t\tremote_name = remote_list.strings[i];\n\t\t\t} else {\n\t\t\t\tgit_remote_free(remote);\n\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Reference '%s' is ambiguous\", refname);\n\t\t\t\terror = GIT_EAMBIGUOUS;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tgit_remote_free(remote);\n\t}\n\n\tif (remote_name) {\n\t\tgit_buf_clear(buf);\n\t\terror = git_buf_puts(buf, remote_name);\n\t} else {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not determine remote for '%s'\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit_buf_free(buf);\n\n\tgit_strarray_free(&remote_list);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_remote_name(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tgit_strarray remote_list = {0};\n\tsize_t i;\n\tgit_remote *remote;\n\tconst git_refspec *fetchspec;\n\tint error = 0;\n\tchar *remote_name = NULL;\n\n\tassert(buf && repo && refname);\n\n\tgit_buf_sanitize(buf);\n\n\t/* Verify that this is a remote branch */\n\tif (!git_reference__is_remote(refname)) {\n\t\tgiterr_set(GITERR_INVALID, \"Reference '%s' is not a remote branch.\",\n\t\t\trefname);\n\t\terror = GIT_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\t/* Get the remotes */\n\tif ((error = git_remote_list(&remote_list, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* Find matching remotes */\n\tfor (i = 0; i < remote_list.count; i++) {\n\t\tif ((error = git_remote_lookup(&remote, repo, remote_list.strings[i])) < 0)\n\t\t\tcontinue;\n\n\t\tfetchspec = git_remote__matching_dst_refspec(remote, refname);\n\t\tif (fetchspec) {\n\t\t\t/* If we have not already set out yet, then set\n\t\t\t * it to the matching remote name. Otherwise\n\t\t\t * multiple remotes match this reference, and it\n\t\t\t * is ambiguous. */\n\t\t\tif (!remote_name) {\n\t\t\t\tremote_name = remote_list.strings[i];\n\t\t\t} else {\n\t\t\t\tgit_remote_free(remote);\n\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Reference '%s' is ambiguous\", refname);\n\t\t\t\terror = GIT_EAMBIGUOUS;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tgit_remote_free(remote);\n\t}\n\n\tif (remote_name) {\n\t\tgit_buf_clear(buf);\n\t\terror = git_buf_puts(buf, remote_name);\n\t} else {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not determine remote for '%s'\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit_buf_free(buf);\n\n\tgit_strarray_free(&remote_list);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Cannot set upstream for branch '%s'\"",
            "shortname"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_lookup",
          "args": [
            "&upstream",
            "repo",
            "upstream_name",
            "GIT_BRANCH_REMOTE"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "280-289",
          "snippet": "int git_branch_lookup(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tgit_branch_t branch_type)\n{\n\tassert(ref_out && repo && branch_name);\n\n\treturn retrieve_branch_reference(ref_out, repo, branch_name, branch_type == GIT_BRANCH_REMOTE);\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_lookup(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tgit_branch_t branch_type)\n{\n\tassert(ref_out && repo && branch_name);\n\n\treturn retrieve_branch_reference(ref_out, repo, branch_name, branch_type == GIT_BRANCH_REMOTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_owner",
          "args": [
            "branch"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "315-319",
          "snippet": "git_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unset_upstream",
          "args": [
            "config",
            "shortname"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "unset_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "510-533",
          "snippet": "static int unset_upstream(git_config *config, const char *shortname)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tif (git_buf_printf(&buf, \"branch.%s.remote\", shortname) < 0)\n\t\treturn -1;\n\n\tif (git_config_delete_entry(config, git_buf_cstr(&buf)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_clear(&buf);\n\tif (git_buf_printf(&buf, \"branch.%s.merge\", shortname) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_delete_entry(config, git_buf_cstr(&buf)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&buf);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&buf);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int unset_upstream(git_config *config, const char *shortname)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tif (git_buf_printf(&buf, \"branch.%s.remote\", shortname) < 0)\n\t\treturn -1;\n\n\tif (git_config_delete_entry(config, git_buf_cstr(&buf)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_clear(&buf);\n\tif (git_buf_printf(&buf, \"branch.%s.merge\", shortname) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_delete_entry(config, git_buf_cstr(&buf)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&buf);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&buf);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&config",
            "git_reference_owner(branch)"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "not_a_local_branch",
          "args": [
            "name"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "not_a_local_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "45-51",
          "snippet": "static int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__is_branch",
          "args": [
            "name"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1172-1175",
          "snippet": "int git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_set_upstream(git_reference *branch, const char *upstream_name)\n{\n\tgit_buf key = GIT_BUF_INIT, value = GIT_BUF_INIT;\n\tgit_reference *upstream;\n\tgit_repository *repo;\n\tgit_remote *remote = NULL;\n\tgit_config *config;\n\tconst char *name, *shortname;\n\tint local, error;\n\tconst git_refspec *fetchspec;\n\n\tname = git_reference_name(branch);\n\tif (!git_reference__is_branch(name))\n\t\treturn not_a_local_branch(name);\n\n\tif (git_repository_config__weakptr(&config, git_reference_owner(branch)) < 0)\n\t\treturn -1;\n\n\tshortname = name + strlen(GIT_REFS_HEADS_DIR);\n\n\tif (upstream_name == NULL)\n\t\treturn unset_upstream(config, shortname);\n\n\trepo = git_reference_owner(branch);\n\n\t/* First we need to figure out whether it's a branch or remote-tracking */\n\tif (git_branch_lookup(&upstream, repo, upstream_name, GIT_BRANCH_LOCAL) == 0)\n\t\tlocal = 1;\n\telse if (git_branch_lookup(&upstream, repo, upstream_name, GIT_BRANCH_REMOTE) == 0)\n\t\tlocal = 0;\n\telse {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot set upstream for branch '%s'\", shortname);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/*\n\t * If it's local, the remote is \".\" and the branch name is\n\t * simply the refname. Otherwise we need to figure out what\n\t * the remote-tracking branch's name on the remote is and use\n\t * that.\n\t */\n\tif (local)\n\t\terror = git_buf_puts(&value, \".\");\n\telse\n\t\terror = git_branch_remote_name(&value, repo, git_reference_name(upstream));\n\n\tif (error < 0)\n\t\tgoto on_error;\n\n\tif (git_buf_printf(&key, \"branch.%s.remote\", shortname) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_set_string(config, git_buf_cstr(&key), git_buf_cstr(&value)) < 0)\n\t\tgoto on_error;\n\n\tif (local) {\n\t\tgit_buf_clear(&value);\n\t\tif (git_buf_puts(&value, git_reference_name(upstream)) < 0)\n\t\t\tgoto on_error;\n\t} else {\n\t\t/* Get the remoe-tracking branch's refname in its repo */\n\t\tif (git_remote_lookup(&remote, repo, git_buf_cstr(&value)) < 0)\n\t\t\tgoto on_error;\n\n\t\tfetchspec = git_remote__matching_dst_refspec(remote, git_reference_name(upstream));\n\t\tgit_buf_clear(&value);\n\t\tif (!fetchspec || git_refspec_rtransform(&value, fetchspec, git_reference_name(upstream)) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_remote_free(remote);\n\t\tremote = NULL;\n\t}\n\n\tgit_buf_clear(&key);\n\tif (git_buf_printf(&key, \"branch.%s.merge\", shortname) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_set_string(config, git_buf_cstr(&key), git_buf_cstr(&value)) < 0)\n\t\tgoto on_error;\n\n\tgit_reference_free(upstream);\n\tgit_buf_free(&key);\n\tgit_buf_free(&value);\n\n\treturn 0;\n\non_error:\n\tgit_reference_free(upstream);\n\tgit_buf_free(&key);\n\tgit_buf_free(&value);\n\tgit_remote_free(remote);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "unset_upstream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "510-533",
    "snippet": "static int unset_upstream(git_config *config, const char *shortname)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tif (git_buf_printf(&buf, \"branch.%s.remote\", shortname) < 0)\n\t\treturn -1;\n\n\tif (git_config_delete_entry(config, git_buf_cstr(&buf)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_clear(&buf);\n\tif (git_buf_printf(&buf, \"branch.%s.merge\", shortname) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_delete_entry(config, git_buf_cstr(&buf)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&buf);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&buf);\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_delete_entry",
          "args": [
            "config",
            "git_buf_cstr(&buf)"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "586-597",
          "snippet": "int git_config_delete_entry(git_config *cfg, const char *name)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del(file, name);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_delete_entry(git_config *cfg, const char *name)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del(file, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"branch.%s.merge\"",
            "shortname"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&buf"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int unset_upstream(git_config *config, const char *shortname)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tif (git_buf_printf(&buf, \"branch.%s.remote\", shortname) < 0)\n\t\treturn -1;\n\n\tif (git_config_delete_entry(config, git_buf_cstr(&buf)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_clear(&buf);\n\tif (git_buf_printf(&buf, \"branch.%s.merge\", shortname) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_delete_entry(config, git_buf_cstr(&buf)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&buf);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&buf);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_branch_upstream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "490-508",
    "snippet": "int git_branch_upstream(\n\tgit_reference **tracking_out,\n\tconst git_reference *branch)\n{\n\tint error;\n\tgit_buf tracking_name = GIT_BUF_INIT;\n\n\tif ((error = git_branch_upstream_name(&tracking_name,\n\t\tgit_reference_owner(branch), git_reference_name(branch))) < 0)\n\t\t\treturn error;\n\n\terror = git_reference_lookup(\n\t\ttracking_out,\n\t\tgit_reference_owner(branch),\n\t\tgit_buf_cstr(&tracking_name));\n\n\tgit_buf_free(&tracking_name);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&tracking_name"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "tracking_out",
            "git_reference_owner(branch)",
            "git_buf_cstr(&tracking_name)"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&tracking_name"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_owner",
          "args": [
            "branch"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "315-319",
          "snippet": "git_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_upstream_name",
          "args": [
            "&tracking_name",
            "git_reference_owner(branch)",
            "git_reference_name(branch)"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_upstream_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "332-395",
          "snippet": "int git_branch_upstream_name(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tconst char *refname)\n{\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_buf merge_name = GIT_BUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = -1;\n\tgit_remote *remote = NULL;\n\tconst git_refspec *refspec;\n\tgit_config *config;\n\n\tassert(out && refname);\n\n\tgit_buf_sanitize(out);\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&remote_name, config, refname, \"branch.%s.remote\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&merge_name, config, refname, \"branch.%s.merge\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif (git_buf_len(&remote_name) == 0 || git_buf_len(&merge_name) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"branch '%s' does not have an upstream\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tif (strcmp(\".\", git_buf_cstr(&remote_name)) != 0) {\n\t\tif ((error = git_remote_lookup(&remote, repo, git_buf_cstr(&remote_name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&merge_name));\n\t\tif (!refspec) {\n\t\t\terror = GIT_ENOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (git_refspec_transform(&buf, refspec, git_buf_cstr(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\t} else\n\t\tif (git_buf_set(&buf, git_buf_cstr(&merge_name), git_buf_len(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = git_buf_set(out, git_buf_cstr(&buf), git_buf_len(&buf));\n\ncleanup:\n\tgit_config_free(config);\n\tgit_remote_free(remote);\n\tgit_buf_free(&remote_name);\n\tgit_buf_free(&merge_name);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_upstream_name(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tconst char *refname)\n{\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_buf merge_name = GIT_BUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = -1;\n\tgit_remote *remote = NULL;\n\tconst git_refspec *refspec;\n\tgit_config *config;\n\n\tassert(out && refname);\n\n\tgit_buf_sanitize(out);\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&remote_name, config, refname, \"branch.%s.remote\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&merge_name, config, refname, \"branch.%s.merge\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif (git_buf_len(&remote_name) == 0 || git_buf_len(&merge_name) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"branch '%s' does not have an upstream\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tif (strcmp(\".\", git_buf_cstr(&remote_name)) != 0) {\n\t\tif ((error = git_remote_lookup(&remote, repo, git_buf_cstr(&remote_name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&merge_name));\n\t\tif (!refspec) {\n\t\t\terror = GIT_ENOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (git_refspec_transform(&buf, refspec, git_buf_cstr(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\t} else\n\t\tif (git_buf_set(&buf, git_buf_cstr(&merge_name), git_buf_len(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = git_buf_set(out, git_buf_cstr(&buf), git_buf_len(&buf));\n\ncleanup:\n\tgit_config_free(config);\n\tgit_remote_free(remote);\n\tgit_buf_free(&remote_name);\n\tgit_buf_free(&merge_name);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "branch"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_upstream(\n\tgit_reference **tracking_out,\n\tconst git_reference *branch)\n{\n\tint error;\n\tgit_buf tracking_name = GIT_BUF_INIT;\n\n\tif ((error = git_branch_upstream_name(&tracking_name,\n\t\tgit_reference_owner(branch), git_reference_name(branch))) < 0)\n\t\t\treturn error;\n\n\terror = git_reference_lookup(\n\t\ttracking_out,\n\t\tgit_reference_owner(branch),\n\t\tgit_buf_cstr(&tracking_name));\n\n\tgit_buf_free(&tracking_name);\n\treturn error;\n}"
  },
  {
    "function_name": "git_branch_remote_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "422-488",
    "snippet": "int git_branch_remote_name(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tgit_strarray remote_list = {0};\n\tsize_t i;\n\tgit_remote *remote;\n\tconst git_refspec *fetchspec;\n\tint error = 0;\n\tchar *remote_name = NULL;\n\n\tassert(buf && repo && refname);\n\n\tgit_buf_sanitize(buf);\n\n\t/* Verify that this is a remote branch */\n\tif (!git_reference__is_remote(refname)) {\n\t\tgiterr_set(GITERR_INVALID, \"Reference '%s' is not a remote branch.\",\n\t\t\trefname);\n\t\terror = GIT_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\t/* Get the remotes */\n\tif ((error = git_remote_list(&remote_list, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* Find matching remotes */\n\tfor (i = 0; i < remote_list.count; i++) {\n\t\tif ((error = git_remote_lookup(&remote, repo, remote_list.strings[i])) < 0)\n\t\t\tcontinue;\n\n\t\tfetchspec = git_remote__matching_dst_refspec(remote, refname);\n\t\tif (fetchspec) {\n\t\t\t/* If we have not already set out yet, then set\n\t\t\t * it to the matching remote name. Otherwise\n\t\t\t * multiple remotes match this reference, and it\n\t\t\t * is ambiguous. */\n\t\t\tif (!remote_name) {\n\t\t\t\tremote_name = remote_list.strings[i];\n\t\t\t} else {\n\t\t\t\tgit_remote_free(remote);\n\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Reference '%s' is ambiguous\", refname);\n\t\t\t\terror = GIT_EAMBIGUOUS;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tgit_remote_free(remote);\n\t}\n\n\tif (remote_name) {\n\t\tgit_buf_clear(buf);\n\t\terror = git_buf_puts(buf, remote_name);\n\t} else {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not determine remote for '%s'\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit_buf_free(buf);\n\n\tgit_strarray_free(&remote_list);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strarray_free",
          "args": [
            "&remote_list"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "git_strarray_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "21-34",
          "snippet": "void git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nvoid git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "buf"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Could not determine remote for '%s'\"",
            "refname"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "buf",
            "remote_name"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__matching_dst_refspec",
          "args": [
            "remote",
            "refname"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__matching_dst_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2071-2085",
          "snippet": "git_refspec *git_remote__matching_dst_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_dst_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_refspec *git_remote__matching_dst_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_dst_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_lookup",
          "args": [
            "&remote",
            "repo",
            "remote_list.strings[i]"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "420-524",
          "snippet": "int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_list",
          "args": [
            "&remote_list",
            "repo"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1690-1716",
          "snippet": "int git_remote_list(git_strarray *remotes_list, git_repository *repo)\n{\n\tint error;\n\tgit_config *cfg;\n\tgit_vector list = GIT_VECTOR_INIT;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_vector_init(&list, 4, git__strcmp_cb)) < 0)\n\t\treturn error;\n\n\terror = git_config_foreach_match(\n\t\tcfg, \"^remote\\\\..*\\\\.(push)?url$\", remote_list_cb, &list);\n\n\tif (error < 0) {\n\t\tgit_vector_free_deep(&list);\n\t\treturn error;\n\t}\n\n\tgit_vector_uniq(&list, git__free);\n\n\tremotes_list->strings =\n\t\t(char **)git_vector_detach(&remotes_list->count, NULL, &list);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_list(git_strarray *remotes_list, git_repository *repo)\n{\n\tint error;\n\tgit_config *cfg;\n\tgit_vector list = GIT_VECTOR_INIT;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_vector_init(&list, 4, git__strcmp_cb)) < 0)\n\t\treturn error;\n\n\terror = git_config_foreach_match(\n\t\tcfg, \"^remote\\\\..*\\\\.(push)?url$\", remote_list_cb, &list);\n\n\tif (error < 0) {\n\t\tgit_vector_free_deep(&list);\n\t\treturn error;\n\t}\n\n\tgit_vector_uniq(&list, git__free);\n\n\tremotes_list->strings =\n\t\t(char **)git_vector_detach(&remotes_list->count, NULL, &list);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__is_remote",
          "args": [
            "refname"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1183-1186",
          "snippet": "int git_reference__is_remote(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_REMOTES_DIR) == 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_remote(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_REMOTES_DIR) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "buf"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "buf && repo && refname"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_remote_name(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tgit_strarray remote_list = {0};\n\tsize_t i;\n\tgit_remote *remote;\n\tconst git_refspec *fetchspec;\n\tint error = 0;\n\tchar *remote_name = NULL;\n\n\tassert(buf && repo && refname);\n\n\tgit_buf_sanitize(buf);\n\n\t/* Verify that this is a remote branch */\n\tif (!git_reference__is_remote(refname)) {\n\t\tgiterr_set(GITERR_INVALID, \"Reference '%s' is not a remote branch.\",\n\t\t\trefname);\n\t\terror = GIT_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\t/* Get the remotes */\n\tif ((error = git_remote_list(&remote_list, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* Find matching remotes */\n\tfor (i = 0; i < remote_list.count; i++) {\n\t\tif ((error = git_remote_lookup(&remote, repo, remote_list.strings[i])) < 0)\n\t\t\tcontinue;\n\n\t\tfetchspec = git_remote__matching_dst_refspec(remote, refname);\n\t\tif (fetchspec) {\n\t\t\t/* If we have not already set out yet, then set\n\t\t\t * it to the matching remote name. Otherwise\n\t\t\t * multiple remotes match this reference, and it\n\t\t\t * is ambiguous. */\n\t\t\tif (!remote_name) {\n\t\t\t\tremote_name = remote_list.strings[i];\n\t\t\t} else {\n\t\t\t\tgit_remote_free(remote);\n\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Reference '%s' is ambiguous\", refname);\n\t\t\t\terror = GIT_EAMBIGUOUS;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tgit_remote_free(remote);\n\t}\n\n\tif (remote_name) {\n\t\tgit_buf_clear(buf);\n\t\terror = git_buf_puts(buf, remote_name);\n\t} else {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not determine remote for '%s'\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit_buf_free(buf);\n\n\tgit_strarray_free(&remote_list);\n\treturn error;\n}"
  },
  {
    "function_name": "git_branch_upstream_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "397-420",
    "snippet": "int git_branch_upstream_remote(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_config *cfg;\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tgit_buf_sanitize(buf);\n\n\tif ((error = retrieve_upstream_configuration(buf, cfg, refname, \"branch.%s.remote\")) < 0)\n\t\treturn error;\n\n\tif (git_buf_len(buf) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE, \"branch '%s' does not have an upstream remote\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgit_buf_clear(buf);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"branch '%s' does not have an upstream remote\"",
            "refname"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "buf"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_upstream_configuration",
          "args": [
            "buf",
            "cfg",
            "refname",
            "\"branch.%s.remote\""
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_upstream_configuration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "314-330",
          "snippet": "static int retrieve_upstream_configuration(\n\tgit_buf *out,\n\tconst git_config *config,\n\tconst char *canonical_branch_name,\n\tconst char *format)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, format,\n\t\tcanonical_branch_name + strlen(GIT_REFS_HEADS_DIR)) < 0)\n\t\t\treturn -1;\n\n\terror = git_config_get_string_buf(out, config, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_upstream_configuration(\n\tgit_buf *out,\n\tconst git_config *config,\n\tconst char *canonical_branch_name,\n\tconst char *format)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, format,\n\t\tcanonical_branch_name + strlen(GIT_REFS_HEADS_DIR)) < 0)\n\t\t\treturn -1;\n\n\terror = git_config_get_string_buf(out, config, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "buf"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "repo"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "not_a_local_branch",
          "args": [
            "refname"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "not_a_local_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "45-51",
          "snippet": "static int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__is_branch",
          "args": [
            "refname"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1172-1175",
          "snippet": "int git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_upstream_remote(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_config *cfg;\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tgit_buf_sanitize(buf);\n\n\tif ((error = retrieve_upstream_configuration(buf, cfg, refname, \"branch.%s.remote\")) < 0)\n\t\treturn error;\n\n\tif (git_buf_len(buf) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE, \"branch '%s' does not have an upstream remote\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgit_buf_clear(buf);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_branch_upstream_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "332-395",
    "snippet": "int git_branch_upstream_name(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tconst char *refname)\n{\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_buf merge_name = GIT_BUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = -1;\n\tgit_remote *remote = NULL;\n\tconst git_refspec *refspec;\n\tgit_config *config;\n\n\tassert(out && refname);\n\n\tgit_buf_sanitize(out);\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&remote_name, config, refname, \"branch.%s.remote\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&merge_name, config, refname, \"branch.%s.merge\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif (git_buf_len(&remote_name) == 0 || git_buf_len(&merge_name) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"branch '%s' does not have an upstream\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tif (strcmp(\".\", git_buf_cstr(&remote_name)) != 0) {\n\t\tif ((error = git_remote_lookup(&remote, repo, git_buf_cstr(&remote_name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&merge_name));\n\t\tif (!refspec) {\n\t\t\terror = GIT_ENOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (git_refspec_transform(&buf, refspec, git_buf_cstr(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\t} else\n\t\tif (git_buf_set(&buf, git_buf_cstr(&merge_name), git_buf_len(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = git_buf_set(out, git_buf_cstr(&buf), git_buf_len(&buf));\n\ncleanup:\n\tgit_config_free(config);\n\tgit_remote_free(remote);\n\tgit_buf_free(&remote_name);\n\tgit_buf_free(&merge_name);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "config"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "out",
            "git_buf_cstr(&buf)",
            "git_buf_len(&buf)"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&buf"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_transform",
          "args": [
            "&buf",
            "refspec",
            "git_buf_cstr(&merge_name)"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "244-258",
          "snippet": "int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__matching_refspec",
          "args": [
            "remote",
            "git_buf_cstr(&merge_name)"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__matching_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2055-2069",
          "snippet": "git_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_lookup",
          "args": [
            "&remote",
            "repo",
            "git_buf_cstr(&remote_name)"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "420-524",
          "snippet": "int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\".\"",
            "git_buf_cstr(&remote_name)"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"branch '%s' does not have an upstream\"",
            "refname"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_upstream_configuration",
          "args": [
            "&merge_name",
            "config",
            "refname",
            "\"branch.%s.merge\""
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_upstream_configuration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "314-330",
          "snippet": "static int retrieve_upstream_configuration(\n\tgit_buf *out,\n\tconst git_config *config,\n\tconst char *canonical_branch_name,\n\tconst char *format)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, format,\n\t\tcanonical_branch_name + strlen(GIT_REFS_HEADS_DIR)) < 0)\n\t\t\treturn -1;\n\n\terror = git_config_get_string_buf(out, config, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_upstream_configuration(\n\tgit_buf *out,\n\tconst git_config *config,\n\tconst char *canonical_branch_name,\n\tconst char *format)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, format,\n\t\tcanonical_branch_name + strlen(GIT_REFS_HEADS_DIR)) < 0)\n\t\t\treturn -1;\n\n\terror = git_config_get_string_buf(out, config, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config_snapshot",
          "args": [
            "&config",
            "repo"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "716-725",
          "snippet": "int git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}"
        }
      },
      {
        "call_info": {
          "callee": "not_a_local_branch",
          "args": [
            "refname"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "not_a_local_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "45-51",
          "snippet": "static int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__is_branch",
          "args": [
            "refname"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1172-1175",
          "snippet": "int git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "out"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && refname"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_upstream_name(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tconst char *refname)\n{\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_buf merge_name = GIT_BUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = -1;\n\tgit_remote *remote = NULL;\n\tconst git_refspec *refspec;\n\tgit_config *config;\n\n\tassert(out && refname);\n\n\tgit_buf_sanitize(out);\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&remote_name, config, refname, \"branch.%s.remote\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&merge_name, config, refname, \"branch.%s.merge\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif (git_buf_len(&remote_name) == 0 || git_buf_len(&merge_name) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"branch '%s' does not have an upstream\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tif (strcmp(\".\", git_buf_cstr(&remote_name)) != 0) {\n\t\tif ((error = git_remote_lookup(&remote, repo, git_buf_cstr(&remote_name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&merge_name));\n\t\tif (!refspec) {\n\t\t\terror = GIT_ENOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (git_refspec_transform(&buf, refspec, git_buf_cstr(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\t} else\n\t\tif (git_buf_set(&buf, git_buf_cstr(&merge_name), git_buf_len(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = git_buf_set(out, git_buf_cstr(&buf), git_buf_len(&buf));\n\ncleanup:\n\tgit_config_free(config);\n\tgit_remote_free(remote);\n\tgit_buf_free(&remote_name);\n\tgit_buf_free(&merge_name);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
  },
  {
    "function_name": "retrieve_upstream_configuration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "314-330",
    "snippet": "static int retrieve_upstream_configuration(\n\tgit_buf *out,\n\tconst git_config *config,\n\tconst char *canonical_branch_name,\n\tconst char *format)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, format,\n\t\tcanonical_branch_name + strlen(GIT_REFS_HEADS_DIR)) < 0)\n\t\t\treturn -1;\n\n\terror = git_config_get_string_buf(out, config, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_get_string_buf",
          "args": [
            "out",
            "config",
            "git_buf_cstr(&buf)"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_get_string_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "857-875",
          "snippet": "int git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "format",
            "canonical_branch_name + strlen(GIT_REFS_HEADS_DIR)"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_upstream_configuration(\n\tgit_buf *out,\n\tconst git_config *config,\n\tconst char *canonical_branch_name,\n\tconst char *format)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, format,\n\t\tcanonical_branch_name + strlen(GIT_REFS_HEADS_DIR)) < 0)\n\t\t\treturn -1;\n\n\terror = git_config_get_string_buf(out, config, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\treturn error;\n}"
  },
  {
    "function_name": "git_branch_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "291-312",
    "snippet": "int git_branch_name(\n\tconst char **out,\n\tconst git_reference *ref)\n{\n\tconst char *branch_name;\n\n\tassert(out && ref);\n\n\tbranch_name = ref->name;\n\n\tif (git_reference_is_branch(ref)) {\n\t\tbranch_name += strlen(GIT_REFS_HEADS_DIR);\n\t} else if (git_reference_is_remote(ref)) {\n\t\tbranch_name += strlen(GIT_REFS_REMOTES_DIR);\n\t} else {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\"Reference '%s' is neither a local nor a remote branch.\", ref->name);\n\t\treturn -1;\n\t}\n\t*out = branch_name;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Reference '%s' is neither a local nor a remote branch.\"",
            "ref->name"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_REMOTES_DIR"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_is_remote",
          "args": [
            "ref"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1188-1192",
          "snippet": "int git_reference_is_remote(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_remote(ref->name);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_remote(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_remote(ref->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_is_branch",
          "args": [
            "ref"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1177-1181",
          "snippet": "int git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && ref"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_name(\n\tconst char **out,\n\tconst git_reference *ref)\n{\n\tconst char *branch_name;\n\n\tassert(out && ref);\n\n\tbranch_name = ref->name;\n\n\tif (git_reference_is_branch(ref)) {\n\t\tbranch_name += strlen(GIT_REFS_HEADS_DIR);\n\t} else if (git_reference_is_remote(ref)) {\n\t\tbranch_name += strlen(GIT_REFS_REMOTES_DIR);\n\t} else {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\"Reference '%s' is neither a local nor a remote branch.\", ref->name);\n\t\treturn -1;\n\t}\n\t*out = branch_name;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_branch_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "280-289",
    "snippet": "int git_branch_lookup(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tgit_branch_t branch_type)\n{\n\tassert(ref_out && repo && branch_name);\n\n\treturn retrieve_branch_reference(ref_out, repo, branch_name, branch_type == GIT_BRANCH_REMOTE);\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retrieve_branch_reference",
          "args": [
            "ref_out",
            "repo",
            "branch_name",
            "branch_type == GIT_BRANCH_REMOTE"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_branch_reference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "19-43",
          "snippet": "static int retrieve_branch_reference(\n\tgit_reference **branch_reference_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tint is_remote)\n{\n\tgit_reference *branch = NULL;\n\tint error = 0;\n\tchar *prefix;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tprefix = is_remote ? GIT_REFS_REMOTES_DIR : GIT_REFS_HEADS_DIR;\n\n\tif ((error = git_buf_joinpath(&ref_name, prefix, branch_name)) < 0)\n\t\t/* OOM */;\n\telse if ((error = git_reference_lookup(&branch, repo, ref_name.ptr)) < 0)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE, \"Cannot locate %s branch '%s'\",\n\t\t\tis_remote ? \"remote-tracking\" : \"local\", branch_name);\n\n\t*branch_reference_out = branch; /* will be NULL on error */\n\n\tgit_buf_free(&ref_name);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_branch_reference(\n\tgit_reference **branch_reference_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tint is_remote)\n{\n\tgit_reference *branch = NULL;\n\tint error = 0;\n\tchar *prefix;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tprefix = is_remote ? GIT_REFS_REMOTES_DIR : GIT_REFS_HEADS_DIR;\n\n\tif ((error = git_buf_joinpath(&ref_name, prefix, branch_name)) < 0)\n\t\t/* OOM */;\n\telse if ((error = git_reference_lookup(&branch, repo, ref_name.ptr)) < 0)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE, \"Cannot locate %s branch '%s'\",\n\t\t\tis_remote ? \"remote-tracking\" : \"local\", branch_name);\n\n\t*branch_reference_out = branch; /* will be NULL on error */\n\n\tgit_buf_free(&ref_name);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref_out && repo && branch_name"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_lookup(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tgit_branch_t branch_type)\n{\n\tassert(ref_out && repo && branch_name);\n\n\treturn retrieve_branch_reference(ref_out, repo, branch_name, branch_type == GIT_BRANCH_REMOTE);\n}"
  },
  {
    "function_name": "git_branch_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "230-278",
    "snippet": "int git_branch_move(\n\tgit_reference **out,\n\tgit_reference *branch,\n\tconst char *new_branch_name,\n\tint force)\n{\n\tgit_buf new_reference_name = GIT_BUF_INIT,\n\t        old_config_section = GIT_BUF_INIT,\n\t        new_config_section = GIT_BUF_INIT,\n\t        log_message = GIT_BUF_INIT;\n\tint error;\n\n\tassert(branch && new_branch_name);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn not_a_local_branch(git_reference_name(branch));\n\n\tif ((error = git_buf_joinpath(&new_reference_name, GIT_REFS_HEADS_DIR, new_branch_name)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_buf_printf(&log_message, \"branch: renamed %s to %s\",\n\t\t\t\t    git_reference_name(branch), git_buf_cstr(&new_reference_name))) < 0)\n\t\t\tgoto done;\n\n\t/* first update ref then config so failure won't trash config */\n\n\terror = git_reference_rename(\n\t\tout, branch, git_buf_cstr(&new_reference_name), force,\n\t\tgit_buf_cstr(&log_message));\n\tif (error < 0)\n\t\tgoto done;\n\n\tgit_buf_join(&old_config_section, '.', \"branch\",\n\t\tgit_reference_name(branch) + strlen(GIT_REFS_HEADS_DIR));\n\tgit_buf_join(&new_config_section, '.', \"branch\", new_branch_name);\n\n\terror = git_config_rename_section(\n\t\tgit_reference_owner(branch),\n\t\tgit_buf_cstr(&old_config_section),\n\t\tgit_buf_cstr(&new_config_section));\n\ndone:\n\tgit_buf_free(&new_reference_name);\n\tgit_buf_free(&old_config_section);\n\tgit_buf_free(&new_config_section);\n\tgit_buf_free(&log_message);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&log_message"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_rename_section",
          "args": [
            "git_reference_owner(branch)",
            "git_buf_cstr(&old_config_section)",
            "git_buf_cstr(&new_config_section)"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_rename_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1434-1476",
          "snippet": "int git_config_rename_section(\n\tgit_repository *repo,\n\tconst char *old_section_name,\n\tconst char *new_section_name)\n{\n\tgit_config *config;\n\tgit_buf pattern = GIT_BUF_INIT, replace = GIT_BUF_INIT;\n\tint error = 0;\n\tstruct rename_data data;\n\n\tgit_buf_text_puts_escape_regex(&pattern, old_section_name);\n\n\tif ((error = git_buf_puts(&pattern, \"\\\\..+\")) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\tgoto cleanup;\n\n\tdata.config  = config;\n\tdata.name    = &replace;\n\tdata.old_len = strlen(old_section_name) + 1;\n\n\tif ((error = git_buf_join(&replace, '.', new_section_name, \"\")) < 0)\n\t\tgoto cleanup;\n\n\tif (new_section_name != NULL &&\n\t\t(error = git_config_file_normalize_section(\n\t\t\treplace.ptr, strchr(replace.ptr, '.'))) < 0)\n\t{\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG, \"Invalid config section '%s'\", new_section_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = git_config_foreach_match(\n\t\tconfig, git_buf_cstr(&pattern), rename_config_entries_cb, &data);\n\ncleanup:\n\tgit_buf_free(&pattern);\n\tgit_buf_free(&replace);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_rename_section(\n\tgit_repository *repo,\n\tconst char *old_section_name,\n\tconst char *new_section_name)\n{\n\tgit_config *config;\n\tgit_buf pattern = GIT_BUF_INIT, replace = GIT_BUF_INIT;\n\tint error = 0;\n\tstruct rename_data data;\n\n\tgit_buf_text_puts_escape_regex(&pattern, old_section_name);\n\n\tif ((error = git_buf_puts(&pattern, \"\\\\..+\")) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\tgoto cleanup;\n\n\tdata.config  = config;\n\tdata.name    = &replace;\n\tdata.old_len = strlen(old_section_name) + 1;\n\n\tif ((error = git_buf_join(&replace, '.', new_section_name, \"\")) < 0)\n\t\tgoto cleanup;\n\n\tif (new_section_name != NULL &&\n\t\t(error = git_config_file_normalize_section(\n\t\t\treplace.ptr, strchr(replace.ptr, '.'))) < 0)\n\t{\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG, \"Invalid config section '%s'\", new_section_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = git_config_foreach_match(\n\t\tconfig, git_buf_cstr(&pattern), rename_config_entries_cb, &data);\n\ncleanup:\n\tgit_buf_free(&pattern);\n\tgit_buf_free(&replace);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&new_config_section"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_owner",
          "args": [
            "branch"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "315-319",
          "snippet": "git_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_join",
          "args": [
            "&new_config_section",
            "'.'",
            "\"branch\"",
            "new_branch_name"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "607-655",
          "snippet": "int git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "branch"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_rename",
          "args": [
            "out",
            "branch",
            "git_buf_cstr(&new_reference_name)",
            "force",
            "git_buf_cstr(&log_message)"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "598-615",
          "snippet": "int git_reference_rename(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *new_name,\n\tint force,\n\tconst char *log_message)\n{\n\tgit_signature *who;\n\tint error;\n\n\tif ((error = git_reference__log_signature(&who, ref->db->repo)) < 0)\n\t\treturn error;\n\n\terror = reference__rename(out, ref, new_name, force, who, log_message);\n\tgit_signature_free(who);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_rename(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *new_name,\n\tint force,\n\tconst char *log_message)\n{\n\tgit_signature *who;\n\tint error;\n\n\tif ((error = git_reference__log_signature(&who, ref->db->repo)) < 0)\n\t\treturn error;\n\n\terror = reference__rename(out, ref, new_name, force, who, log_message);\n\tgit_signature_free(who);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&log_message",
            "\"branch: renamed %s to %s\"",
            "git_reference_name(branch)",
            "git_buf_cstr(&new_reference_name)"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&new_reference_name",
            "GIT_REFS_HEADS_DIR",
            "new_branch_name"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "not_a_local_branch",
          "args": [
            "git_reference_name(branch)"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "not_a_local_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "45-51",
          "snippet": "static int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_branch",
          "args": [
            "branch"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1177-1181",
          "snippet": "int git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "branch && new_branch_name"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_move(\n\tgit_reference **out,\n\tgit_reference *branch,\n\tconst char *new_branch_name,\n\tint force)\n{\n\tgit_buf new_reference_name = GIT_BUF_INIT,\n\t        old_config_section = GIT_BUF_INIT,\n\t        new_config_section = GIT_BUF_INIT,\n\t        log_message = GIT_BUF_INIT;\n\tint error;\n\n\tassert(branch && new_branch_name);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn not_a_local_branch(git_reference_name(branch));\n\n\tif ((error = git_buf_joinpath(&new_reference_name, GIT_REFS_HEADS_DIR, new_branch_name)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_buf_printf(&log_message, \"branch: renamed %s to %s\",\n\t\t\t\t    git_reference_name(branch), git_buf_cstr(&new_reference_name))) < 0)\n\t\t\tgoto done;\n\n\t/* first update ref then config so failure won't trash config */\n\n\terror = git_reference_rename(\n\t\tout, branch, git_buf_cstr(&new_reference_name), force,\n\t\tgit_buf_cstr(&log_message));\n\tif (error < 0)\n\t\tgoto done;\n\n\tgit_buf_join(&old_config_section, '.', \"branch\",\n\t\tgit_reference_name(branch) + strlen(GIT_REFS_HEADS_DIR));\n\tgit_buf_join(&new_config_section, '.', \"branch\", new_branch_name);\n\n\terror = git_config_rename_section(\n\t\tgit_reference_owner(branch),\n\t\tgit_buf_cstr(&old_config_section),\n\t\tgit_buf_cstr(&new_config_section));\n\ndone:\n\tgit_buf_free(&new_reference_name);\n\tgit_buf_free(&old_config_section);\n\tgit_buf_free(&new_config_section);\n\tgit_buf_free(&log_message);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_branch_iterator_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "219-228",
    "snippet": "void git_branch_iterator_free(git_branch_iterator *_iter)\n{\n\tbranch_iter *iter = (branch_iter *) _iter;\n\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_reference_iterator_free(iter->iter);\n\tgit__free(iter);\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "iter"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_iterator_free",
          "args": [
            "iter->iter"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "742-748",
          "snippet": "void git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_branch_iterator_free(git_branch_iterator *_iter)\n{\n\tbranch_iter *iter = (branch_iter *) _iter;\n\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_reference_iterator_free(iter->iter);\n\tgit__free(iter);\n}"
  },
  {
    "function_name": "git_branch_iterator_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "197-217",
    "snippet": "int git_branch_iterator_new(\n\tgit_branch_iterator **out,\n\tgit_repository *repo,\n\tgit_branch_t list_flags)\n{\n\tbranch_iter *iter;\n\n\titer = git__calloc(1, sizeof(branch_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\titer->flags = list_flags;\n\n\tif (git_reference_iterator_new(&iter->iter, repo) < 0) {\n\t\tgit__free(iter);\n\t\treturn -1;\n\t}\n\n\t*out = (git_branch_iterator *) iter;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "iter"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_iterator_new",
          "args": [
            "&iter->iter",
            "repo"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "711-719",
          "snippet": "int git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "iter"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(branch_iter)"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_iterator_new(\n\tgit_branch_iterator **out,\n\tgit_repository *repo,\n\tgit_branch_t list_flags)\n{\n\tbranch_iter *iter;\n\n\titer = git__calloc(1, sizeof(branch_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\titer->flags = list_flags;\n\n\tif (git_reference_iterator_new(&iter->iter, repo) < 0) {\n\t\tgit__free(iter);\n\t\treturn -1;\n\t}\n\n\t*out = (git_branch_iterator *) iter;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_branch_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "170-195",
    "snippet": "int git_branch_next(git_reference **out, git_branch_t *out_type, git_branch_iterator *_iter)\n{\n\tbranch_iter *iter = (branch_iter *) _iter;\n\tgit_reference *ref;\n\tint error;\n\n\twhile ((error = git_reference_next(&ref, iter->iter)) == 0) {\n\t\tif ((iter->flags & GIT_BRANCH_LOCAL) &&\n\t\t    !git__prefixcmp(ref->name, GIT_REFS_HEADS_DIR)) {\n\t\t\t*out = ref;\n\t\t\t*out_type = GIT_BRANCH_LOCAL;\n\n\t\t\treturn 0;\n\t\t} else  if ((iter->flags & GIT_BRANCH_REMOTE) &&\n\t\t\t    !git__prefixcmp(ref->name, GIT_REFS_REMOTES_DIR)) {\n\t\t\t*out = ref;\n\t\t\t*out_type = GIT_BRANCH_REMOTE;\n\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tgit_reference_free(ref);\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ref->name",
            "GIT_REFS_REMOTES_DIR"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_next",
          "args": [
            "&ref",
            "iter->iter"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_next_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "737-740",
          "snippet": "int git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_next(git_reference **out, git_branch_t *out_type, git_branch_iterator *_iter)\n{\n\tbranch_iter *iter = (branch_iter *) _iter;\n\tgit_reference *ref;\n\tint error;\n\n\twhile ((error = git_reference_next(&ref, iter->iter)) == 0) {\n\t\tif ((iter->flags & GIT_BRANCH_LOCAL) &&\n\t\t    !git__prefixcmp(ref->name, GIT_REFS_HEADS_DIR)) {\n\t\t\t*out = ref;\n\t\t\t*out_type = GIT_BRANCH_LOCAL;\n\n\t\t\treturn 0;\n\t\t} else  if ((iter->flags & GIT_BRANCH_REMOTE) &&\n\t\t\t    !git__prefixcmp(ref->name, GIT_REFS_REMOTES_DIR)) {\n\t\t\t*out = ref;\n\t\t\t*out_type = GIT_BRANCH_REMOTE;\n\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tgit_reference_free(ref);\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_branch_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "127-163",
    "snippet": "int git_branch_delete(git_reference *branch)\n{\n\tint is_head;\n\tgit_buf config_section = GIT_BUF_INIT;\n\tint error = -1;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch) && !git_reference_is_remote(branch)) {\n\t\tgiterr_set(GITERR_INVALID, \"Reference '%s' is not a valid branch.\",\n\t\t\tgit_reference_name(branch));\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((is_head = git_branch_is_head(branch)) < 0)\n\t\treturn is_head;\n\n\tif (is_head) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Cannot delete branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\", git_reference_name(branch));\n\t\treturn -1;\n\t}\n\n\tif (git_buf_join(&config_section, '.', \"branch\",\n\t\t\tgit_reference_name(branch) + strlen(GIT_REFS_HEADS_DIR)) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_rename_section(\n\t\tgit_reference_owner(branch), git_buf_cstr(&config_section), NULL) < 0)\n\t\tgoto on_error;\n\n\terror = git_reference_delete(branch);\n\non_error:\n\tgit_buf_free(&config_section);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&config_section"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_delete",
          "args": [
            "branch"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "122-133",
          "snippet": "int git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_rename_section",
          "args": [
            "git_reference_owner(branch)",
            "git_buf_cstr(&config_section)",
            "NULL"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_rename_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1434-1476",
          "snippet": "int git_config_rename_section(\n\tgit_repository *repo,\n\tconst char *old_section_name,\n\tconst char *new_section_name)\n{\n\tgit_config *config;\n\tgit_buf pattern = GIT_BUF_INIT, replace = GIT_BUF_INIT;\n\tint error = 0;\n\tstruct rename_data data;\n\n\tgit_buf_text_puts_escape_regex(&pattern, old_section_name);\n\n\tif ((error = git_buf_puts(&pattern, \"\\\\..+\")) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\tgoto cleanup;\n\n\tdata.config  = config;\n\tdata.name    = &replace;\n\tdata.old_len = strlen(old_section_name) + 1;\n\n\tif ((error = git_buf_join(&replace, '.', new_section_name, \"\")) < 0)\n\t\tgoto cleanup;\n\n\tif (new_section_name != NULL &&\n\t\t(error = git_config_file_normalize_section(\n\t\t\treplace.ptr, strchr(replace.ptr, '.'))) < 0)\n\t{\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG, \"Invalid config section '%s'\", new_section_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = git_config_foreach_match(\n\t\tconfig, git_buf_cstr(&pattern), rename_config_entries_cb, &data);\n\ncleanup:\n\tgit_buf_free(&pattern);\n\tgit_buf_free(&replace);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_rename_section(\n\tgit_repository *repo,\n\tconst char *old_section_name,\n\tconst char *new_section_name)\n{\n\tgit_config *config;\n\tgit_buf pattern = GIT_BUF_INIT, replace = GIT_BUF_INIT;\n\tint error = 0;\n\tstruct rename_data data;\n\n\tgit_buf_text_puts_escape_regex(&pattern, old_section_name);\n\n\tif ((error = git_buf_puts(&pattern, \"\\\\..+\")) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\tgoto cleanup;\n\n\tdata.config  = config;\n\tdata.name    = &replace;\n\tdata.old_len = strlen(old_section_name) + 1;\n\n\tif ((error = git_buf_join(&replace, '.', new_section_name, \"\")) < 0)\n\t\tgoto cleanup;\n\n\tif (new_section_name != NULL &&\n\t\t(error = git_config_file_normalize_section(\n\t\t\treplace.ptr, strchr(replace.ptr, '.'))) < 0)\n\t{\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG, \"Invalid config section '%s'\", new_section_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = git_config_foreach_match(\n\t\tconfig, git_buf_cstr(&pattern), rename_config_entries_cb, &data);\n\ncleanup:\n\tgit_buf_free(&pattern);\n\tgit_buf_free(&replace);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&config_section"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_owner",
          "args": [
            "branch"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "315-319",
          "snippet": "git_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_join",
          "args": [
            "&config_section",
            "'.'",
            "\"branch\"",
            "git_reference_name(branch) + strlen(GIT_REFS_HEADS_DIR)"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "607-655",
          "snippet": "int git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "branch"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Cannot delete branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\"",
            "git_reference_name(branch)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_is_head",
          "args": [
            "branch"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_is_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "631-658",
          "snippet": "int git_branch_is_head(\n\t\tconst git_reference *branch)\n{\n\tgit_reference *head;\n\tbool is_same = false;\n\tint error;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn false;\n\n\terror = git_repository_head(&head, git_reference_owner(branch));\n\n\tif (error == GIT_EUNBORNBRANCH || error == GIT_ENOTFOUND)\n\t\treturn false;\n\n\tif (error < 0)\n\t\treturn -1;\n\n\tis_same = strcmp(\n\t\tgit_reference_name(branch),\n\t\tgit_reference_name(head)) == 0;\n\n\tgit_reference_free(head);\n\n\treturn is_same;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_is_head(\n\t\tconst git_reference *branch)\n{\n\tgit_reference *head;\n\tbool is_same = false;\n\tint error;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn false;\n\n\terror = git_repository_head(&head, git_reference_owner(branch));\n\n\tif (error == GIT_EUNBORNBRANCH || error == GIT_ENOTFOUND)\n\t\treturn false;\n\n\tif (error < 0)\n\t\treturn -1;\n\n\tis_same = strcmp(\n\t\tgit_reference_name(branch),\n\t\tgit_reference_name(head)) == 0;\n\n\tgit_reference_free(head);\n\n\treturn is_same;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_remote",
          "args": [
            "branch"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1188-1192",
          "snippet": "int git_reference_is_remote(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_remote(ref->name);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_remote(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_remote(ref->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_branch",
          "args": [
            "branch"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1177-1181",
          "snippet": "int git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "branch"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_delete(git_reference *branch)\n{\n\tint is_head;\n\tgit_buf config_section = GIT_BUF_INIT;\n\tint error = -1;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch) && !git_reference_is_remote(branch)) {\n\t\tgiterr_set(GITERR_INVALID, \"Reference '%s' is not a valid branch.\",\n\t\t\tgit_reference_name(branch));\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((is_head = git_branch_is_head(branch)) < 0)\n\t\treturn is_head;\n\n\tif (is_head) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Cannot delete branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\", git_reference_name(branch));\n\t\treturn -1;\n\t}\n\n\tif (git_buf_join(&config_section, '.', \"branch\",\n\t\t\tgit_reference_name(branch) + strlen(GIT_REFS_HEADS_DIR)) < 0)\n\t\tgoto on_error;\n\n\tif (git_config_rename_section(\n\t\tgit_reference_owner(branch), git_buf_cstr(&config_section), NULL) < 0)\n\t\tgoto on_error;\n\n\terror = git_reference_delete(branch);\n\non_error:\n\tgit_buf_free(&config_section);\n\treturn error;\n}"
  },
  {
    "function_name": "git_branch_create_from_annotated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "117-125",
    "snippet": "int git_branch_create_from_annotated(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_annotated_commit *commit,\n\tint force)\n{\n\treturn create_branch(ref_out, repository, branch_name, commit->commit, commit->ref_name, force);\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "ref_out",
            "repository",
            "branch_name",
            "commit->commit",
            "commit->ref_name",
            "force"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "create_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "53-105",
          "snippet": "static int create_branch(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_commit *commit,\n\tconst char *from,\n\tint force)\n{\n\tint is_head = 0;\n\tgit_reference *branch = NULL;\n\tgit_buf canonical_branch_name = GIT_BUF_INIT,\n\t\t\t  log_message = GIT_BUF_INIT;\n\tint error = -1;\n\n\tassert(branch_name && commit && ref_out);\n\tassert(git_object_owner((const git_object *)commit) == repository);\n\n\tif (force && git_branch_lookup(&branch, repository, branch_name, GIT_BRANCH_LOCAL) == 0) {\n\t\terror = git_branch_is_head(branch);\n\t\tgit_reference_free(branch);\n\t\tbranch = NULL;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tis_head = error;\n\t}\n\n\tif (is_head && force) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Cannot force update branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\", branch_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_buf_joinpath(&canonical_branch_name, GIT_REFS_HEADS_DIR, branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&log_message, \"branch: Created from %s\", from) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_create(&branch, repository,\n\t\tgit_buf_cstr(&canonical_branch_name), git_commit_id(commit), force,\n\t\tgit_buf_cstr(&log_message));\n\n\tif (!error)\n\t\t*ref_out = branch;\n\ncleanup:\n\tgit_buf_free(&canonical_branch_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int create_branch(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_commit *commit,\n\tconst char *from,\n\tint force)\n{\n\tint is_head = 0;\n\tgit_reference *branch = NULL;\n\tgit_buf canonical_branch_name = GIT_BUF_INIT,\n\t\t\t  log_message = GIT_BUF_INIT;\n\tint error = -1;\n\n\tassert(branch_name && commit && ref_out);\n\tassert(git_object_owner((const git_object *)commit) == repository);\n\n\tif (force && git_branch_lookup(&branch, repository, branch_name, GIT_BRANCH_LOCAL) == 0) {\n\t\terror = git_branch_is_head(branch);\n\t\tgit_reference_free(branch);\n\t\tbranch = NULL;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tis_head = error;\n\t}\n\n\tif (is_head && force) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Cannot force update branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\", branch_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_buf_joinpath(&canonical_branch_name, GIT_REFS_HEADS_DIR, branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&log_message, \"branch: Created from %s\", from) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_create(&branch, repository,\n\t\tgit_buf_cstr(&canonical_branch_name), git_commit_id(commit), force,\n\t\tgit_buf_cstr(&log_message));\n\n\tif (!error)\n\t\t*ref_out = branch;\n\ncleanup:\n\tgit_buf_free(&canonical_branch_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_create_from_annotated(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_annotated_commit *commit,\n\tint force)\n{\n\treturn create_branch(ref_out, repository, branch_name, commit->commit, commit->ref_name, force);\n}"
  },
  {
    "function_name": "git_branch_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "107-115",
    "snippet": "int git_branch_create(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_commit *commit,\n\tint force)\n{\n\treturn create_branch(ref_out, repository, branch_name, commit, git_oid_tostr_s(git_commit_id(commit)), force);\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "ref_out",
            "repository",
            "branch_name",
            "commit",
            "git_oid_tostr_s(git_commit_id(commit))",
            "force"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "create_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "53-105",
          "snippet": "static int create_branch(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_commit *commit,\n\tconst char *from,\n\tint force)\n{\n\tint is_head = 0;\n\tgit_reference *branch = NULL;\n\tgit_buf canonical_branch_name = GIT_BUF_INIT,\n\t\t\t  log_message = GIT_BUF_INIT;\n\tint error = -1;\n\n\tassert(branch_name && commit && ref_out);\n\tassert(git_object_owner((const git_object *)commit) == repository);\n\n\tif (force && git_branch_lookup(&branch, repository, branch_name, GIT_BRANCH_LOCAL) == 0) {\n\t\terror = git_branch_is_head(branch);\n\t\tgit_reference_free(branch);\n\t\tbranch = NULL;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tis_head = error;\n\t}\n\n\tif (is_head && force) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Cannot force update branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\", branch_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_buf_joinpath(&canonical_branch_name, GIT_REFS_HEADS_DIR, branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&log_message, \"branch: Created from %s\", from) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_create(&branch, repository,\n\t\tgit_buf_cstr(&canonical_branch_name), git_commit_id(commit), force,\n\t\tgit_buf_cstr(&log_message));\n\n\tif (!error)\n\t\t*ref_out = branch;\n\ncleanup:\n\tgit_buf_free(&canonical_branch_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int create_branch(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_commit *commit,\n\tconst char *from,\n\tint force)\n{\n\tint is_head = 0;\n\tgit_reference *branch = NULL;\n\tgit_buf canonical_branch_name = GIT_BUF_INIT,\n\t\t\t  log_message = GIT_BUF_INIT;\n\tint error = -1;\n\n\tassert(branch_name && commit && ref_out);\n\tassert(git_object_owner((const git_object *)commit) == repository);\n\n\tif (force && git_branch_lookup(&branch, repository, branch_name, GIT_BRANCH_LOCAL) == 0) {\n\t\terror = git_branch_is_head(branch);\n\t\tgit_reference_free(branch);\n\t\tbranch = NULL;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tis_head = error;\n\t}\n\n\tif (is_head && force) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Cannot force update branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\", branch_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_buf_joinpath(&canonical_branch_name, GIT_REFS_HEADS_DIR, branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&log_message, \"branch: Created from %s\", from) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_create(&branch, repository,\n\t\tgit_buf_cstr(&canonical_branch_name), git_commit_id(commit), force,\n\t\tgit_buf_cstr(&log_message));\n\n\tif (!error)\n\t\t*ref_out = branch;\n\ncleanup:\n\tgit_buf_free(&canonical_branch_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_tostr_s",
          "args": [
            "git_commit_id(commit)"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_tostr_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "103-108",
          "snippet": "char *git_oid_tostr_s(const git_oid *oid)\n{\n\tchar *str = GIT_GLOBAL->oid_fmt;\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ + 1, oid);\n\treturn str;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nchar *git_oid_tostr_s(const git_oid *oid)\n{\n\tchar *str = GIT_GLOBAL->oid_fmt;\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ + 1, oid);\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_create(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_commit *commit,\n\tint force)\n{\n\treturn create_branch(ref_out, repository, branch_name, commit, git_oid_tostr_s(git_commit_id(commit)), force);\n}"
  },
  {
    "function_name": "create_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "53-105",
    "snippet": "static int create_branch(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_commit *commit,\n\tconst char *from,\n\tint force)\n{\n\tint is_head = 0;\n\tgit_reference *branch = NULL;\n\tgit_buf canonical_branch_name = GIT_BUF_INIT,\n\t\t\t  log_message = GIT_BUF_INIT;\n\tint error = -1;\n\n\tassert(branch_name && commit && ref_out);\n\tassert(git_object_owner((const git_object *)commit) == repository);\n\n\tif (force && git_branch_lookup(&branch, repository, branch_name, GIT_BRANCH_LOCAL) == 0) {\n\t\terror = git_branch_is_head(branch);\n\t\tgit_reference_free(branch);\n\t\tbranch = NULL;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tis_head = error;\n\t}\n\n\tif (is_head && force) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Cannot force update branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\", branch_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_buf_joinpath(&canonical_branch_name, GIT_REFS_HEADS_DIR, branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&log_message, \"branch: Created from %s\", from) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_create(&branch, repository,\n\t\tgit_buf_cstr(&canonical_branch_name), git_commit_id(commit), force,\n\t\tgit_buf_cstr(&log_message));\n\n\tif (!error)\n\t\t*ref_out = branch;\n\ncleanup:\n\tgit_buf_free(&canonical_branch_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&log_message"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_create",
          "args": [
            "&branch",
            "repository",
            "git_buf_cstr(&canonical_branch_name)",
            "git_commit_id(commit)",
            "force",
            "git_buf_cstr(&log_message)"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "464-473",
          "snippet": "int git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&log_message"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&log_message",
            "\"branch: Created from %s\"",
            "from"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&canonical_branch_name",
            "GIT_REFS_HEADS_DIR",
            "branch_name"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Cannot force update branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\"",
            "branch_name"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "branch"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_is_head",
          "args": [
            "branch"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_is_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "631-658",
          "snippet": "int git_branch_is_head(\n\t\tconst git_reference *branch)\n{\n\tgit_reference *head;\n\tbool is_same = false;\n\tint error;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn false;\n\n\terror = git_repository_head(&head, git_reference_owner(branch));\n\n\tif (error == GIT_EUNBORNBRANCH || error == GIT_ENOTFOUND)\n\t\treturn false;\n\n\tif (error < 0)\n\t\treturn -1;\n\n\tis_same = strcmp(\n\t\tgit_reference_name(branch),\n\t\tgit_reference_name(head)) == 0;\n\n\tgit_reference_free(head);\n\n\treturn is_same;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_is_head(\n\t\tconst git_reference *branch)\n{\n\tgit_reference *head;\n\tbool is_same = false;\n\tint error;\n\n\tassert(branch);\n\n\tif (!git_reference_is_branch(branch))\n\t\treturn false;\n\n\terror = git_repository_head(&head, git_reference_owner(branch));\n\n\tif (error == GIT_EUNBORNBRANCH || error == GIT_ENOTFOUND)\n\t\treturn false;\n\n\tif (error < 0)\n\t\treturn -1;\n\n\tis_same = strcmp(\n\t\tgit_reference_name(branch),\n\t\tgit_reference_name(head)) == 0;\n\n\tgit_reference_free(head);\n\n\treturn is_same;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_lookup",
          "args": [
            "&branch",
            "repository",
            "branch_name",
            "GIT_BRANCH_LOCAL"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "280-289",
          "snippet": "int git_branch_lookup(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tgit_branch_t branch_type)\n{\n\tassert(ref_out && repo && branch_name);\n\n\treturn retrieve_branch_reference(ref_out, repo, branch_name, branch_type == GIT_BRANCH_REMOTE);\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_lookup(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tgit_branch_t branch_type)\n{\n\tassert(ref_out && repo && branch_name);\n\n\treturn retrieve_branch_reference(ref_out, repo, branch_name, branch_type == GIT_BRANCH_REMOTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_object_owner((const git_object *)commit) == repository"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "(const git_object *)commit"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "branch_name && commit && ref_out"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int create_branch(\n\tgit_reference **ref_out,\n\tgit_repository *repository,\n\tconst char *branch_name,\n\tconst git_commit *commit,\n\tconst char *from,\n\tint force)\n{\n\tint is_head = 0;\n\tgit_reference *branch = NULL;\n\tgit_buf canonical_branch_name = GIT_BUF_INIT,\n\t\t\t  log_message = GIT_BUF_INIT;\n\tint error = -1;\n\n\tassert(branch_name && commit && ref_out);\n\tassert(git_object_owner((const git_object *)commit) == repository);\n\n\tif (force && git_branch_lookup(&branch, repository, branch_name, GIT_BRANCH_LOCAL) == 0) {\n\t\terror = git_branch_is_head(branch);\n\t\tgit_reference_free(branch);\n\t\tbranch = NULL;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tis_head = error;\n\t}\n\n\tif (is_head && force) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Cannot force update branch '%s' as it is \"\n\t\t\t\"the current HEAD of the repository.\", branch_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_buf_joinpath(&canonical_branch_name, GIT_REFS_HEADS_DIR, branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&log_message, \"branch: Created from %s\", from) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_create(&branch, repository,\n\t\tgit_buf_cstr(&canonical_branch_name), git_commit_id(commit), force,\n\t\tgit_buf_cstr(&log_message));\n\n\tif (!error)\n\t\t*ref_out = branch;\n\ncleanup:\n\tgit_buf_free(&canonical_branch_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}"
  },
  {
    "function_name": "not_a_local_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "45-51",
    "snippet": "static int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Reference '%s' is not a local branch.\"",
            "reference_name"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int not_a_local_branch(const char *reference_name)\n{\n\tgiterr_set(\n\t\tGITERR_INVALID,\n\t\t\"Reference '%s' is not a local branch.\", reference_name);\n\treturn -1;\n}"
  },
  {
    "function_name": "retrieve_branch_reference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
    "lines": "19-43",
    "snippet": "static int retrieve_branch_reference(\n\tgit_reference **branch_reference_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tint is_remote)\n{\n\tgit_reference *branch = NULL;\n\tint error = 0;\n\tchar *prefix;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tprefix = is_remote ? GIT_REFS_REMOTES_DIR : GIT_REFS_HEADS_DIR;\n\n\tif ((error = git_buf_joinpath(&ref_name, prefix, branch_name)) < 0)\n\t\t/* OOM */;\n\telse if ((error = git_reference_lookup(&branch, repo, ref_name.ptr)) < 0)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE, \"Cannot locate %s branch '%s'\",\n\t\t\tis_remote ? \"remote-tracking\" : \"local\", branch_name);\n\n\t*branch_reference_out = branch; /* will be NULL on error */\n\n\tgit_buf_free(&ref_name);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/branch.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"remote.h\"",
      "#include \"refs.h\"",
      "#include \"refspec.h\"",
      "#include \"config.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ref_name"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Cannot locate %s branch '%s'\"",
            "is_remote ? \"remote-tracking\" : \"local\"",
            "branch_name"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&branch",
            "repo",
            "ref_name.ptr"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&ref_name",
            "prefix",
            "branch_name"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_branch_reference(\n\tgit_reference **branch_reference_out,\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tint is_remote)\n{\n\tgit_reference *branch = NULL;\n\tint error = 0;\n\tchar *prefix;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tprefix = is_remote ? GIT_REFS_REMOTES_DIR : GIT_REFS_HEADS_DIR;\n\n\tif ((error = git_buf_joinpath(&ref_name, prefix, branch_name)) < 0)\n\t\t/* OOM */;\n\telse if ((error = git_reference_lookup(&branch, repo, ref_name.ptr)) < 0)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE, \"Cannot locate %s branch '%s'\",\n\t\t\tis_remote ? \"remote-tracking\" : \"local\", branch_name);\n\n\t*branch_reference_out = branch; /* will be NULL on error */\n\n\tgit_buf_free(&ref_name);\n\treturn error;\n}"
  }
]