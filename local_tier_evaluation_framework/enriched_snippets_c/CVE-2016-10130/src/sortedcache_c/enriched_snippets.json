[
  {
    "function_name": "git_sortedcache_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "357-380",
    "snippet": "int git_sortedcache_remove(git_sortedcache *sc, size_t pos)\n{\n\tchar *item;\n\tkhiter_t mappos;\n\n\t/* because of pool allocation, this can't actually remove the item,\n\t * but we can remove it from the items vector and the hash table.\n\t */\n\n\tif ((item = git_vector_get(&sc->items, pos)) == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Removing item out of range\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t(void)git_vector_remove(&sc->items, pos);\n\n\tmappos = git_strmap_lookup_index(sc->map, item + sc->item_path_offset);\n\tgit_strmap_delete_at(sc->map, mappos);\n\n\tif (sc->free_item)\n\t\tsc->free_item(sc->free_item_payload, item);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->free_item",
          "args": [
            "sc->free_item_payload",
            "item"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_delete_at",
          "args": [
            "sc->map",
            "mappos"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "sc->map",
            "item + sc->item_path_offset"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_remove",
          "args": [
            "&sc->items",
            "pos"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "233-250",
          "snippet": "int git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Removing item out of range\""
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&sc->items",
            "pos"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_remove(git_sortedcache *sc, size_t pos)\n{\n\tchar *item;\n\tkhiter_t mappos;\n\n\t/* because of pool allocation, this can't actually remove the item,\n\t * but we can remove it from the items vector and the hash table.\n\t */\n\n\tif ((item = git_vector_get(&sc->items, pos)) == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Removing item out of range\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t(void)git_vector_remove(&sc->items, pos);\n\n\tmappos = git_strmap_lookup_index(sc->map, item + sc->item_path_offset);\n\tgit_strmap_delete_at(sc->map, mappos);\n\n\tif (sc->free_item)\n\t\tsc->free_item(sc->free_item_payload, item);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_sortedcache_lookup_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "345-354",
    "snippet": "int git_sortedcache_lookup_index(\n\tsize_t *out, git_sortedcache *sc, const char *key)\n{\n\tstruct sortedcache_magic_key magic;\n\n\tmagic.offset = sc->item_path_offset;\n\tmagic.key    = key;\n\n\treturn git_vector_bsearch2(out, &sc->items, sortedcache_magic_cmp, &magic);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_bsearch2",
          "args": [
            "out",
            "&sc->items",
            "sortedcache_magic_cmp",
            "&magic"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "187-202",
          "snippet": "int git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_lookup_index(\n\tsize_t *out, git_sortedcache *sc, const char *key)\n{\n\tstruct sortedcache_magic_key magic;\n\n\tmagic.offset = sc->item_path_offset;\n\tmagic.key    = key;\n\n\treturn git_vector_bsearch2(out, &sc->items, sortedcache_magic_cmp, &magic);\n}"
  },
  {
    "function_name": "sortedcache_magic_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "337-342",
    "snippet": "static int sortedcache_magic_cmp(const void *key, const void *value)\n{\n\tconst struct sortedcache_magic_key *magic = key;\n\tconst char *value_key = ((const char *)value) + magic->offset;\n\treturn strcmp(magic->key, value_key);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "magic->key",
            "value_key"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nstatic int sortedcache_magic_cmp(const void *key, const void *value)\n{\n\tconst struct sortedcache_magic_key *magic = key;\n\tconst char *value_key = ((const char *)value) + magic->offset;\n\treturn strcmp(magic->key, value_key);\n}"
  },
  {
    "function_name": "git_sortedcache_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "322-329",
    "snippet": "void *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&sc->items",
            "pos"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&sc->items"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_is_sorted",
          "args": [
            "&sc->items"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}"
  },
  {
    "function_name": "git_sortedcache_entrycount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "316-319",
    "snippet": "size_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_length",
          "args": [
            "&sc->items"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "67-70",
          "snippet": "GIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nsize_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}"
  },
  {
    "function_name": "git_sortedcache_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "307-313",
    "snippet": "void *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)\n{\n\tkhiter_t pos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos))\n\t\treturn git_strmap_value_at(sc->map, pos);\n\treturn NULL;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "sc->map",
            "pos"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "sc->map",
            "pos"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "sc->map",
            "key"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)\n{\n\tkhiter_t pos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos))\n\t\treturn git_strmap_value_at(sc->map, pos);\n\treturn NULL;\n}"
  },
  {
    "function_name": "git_sortedcache_upsert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "257-304",
    "snippet": "int git_sortedcache_upsert(void **out, git_sortedcache *sc, const char *key)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tvoid *item;\n\tsize_t keylen, itemlen;\n\tchar *item_key;\n\n\tpos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos)) {\n\t\titem = git_strmap_value_at(sc->map, pos);\n\t\tgoto done;\n\t}\n\n\tkeylen  = strlen(key);\n\titemlen = sc->item_path_offset + keylen + 1;\n\titemlen = (itemlen + 7) & ~7;\n\n\tif ((item = git_pool_mallocz(&sc->pool, (uint32_t)itemlen)) == NULL) {\n\t\t/* don't use GITERR_CHECK_ALLOC b/c of lock */\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t/* one strange thing is that even if the vector or hash table insert\n\t * fail, there is no way to free the pool item so we just abandon it\n\t */\n\n\titem_key = ((char *)item) + sc->item_path_offset;\n\tmemcpy(item_key, key, keylen);\n\n\tpos = kh_put(str, sc->map, item_key, &error);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (!error)\n\t\tkh_key(sc->map, pos) = item_key;\n\tkh_val(sc->map, pos) = item;\n\n\terror = git_vector_insert(&sc->items, item);\n\tif (error < 0)\n\t\tgit_strmap_delete_at(sc->map, pos);\n\ndone:\n\tif (out)\n\t\t*out = !error ? item : NULL;\n\treturn error;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_delete_at",
          "args": [
            "sc->map",
            "pos"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&sc->items",
            "item"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_val",
          "args": [
            "sc->map",
            "pos"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_key",
          "args": [
            "sc->map",
            "pos"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_put",
          "args": [
            "str",
            "sc->map",
            "item_key",
            "&error"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "item_key",
            "key",
            "keylen"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_mallocz",
          "args": [
            "&sc->pool",
            "(uint32_t)itemlen"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "sc->map",
            "pos"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "sc->map",
            "pos"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "sc->map",
            "key"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_upsert(void **out, git_sortedcache *sc, const char *key)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tvoid *item;\n\tsize_t keylen, itemlen;\n\tchar *item_key;\n\n\tpos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos)) {\n\t\titem = git_strmap_value_at(sc->map, pos);\n\t\tgoto done;\n\t}\n\n\tkeylen  = strlen(key);\n\titemlen = sc->item_path_offset + keylen + 1;\n\titemlen = (itemlen + 7) & ~7;\n\n\tif ((item = git_pool_mallocz(&sc->pool, (uint32_t)itemlen)) == NULL) {\n\t\t/* don't use GITERR_CHECK_ALLOC b/c of lock */\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t/* one strange thing is that even if the vector or hash table insert\n\t * fail, there is no way to free the pool item so we just abandon it\n\t */\n\n\titem_key = ((char *)item) + sc->item_path_offset;\n\tmemcpy(item_key, key, keylen);\n\n\tpos = kh_put(str, sc->map, item_key, &error);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (!error)\n\t\tkh_key(sc->map, pos) = item_key;\n\tkh_val(sc->map, pos) = item;\n\n\terror = git_vector_insert(&sc->items, item);\n\tif (error < 0)\n\t\tgit_strmap_delete_at(sc->map, pos);\n\ndone:\n\tif (out)\n\t\t*out = !error ? item : NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "git_sortedcache_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "243-254",
    "snippet": "int git_sortedcache_clear(git_sortedcache *sc, bool wlock)\n{\n\tif (wlock && git_sortedcache_wlock(sc) < 0)\n\t\treturn -1;\n\n\tsortedcache_clear(sc);\n\n\tif (wlock)\n\t\tgit_sortedcache_wunlock(sc);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_sortedcache_wunlock",
          "args": [
            "sc"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "172-176",
          "snippet": "void git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sortedcache_clear",
          "args": [
            "sc"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "sortedcache_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "62-78",
          "snippet": "static void sortedcache_clear(git_sortedcache *sc)\n{\n\tgit_strmap_clear(sc->map);\n\n\tif (sc->free_item) {\n\t\tsize_t i;\n\t\tvoid *item;\n\n\t\tgit_vector_foreach(&sc->items, i, item) {\n\t\t\tsc->free_item(sc->free_item_payload, item);\n\t\t}\n\t}\n\n\tgit_vector_clear(&sc->items);\n\n\tgit_pool_clear(&sc->pool);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nstatic void sortedcache_clear(git_sortedcache *sc)\n{\n\tgit_strmap_clear(sc->map);\n\n\tif (sc->free_item) {\n\t\tsize_t i;\n\t\tvoid *item;\n\n\t\tgit_vector_foreach(&sc->items, i, item) {\n\t\t\tsc->free_item(sc->free_item_payload, item);\n\t\t}\n\t}\n\n\tgit_vector_clear(&sc->items);\n\n\tgit_pool_clear(&sc->pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wlock",
          "args": [
            "sc"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "160-169",
          "snippet": "int git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_clear(git_sortedcache *sc, bool wlock)\n{\n\tif (wlock && git_sortedcache_wlock(sc) < 0)\n\t\treturn -1;\n\n\tsortedcache_clear(sc);\n\n\tif (wlock)\n\t\tgit_sortedcache_wunlock(sc);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_sortedcache_updated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "236-240",
    "snippet": "void git_sortedcache_updated(git_sortedcache *sc)\n{\n\t/* update filestamp to latest value */\n\tgit_futils_filestamp_check(&sc->stamp, sc->path);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_filestamp_check",
          "args": [
            "&sc->stamp",
            "sc->path"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filestamp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "1033-1061",
          "snippet": "int git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_updated(git_sortedcache *sc)\n{\n\t/* update filestamp to latest value */\n\tgit_futils_filestamp_check(&sc->stamp, sc->path);\n}"
  },
  {
    "function_name": "git_sortedcache_lockandload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "200-234",
    "snippet": "int git_sortedcache_lockandload(git_sortedcache *sc, git_buf *buf)\n{\n\tint error, fd;\n\n\tif ((error = git_sortedcache_wlock(sc)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(&sc->stamp, sc->path)) <= 0)\n\t\tgoto unlock;\n\n\tif (!git__is_sizet(sc->stamp.size)) {\n\t\tgiterr_set(GITERR_INVALID, \"Unable to load file larger than size_t\");\n\t\terror = -1;\n\t\tgoto unlock;\n\t}\n\n\tif ((fd = git_futils_open_ro(sc->path)) < 0) {\n\t\terror = fd;\n\t\tgoto unlock;\n\t}\n\n\tif (buf)\n\t\terror = git_futils_readbuffer_fd(buf, fd, (size_t)sc->stamp.size);\n\n\t(void)p_close(fd);\n\n\tif (error < 0)\n\t\tgoto unlock;\n\n\treturn 1; /* return 1 -> file needs reload and was successfully loaded */\n\nunlock:\n\tgit_sortedcache_wunlock(sc);\n\treturn error;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_sortedcache_wunlock",
          "args": [
            "sc"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "172-176",
          "snippet": "void git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer_fd",
          "args": [
            "buf",
            "fd",
            "(size_t)sc->stamp.size"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "124-153",
          "snippet": "int git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "sc->path"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Unable to load file larger than size_t\""
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__is_sizet",
          "args": [
            "sc->stamp.size"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_sizet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "11-15",
          "snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_filestamp_check",
          "args": [
            "&sc->stamp",
            "sc->path"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filestamp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "1033-1061",
          "snippet": "int git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wlock",
          "args": [
            "sc"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "160-169",
          "snippet": "int git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_lockandload(git_sortedcache *sc, git_buf *buf)\n{\n\tint error, fd;\n\n\tif ((error = git_sortedcache_wlock(sc)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(&sc->stamp, sc->path)) <= 0)\n\t\tgoto unlock;\n\n\tif (!git__is_sizet(sc->stamp.size)) {\n\t\tgiterr_set(GITERR_INVALID, \"Unable to load file larger than size_t\");\n\t\terror = -1;\n\t\tgoto unlock;\n\t}\n\n\tif ((fd = git_futils_open_ro(sc->path)) < 0) {\n\t\terror = fd;\n\t\tgoto unlock;\n\t}\n\n\tif (buf)\n\t\terror = git_futils_readbuffer_fd(buf, fd, (size_t)sc->stamp.size);\n\n\t(void)p_close(fd);\n\n\tif (error < 0)\n\t\tgoto unlock;\n\n\treturn 1; /* return 1 -> file needs reload and was successfully loaded */\n\nunlock:\n\tgit_sortedcache_wunlock(sc);\n\treturn error;\n}"
  },
  {
    "function_name": "git_sortedcache_runlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "191-195",
    "snippet": "void git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_rwlock_rdunlock",
          "args": [
            "&sc->lock"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "git_rwlock_rdunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "203-211",
          "snippet": "int git_rwlock_rdunlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_release_shared)\n\t\twin32_srwlock_release_shared(&lock->native.srwl);\n\telse\n\t\tLeaveCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static win32_srwlock_fn win32_srwlock_release_shared;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_release_shared;\n\nint git_rwlock_rdunlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_release_shared)\n\t\twin32_srwlock_release_shared(&lock->native.srwl);\n\telse\n\t\tLeaveCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "sc"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}"
  },
  {
    "function_name": "git_sortedcache_rlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "179-188",
    "snippet": "int git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Unable to acquire read lock on cache\""
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_rwlock_rdlock",
          "args": [
            "&sc->lock"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "git_rwlock_rdlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "193-201",
          "snippet": "int git_rwlock_rdlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_acquire_shared)\n\t\twin32_srwlock_acquire_shared(&lock->native.srwl);\n\telse\n\t\tEnterCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static win32_srwlock_fn win32_srwlock_acquire_shared;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_acquire_shared;\n\nint git_rwlock_rdlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_acquire_shared)\n\t\twin32_srwlock_acquire_shared(&lock->native.srwl);\n\telse\n\t\tEnterCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "sc"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "git_sortedcache_wunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "172-176",
    "snippet": "void git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_rwlock_wrunlock",
          "args": [
            "&sc->lock"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "git_rwlock_wrunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "223-231",
          "snippet": "int git_rwlock_wrunlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_release_exclusive)\n\t\twin32_srwlock_release_exclusive(&lock->native.srwl);\n\telse\n\t\tLeaveCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static win32_srwlock_fn win32_srwlock_release_exclusive;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_release_exclusive;\n\nint git_rwlock_wrunlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_release_exclusive)\n\t\twin32_srwlock_release_exclusive(&lock->native.srwl);\n\telse\n\t\tLeaveCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&sc->items"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}"
  },
  {
    "function_name": "git_sortedcache_wlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "160-169",
    "snippet": "int git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Unable to acquire write lock on cache\""
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_rwlock_wrlock",
          "args": [
            "&sc->lock"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "git_rwlock_wrlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "213-221",
          "snippet": "int git_rwlock_wrlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_acquire_exclusive)\n\t\twin32_srwlock_acquire_exclusive(&lock->native.srwl);\n\telse\n\t\tEnterCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static win32_srwlock_fn win32_srwlock_acquire_exclusive;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_acquire_exclusive;\n\nint git_rwlock_wrlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_acquire_exclusive)\n\t\twin32_srwlock_acquire_exclusive(&lock->native.srwl);\n\telse\n\t\tEnterCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "sc"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "git_sortedcache_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "112-157",
    "snippet": "int git_sortedcache_copy(\n\tgit_sortedcache **out,\n\tgit_sortedcache *src,\n\tbool lock,\n\tint (*copy_item)(void *payload, void *tgt_item, void *src_item),\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_sortedcache *tgt;\n\tsize_t i;\n\tvoid *src_item, *tgt_item;\n\n\t/* just use memcpy if no special copy fn is passed in */\n\tif (!copy_item) {\n\t\tcopy_item = sortedcache_copy_item;\n\t\tpayload   = src;\n\t}\n\n\tif ((error = git_sortedcache_new(\n\t\t\t&tgt, src->item_path_offset,\n\t\t\tsrc->free_item, src->free_item_payload,\n\t\t\tsrc->items._cmp, src->path)) < 0)\n\t\treturn error;\n\n\tif (lock && git_sortedcache_rlock(src) < 0) {\n\t\tgit_sortedcache_free(tgt);\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&src->items, i, src_item) {\n\t\tchar *path = ((char *)src_item) + src->item_path_offset;\n\n\t\tif ((error = git_sortedcache_upsert(&tgt_item, tgt, path)) < 0 ||\n\t\t\t(error = copy_item(payload, tgt_item, src_item)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (lock)\n\t\tgit_sortedcache_runlock(src);\n\tif (error)\n\t\tgit_sortedcache_free(tgt);\n\n\t*out = !error ? tgt : NULL;\n\n\treturn error;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_sortedcache_free",
          "args": [
            "tgt"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "96-101",
          "snippet": "void git_sortedcache_free(git_sortedcache *sc)\n{\n\tif (!sc)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sc, sortedcache_free);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_free(git_sortedcache *sc)\n{\n\tif (!sc)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sc, sortedcache_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_runlock",
          "args": [
            "src"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_runlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "191-195",
          "snippet": "void git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_item",
          "args": [
            "payload",
            "tgt_item",
            "src_item"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "sortedcache_copy_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "103-109",
          "snippet": "static int sortedcache_copy_item(void *payload, void *tgt_item, void *src_item)\n{\n\tgit_sortedcache *sc = payload;\n\t/* path will already have been copied by upsert */\n\tmemcpy(tgt_item, src_item, sc->item_path_offset);\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nstatic int sortedcache_copy_item(void *payload, void *tgt_item, void *src_item)\n{\n\tgit_sortedcache *sc = payload;\n\t/* path will already have been copied by upsert */\n\tmemcpy(tgt_item, src_item, sc->item_path_offset);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_upsert",
          "args": [
            "&tgt_item",
            "tgt",
            "path"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_upsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "257-304",
          "snippet": "int git_sortedcache_upsert(void **out, git_sortedcache *sc, const char *key)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tvoid *item;\n\tsize_t keylen, itemlen;\n\tchar *item_key;\n\n\tpos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos)) {\n\t\titem = git_strmap_value_at(sc->map, pos);\n\t\tgoto done;\n\t}\n\n\tkeylen  = strlen(key);\n\titemlen = sc->item_path_offset + keylen + 1;\n\titemlen = (itemlen + 7) & ~7;\n\n\tif ((item = git_pool_mallocz(&sc->pool, (uint32_t)itemlen)) == NULL) {\n\t\t/* don't use GITERR_CHECK_ALLOC b/c of lock */\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t/* one strange thing is that even if the vector or hash table insert\n\t * fail, there is no way to free the pool item so we just abandon it\n\t */\n\n\titem_key = ((char *)item) + sc->item_path_offset;\n\tmemcpy(item_key, key, keylen);\n\n\tpos = kh_put(str, sc->map, item_key, &error);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (!error)\n\t\tkh_key(sc->map, pos) = item_key;\n\tkh_val(sc->map, pos) = item;\n\n\terror = git_vector_insert(&sc->items, item);\n\tif (error < 0)\n\t\tgit_strmap_delete_at(sc->map, pos);\n\ndone:\n\tif (out)\n\t\t*out = !error ? item : NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_upsert(void **out, git_sortedcache *sc, const char *key)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tvoid *item;\n\tsize_t keylen, itemlen;\n\tchar *item_key;\n\n\tpos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos)) {\n\t\titem = git_strmap_value_at(sc->map, pos);\n\t\tgoto done;\n\t}\n\n\tkeylen  = strlen(key);\n\titemlen = sc->item_path_offset + keylen + 1;\n\titemlen = (itemlen + 7) & ~7;\n\n\tif ((item = git_pool_mallocz(&sc->pool, (uint32_t)itemlen)) == NULL) {\n\t\t/* don't use GITERR_CHECK_ALLOC b/c of lock */\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t/* one strange thing is that even if the vector or hash table insert\n\t * fail, there is no way to free the pool item so we just abandon it\n\t */\n\n\titem_key = ((char *)item) + sc->item_path_offset;\n\tmemcpy(item_key, key, keylen);\n\n\tpos = kh_put(str, sc->map, item_key, &error);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (!error)\n\t\tkh_key(sc->map, pos) = item_key;\n\tkh_val(sc->map, pos) = item;\n\n\terror = git_vector_insert(&sc->items, item);\n\tif (error < 0)\n\t\tgit_strmap_delete_at(sc->map, pos);\n\ndone:\n\tif (out)\n\t\t*out = !error ? item : NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&src->items",
            "i",
            "src_item"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_sortedcache_rlock",
          "args": [
            "src"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_rlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "179-188",
          "snippet": "int git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_new",
          "args": [
            "&tgt",
            "src->item_path_offset",
            "src->free_item",
            "src->free_item_payload",
            "src->items._cmp",
            "src->path"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "3-50",
          "snippet": "GIT__USE_STRMAP\n\nint git_sortedcache_new(\n\tgit_sortedcache **out,\n\tsize_t item_path_offset,\n\tgit_sortedcache_free_item_fn free_item,\n\tvoid *free_item_payload,\n\tgit_vector_cmp item_cmp,\n\tconst char *path)\n{\n\tgit_sortedcache *sc;\n\tsize_t pathlen, alloclen;\n\n\tpathlen = path ? strlen(path) : 0;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_sortedcache), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tsc = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(sc);\n\n\tgit_pool_init(&sc->pool, 1);\n\n\tif (git_vector_init(&sc->items, 4, item_cmp) < 0 ||\n\t\tgit_strmap_alloc(&sc->map) < 0)\n\t\tgoto fail;\n\n\tif (git_rwlock_init(&sc->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgoto fail;\n\t}\n\n\tsc->item_path_offset  = item_path_offset;\n\tsc->free_item         = free_item;\n\tsc->free_item_payload = free_item_payload;\n\tGIT_REFCOUNT_INC(sc);\n\tif (pathlen)\n\t\tmemcpy(sc->path, path, pathlen);\n\n\t*out = sc;\n\treturn 0;\n\nfail:\n\tgit_strmap_free(sc->map);\n\tgit_vector_free(&sc->items);\n\tgit_pool_clear(&sc->pool);\n\tgit__free(sc);\n\treturn -1;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nGIT__USE_STRMAP\n\nint git_sortedcache_new(\n\tgit_sortedcache **out,\n\tsize_t item_path_offset,\n\tgit_sortedcache_free_item_fn free_item,\n\tvoid *free_item_payload,\n\tgit_vector_cmp item_cmp,\n\tconst char *path)\n{\n\tgit_sortedcache *sc;\n\tsize_t pathlen, alloclen;\n\n\tpathlen = path ? strlen(path) : 0;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_sortedcache), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tsc = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(sc);\n\n\tgit_pool_init(&sc->pool, 1);\n\n\tif (git_vector_init(&sc->items, 4, item_cmp) < 0 ||\n\t\tgit_strmap_alloc(&sc->map) < 0)\n\t\tgoto fail;\n\n\tif (git_rwlock_init(&sc->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgoto fail;\n\t}\n\n\tsc->item_path_offset  = item_path_offset;\n\tsc->free_item         = free_item;\n\tsc->free_item_payload = free_item_payload;\n\tGIT_REFCOUNT_INC(sc);\n\tif (pathlen)\n\t\tmemcpy(sc->path, path, pathlen);\n\n\t*out = sc;\n\treturn 0;\n\nfail:\n\tgit_strmap_free(sc->map);\n\tgit_vector_free(&sc->items);\n\tgit_pool_clear(&sc->pool);\n\tgit__free(sc);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_copy(\n\tgit_sortedcache **out,\n\tgit_sortedcache *src,\n\tbool lock,\n\tint (*copy_item)(void *payload, void *tgt_item, void *src_item),\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_sortedcache *tgt;\n\tsize_t i;\n\tvoid *src_item, *tgt_item;\n\n\t/* just use memcpy if no special copy fn is passed in */\n\tif (!copy_item) {\n\t\tcopy_item = sortedcache_copy_item;\n\t\tpayload   = src;\n\t}\n\n\tif ((error = git_sortedcache_new(\n\t\t\t&tgt, src->item_path_offset,\n\t\t\tsrc->free_item, src->free_item_payload,\n\t\t\tsrc->items._cmp, src->path)) < 0)\n\t\treturn error;\n\n\tif (lock && git_sortedcache_rlock(src) < 0) {\n\t\tgit_sortedcache_free(tgt);\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&src->items, i, src_item) {\n\t\tchar *path = ((char *)src_item) + src->item_path_offset;\n\n\t\tif ((error = git_sortedcache_upsert(&tgt_item, tgt, path)) < 0 ||\n\t\t\t(error = copy_item(payload, tgt_item, src_item)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (lock)\n\t\tgit_sortedcache_runlock(src);\n\tif (error)\n\t\tgit_sortedcache_free(tgt);\n\n\t*out = !error ? tgt : NULL;\n\n\treturn error;\n}"
  },
  {
    "function_name": "sortedcache_copy_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "103-109",
    "snippet": "static int sortedcache_copy_item(void *payload, void *tgt_item, void *src_item)\n{\n\tgit_sortedcache *sc = payload;\n\t/* path will already have been copied by upsert */\n\tmemcpy(tgt_item, src_item, sc->item_path_offset);\n\treturn 0;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tgt_item",
            "src_item",
            "sc->item_path_offset"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nstatic int sortedcache_copy_item(void *payload, void *tgt_item, void *src_item)\n{\n\tgit_sortedcache *sc = payload;\n\t/* path will already have been copied by upsert */\n\tmemcpy(tgt_item, src_item, sc->item_path_offset);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_sortedcache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "96-101",
    "snippet": "void git_sortedcache_free(git_sortedcache *sc)\n{\n\tif (!sc)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sc, sortedcache_free);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_DEC",
          "args": [
            "sc",
            "sortedcache_free"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_free(git_sortedcache *sc)\n{\n\tif (!sc)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sc, sortedcache_free);\n}"
  },
  {
    "function_name": "sortedcache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "80-94",
    "snippet": "static void sortedcache_free(git_sortedcache *sc)\n{\n\t/* acquire write lock to make sure everyone else is done */\n\tif (git_sortedcache_wlock(sc) < 0)\n\t\treturn;\n\n\tsortedcache_clear(sc);\n\tgit_vector_free(&sc->items);\n\tgit_strmap_free(sc->map);\n\n\tgit_sortedcache_wunlock(sc);\n\n\tgit_rwlock_free(&sc->lock);\n\tgit__free(sc);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sc"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_rwlock_free",
          "args": [
            "&sc->lock"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "git_rwlock_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "233-239",
          "snippet": "int git_rwlock_free(git_rwlock *lock)\n{\n\tif (!win32_srwlock_initialize)\n\t\tDeleteCriticalSection(&lock->native.csec);\n\tgit__memzero(lock, sizeof(*lock));\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static win32_srwlock_fn win32_srwlock_initialize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_initialize;\n\nint git_rwlock_free(git_rwlock *lock)\n{\n\tif (!win32_srwlock_initialize)\n\t\tDeleteCriticalSection(&lock->native.csec);\n\tgit__memzero(lock, sizeof(*lock));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wunlock",
          "args": [
            "sc"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "172-176",
          "snippet": "void git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_free",
          "args": [
            "sc->map"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&sc->items"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sortedcache_clear",
          "args": [
            "sc"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "sortedcache_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "62-78",
          "snippet": "static void sortedcache_clear(git_sortedcache *sc)\n{\n\tgit_strmap_clear(sc->map);\n\n\tif (sc->free_item) {\n\t\tsize_t i;\n\t\tvoid *item;\n\n\t\tgit_vector_foreach(&sc->items, i, item) {\n\t\t\tsc->free_item(sc->free_item_payload, item);\n\t\t}\n\t}\n\n\tgit_vector_clear(&sc->items);\n\n\tgit_pool_clear(&sc->pool);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nstatic void sortedcache_clear(git_sortedcache *sc)\n{\n\tgit_strmap_clear(sc->map);\n\n\tif (sc->free_item) {\n\t\tsize_t i;\n\t\tvoid *item;\n\n\t\tgit_vector_foreach(&sc->items, i, item) {\n\t\t\tsc->free_item(sc->free_item_payload, item);\n\t\t}\n\t}\n\n\tgit_vector_clear(&sc->items);\n\n\tgit_pool_clear(&sc->pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wlock",
          "args": [
            "sc"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "160-169",
          "snippet": "int git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nstatic void sortedcache_free(git_sortedcache *sc)\n{\n\t/* acquire write lock to make sure everyone else is done */\n\tif (git_sortedcache_wlock(sc) < 0)\n\t\treturn;\n\n\tsortedcache_clear(sc);\n\tgit_vector_free(&sc->items);\n\tgit_strmap_free(sc->map);\n\n\tgit_sortedcache_wunlock(sc);\n\n\tgit_rwlock_free(&sc->lock);\n\tgit__free(sc);\n}"
  },
  {
    "function_name": "sortedcache_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "62-78",
    "snippet": "static void sortedcache_clear(git_sortedcache *sc)\n{\n\tgit_strmap_clear(sc->map);\n\n\tif (sc->free_item) {\n\t\tsize_t i;\n\t\tvoid *item;\n\n\t\tgit_vector_foreach(&sc->items, i, item) {\n\t\t\tsc->free_item(sc->free_item_payload, item);\n\t\t}\n\t}\n\n\tgit_vector_clear(&sc->items);\n\n\tgit_pool_clear(&sc->pool);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&sc->pool"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&sc->items"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->free_item",
          "args": [
            "sc->free_item_payload",
            "item"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&sc->items",
            "i",
            "item"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_clear",
          "args": [
            "sc->map"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nstatic void sortedcache_clear(git_sortedcache *sc)\n{\n\tgit_strmap_clear(sc->map);\n\n\tif (sc->free_item) {\n\t\tsize_t i;\n\t\tvoid *item;\n\n\t\tgit_vector_foreach(&sc->items, i, item) {\n\t\t\tsc->free_item(sc->free_item_payload, item);\n\t\t}\n\t}\n\n\tgit_vector_clear(&sc->items);\n\n\tgit_pool_clear(&sc->pool);\n}"
  },
  {
    "function_name": "git_sortedcache_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "57-60",
    "snippet": "const char *git_sortedcache_path(git_sortedcache *sc)\n{\n\treturn sc->path;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nconst char *git_sortedcache_path(git_sortedcache *sc)\n{\n\treturn sc->path;\n}"
  },
  {
    "function_name": "git_sortedcache_incref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "52-55",
    "snippet": "void git_sortedcache_incref(git_sortedcache *sc)\n{\n\tGIT_REFCOUNT_INC(sc);\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "sc"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_incref(git_sortedcache *sc)\n{\n\tGIT_REFCOUNT_INC(sc);\n}"
  },
  {
    "function_name": "git_sortedcache_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
    "lines": "3-50",
    "snippet": "GIT__USE_STRMAP\n\nint git_sortedcache_new(\n\tgit_sortedcache **out,\n\tsize_t item_path_offset,\n\tgit_sortedcache_free_item_fn free_item,\n\tvoid *free_item_payload,\n\tgit_vector_cmp item_cmp,\n\tconst char *path)\n{\n\tgit_sortedcache *sc;\n\tsize_t pathlen, alloclen;\n\n\tpathlen = path ? strlen(path) : 0;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_sortedcache), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tsc = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(sc);\n\n\tgit_pool_init(&sc->pool, 1);\n\n\tif (git_vector_init(&sc->items, 4, item_cmp) < 0 ||\n\t\tgit_strmap_alloc(&sc->map) < 0)\n\t\tgoto fail;\n\n\tif (git_rwlock_init(&sc->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgoto fail;\n\t}\n\n\tsc->item_path_offset  = item_path_offset;\n\tsc->free_item         = free_item;\n\tsc->free_item_payload = free_item_payload;\n\tGIT_REFCOUNT_INC(sc);\n\tif (pathlen)\n\t\tmemcpy(sc->path, path, pathlen);\n\n\t*out = sc;\n\treturn 0;\n\nfail:\n\tgit_strmap_free(sc->map);\n\tgit_vector_free(&sc->items);\n\tgit_pool_clear(&sc->pool);\n\tgit__free(sc);\n\treturn -1;\n}",
    "includes": [
      "#include \"sortedcache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sc"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&sc->pool"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&sc->items"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_free",
          "args": [
            "sc->map"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->path",
            "path",
            "pathlen"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "sc"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to initialize lock\""
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_rwlock_init",
          "args": [
            "&sc->lock"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "git_rwlock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "183-191",
          "snippet": "int git_rwlock_init(git_rwlock *GIT_RESTRICT lock)\n{\n\tif (win32_srwlock_initialize)\n\t\twin32_srwlock_initialize(&lock->native.srwl);\n\telse\n\t\tInitializeCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static win32_srwlock_fn win32_srwlock_initialize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_initialize;\n\nint git_rwlock_init(git_rwlock *GIT_RESTRICT lock)\n{\n\tif (win32_srwlock_initialize)\n\t\twin32_srwlock_initialize(&lock->native.srwl);\n\telse\n\t\tInitializeCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_alloc",
          "args": [
            "&sc->map"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&sc->items",
            "4",
            "item_cmp"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_init",
          "args": [
            "&sc->pool",
            "1"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "120-129",
          "snippet": "void git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "sc"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "alloclen"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "alloclen",
            "1"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "sizeof(git_sortedcache)",
            "pathlen"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sortedcache.h\"\n\nGIT__USE_STRMAP\n\nint git_sortedcache_new(\n\tgit_sortedcache **out,\n\tsize_t item_path_offset,\n\tgit_sortedcache_free_item_fn free_item,\n\tvoid *free_item_payload,\n\tgit_vector_cmp item_cmp,\n\tconst char *path)\n{\n\tgit_sortedcache *sc;\n\tsize_t pathlen, alloclen;\n\n\tpathlen = path ? strlen(path) : 0;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_sortedcache), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tsc = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(sc);\n\n\tgit_pool_init(&sc->pool, 1);\n\n\tif (git_vector_init(&sc->items, 4, item_cmp) < 0 ||\n\t\tgit_strmap_alloc(&sc->map) < 0)\n\t\tgoto fail;\n\n\tif (git_rwlock_init(&sc->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgoto fail;\n\t}\n\n\tsc->item_path_offset  = item_path_offset;\n\tsc->free_item         = free_item;\n\tsc->free_item_payload = free_item_payload;\n\tGIT_REFCOUNT_INC(sc);\n\tif (pathlen)\n\t\tmemcpy(sc->path, path, pathlen);\n\n\t*out = sc;\n\treturn 0;\n\nfail:\n\tgit_strmap_free(sc->map);\n\tgit_vector_free(&sc->items);\n\tgit_pool_clear(&sc->pool);\n\tgit__free(sc);\n\treturn -1;\n}"
  }
]