[
  {
    "function_name": "git_fetch_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetch.c",
    "lines": "151-156",
    "snippet": "int git_fetch_init_options(git_fetch_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_fetch_options, GIT_FETCH_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"refs.h\"",
      "#include \"repository.h\"",
      "#include \"netops.h\"",
      "#include \"fetch.h\"",
      "#include \"pack.h\"",
      "#include \"refspec.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/revwalk.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/oid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_fetch_options",
            "GIT_FETCH_OPTIONS_INIT"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refs.h\"\n#include \"repository.h\"\n#include \"netops.h\"\n#include \"fetch.h\"\n#include \"pack.h\"\n#include \"refspec.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/transport.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/oid.h\"\n\nint git_fetch_init_options(git_fetch_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_fetch_options, GIT_FETCH_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_fetch_download_pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetch.c",
    "lines": "134-149",
    "snippet": "int git_fetch_download_pack(git_remote *remote, const git_remote_callbacks *callbacks)\n{\n\tgit_transport *t = remote->transport;\n\tgit_transfer_progress_cb progress = NULL;\n\tvoid *payload = NULL;\n\n\tif (!remote->need_pack)\n\t\treturn 0;\n\n\tif (callbacks) {\n\t\tprogress = callbacks->transfer_progress;\n\t\tpayload  = callbacks->payload;\n\t}\n\n\treturn t->download_pack(t, remote->repo, &remote->stats, progress, payload);\n}",
    "includes": [
      "#include \"refs.h\"",
      "#include \"repository.h\"",
      "#include \"netops.h\"",
      "#include \"fetch.h\"",
      "#include \"pack.h\"",
      "#include \"refspec.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/revwalk.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/oid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->download_pack",
          "args": [
            "t",
            "remote->repo",
            "&remote->stats",
            "progress",
            "payload"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refs.h\"\n#include \"repository.h\"\n#include \"netops.h\"\n#include \"fetch.h\"\n#include \"pack.h\"\n#include \"refspec.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/transport.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/oid.h\"\n\nint git_fetch_download_pack(git_remote *remote, const git_remote_callbacks *callbacks)\n{\n\tgit_transport *t = remote->transport;\n\tgit_transfer_progress_cb progress = NULL;\n\tvoid *payload = NULL;\n\n\tif (!remote->need_pack)\n\t\treturn 0;\n\n\tif (callbacks) {\n\t\tprogress = callbacks->transfer_progress;\n\t\tpayload  = callbacks->payload;\n\t}\n\n\treturn t->download_pack(t, remote->repo, &remote->stats, progress, payload);\n}"
  },
  {
    "function_name": "git_fetch_negotiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetch.c",
    "lines": "109-132",
    "snippet": "int git_fetch_negotiate(git_remote *remote, const git_fetch_options *opts)\n{\n\tgit_transport *t = remote->transport;\n\n\tremote->need_pack = 0;\n\n\tif (filter_wants(remote, opts) < 0) {\n\t\tgiterr_set(GITERR_NET, \"Failed to filter the reference list for wants\");\n\t\treturn -1;\n\t}\n\n\t/* Don't try to negotiate when we don't want anything */\n\tif (!remote->need_pack)\n\t\treturn 0;\n\n\t/*\n\t * Now we have everything set up so we can start tell the\n\t * server what we want and what we have.\n\t */\n\treturn t->negotiate_fetch(t,\n\t\tremote->repo,\n\t\t(const git_remote_head * const *)remote->refs.contents,\n\t\tremote->refs.length);\n}",
    "includes": [
      "#include \"refs.h\"",
      "#include \"repository.h\"",
      "#include \"netops.h\"",
      "#include \"fetch.h\"",
      "#include \"pack.h\"",
      "#include \"refspec.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/revwalk.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/oid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->negotiate_fetch",
          "args": [
            "t",
            "remote->repo",
            "(const git_remote_head * const *)remote->refs.contents",
            "remote->refs.length"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Failed to filter the reference list for wants\""
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_wants",
          "args": [
            "remote",
            "opts"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "filter_wants",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetch.c",
          "lines": "54-102",
          "snippet": "static int filter_wants(git_remote *remote, const git_fetch_options *opts)\n{\n\tgit_remote_head **heads;\n\tgit_refspec tagspec, head;\n\tint error = 0;\n\tgit_odb *odb;\n\tsize_t i, heads_len;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\n\tif (opts && opts->download_tags != GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = opts->download_tags;\n\n\tgit_vector_clear(&remote->refs);\n\tif ((error = git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true)) < 0)\n\t\treturn error;\n\n\t/*\n\t * The fetch refspec can be NULL, and what this means is that the\n\t * user didn't specify one. This is fine, as it means that we're\n\t * not interested in any particular branch but just the remote's\n\t * HEAD, which will be stored in FETCH_HEAD after the fetch.\n\t */\n\tif (remote->active_refspecs.length == 0) {\n\t\tif ((error = git_refspec__parse(&head, \"HEAD\", true)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_refspec__dwim_one(&remote->active_refspecs, &head, &remote->refs);\n\t\tgit_refspec__free(&head);\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (git_repository_odb__weakptr(&odb, remote->repo) < 0)\n\t\tgoto cleanup;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif ((error = maybe_want(remote, heads[i], odb, &tagspec, tagopt)) < 0)\n\t\t\tbreak;\n\t}\n\ncleanup:\n\tgit_refspec__free(&tagspec);\n\n\treturn error;\n}",
          "includes": [
            "#include \"refs.h\"",
            "#include \"repository.h\"",
            "#include \"netops.h\"",
            "#include \"fetch.h\"",
            "#include \"pack.h\"",
            "#include \"refspec.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refs.h\"\n#include \"repository.h\"\n#include \"netops.h\"\n#include \"fetch.h\"\n#include \"pack.h\"\n#include \"refspec.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/transport.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/oid.h\"\n\nstatic int filter_wants(git_remote *remote, const git_fetch_options *opts)\n{\n\tgit_remote_head **heads;\n\tgit_refspec tagspec, head;\n\tint error = 0;\n\tgit_odb *odb;\n\tsize_t i, heads_len;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\n\tif (opts && opts->download_tags != GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = opts->download_tags;\n\n\tgit_vector_clear(&remote->refs);\n\tif ((error = git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true)) < 0)\n\t\treturn error;\n\n\t/*\n\t * The fetch refspec can be NULL, and what this means is that the\n\t * user didn't specify one. This is fine, as it means that we're\n\t * not interested in any particular branch but just the remote's\n\t * HEAD, which will be stored in FETCH_HEAD after the fetch.\n\t */\n\tif (remote->active_refspecs.length == 0) {\n\t\tif ((error = git_refspec__parse(&head, \"HEAD\", true)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_refspec__dwim_one(&remote->active_refspecs, &head, &remote->refs);\n\t\tgit_refspec__free(&head);\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (git_repository_odb__weakptr(&odb, remote->repo) < 0)\n\t\tgoto cleanup;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif ((error = maybe_want(remote, heads[i], odb, &tagspec, tagopt)) < 0)\n\t\t\tbreak;\n\t}\n\ncleanup:\n\tgit_refspec__free(&tagspec);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refs.h\"\n#include \"repository.h\"\n#include \"netops.h\"\n#include \"fetch.h\"\n#include \"pack.h\"\n#include \"refspec.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/transport.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/oid.h\"\n\nint git_fetch_negotiate(git_remote *remote, const git_fetch_options *opts)\n{\n\tgit_transport *t = remote->transport;\n\n\tremote->need_pack = 0;\n\n\tif (filter_wants(remote, opts) < 0) {\n\t\tgiterr_set(GITERR_NET, \"Failed to filter the reference list for wants\");\n\t\treturn -1;\n\t}\n\n\t/* Don't try to negotiate when we don't want anything */\n\tif (!remote->need_pack)\n\t\treturn 0;\n\n\t/*\n\t * Now we have everything set up so we can start tell the\n\t * server what we want and what we have.\n\t */\n\treturn t->negotiate_fetch(t,\n\t\tremote->repo,\n\t\t(const git_remote_head * const *)remote->refs.contents,\n\t\tremote->refs.length);\n}"
  },
  {
    "function_name": "filter_wants",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetch.c",
    "lines": "54-102",
    "snippet": "static int filter_wants(git_remote *remote, const git_fetch_options *opts)\n{\n\tgit_remote_head **heads;\n\tgit_refspec tagspec, head;\n\tint error = 0;\n\tgit_odb *odb;\n\tsize_t i, heads_len;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\n\tif (opts && opts->download_tags != GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = opts->download_tags;\n\n\tgit_vector_clear(&remote->refs);\n\tif ((error = git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true)) < 0)\n\t\treturn error;\n\n\t/*\n\t * The fetch refspec can be NULL, and what this means is that the\n\t * user didn't specify one. This is fine, as it means that we're\n\t * not interested in any particular branch but just the remote's\n\t * HEAD, which will be stored in FETCH_HEAD after the fetch.\n\t */\n\tif (remote->active_refspecs.length == 0) {\n\t\tif ((error = git_refspec__parse(&head, \"HEAD\", true)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_refspec__dwim_one(&remote->active_refspecs, &head, &remote->refs);\n\t\tgit_refspec__free(&head);\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (git_repository_odb__weakptr(&odb, remote->repo) < 0)\n\t\tgoto cleanup;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif ((error = maybe_want(remote, heads[i], odb, &tagspec, tagopt)) < 0)\n\t\t\tbreak;\n\t}\n\ncleanup:\n\tgit_refspec__free(&tagspec);\n\n\treturn error;\n}",
    "includes": [
      "#include \"refs.h\"",
      "#include \"repository.h\"",
      "#include \"netops.h\"",
      "#include \"fetch.h\"",
      "#include \"pack.h\"",
      "#include \"refspec.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/revwalk.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/oid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "&tagspec"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_want",
          "args": [
            "remote",
            "heads[i]",
            "odb",
            "&tagspec",
            "tagopt"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_want",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetch.c",
          "lines": "22-52",
          "snippet": "static int maybe_want(git_remote *remote, git_remote_head *head, git_odb *odb, git_refspec *tagspec, git_remote_autotag_option_t tagopt)\n{\n\tint match = 0;\n\n\tif (!git_reference_is_valid_name(head->name))\n\t\treturn 0;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\t/*\n\t\t * If tagopt is --tags, always request tags\n\t\t * in addition to the remote's refspecs\n\t\t */\n\t\tif (git_refspec_src_matches(tagspec, head->name))\n\t\t\tmatch = 1;\n\t}\n\n\tif (!match && git_remote__matching_refspec(remote, head->name))\n\t\tmatch = 1;\n\n\tif (!match)\n\t\treturn 0;\n\n\t/* If we have the object, mark it so we don't ask for it */\n\tif (git_odb_exists(odb, &head->oid)) {\n\t\thead->local = 1;\n\t}\n\telse\n\t\tremote->need_pack = 1;\n\n\treturn git_vector_insert(&remote->refs, head);\n}",
          "includes": [
            "#include \"refs.h\"",
            "#include \"repository.h\"",
            "#include \"netops.h\"",
            "#include \"fetch.h\"",
            "#include \"pack.h\"",
            "#include \"refspec.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refs.h\"\n#include \"repository.h\"\n#include \"netops.h\"\n#include \"fetch.h\"\n#include \"pack.h\"\n#include \"refspec.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/transport.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/oid.h\"\n\nstatic int maybe_want(git_remote *remote, git_remote_head *head, git_odb *odb, git_refspec *tagspec, git_remote_autotag_option_t tagopt)\n{\n\tint match = 0;\n\n\tif (!git_reference_is_valid_name(head->name))\n\t\treturn 0;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\t/*\n\t\t * If tagopt is --tags, always request tags\n\t\t * in addition to the remote's refspecs\n\t\t */\n\t\tif (git_refspec_src_matches(tagspec, head->name))\n\t\t\tmatch = 1;\n\t}\n\n\tif (!match && git_remote__matching_refspec(remote, head->name))\n\t\tmatch = 1;\n\n\tif (!match)\n\t\treturn 0;\n\n\t/* If we have the object, mark it so we don't ask for it */\n\tif (git_odb_exists(odb, &head->oid)) {\n\t\thead->local = 1;\n\t}\n\telse\n\t\tremote->need_pack = 1;\n\n\treturn git_vector_insert(&remote->refs, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_ls",
          "args": [
            "(const git_remote_head ***)&heads",
            "&heads_len",
            "remote"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "757-767",
          "snippet": "int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "remote->repo"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__dwim_one",
          "args": [
            "&remote->active_refspecs",
            "&head",
            "&remote->refs"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__dwim_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "302-367",
          "snippet": "int git_refspec__dwim_one(git_vector *out, git_refspec *spec, git_vector *refs)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t j, pos;\n\tgit_remote_head key;\n\n\tconst char* formatters[] = {\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tNULL\n\t};\n\n\tgit_refspec *cur = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(cur);\n\n\tcur->force = spec->force;\n\tcur->push = spec->push;\n\tcur->pattern = spec->pattern;\n\tcur->matching = spec->matching;\n\tcur->string = git__strdup(spec->string);\n\n\t/* shorthand on the lhs */\n\tif (git__prefixcmp(spec->src, GIT_REFS_DIR)) {\n\t\tfor (j = 0; formatters[j]; j++) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_printf(&buf, formatters[j], spec->src);\n\t\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\tif (!git_vector_search(&pos, refs, &key)) {\n\t\t\t\t/* we found something to match the shorthand, set src to that */\n\t\t\t\tcur->src = git_buf_detach(&buf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* No shorthands found, copy over the name */\n\tif (cur->src == NULL && spec->src != NULL) {\n\t\tcur->src = git__strdup(spec->src);\n\t\tGITERR_CHECK_ALLOC(cur->src);\n\t}\n\n\tif (spec->dst && git__prefixcmp(spec->dst, GIT_REFS_DIR)) {\n\t\t/* if it starts with \"remotes\" then we just prepend \"refs/\" */\n\t\tif (!git__prefixcmp(spec->dst, \"remotes/\")) {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_DIR);\n\t\t} else {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_HEADS_DIR);\n\t\t}\n\n\t\tgit_buf_puts(&buf, spec->dst);\n\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\tcur->dst = git_buf_detach(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\n\tif (cur->dst == NULL && spec->dst != NULL) {\n\t\tcur->dst = git__strdup(spec->dst);\n\t\tGITERR_CHECK_ALLOC(cur->dst);\n\t}\n\n\treturn git_vector_insert(out, cur);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__dwim_one(git_vector *out, git_refspec *spec, git_vector *refs)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t j, pos;\n\tgit_remote_head key;\n\n\tconst char* formatters[] = {\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tNULL\n\t};\n\n\tgit_refspec *cur = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(cur);\n\n\tcur->force = spec->force;\n\tcur->push = spec->push;\n\tcur->pattern = spec->pattern;\n\tcur->matching = spec->matching;\n\tcur->string = git__strdup(spec->string);\n\n\t/* shorthand on the lhs */\n\tif (git__prefixcmp(spec->src, GIT_REFS_DIR)) {\n\t\tfor (j = 0; formatters[j]; j++) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_printf(&buf, formatters[j], spec->src);\n\t\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\tif (!git_vector_search(&pos, refs, &key)) {\n\t\t\t\t/* we found something to match the shorthand, set src to that */\n\t\t\t\tcur->src = git_buf_detach(&buf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* No shorthands found, copy over the name */\n\tif (cur->src == NULL && spec->src != NULL) {\n\t\tcur->src = git__strdup(spec->src);\n\t\tGITERR_CHECK_ALLOC(cur->src);\n\t}\n\n\tif (spec->dst && git__prefixcmp(spec->dst, GIT_REFS_DIR)) {\n\t\t/* if it starts with \"remotes\" then we just prepend \"refs/\" */\n\t\tif (!git__prefixcmp(spec->dst, \"remotes/\")) {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_DIR);\n\t\t} else {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_HEADS_DIR);\n\t\t}\n\n\t\tgit_buf_puts(&buf, spec->dst);\n\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\tcur->dst = git_buf_detach(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\n\tif (cur->dst == NULL && spec->dst != NULL) {\n\t\tcur->dst = git__strdup(spec->dst);\n\t\tGITERR_CHECK_ALLOC(cur->dst);\n\t}\n\n\treturn git_vector_insert(out, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__parse",
          "args": [
            "&head",
            "\"HEAD\"",
            "true"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "17-149",
          "snippet": "int git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&remote->refs"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refs.h\"\n#include \"repository.h\"\n#include \"netops.h\"\n#include \"fetch.h\"\n#include \"pack.h\"\n#include \"refspec.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/transport.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/oid.h\"\n\nstatic int filter_wants(git_remote *remote, const git_fetch_options *opts)\n{\n\tgit_remote_head **heads;\n\tgit_refspec tagspec, head;\n\tint error = 0;\n\tgit_odb *odb;\n\tsize_t i, heads_len;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\n\tif (opts && opts->download_tags != GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = opts->download_tags;\n\n\tgit_vector_clear(&remote->refs);\n\tif ((error = git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true)) < 0)\n\t\treturn error;\n\n\t/*\n\t * The fetch refspec can be NULL, and what this means is that the\n\t * user didn't specify one. This is fine, as it means that we're\n\t * not interested in any particular branch but just the remote's\n\t * HEAD, which will be stored in FETCH_HEAD after the fetch.\n\t */\n\tif (remote->active_refspecs.length == 0) {\n\t\tif ((error = git_refspec__parse(&head, \"HEAD\", true)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_refspec__dwim_one(&remote->active_refspecs, &head, &remote->refs);\n\t\tgit_refspec__free(&head);\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (git_repository_odb__weakptr(&odb, remote->repo) < 0)\n\t\tgoto cleanup;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif ((error = maybe_want(remote, heads[i], odb, &tagspec, tagopt)) < 0)\n\t\t\tbreak;\n\t}\n\ncleanup:\n\tgit_refspec__free(&tagspec);\n\n\treturn error;\n}"
  },
  {
    "function_name": "maybe_want",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetch.c",
    "lines": "22-52",
    "snippet": "static int maybe_want(git_remote *remote, git_remote_head *head, git_odb *odb, git_refspec *tagspec, git_remote_autotag_option_t tagopt)\n{\n\tint match = 0;\n\n\tif (!git_reference_is_valid_name(head->name))\n\t\treturn 0;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\t/*\n\t\t * If tagopt is --tags, always request tags\n\t\t * in addition to the remote's refspecs\n\t\t */\n\t\tif (git_refspec_src_matches(tagspec, head->name))\n\t\t\tmatch = 1;\n\t}\n\n\tif (!match && git_remote__matching_refspec(remote, head->name))\n\t\tmatch = 1;\n\n\tif (!match)\n\t\treturn 0;\n\n\t/* If we have the object, mark it so we don't ask for it */\n\tif (git_odb_exists(odb, &head->oid)) {\n\t\thead->local = 1;\n\t}\n\telse\n\t\tremote->need_pack = 1;\n\n\treturn git_vector_insert(&remote->refs, head);\n}",
    "includes": [
      "#include \"refs.h\"",
      "#include \"repository.h\"",
      "#include \"netops.h\"",
      "#include \"fetch.h\"",
      "#include \"pack.h\"",
      "#include \"refspec.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/revwalk.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/oid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&remote->refs",
            "head"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_exists",
          "args": [
            "odb",
            "&head->oid"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "646-665",
          "snippet": "int git_odb_exists(git_odb *db, const git_oid *id)\n{\n\tgit_odb_object *object;\n\n\tassert(db && id);\n\n\tif ((object = git_cache_get_raw(odb_cache(db), id)) != NULL) {\n\t\tgit_odb_object_free(object);\n\t\treturn (int)true;\n\t}\n\n\tif (odb_exists_1(db, id, false))\n\t\treturn 1;\n\n\tif (!git_odb_refresh(db))\n\t\treturn odb_exists_1(db, id, true);\n\n\t/* Failed to refresh, hence not found */\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_exists(git_odb *db, const git_oid *id)\n{\n\tgit_odb_object *object;\n\n\tassert(db && id);\n\n\tif ((object = git_cache_get_raw(odb_cache(db), id)) != NULL) {\n\t\tgit_odb_object_free(object);\n\t\treturn (int)true;\n\t}\n\n\tif (odb_exists_1(db, id, false))\n\t\treturn 1;\n\n\tif (!git_odb_refresh(db))\n\t\treturn odb_exists_1(db, id, true);\n\n\t/* Failed to refresh, hence not found */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__matching_refspec",
          "args": [
            "remote",
            "head->name"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__matching_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2055-2069",
          "snippet": "git_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_src_matches",
          "args": [
            "tagspec",
            "head->name"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_src_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "185-191",
          "snippet": "int git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_valid_name",
          "args": [
            "head->name"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1279-1282",
          "snippet": "int git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refs.h\"\n#include \"repository.h\"\n#include \"netops.h\"\n#include \"fetch.h\"\n#include \"pack.h\"\n#include \"refspec.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/transport.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/oid.h\"\n\nstatic int maybe_want(git_remote *remote, git_remote_head *head, git_odb *odb, git_refspec *tagspec, git_remote_autotag_option_t tagopt)\n{\n\tint match = 0;\n\n\tif (!git_reference_is_valid_name(head->name))\n\t\treturn 0;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\t/*\n\t\t * If tagopt is --tags, always request tags\n\t\t * in addition to the remote's refspecs\n\t\t */\n\t\tif (git_refspec_src_matches(tagspec, head->name))\n\t\t\tmatch = 1;\n\t}\n\n\tif (!match && git_remote__matching_refspec(remote, head->name))\n\t\tmatch = 1;\n\n\tif (!match)\n\t\treturn 0;\n\n\t/* If we have the object, mark it so we don't ask for it */\n\tif (git_odb_exists(odb, &head->oid)) {\n\t\thead->local = 1;\n\t}\n\telse\n\t\tremote->need_pack = 1;\n\n\treturn git_vector_insert(&remote->refs, head);\n}"
  }
]