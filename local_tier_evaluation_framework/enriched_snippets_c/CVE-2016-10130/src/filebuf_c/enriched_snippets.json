[
  {
    "function_name": "git_filebuf_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "558-580",
    "snippet": "int git_filebuf_stats(time_t *mtime, size_t *size, git_filebuf *file)\n{\n\tint res;\n\tstruct stat st;\n\n\tif (file->fd_is_open)\n\t\tres = p_fstat(file->fd, &st);\n\telse\n\t\tres = p_stat(file->path_original, &st);\n\n\tif (res < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not get stat info for '%s'\",\n\t\t\tfile->path_original);\n\t\treturn res;\n\t}\n\n\tif (mtime)\n\t\t*mtime = st.st_mtime;\n\tif (size)\n\t\t*size = (size_t)st.st_size;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not get stat info for '%s'\"",
            "file->path_original"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "file->path_original",
            "&st"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_fstat",
          "args": [
            "file->fd",
            "&st"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "p_fstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "401-415",
          "snippet": "int p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_stats(time_t *mtime, size_t *size, git_filebuf *file)\n{\n\tint res;\n\tstruct stat st;\n\n\tif (file->fd_is_open)\n\t\tres = p_fstat(file->fd, &st);\n\telse\n\t\tres = p_stat(file->path_original, &st);\n\n\tif (res < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not get stat info for '%s'\",\n\t\t\tfile->path_original);\n\t\treturn res;\n\t}\n\n\tif (mtime)\n\t\t*mtime = st.st_mtime;\n\tif (size)\n\t\t*size = (size_t)st.st_size;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_filebuf_printf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "502-556",
    "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "tmp_buffer"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "file",
            "tmp_buffer",
            "len"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "arglist"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_vsnprintf",
          "args": [
            "tmp_buffer",
            "len + 1",
            "format",
            "arglist"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "p_vsnprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "525-546",
          "snippet": "int p_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n#if defined(_MSC_VER)\n\tint len;\n\n\tif (count == 0)\n\t\treturn _vscprintf(format, argptr);\n\n\t#if _MSC_VER >= 1500\n\tlen = _vsnprintf_s(buffer, count, _TRUNCATE, format, argptr);\n\t#else\n\tlen = _vsnprintf(buffer, count, format, argptr);\n\t#endif\n\n\tif (len < 0)\n\t\treturn _vscprintf(format, argptr);\n\n\treturn len;\n#else /* MinGW */\n\treturn vsnprintf(buffer, count, format, argptr);\n#endif\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n#if defined(_MSC_VER)\n\tint len;\n\n\tif (count == 0)\n\t\treturn _vscprintf(format, argptr);\n\n\t#if _MSC_VER >= 1500\n\tlen = _vsnprintf_s(buffer, count, _TRUNCATE, format, argptr);\n\t#else\n\tlen = _vsnprintf(buffer, count, format, argptr);\n\t#endif\n\n\tif (len < 0)\n\t\treturn _vscprintf(format, argptr);\n\n\treturn len;\n#else /* MinGW */\n\treturn vsnprintf(buffer, count, format, argptr);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "arglist",
            "format"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloclen"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloclen",
            "len",
            "1"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_buffer",
          "args": [
            "file"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "flush_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "135-140",
          "snippet": "GIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "arglist"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "arglist",
            "format"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENSURE_BUF_OK",
          "args": [
            "file"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
  },
  {
    "function_name": "git_filebuf_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "478-500",
    "snippet": "int git_filebuf_reserve(git_filebuf *file, void **buffer, size_t len)\n{\n\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t*buffer = NULL;\n\n\tENSURE_BUF_OK(file);\n\n\tif (len > file->buf_size) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tif (space_left <= len) {\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*buffer = (file->buffer + file->buf_pos);\n\tfile->buf_pos += len;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_buffer",
          "args": [
            "file"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "flush_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "135-140",
          "snippet": "GIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ENSURE_BUF_OK",
          "args": [
            "file"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_reserve(git_filebuf *file, void **buffer, size_t len)\n{\n\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t*buffer = NULL;\n\n\tENSURE_BUF_OK(file);\n\n\tif (len > file->buf_size) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tif (space_left <= len) {\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*buffer = (file->buffer + file->buf_pos);\n\tfile->buf_pos += len;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_filebuf_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "451-476",
    "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_buffer",
          "args": [
            "file"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "flush_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "135-140",
          "snippet": "GIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_cache",
          "args": [
            "file",
            "buf",
            "space_left"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "445-449",
          "snippet": "GIT_INLINE(void) add_to_cache(git_filebuf *file, const void *buf, size_t len)\n{\n\tmemcpy(file->buffer + file->buf_pos, buf, len);\n\tfile->buf_pos += len;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) add_to_cache(git_filebuf *file, const void *buf, size_t len)\n{\n\tmemcpy(file->buffer + file->buf_pos, buf, len);\n\tfile->buf_pos += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->write",
          "args": [
            "file",
            "(void *)buff",
            "len"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENSURE_BUF_OK",
          "args": [
            "file"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
  },
  {
    "function_name": "add_to_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "445-449",
    "snippet": "GIT_INLINE(void) add_to_cache(git_filebuf *file, const void *buf, size_t len)\n{\n\tmemcpy(file->buffer + file->buf_pos, buf, len);\n\tfile->buf_pos += len;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "file->buffer + file->buf_pos",
            "buf",
            "len"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) add_to_cache(git_filebuf *file, const void *buf, size_t len)\n{\n\tmemcpy(file->buffer + file->buf_pos, buf, len);\n\tfile->buf_pos += len;\n}"
  },
  {
    "function_name": "git_filebuf_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "410-443",
    "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "file"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to rename lockfile to '%s'\"",
            "file->path_original"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_rename",
          "args": [
            "file->path_lock",
            "file->path_original"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "p_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "142-153",
          "snippet": "int p_rename(const char *from, const char *to)\n{\n\tif (!link(from, to)) {\n\t\tp_unlink(from);\n\t\treturn 0;\n\t}\n\n\tif (!rename(from, to))\n\t\treturn 0;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_rename(const char *from, const char *to)\n{\n\tif (!link(from, to)) {\n\t\tp_unlink(from);\n\t\treturn 0;\n\t}\n\n\tif (!rename(from, to))\n\t\treturn 0;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "file->fd"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_last_error",
          "args": [
            "file"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "verify_last_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "22-41",
          "snippet": "static int verify_last_error(git_filebuf *file)\n{\n\tswitch (file->last_error) {\n\tcase BUFERR_WRITE:\n\t\tgiterr_set(GITERR_OS, \"Failed to write out file\");\n\t\treturn -1;\n\n\tcase BUFERR_MEM:\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\n\tcase BUFERR_ZLIB:\n\t\tgiterr_set(GITERR_ZLIB,\n\t\t\t\"Buffer error when writing out ZLib data\");\n\t\treturn -1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic int verify_last_error(git_filebuf *file)\n{\n\tswitch (file->last_error) {\n\tcase BUFERR_WRITE:\n\t\tgiterr_set(GITERR_OS, \"Failed to write out file\");\n\t\treturn -1;\n\n\tcase BUFERR_MEM:\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\n\tcase BUFERR_ZLIB:\n\t\tgiterr_set(GITERR_ZLIB,\n\t\t\t\"Buffer error when writing out ZLib data\");\n\t\treturn -1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_buffer",
          "args": [
            "file"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "flush_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "135-140",
          "snippet": "GIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "file && file->path_original"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_filebuf_commit_at",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "401-408",
    "snippet": "int git_filebuf_commit_at(git_filebuf *file, const char *path)\n{\n\tgit__free(file->path_original);\n\tfile->path_original = git__strdup(path);\n\tGITERR_CHECK_ALLOC(file->path_original);\n\n\treturn git_filebuf_commit(file);\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "file"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "file->path_original"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "path"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "file->path_original"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit_at(git_filebuf *file, const char *path)\n{\n\tgit__free(file->path_original);\n\tfile->path_original = git__strdup(path);\n\tGITERR_CHECK_ALLOC(file->path_original);\n\n\treturn git_filebuf_commit(file);\n}"
  },
  {
    "function_name": "git_filebuf_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "385-399",
    "snippet": "int git_filebuf_hash(git_oid *oid, git_filebuf *file)\n{\n\tassert(oid && file && file->compute_digest);\n\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\treturn -1;\n\n\tgit_hash_final(oid, &file->digest);\n\tgit_hash_ctx_cleanup(&file->digest);\n\tfile->compute_digest = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hash_ctx_cleanup",
          "args": [
            "&file->digest"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "268-276",
          "snippet": "void git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_final",
          "args": [
            "oid",
            "&file->digest"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "37-42",
          "snippet": "GIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_last_error",
          "args": [
            "file"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "verify_last_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "22-41",
          "snippet": "static int verify_last_error(git_filebuf *file)\n{\n\tswitch (file->last_error) {\n\tcase BUFERR_WRITE:\n\t\tgiterr_set(GITERR_OS, \"Failed to write out file\");\n\t\treturn -1;\n\n\tcase BUFERR_MEM:\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\n\tcase BUFERR_ZLIB:\n\t\tgiterr_set(GITERR_ZLIB,\n\t\t\t\"Buffer error when writing out ZLib data\");\n\t\treturn -1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic int verify_last_error(git_filebuf *file)\n{\n\tswitch (file->last_error) {\n\tcase BUFERR_WRITE:\n\t\tgiterr_set(GITERR_OS, \"Failed to write out file\");\n\t\treturn -1;\n\n\tcase BUFERR_MEM:\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\n\tcase BUFERR_ZLIB:\n\t\tgiterr_set(GITERR_ZLIB,\n\t\t\t\"Buffer error when writing out ZLib data\");\n\t\treturn -1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_buffer",
          "args": [
            "file"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "flush_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "135-140",
          "snippet": "GIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "oid && file && file->compute_digest"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_hash(git_oid *oid, git_filebuf *file)\n{\n\tassert(oid && file && file->compute_digest);\n\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\treturn -1;\n\n\tgit_hash_final(oid, &file->digest);\n\tgit_hash_ctx_cleanup(&file->digest);\n\tfile->compute_digest = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_filebuf_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "274-383",
    "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "file"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_file",
          "args": [
            "file",
            "flags",
            "mode"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "43-102",
          "snippet": "static int lock_file(git_filebuf *file, int flags, mode_t mode)\n{\n\tif (git_path_exists(file->path_lock) == true) {\n\t\tif (flags & GIT_FILEBUF_FORCE)\n\t\t\tp_unlink(file->path_lock);\n\t\telse {\n\t\t\tgiterr_clear(); /* actual OS error code just confuses */\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Failed to lock file '%s' for writing\", file->path_lock);\n\t\t\treturn GIT_ELOCKED;\n\t\t}\n\t}\n\n\t/* create path to the file buffer is required */\n\tif (flags & GIT_FILEBUF_FORCE) {\n\t\t/* XXX: Should dirmode here be configurable? Or is 0777 always fine? */\n\t\tfile->fd = git_futils_creat_locked_withpath(file->path_lock, 0777, mode);\n\t} else {\n\t\tfile->fd = git_futils_creat_locked(file->path_lock, mode);\n\t}\n\n\tif (file->fd < 0)\n\t\treturn file->fd;\n\n\tfile->fd_is_open = true;\n\n\tif ((flags & GIT_FILEBUF_APPEND) && git_path_exists(file->path_original) == true) {\n\t\tgit_file source;\n\t\tchar buffer[FILEIO_BUFSIZE];\n\t\tssize_t read_bytes;\n\t\tint error = 0;\n\n\t\tsource = p_open(file->path_original, O_RDONLY);\n\t\tif (source < 0) {\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Failed to open file '%s' for reading\",\n\t\t\t\tfile->path_original);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile ((read_bytes = p_read(source, buffer, sizeof(buffer))) > 0) {\n\t\t\tif ((error = p_write(file->fd, buffer, read_bytes)) < 0)\n\t\t\t\tbreak;\n\t\t\tif (file->compute_digest)\n\t\t\t\tgit_hash_update(&file->digest, buffer, read_bytes);\n\t\t}\n\n\t\tp_close(source);\n\n\t\tif (read_bytes < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to read file '%s'\", file->path_original);\n\t\t\treturn -1;\n\t\t} else if (error < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to write file '%s'\", file->path_lock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic int lock_file(git_filebuf *file, int flags, mode_t mode)\n{\n\tif (git_path_exists(file->path_lock) == true) {\n\t\tif (flags & GIT_FILEBUF_FORCE)\n\t\t\tp_unlink(file->path_lock);\n\t\telse {\n\t\t\tgiterr_clear(); /* actual OS error code just confuses */\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Failed to lock file '%s' for writing\", file->path_lock);\n\t\t\treturn GIT_ELOCKED;\n\t\t}\n\t}\n\n\t/* create path to the file buffer is required */\n\tif (flags & GIT_FILEBUF_FORCE) {\n\t\t/* XXX: Should dirmode here be configurable? Or is 0777 always fine? */\n\t\tfile->fd = git_futils_creat_locked_withpath(file->path_lock, 0777, mode);\n\t} else {\n\t\tfile->fd = git_futils_creat_locked(file->path_lock, mode);\n\t}\n\n\tif (file->fd < 0)\n\t\treturn file->fd;\n\n\tfile->fd_is_open = true;\n\n\tif ((flags & GIT_FILEBUF_APPEND) && git_path_exists(file->path_original) == true) {\n\t\tgit_file source;\n\t\tchar buffer[FILEIO_BUFSIZE];\n\t\tssize_t read_bytes;\n\t\tint error = 0;\n\n\t\tsource = p_open(file->path_original, O_RDONLY);\n\t\tif (source < 0) {\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Failed to open file '%s' for reading\",\n\t\t\t\tfile->path_original);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile ((read_bytes = p_read(source, buffer, sizeof(buffer))) > 0) {\n\t\t\tif ((error = p_write(file->fd, buffer, read_bytes)) < 0)\n\t\t\t\tbreak;\n\t\t\tif (file->compute_digest)\n\t\t\t\tgit_hash_update(&file->digest, buffer, read_bytes);\n\t\t}\n\n\t\tp_close(source);\n\n\t\tif (read_bytes < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to read file '%s'\", file->path_original);\n\t\t\treturn -1;\n\t\t} else if (error < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to write file '%s'\", file->path_lock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_FILESYSTEM",
            "\"path '%s' is a directory\"",
            "file->path_original"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "file->path_original"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "file->path_lock + path_len",
            "GIT_FILELOCK_EXTENSION",
            "GIT_FILELOCK_EXTLENGTH"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "file->path_lock",
            "file->path_original",
            "path_len"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "file->path_lock"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloc_len"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "path_len",
            "GIT_FILELOCK_EXTLENGTH"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&resolved_path"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve_symlink",
          "args": [
            "&resolved_path",
            "path"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "201-272",
          "snippet": "static int resolve_symlink(git_buf *out, const char *path)\n{\n\tint i, error, root;\n\tssize_t ret;\n\tstruct stat st;\n\tgit_buf curpath = GIT_BUF_INIT, target = GIT_BUF_INIT;\n\n\tif ((error = git_buf_grow(&target, GIT_PATH_MAX + 1)) < 0 ||\n\t    (error = git_buf_puts(&curpath, path)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < MAX_SYMLINK_DEPTH; i++) {\n\t\terror = p_lstat(curpath.ptr, &st);\n\t\tif (error < 0 && errno == ENOENT) {\n\t\t\terror = git_buf_puts(out, curpath.ptr);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", curpath.ptr);\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!S_ISLNK(st.st_mode)) {\n\t\t\terror = git_buf_puts(out, curpath.ptr);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tret = p_readlink(curpath.ptr, target.ptr, GIT_PATH_MAX);\n\t\tif (ret < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to read symlink '%s'\", curpath.ptr);\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (ret == GIT_PATH_MAX) {\n\t\t\tgiterr_set(GITERR_INVALID, \"symlink target too long\");\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* readlink(2) won't NUL-terminate for us */\n\t\ttarget.ptr[ret] = '\\0';\n\t\ttarget.size = ret;\n\n\t\troot = git_path_root(target.ptr);\n\t\tif (root >= 0) {\n\t\t\tif ((error = git_buf_puts(&curpath, target.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tgit_buf dir = GIT_BUF_INIT;\n\n\t\t\tif ((error = git_path_dirname_r(&dir, curpath.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_buf_swap(&curpath, &dir);\n\t\t\tgit_buf_free(&dir);\n\n\t\t\tif ((error = git_path_apply_relative(&curpath, target.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tgiterr_set(GITERR_INVALID, \"maximum symlink depth reached\");\n\terror = -1;\n\ncleanup:\n\tgit_buf_free(&curpath);\n\tgit_buf_free(&target);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MAX_SYMLINK_DEPTH 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\n#define MAX_SYMLINK_DEPTH 5\n\nstatic int resolve_symlink(git_buf *out, const char *path)\n{\n\tint i, error, root;\n\tssize_t ret;\n\tstruct stat st;\n\tgit_buf curpath = GIT_BUF_INIT, target = GIT_BUF_INIT;\n\n\tif ((error = git_buf_grow(&target, GIT_PATH_MAX + 1)) < 0 ||\n\t    (error = git_buf_puts(&curpath, path)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < MAX_SYMLINK_DEPTH; i++) {\n\t\terror = p_lstat(curpath.ptr, &st);\n\t\tif (error < 0 && errno == ENOENT) {\n\t\t\terror = git_buf_puts(out, curpath.ptr);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", curpath.ptr);\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!S_ISLNK(st.st_mode)) {\n\t\t\terror = git_buf_puts(out, curpath.ptr);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tret = p_readlink(curpath.ptr, target.ptr, GIT_PATH_MAX);\n\t\tif (ret < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to read symlink '%s'\", curpath.ptr);\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (ret == GIT_PATH_MAX) {\n\t\t\tgiterr_set(GITERR_INVALID, \"symlink target too long\");\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* readlink(2) won't NUL-terminate for us */\n\t\ttarget.ptr[ret] = '\\0';\n\t\ttarget.size = ret;\n\n\t\troot = git_path_root(target.ptr);\n\t\tif (root >= 0) {\n\t\t\tif ((error = git_buf_puts(&curpath, target.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tgit_buf dir = GIT_BUF_INIT;\n\n\t\t\tif ((error = git_path_dirname_r(&dir, curpath.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_buf_swap(&curpath, &dir);\n\t\t\tgit_buf_free(&dir);\n\n\t\t\tif ((error = git_path_apply_relative(&curpath, target.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tgiterr_set(GITERR_INVALID, \"maximum symlink depth reached\");\n\terror = -1;\n\ncleanup:\n\tgit_buf_free(&curpath);\n\tgit_buf_free(&target);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "file->path_lock"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&tmp_path"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mktmp",
          "args": [
            "&tmp_path",
            "path",
            "mode"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mktmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "25-51",
          "snippet": "int git_futils_mktmp(git_buf *path_out, const char *filename, mode_t mode)\n{\n\tint fd;\n\tmode_t mask;\n\n\tp_umask(mask = p_umask(0));\n\n\tgit_buf_sets(path_out, filename);\n\tgit_buf_puts(path_out, \"_git2_XXXXXX\");\n\n\tif (git_buf_oom(path_out))\n\t\treturn -1;\n\n\tif ((fd = p_mkstemp(path_out->ptr)) < 0) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to create temporary file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\tif (p_chmod(path_out->ptr, (mode & ~mask))) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to set permissions on file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mktmp(git_buf *path_out, const char *filename, mode_t mode)\n{\n\tint fd;\n\tmode_t mask;\n\n\tp_umask(mask = p_umask(0));\n\n\tgit_buf_sets(path_out, filename);\n\tgit_buf_puts(path_out, \"_git2_XXXXXX\");\n\n\tif (git_buf_oom(path_out))\n\t\treturn -1;\n\n\tif ((fd = p_mkstemp(path_out->ptr)) < 0) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to create temporary file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\tif (p_chmod(path_out->ptr, (mode & ~mask))) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to set permissions on file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "file->z_buf"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ZLIB",
            "\"Failed to initialize zlib\""
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deflateInit",
          "args": [
            "&file->zs",
            "compression"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_hash_ctx_init",
          "args": [
            "&file->digest"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "231-248",
          "snippet": "int git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct git_hash_prov hash_prov = {0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic struct git_hash_prov hash_prov = {0};\n\nint git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "file->buffer"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "file",
            "0x0",
            "sizeof(git_filebuf)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "file && path && file->buffer == NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
  },
  {
    "function_name": "resolve_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "201-272",
    "snippet": "static int resolve_symlink(git_buf *out, const char *path)\n{\n\tint i, error, root;\n\tssize_t ret;\n\tstruct stat st;\n\tgit_buf curpath = GIT_BUF_INIT, target = GIT_BUF_INIT;\n\n\tif ((error = git_buf_grow(&target, GIT_PATH_MAX + 1)) < 0 ||\n\t    (error = git_buf_puts(&curpath, path)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < MAX_SYMLINK_DEPTH; i++) {\n\t\terror = p_lstat(curpath.ptr, &st);\n\t\tif (error < 0 && errno == ENOENT) {\n\t\t\terror = git_buf_puts(out, curpath.ptr);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", curpath.ptr);\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!S_ISLNK(st.st_mode)) {\n\t\t\terror = git_buf_puts(out, curpath.ptr);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tret = p_readlink(curpath.ptr, target.ptr, GIT_PATH_MAX);\n\t\tif (ret < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to read symlink '%s'\", curpath.ptr);\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (ret == GIT_PATH_MAX) {\n\t\t\tgiterr_set(GITERR_INVALID, \"symlink target too long\");\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* readlink(2) won't NUL-terminate for us */\n\t\ttarget.ptr[ret] = '\\0';\n\t\ttarget.size = ret;\n\n\t\troot = git_path_root(target.ptr);\n\t\tif (root >= 0) {\n\t\t\tif ((error = git_buf_puts(&curpath, target.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tgit_buf dir = GIT_BUF_INIT;\n\n\t\t\tif ((error = git_path_dirname_r(&dir, curpath.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_buf_swap(&curpath, &dir);\n\t\t\tgit_buf_free(&dir);\n\n\t\t\tif ((error = git_path_apply_relative(&curpath, target.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tgiterr_set(GITERR_INVALID, \"maximum symlink depth reached\");\n\terror = -1;\n\ncleanup:\n\tgit_buf_free(&curpath);\n\tgit_buf_free(&target);\n\treturn error;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define MAX_SYMLINK_DEPTH 5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&target"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"maximum symlink depth reached\""
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_apply_relative",
          "args": [
            "&curpath",
            "target.ptr"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_apply_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "782-786",
          "snippet": "int git_path_apply_relative(git_buf *target, const char *relpath)\n{\n\tgit_buf_joinpath(target, git_buf_cstr(target), relpath);\n\treturn git_path_resolve_relative(target, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_apply_relative(git_buf *target, const char *relpath)\n{\n\tgit_buf_joinpath(target, git_buf_cstr(target), relpath);\n\treturn git_path_resolve_relative(target, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_swap",
          "args": [
            "&curpath",
            "&dir"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "470-475",
          "snippet": "void git_buf_swap(git_buf *buf_a, git_buf *buf_b)\n{\n\tgit_buf t = *buf_a;\n\t*buf_a = *buf_b;\n\t*buf_b = t;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_swap(git_buf *buf_a, git_buf *buf_b)\n{\n\tgit_buf t = *buf_a;\n\t*buf_a = *buf_b;\n\t*buf_b = t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_dirname_r",
          "args": [
            "&dir",
            "curpath.ptr"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_dirname_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "117-178",
          "snippet": "int git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&curpath",
            "target.ptr"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "target.ptr"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to read symlink '%s'\"",
            "curpath.ptr"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_readlink",
          "args": [
            "curpath.ptr",
            "target.ptr",
            "GIT_PATH_MAX"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "p_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "251-273",
          "snippet": "int p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st.st_mode"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_lstat",
          "args": [
            "curpath.ptr",
            "&st"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "p_lstat_posixly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "208-211",
          "snippet": "int p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "&target",
            "GIT_PATH_MAX + 1"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\n#define MAX_SYMLINK_DEPTH 5\n\nstatic int resolve_symlink(git_buf *out, const char *path)\n{\n\tint i, error, root;\n\tssize_t ret;\n\tstruct stat st;\n\tgit_buf curpath = GIT_BUF_INIT, target = GIT_BUF_INIT;\n\n\tif ((error = git_buf_grow(&target, GIT_PATH_MAX + 1)) < 0 ||\n\t    (error = git_buf_puts(&curpath, path)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < MAX_SYMLINK_DEPTH; i++) {\n\t\terror = p_lstat(curpath.ptr, &st);\n\t\tif (error < 0 && errno == ENOENT) {\n\t\t\terror = git_buf_puts(out, curpath.ptr);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", curpath.ptr);\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!S_ISLNK(st.st_mode)) {\n\t\t\terror = git_buf_puts(out, curpath.ptr);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tret = p_readlink(curpath.ptr, target.ptr, GIT_PATH_MAX);\n\t\tif (ret < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to read symlink '%s'\", curpath.ptr);\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (ret == GIT_PATH_MAX) {\n\t\t\tgiterr_set(GITERR_INVALID, \"symlink target too long\");\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* readlink(2) won't NUL-terminate for us */\n\t\ttarget.ptr[ret] = '\\0';\n\t\ttarget.size = ret;\n\n\t\troot = git_path_root(target.ptr);\n\t\tif (root >= 0) {\n\t\t\tif ((error = git_buf_puts(&curpath, target.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tgit_buf dir = GIT_BUF_INIT;\n\n\t\t\tif ((error = git_path_dirname_r(&dir, curpath.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_buf_swap(&curpath, &dir);\n\t\t\tgit_buf_free(&dir);\n\n\t\t\tif ((error = git_path_apply_relative(&curpath, target.ptr)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tgiterr_set(GITERR_INVALID, \"maximum symlink depth reached\");\n\terror = -1;\n\ncleanup:\n\tgit_buf_free(&curpath);\n\tgit_buf_free(&target);\n\treturn error;\n}"
  },
  {
    "function_name": "write_deflate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "162-197",
    "snippet": "static int write_deflate(git_filebuf *file, void *source, size_t len)\n{\n\tz_stream *zs = &file->zs;\n\n\tif (len > 0 || file->flush_mode == Z_FINISH) {\n\t\tzs->next_in = source;\n\t\tzs->avail_in = (uInt)len;\n\n\t\tdo {\n\t\t\tsize_t have;\n\n\t\t\tzs->next_out = file->z_buf;\n\t\t\tzs->avail_out = (uInt)file->buf_size;\n\n\t\t\tif (deflate(zs, file->flush_mode) == Z_STREAM_ERROR) {\n\t\t\t\tfile->last_error = BUFERR_ZLIB;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\thave = file->buf_size - (size_t)zs->avail_out;\n\n\t\t\tif (p_write(file->fd, file->z_buf, have) < 0) {\n\t\t\t\tfile->last_error = BUFERR_WRITE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t} while (zs->avail_out == 0);\n\n\t\tassert(zs->avail_in == 0);\n\n\t\tif (file->compute_digest)\n\t\t\tgit_hash_update(&file->digest, source, len);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hash_update",
          "args": [
            "&file->digest",
            "source",
            "len"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "30-35",
          "snippet": "GIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "zs->avail_in == 0"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write",
          "args": [
            "file->fd",
            "file->z_buf",
            "have"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "p_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "189-214",
          "snippet": "int p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deflate",
          "args": [
            "zs",
            "file->flush_mode"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic int write_deflate(git_filebuf *file, void *source, size_t len)\n{\n\tz_stream *zs = &file->zs;\n\n\tif (len > 0 || file->flush_mode == Z_FINISH) {\n\t\tzs->next_in = source;\n\t\tzs->avail_in = (uInt)len;\n\n\t\tdo {\n\t\t\tsize_t have;\n\n\t\t\tzs->next_out = file->z_buf;\n\t\t\tzs->avail_out = (uInt)file->buf_size;\n\n\t\t\tif (deflate(zs, file->flush_mode) == Z_STREAM_ERROR) {\n\t\t\t\tfile->last_error = BUFERR_ZLIB;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\thave = file->buf_size - (size_t)zs->avail_out;\n\n\t\t\tif (p_write(file->fd, file->z_buf, have) < 0) {\n\t\t\t\tfile->last_error = BUFERR_WRITE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t} while (zs->avail_out == 0);\n\n\t\tassert(zs->avail_in == 0);\n\n\t\tif (file->compute_digest)\n\t\t\tgit_hash_update(&file->digest, source, len);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "write_normal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "147-160",
    "snippet": "static int write_normal(git_filebuf *file, void *source, size_t len)\n{\n\tif (len > 0) {\n\t\tif (p_write(file->fd, (void *)source, len) < 0) {\n\t\t\tfile->last_error = BUFERR_WRITE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (file->compute_digest)\n\t\t\tgit_hash_update(&file->digest, source, len);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hash_update",
          "args": [
            "&file->digest",
            "source",
            "len"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "30-35",
          "snippet": "GIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write",
          "args": [
            "file->fd",
            "(void *)source",
            "len"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "p_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "189-214",
          "snippet": "int p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic int write_normal(git_filebuf *file, void *source, size_t len)\n{\n\tif (len > 0) {\n\t\tif (p_write(file->fd, (void *)source, len) < 0) {\n\t\t\tfile->last_error = BUFERR_WRITE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (file->compute_digest)\n\t\t\tgit_hash_update(&file->digest, source, len);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_filebuf_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "142-145",
    "snippet": "int git_filebuf_flush(git_filebuf *file)\n{\n\treturn flush_buffer(file);\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_buffer",
          "args": [
            "file"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "flush_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "135-140",
          "snippet": "GIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_flush(git_filebuf *file)\n{\n\treturn flush_buffer(file);\n}"
  },
  {
    "function_name": "flush_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "135-140",
    "snippet": "GIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file->write",
          "args": [
            "file",
            "file->buffer",
            "file->buf_pos"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) flush_buffer(git_filebuf *file)\n{\n\tint result = file->write(file, file->buffer, file->buf_pos);\n\tfile->buf_pos = 0;\n\treturn result;\n}"
  },
  {
    "function_name": "git_filebuf_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "104-133",
    "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "file",
            "0x0",
            "sizeof(git_filebuf)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "file->path_lock"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deflateEnd",
          "args": [
            "&file->zs"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_hash_ctx_cleanup",
          "args": [
            "&file->digest"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "268-276",
          "snippet": "void git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "file->path_lock"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "file->path_lock"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "file->fd"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
  },
  {
    "function_name": "lock_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "43-102",
    "snippet": "static int lock_file(git_filebuf *file, int flags, mode_t mode)\n{\n\tif (git_path_exists(file->path_lock) == true) {\n\t\tif (flags & GIT_FILEBUF_FORCE)\n\t\t\tp_unlink(file->path_lock);\n\t\telse {\n\t\t\tgiterr_clear(); /* actual OS error code just confuses */\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Failed to lock file '%s' for writing\", file->path_lock);\n\t\t\treturn GIT_ELOCKED;\n\t\t}\n\t}\n\n\t/* create path to the file buffer is required */\n\tif (flags & GIT_FILEBUF_FORCE) {\n\t\t/* XXX: Should dirmode here be configurable? Or is 0777 always fine? */\n\t\tfile->fd = git_futils_creat_locked_withpath(file->path_lock, 0777, mode);\n\t} else {\n\t\tfile->fd = git_futils_creat_locked(file->path_lock, mode);\n\t}\n\n\tif (file->fd < 0)\n\t\treturn file->fd;\n\n\tfile->fd_is_open = true;\n\n\tif ((flags & GIT_FILEBUF_APPEND) && git_path_exists(file->path_original) == true) {\n\t\tgit_file source;\n\t\tchar buffer[FILEIO_BUFSIZE];\n\t\tssize_t read_bytes;\n\t\tint error = 0;\n\n\t\tsource = p_open(file->path_original, O_RDONLY);\n\t\tif (source < 0) {\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Failed to open file '%s' for reading\",\n\t\t\t\tfile->path_original);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile ((read_bytes = p_read(source, buffer, sizeof(buffer))) > 0) {\n\t\t\tif ((error = p_write(file->fd, buffer, read_bytes)) < 0)\n\t\t\t\tbreak;\n\t\t\tif (file->compute_digest)\n\t\t\t\tgit_hash_update(&file->digest, buffer, read_bytes);\n\t\t}\n\n\t\tp_close(source);\n\n\t\tif (read_bytes < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to read file '%s'\", file->path_original);\n\t\t\treturn -1;\n\t\t} else if (error < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to write file '%s'\", file->path_lock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to write file '%s'\"",
            "file->path_lock"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "source"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_update",
          "args": [
            "&file->digest",
            "buffer",
            "read_bytes"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "30-35",
          "snippet": "GIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write",
          "args": [
            "file->fd",
            "buffer",
            "read_bytes"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "p_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "189-214",
          "snippet": "int p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_read",
          "args": [
            "source",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "p_readdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.h",
          "lines": "126-131",
          "snippet": "GIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <netdb.h>",
            "#include \"strnlen.h\"",
            "#\tinclude \"unix/posix.h\"",
            "#\tinclude \"win32/posix.h\"",
            "#include \"fnmatch.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <netdb.h>\n#include \"strnlen.h\"\n#\tinclude \"unix/posix.h\"\n#\tinclude \"win32/posix.h\"\n#include \"fnmatch.h\"\n#include <time.h>\n#include <fcntl.h>\n#include \"common.h\"\n\nGIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_open",
          "args": [
            "file->path_original",
            "O_RDONLY"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "p_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "105-118",
          "snippet": "int p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "file->path_original"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_creat_locked",
          "args": [
            "file->path_lock",
            "mode"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_creat_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "69-80",
          "snippet": "int git_futils_creat_locked(const char *path, const mode_t mode)\n{\n\tint fd = p_open(path, O_WRONLY | O_CREAT | O_TRUNC |\n\t\tO_EXCL | O_BINARY | O_CLOEXEC, mode);\n\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create locked file '%s'\", path);\n\t\treturn errno == EEXIST ? GIT_ELOCKED : -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_creat_locked(const char *path, const mode_t mode)\n{\n\tint fd = p_open(path, O_WRONLY | O_CREAT | O_TRUNC |\n\t\tO_EXCL | O_BINARY | O_CLOEXEC, mode);\n\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create locked file '%s'\", path);\n\t\treturn errno == EEXIST ? GIT_ELOCKED : -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_creat_locked_withpath",
          "args": [
            "file->path_lock",
            "0777",
            "mode"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_creat_locked_withpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "82-88",
          "snippet": "int git_futils_creat_locked_withpath(const char *path, const mode_t dirmode, const mode_t mode)\n{\n\tif (git_futils_mkpath2file(path, dirmode) < 0)\n\t\treturn -1;\n\n\treturn git_futils_creat_locked(path, mode);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_creat_locked_withpath(const char *path, const mode_t dirmode, const mode_t mode)\n{\n\tif (git_futils_mkpath2file(path, dirmode) < 0)\n\t\treturn -1;\n\n\treturn git_futils_creat_locked(path, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "file->path_lock"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic int lock_file(git_filebuf *file, int flags, mode_t mode)\n{\n\tif (git_path_exists(file->path_lock) == true) {\n\t\tif (flags & GIT_FILEBUF_FORCE)\n\t\t\tp_unlink(file->path_lock);\n\t\telse {\n\t\t\tgiterr_clear(); /* actual OS error code just confuses */\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Failed to lock file '%s' for writing\", file->path_lock);\n\t\t\treturn GIT_ELOCKED;\n\t\t}\n\t}\n\n\t/* create path to the file buffer is required */\n\tif (flags & GIT_FILEBUF_FORCE) {\n\t\t/* XXX: Should dirmode here be configurable? Or is 0777 always fine? */\n\t\tfile->fd = git_futils_creat_locked_withpath(file->path_lock, 0777, mode);\n\t} else {\n\t\tfile->fd = git_futils_creat_locked(file->path_lock, mode);\n\t}\n\n\tif (file->fd < 0)\n\t\treturn file->fd;\n\n\tfile->fd_is_open = true;\n\n\tif ((flags & GIT_FILEBUF_APPEND) && git_path_exists(file->path_original) == true) {\n\t\tgit_file source;\n\t\tchar buffer[FILEIO_BUFSIZE];\n\t\tssize_t read_bytes;\n\t\tint error = 0;\n\n\t\tsource = p_open(file->path_original, O_RDONLY);\n\t\tif (source < 0) {\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Failed to open file '%s' for reading\",\n\t\t\t\tfile->path_original);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile ((read_bytes = p_read(source, buffer, sizeof(buffer))) > 0) {\n\t\t\tif ((error = p_write(file->fd, buffer, read_bytes)) < 0)\n\t\t\t\tbreak;\n\t\t\tif (file->compute_digest)\n\t\t\t\tgit_hash_update(&file->digest, buffer, read_bytes);\n\t\t}\n\n\t\tp_close(source);\n\n\t\tif (read_bytes < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to read file '%s'\", file->path_original);\n\t\t\treturn -1;\n\t\t} else if (error < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to write file '%s'\", file->path_lock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "verify_last_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
    "lines": "22-41",
    "snippet": "static int verify_last_error(git_filebuf *file)\n{\n\tswitch (file->last_error) {\n\tcase BUFERR_WRITE:\n\t\tgiterr_set(GITERR_OS, \"Failed to write out file\");\n\t\treturn -1;\n\n\tcase BUFERR_MEM:\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\n\tcase BUFERR_ZLIB:\n\t\tgiterr_set(GITERR_ZLIB,\n\t\t\t\"Buffer error when writing out ZLib data\");\n\t\treturn -1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"fileops.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ZLIB",
            "\"Buffer error when writing out ZLib data\""
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_oom",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "45-48",
          "snippet": "void giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};\n\nvoid giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic int verify_last_error(git_filebuf *file)\n{\n\tswitch (file->last_error) {\n\tcase BUFERR_WRITE:\n\t\tgiterr_set(GITERR_OS, \"Failed to write out file\");\n\t\treturn -1;\n\n\tcase BUFERR_MEM:\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\n\tcase BUFERR_ZLIB:\n\t\tgiterr_set(GITERR_ZLIB,\n\t\t\t\"Buffer error when writing out ZLib data\");\n\t\treturn -1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  }
]