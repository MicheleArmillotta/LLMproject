[
  {
    "function_name": "sha1_position",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sha1_lookup.c",
    "lines": "228-249",
    "snippet": "int sha1_position(const void *table,\n\t\t\tsize_t stride,\n\t\t\tunsigned lo, unsigned hi,\n\t\t\tconst unsigned char *key)\n{\n\tconst unsigned char *base = table;\n\n\tdo {\n\t\tunsigned mi = (lo + hi) / 2;\n\t\tint cmp = git_oid__hashcmp(base + mi * stride, key);\n\n\t\tif (!cmp)\n\t\t\treturn mi;\n\n\t\tif (cmp > 0)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi+1;\n\t} while (lo < hi);\n\n\treturn -((int)lo)-1;\n}",
    "includes": [
      "#include \"oid.h\"",
      "#include \"common.h\"",
      "#include \"sha1_lookup.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid__hashcmp",
          "args": [
            "base + mi * stride",
            "key"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__hashcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "23-33",
          "snippet": "GIT_INLINE(int) git_oid__hashcmp(const unsigned char *sha1, const unsigned char *sha2)\n{\n\tint i;\n\n\tfor (i = 0; i < GIT_OID_RAWSZ; i++, sha1++, sha2++) {\n\t\tif (*sha1 != *sha2)\n\t\t\treturn *sha1 - *sha2;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__hashcmp(const unsigned char *sha1, const unsigned char *sha2)\n{\n\tint i;\n\n\tfor (i = 0; i < GIT_OID_RAWSZ; i++, sha1++, sha2++) {\n\t\tif (*sha1 != *sha2)\n\t\t\treturn *sha1 - *sha2;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oid.h\"\n#include \"common.h\"\n#include \"sha1_lookup.h\"\n#include <stdio.h>\n\nint sha1_position(const void *table,\n\t\t\tsize_t stride,\n\t\t\tunsigned lo, unsigned hi,\n\t\t\tconst unsigned char *key)\n{\n\tconst unsigned char *base = table;\n\n\tdo {\n\t\tunsigned mi = (lo + hi) / 2;\n\t\tint cmp = git_oid__hashcmp(base + mi * stride, key);\n\n\t\tif (!cmp)\n\t\t\treturn mi;\n\n\t\tif (cmp > 0)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi+1;\n\t} while (lo < hi);\n\n\treturn -((int)lo)-1;\n}"
  },
  {
    "function_name": "sha1_entry_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sha1_lookup.c",
    "lines": "76-226",
    "snippet": "int sha1_entry_pos(const void *table,\n\t\t\tsize_t elem_size,\n\t\t\tsize_t key_offset,\n\t\t\tunsigned lo, unsigned hi, unsigned nr,\n\t\t\tconst unsigned char *key)\n{\n\tconst unsigned char *base = (const unsigned char*)table;\n\tconst unsigned char *hi_key, *lo_key;\n\tunsigned ofs_0;\n\n\tif (!nr || lo >= hi)\n\t\treturn -1;\n\n\tif (nr == hi)\n\t\thi_key = NULL;\n\telse\n\t\thi_key = base + elem_size * hi + key_offset;\n\tlo_key = base + elem_size * lo + key_offset;\n\n\tofs_0 = 0;\n\tdo {\n\t\tint cmp;\n\t\tunsigned ofs, mi, range;\n\t\tunsigned lov, hiv, kyv;\n\t\tconst unsigned char *mi_key;\n\n\t\trange = hi - lo;\n\t\tif (hi_key) {\n\t\t\tfor (ofs = ofs_0; ofs < 20; ofs++)\n\t\t\t\tif (lo_key[ofs] != hi_key[ofs])\n\t\t\t\t\tbreak;\n\t\t\tofs_0 = ofs;\n\t\t\t/*\n\t\t\t * byte 0 thru (ofs-1) are the same between\n\t\t\t * lo and hi; ofs is the first byte that is\n\t\t\t * different.\n\t\t\t *\n\t\t\t * If ofs==20, then no bytes are different,\n\t\t\t * meaning we have entries with duplicate\n\t\t\t * keys. We know that we are in a solid run\n\t\t\t * of this entry (because the entries are\n\t\t\t * sorted, and our lo and hi are the same,\n\t\t\t * there can be nothing but this single key\n\t\t\t * in between). So we can stop the search.\n\t\t\t * Either one of these entries is it (and\n\t\t\t * we do not care which), or we do not have\n\t\t\t * it.\n\t\t\t *\n\t\t\t * Furthermore, we know that one of our\n\t\t\t * endpoints must be the edge of the run of\n\t\t\t * duplicates. For example, given this\n\t\t\t * sequence:\n\t\t\t *\n\t\t\t *     idx 0 1 2 3 4 5\n\t\t\t *     key A C C C C D\n\t\t\t *\n\t\t\t * If we are searching for \"B\", we might\n\t\t\t * hit the duplicate run at lo=1, hi=3\n\t\t\t * (e.g., by first mi=3, then mi=0). But we\n\t\t\t * can never have lo > 1, because B < C.\n\t\t\t * That is, if our key is less than the\n\t\t\t * run, we know that \"lo\" is the edge, but\n\t\t\t * we can say nothing of \"hi\". Similarly,\n\t\t\t * if our key is greater than the run, we\n\t\t\t * know that \"hi\" is the edge, but we can\n\t\t\t * say nothing of \"lo\".\n\t\t\t *\n\t\t\t * Therefore if we do not find it, we also\n\t\t\t * know where it would go if it did exist:\n\t\t\t * just on the far side of the edge that we\n\t\t\t * know about.\n\t\t\t */\n\t\t\tif (ofs == 20) {\n\t\t\t\tmi = lo;\n\t\t\t\tmi_key = base + elem_size * mi + key_offset;\n\t\t\t\tcmp = memcmp(mi_key, key, 20);\n\t\t\t\tif (!cmp)\n\t\t\t\t\treturn mi;\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\treturn -1 - hi;\n\t\t\t\telse\n\t\t\t\t\treturn -1 - lo;\n\t\t\t}\n\n\t\t\thiv = hi_key[ofs_0];\n\t\t\tif (ofs_0 < 19)\n\t\t\t\thiv = (hiv << 8) | hi_key[ofs_0+1];\n\t\t} else {\n\t\t\thiv = 256;\n\t\t\tif (ofs_0 < 19)\n\t\t\t\thiv <<= 8;\n\t\t}\n\t\tlov = lo_key[ofs_0];\n\t\tkyv = key[ofs_0];\n\t\tif (ofs_0 < 19) {\n\t\t\tlov = (lov << 8) | lo_key[ofs_0+1];\n\t\t\tkyv = (kyv << 8) | key[ofs_0+1];\n\t\t}\n\t\tassert(lov < hiv);\n\n\t\tif (kyv < lov)\n\t\t\treturn -1 - lo;\n\t\tif (hiv < kyv)\n\t\t\treturn -1 - hi;\n\n\t\t/*\n\t\t * Even if we know the target is much closer to 'hi'\n\t\t * than 'lo', if we pick too precisely and overshoot\n\t\t * (e.g. when we know 'mi' is closer to 'hi' than to\n\t\t * 'lo', pick 'mi' that is higher than the target), we\n\t\t * end up narrowing the search space by a smaller\n\t\t * amount (i.e. the distance between 'mi' and 'hi')\n\t\t * than what we would have (i.e. about half of 'lo'\n\t\t * and 'hi'). Hedge our bets to pick 'mi' less\n\t\t * aggressively, i.e. make 'mi' a bit closer to the\n\t\t * middle than we would otherwise pick.\n\t\t */\n\t\tkyv = (kyv * 6 + lov + hiv) / 8;\n\t\tif (lov < hiv - 1) {\n\t\t\tif (kyv == lov)\n\t\t\t\tkyv++;\n\t\t\telse if (kyv == hiv)\n\t\t\t\tkyv--;\n\t\t}\n\t\tmi = (range - 1) * (kyv - lov) / (hiv - lov) + lo;\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t\tprintf(\"lo %u hi %u rg %u mi %u \", lo, hi, range, mi);\n\t\tprintf(\"ofs %u lov %x, hiv %x, kyv %x\\n\",\n\t\t\t\tofs_0, lov, hiv, kyv);\n#endif\n\n\t\tif (!(lo <= mi && mi < hi)) {\n\t\t\tgiterr_set(GITERR_INVALID, \"Assertion failure. Binary search invariant is false\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmi_key = base + elem_size * mi + key_offset;\n\t\tcmp = memcmp(mi_key + ofs_0, key + ofs_0, 20 - ofs_0);\n\t\tif (!cmp)\n\t\t\treturn mi;\n\t\tif (cmp > 0) {\n\t\t\thi = mi;\n\t\t\thi_key = mi_key;\n\t\t} else {\n\t\t\tlo = mi + 1;\n\t\t\tlo_key = mi_key + elem_size;\n\t\t}\n\t} while (lo < hi);\n\treturn -((int)lo)-1;\n}",
    "includes": [
      "#include \"oid.h\"",
      "#include \"common.h\"",
      "#include \"sha1_lookup.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mi_key + ofs_0",
            "key + ofs_0",
            "20 - ofs_0"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Assertion failure. Binary search invariant is false\""
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ofs %u lov %x, hiv %x, kyv %x\\n\"",
            "ofs_0",
            "lov",
            "hiv",
            "kyv"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "lov < hiv"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mi_key",
            "key",
            "20"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"oid.h\"\n#include \"common.h\"\n#include \"sha1_lookup.h\"\n#include <stdio.h>\n\nint sha1_entry_pos(const void *table,\n\t\t\tsize_t elem_size,\n\t\t\tsize_t key_offset,\n\t\t\tunsigned lo, unsigned hi, unsigned nr,\n\t\t\tconst unsigned char *key)\n{\n\tconst unsigned char *base = (const unsigned char*)table;\n\tconst unsigned char *hi_key, *lo_key;\n\tunsigned ofs_0;\n\n\tif (!nr || lo >= hi)\n\t\treturn -1;\n\n\tif (nr == hi)\n\t\thi_key = NULL;\n\telse\n\t\thi_key = base + elem_size * hi + key_offset;\n\tlo_key = base + elem_size * lo + key_offset;\n\n\tofs_0 = 0;\n\tdo {\n\t\tint cmp;\n\t\tunsigned ofs, mi, range;\n\t\tunsigned lov, hiv, kyv;\n\t\tconst unsigned char *mi_key;\n\n\t\trange = hi - lo;\n\t\tif (hi_key) {\n\t\t\tfor (ofs = ofs_0; ofs < 20; ofs++)\n\t\t\t\tif (lo_key[ofs] != hi_key[ofs])\n\t\t\t\t\tbreak;\n\t\t\tofs_0 = ofs;\n\t\t\t/*\n\t\t\t * byte 0 thru (ofs-1) are the same between\n\t\t\t * lo and hi; ofs is the first byte that is\n\t\t\t * different.\n\t\t\t *\n\t\t\t * If ofs==20, then no bytes are different,\n\t\t\t * meaning we have entries with duplicate\n\t\t\t * keys. We know that we are in a solid run\n\t\t\t * of this entry (because the entries are\n\t\t\t * sorted, and our lo and hi are the same,\n\t\t\t * there can be nothing but this single key\n\t\t\t * in between). So we can stop the search.\n\t\t\t * Either one of these entries is it (and\n\t\t\t * we do not care which), or we do not have\n\t\t\t * it.\n\t\t\t *\n\t\t\t * Furthermore, we know that one of our\n\t\t\t * endpoints must be the edge of the run of\n\t\t\t * duplicates. For example, given this\n\t\t\t * sequence:\n\t\t\t *\n\t\t\t *     idx 0 1 2 3 4 5\n\t\t\t *     key A C C C C D\n\t\t\t *\n\t\t\t * If we are searching for \"B\", we might\n\t\t\t * hit the duplicate run at lo=1, hi=3\n\t\t\t * (e.g., by first mi=3, then mi=0). But we\n\t\t\t * can never have lo > 1, because B < C.\n\t\t\t * That is, if our key is less than the\n\t\t\t * run, we know that \"lo\" is the edge, but\n\t\t\t * we can say nothing of \"hi\". Similarly,\n\t\t\t * if our key is greater than the run, we\n\t\t\t * know that \"hi\" is the edge, but we can\n\t\t\t * say nothing of \"lo\".\n\t\t\t *\n\t\t\t * Therefore if we do not find it, we also\n\t\t\t * know where it would go if it did exist:\n\t\t\t * just on the far side of the edge that we\n\t\t\t * know about.\n\t\t\t */\n\t\t\tif (ofs == 20) {\n\t\t\t\tmi = lo;\n\t\t\t\tmi_key = base + elem_size * mi + key_offset;\n\t\t\t\tcmp = memcmp(mi_key, key, 20);\n\t\t\t\tif (!cmp)\n\t\t\t\t\treturn mi;\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\treturn -1 - hi;\n\t\t\t\telse\n\t\t\t\t\treturn -1 - lo;\n\t\t\t}\n\n\t\t\thiv = hi_key[ofs_0];\n\t\t\tif (ofs_0 < 19)\n\t\t\t\thiv = (hiv << 8) | hi_key[ofs_0+1];\n\t\t} else {\n\t\t\thiv = 256;\n\t\t\tif (ofs_0 < 19)\n\t\t\t\thiv <<= 8;\n\t\t}\n\t\tlov = lo_key[ofs_0];\n\t\tkyv = key[ofs_0];\n\t\tif (ofs_0 < 19) {\n\t\t\tlov = (lov << 8) | lo_key[ofs_0+1];\n\t\t\tkyv = (kyv << 8) | key[ofs_0+1];\n\t\t}\n\t\tassert(lov < hiv);\n\n\t\tif (kyv < lov)\n\t\t\treturn -1 - lo;\n\t\tif (hiv < kyv)\n\t\t\treturn -1 - hi;\n\n\t\t/*\n\t\t * Even if we know the target is much closer to 'hi'\n\t\t * than 'lo', if we pick too precisely and overshoot\n\t\t * (e.g. when we know 'mi' is closer to 'hi' than to\n\t\t * 'lo', pick 'mi' that is higher than the target), we\n\t\t * end up narrowing the search space by a smaller\n\t\t * amount (i.e. the distance between 'mi' and 'hi')\n\t\t * than what we would have (i.e. about half of 'lo'\n\t\t * and 'hi'). Hedge our bets to pick 'mi' less\n\t\t * aggressively, i.e. make 'mi' a bit closer to the\n\t\t * middle than we would otherwise pick.\n\t\t */\n\t\tkyv = (kyv * 6 + lov + hiv) / 8;\n\t\tif (lov < hiv - 1) {\n\t\t\tif (kyv == lov)\n\t\t\t\tkyv++;\n\t\t\telse if (kyv == hiv)\n\t\t\t\tkyv--;\n\t\t}\n\t\tmi = (range - 1) * (kyv - lov) / (hiv - lov) + lo;\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t\tprintf(\"lo %u hi %u rg %u mi %u \", lo, hi, range, mi);\n\t\tprintf(\"ofs %u lov %x, hiv %x, kyv %x\\n\",\n\t\t\t\tofs_0, lov, hiv, kyv);\n#endif\n\n\t\tif (!(lo <= mi && mi < hi)) {\n\t\t\tgiterr_set(GITERR_INVALID, \"Assertion failure. Binary search invariant is false\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmi_key = base + elem_size * mi + key_offset;\n\t\tcmp = memcmp(mi_key + ofs_0, key + ofs_0, 20 - ofs_0);\n\t\tif (!cmp)\n\t\t\treturn mi;\n\t\tif (cmp > 0) {\n\t\t\thi = mi;\n\t\t\thi_key = mi_key;\n\t\t} else {\n\t\t\tlo = mi + 1;\n\t\t\tlo_key = mi_key + elem_size;\n\t\t}\n\t} while (lo < hi);\n\treturn -((int)lo)-1;\n}"
  }
]