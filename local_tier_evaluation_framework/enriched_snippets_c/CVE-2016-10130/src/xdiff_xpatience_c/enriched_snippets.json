[
  {
    "function_name": "xdl_do_patience_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
    "lines": "349-358",
    "snippet": "int xdl_do_patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env)\n{\n\tif (xdl_prepare_env(file1, file2, xpp, env) < 0)\n\t\treturn -1;\n\n\t/* environment is cleaned up in xdl_diff() */\n\treturn patience_diff(file1, file2, xpp, env,\n\t\t\t1, env->xdf1.nrec, 1, env->xdf2.nrec);\n}",
    "includes": [
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patience_diff",
          "args": [
            "file1",
            "file2",
            "xpp",
            "env",
            "1",
            "env->xdf1.nrec",
            "1",
            "env->xdf2.nrec"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "patience_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "303-347",
          "snippet": "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tstruct hashmap map;\n\tstruct entry *first;\n\tint result = 0;\n\n\t/* trivial case: one side is empty */\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&map, 0, sizeof(map));\n\tif (fill_hashmap(file1, file2, xpp, env, &map,\n\t\t\tline1, count1, line2, count2))\n\t\treturn -1;\n\n\t/* are there any matching lines at all? */\n\tif (!map.has_matches) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\txdl_free(map.entries);\n\t\treturn 0;\n\t}\n\n\tfirst = find_longest_common_sequence(&map);\n\tif (first)\n\t\tresult = walk_common_sequence(&map, first,\n\t\t\tline1, count1, line2, count2);\n\telse\n\t\tresult = fall_back_to_classic_diff(&map,\n\t\t\tline1, count1, line2, count2);\n\n\txdl_free(map.entries);\n\treturn result;\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tstruct hashmap map;\n\tstruct entry *first;\n\tint result = 0;\n\n\t/* trivial case: one side is empty */\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&map, 0, sizeof(map));\n\tif (fill_hashmap(file1, file2, xpp, env, &map,\n\t\t\tline1, count1, line2, count2))\n\t\treturn -1;\n\n\t/* are there any matching lines at all? */\n\tif (!map.has_matches) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\txdl_free(map.entries);\n\t\treturn 0;\n\t}\n\n\tfirst = find_longest_common_sequence(&map);\n\tif (first)\n\t\tresult = walk_common_sequence(&map, first,\n\t\t\tline1, count1, line2, count2);\n\telse\n\t\tresult = fall_back_to_classic_diff(&map,\n\t\t\tline1, count1, line2, count2);\n\n\txdl_free(map.entries);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_prepare_env",
          "args": [
            "file1",
            "file2",
            "xpp",
            "env"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_prepare_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "262-312",
          "snippet": "int xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF &&\n\t    xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)\n\t\txdl_free_classifier(&cf);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_GUESS_NLINES2 20",
            "#define XDL_GUESS_NLINES1 256"
          ],
          "globals_used": [
            "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
            "static void xdl_free_classifier(xdlclassifier_t *cf);",
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\n#define XDL_GUESS_NLINES2 20\n#define XDL_GUESS_NLINES1 256\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nint xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF &&\n\t    xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)\n\t\txdl_free_classifier(&cf);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nint xdl_do_patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env)\n{\n\tif (xdl_prepare_env(file1, file2, xpp, env) < 0)\n\t\treturn -1;\n\n\t/* environment is cleaned up in xdl_diff() */\n\treturn patience_diff(file1, file2, xpp, env,\n\t\t\t1, env->xdf1.nrec, 1, env->xdf2.nrec);\n}"
  },
  {
    "function_name": "patience_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
    "lines": "303-347",
    "snippet": "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tstruct hashmap map;\n\tstruct entry *first;\n\tint result = 0;\n\n\t/* trivial case: one side is empty */\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&map, 0, sizeof(map));\n\tif (fill_hashmap(file1, file2, xpp, env, &map,\n\t\t\tline1, count1, line2, count2))\n\t\treturn -1;\n\n\t/* are there any matching lines at all? */\n\tif (!map.has_matches) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\txdl_free(map.entries);\n\t\treturn 0;\n\t}\n\n\tfirst = find_longest_common_sequence(&map);\n\tif (first)\n\t\tresult = walk_common_sequence(&map, first,\n\t\t\tline1, count1, line2, count2);\n\telse\n\t\tresult = fall_back_to_classic_diff(&map,\n\t\t\tline1, count1, line2, count2);\n\n\txdl_free(map.entries);\n\treturn result;\n}",
    "includes": [
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "map.entries"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fall_back_to_classic_diff",
          "args": [
            "&map",
            "line1",
            "count1",
            "line2",
            "count2"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "fall_back_to_classic_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "287-295",
          "snippet": "static int fall_back_to_classic_diff(struct hashmap *map,\n\t\tint line1, int count1, int line2, int count2)\n{\n\txpparam_t xpp;\n\txpp.flags = map->xpp->flags & ~XDF_DIFF_ALGORITHM_MASK;\n\n\treturn xdl_fall_back_diff(map->env, &xpp,\n\t\t\t\t  line1, count1, line2, count2);\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int fall_back_to_classic_diff(struct hashmap *map,\n\t\tint line1, int count1, int line2, int count2)\n{\n\txpparam_t xpp;\n\txpp.flags = map->xpp->flags & ~XDF_DIFF_ALGORITHM_MASK;\n\n\treturn xdl_fall_back_diff(map->env, &xpp,\n\t\t\t\t  line1, count1, line2, count2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_common_sequence",
          "args": [
            "&map",
            "first",
            "line1",
            "count1",
            "line2",
            "count2"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "walk_common_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "234-285",
          "snippet": "static int walk_common_sequence(struct hashmap *map, struct entry *first,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tint end1 = line1 + count1, end2 = line2 + count2;\n\tint next1, next2;\n\n\tfor (;;) {\n\t\t/* Try to grow the line ranges of common lines */\n\t\tif (first) {\n\t\t\tnext1 = first->line1;\n\t\t\tnext2 = first->line2;\n\t\t\twhile (next1 > line1 && next2 > line2 &&\n\t\t\t\t\tmatch(map, next1 - 1, next2 - 1)) {\n\t\t\t\tnext1--;\n\t\t\t\tnext2--;\n\t\t\t}\n\t\t} else {\n\t\t\tnext1 = end1;\n\t\t\tnext2 = end2;\n\t\t}\n\t\twhile (line1 < next1 && line2 < next2 &&\n\t\t\t\tmatch(map, line1, line2)) {\n\t\t\tline1++;\n\t\t\tline2++;\n\t\t}\n\n\t\t/* Recurse */\n\t\tif (next1 > line1 || next2 > line2) {\n\t\t\tstruct hashmap submap;\n\n\t\t\tmemset(&submap, 0, sizeof(submap));\n\t\t\tif (patience_diff(map->file1, map->file2,\n\t\t\t\t\tmap->xpp, map->env,\n\t\t\t\t\tline1, next1 - line1,\n\t\t\t\t\tline2, next2 - line2))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!first)\n\t\t\treturn 0;\n\n\t\twhile (first->next &&\n\t\t\t\tfirst->next->line1 == first->line1 + 1 &&\n\t\t\t\tfirst->next->line2 == first->line2 + 1)\n\t\t\tfirst = first->next;\n\n\t\tline1 = first->line1 + 1;\n\t\tline2 = first->line2 + 1;\n\n\t\tfirst = first->next;\n\t}\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int walk_common_sequence(struct hashmap *map, struct entry *first,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tint end1 = line1 + count1, end2 = line2 + count2;\n\tint next1, next2;\n\n\tfor (;;) {\n\t\t/* Try to grow the line ranges of common lines */\n\t\tif (first) {\n\t\t\tnext1 = first->line1;\n\t\t\tnext2 = first->line2;\n\t\t\twhile (next1 > line1 && next2 > line2 &&\n\t\t\t\t\tmatch(map, next1 - 1, next2 - 1)) {\n\t\t\t\tnext1--;\n\t\t\t\tnext2--;\n\t\t\t}\n\t\t} else {\n\t\t\tnext1 = end1;\n\t\t\tnext2 = end2;\n\t\t}\n\t\twhile (line1 < next1 && line2 < next2 &&\n\t\t\t\tmatch(map, line1, line2)) {\n\t\t\tline1++;\n\t\t\tline2++;\n\t\t}\n\n\t\t/* Recurse */\n\t\tif (next1 > line1 || next2 > line2) {\n\t\t\tstruct hashmap submap;\n\n\t\t\tmemset(&submap, 0, sizeof(submap));\n\t\t\tif (patience_diff(map->file1, map->file2,\n\t\t\t\t\tmap->xpp, map->env,\n\t\t\t\t\tline1, next1 - line1,\n\t\t\t\t\tline2, next2 - line2))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!first)\n\t\t\treturn 0;\n\n\t\twhile (first->next &&\n\t\t\t\tfirst->next->line1 == first->line1 + 1 &&\n\t\t\t\tfirst->next->line2 == first->line2 + 1)\n\t\t\tfirst = first->next;\n\n\t\tline1 = first->line1 + 1;\n\t\tline2 = first->line2 + 1;\n\n\t\tfirst = first->next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_longest_common_sequence",
          "args": [
            "&map"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "find_longest_common_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "189-220",
          "snippet": "static struct entry *find_longest_common_sequence(struct hashmap *map)\n{\n\tstruct entry **sequence = xdl_malloc(map->nr * sizeof(struct entry *));\n\tint longest = 0, i;\n\tstruct entry *entry;\n\n\tfor (entry = map->first; entry; entry = entry->next) {\n\t\tif (!entry->line2 || entry->line2 == NON_UNIQUE)\n\t\t\tcontinue;\n\t\ti = binary_search(sequence, longest, entry);\n\t\tentry->previous = i < 0 ? NULL : sequence[i];\n\t\tsequence[++i] = entry;\n\t\tif (i == longest)\n\t\t\tlongest++;\n\t}\n\n\t/* No common unique lines were found */\n\tif (!longest) {\n\t\txdl_free(sequence);\n\t\treturn NULL;\n\t}\n\n\t/* Iterate starting at the last element, adjusting the \"next\" members */\n\tentry = sequence[longest - 1];\n\tentry->next = NULL;\n\twhile (entry->previous) {\n\t\tentry->previous->next = entry;\n\t\tentry = entry->previous;\n\t}\n\txdl_free(sequence);\n\treturn entry;\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define NON_UNIQUE ULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\n#define NON_UNIQUE ULONG_MAX\n\nstatic struct entry *find_longest_common_sequence(struct hashmap *map)\n{\n\tstruct entry **sequence = xdl_malloc(map->nr * sizeof(struct entry *));\n\tint longest = 0, i;\n\tstruct entry *entry;\n\n\tfor (entry = map->first; entry; entry = entry->next) {\n\t\tif (!entry->line2 || entry->line2 == NON_UNIQUE)\n\t\t\tcontinue;\n\t\ti = binary_search(sequence, longest, entry);\n\t\tentry->previous = i < 0 ? NULL : sequence[i];\n\t\tsequence[++i] = entry;\n\t\tif (i == longest)\n\t\t\tlongest++;\n\t}\n\n\t/* No common unique lines were found */\n\tif (!longest) {\n\t\txdl_free(sequence);\n\t\treturn NULL;\n\t}\n\n\t/* Iterate starting at the last element, adjusting the \"next\" members */\n\tentry = sequence[longest - 1];\n\tentry->next = NULL;\n\twhile (entry->previous) {\n\t\tentry->previous->next = entry;\n\t\tentry = entry->previous;\n\t}\n\txdl_free(sequence);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_hashmap",
          "args": [
            "file1",
            "file2",
            "xpp",
            "env",
            "&map",
            "line1",
            "count1",
            "line2",
            "count2"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "fill_hashmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "130-157",
          "snippet": "static int fill_hashmap(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tstruct hashmap *result,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tresult->file1 = file1;\n\tresult->file2 = file2;\n\tresult->xpp = xpp;\n\tresult->env = env;\n\n\t/* We know exactly how large we want the hash map */\n\tresult->alloc = count1 * 2;\n\tresult->entries = (struct entry *)\n\t\txdl_malloc(result->alloc * sizeof(struct entry));\n\tif (!result->entries)\n\t\treturn -1;\n\tmemset(result->entries, 0, result->alloc * sizeof(struct entry));\n\n\t/* First, fill with entries from the first file */\n\twhile (count1--)\n\t\tinsert_record(line1++, result, 1);\n\n\t/* Then search for matches in the second file */\n\twhile (count2--)\n\t\tinsert_record(line2++, result, 2);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int fill_hashmap(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tstruct hashmap *result,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tresult->file1 = file1;\n\tresult->file2 = file2;\n\tresult->xpp = xpp;\n\tresult->env = env;\n\n\t/* We know exactly how large we want the hash map */\n\tresult->alloc = count1 * 2;\n\tresult->entries = (struct entry *)\n\t\txdl_malloc(result->alloc * sizeof(struct entry));\n\tif (!result->entries)\n\t\treturn -1;\n\tmemset(result->entries, 0, result->alloc * sizeof(struct entry));\n\n\t/* First, fill with entries from the first file */\n\twhile (count1--)\n\t\tinsert_record(line1++, result, 1);\n\n\t/* Then search for matches in the second file */\n\twhile (count2--)\n\t\tinsert_record(line2++, result, 2);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&map",
            "0",
            "sizeof(map)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tstruct hashmap map;\n\tstruct entry *first;\n\tint result = 0;\n\n\t/* trivial case: one side is empty */\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&map, 0, sizeof(map));\n\tif (fill_hashmap(file1, file2, xpp, env, &map,\n\t\t\tline1, count1, line2, count2))\n\t\treturn -1;\n\n\t/* are there any matching lines at all? */\n\tif (!map.has_matches) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\txdl_free(map.entries);\n\t\treturn 0;\n\t}\n\n\tfirst = find_longest_common_sequence(&map);\n\tif (first)\n\t\tresult = walk_common_sequence(&map, first,\n\t\t\tline1, count1, line2, count2);\n\telse\n\t\tresult = fall_back_to_classic_diff(&map,\n\t\t\tline1, count1, line2, count2);\n\n\txdl_free(map.entries);\n\treturn result;\n}"
  },
  {
    "function_name": "fall_back_to_classic_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
    "lines": "287-295",
    "snippet": "static int fall_back_to_classic_diff(struct hashmap *map,\n\t\tint line1, int count1, int line2, int count2)\n{\n\txpparam_t xpp;\n\txpp.flags = map->xpp->flags & ~XDF_DIFF_ALGORITHM_MASK;\n\n\treturn xdl_fall_back_diff(map->env, &xpp,\n\t\t\t\t  line1, count1, line2, count2);\n}",
    "includes": [
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_fall_back_diff",
          "args": [
            "map->env",
            "&xpp",
            "line1",
            "count1",
            "line2",
            "count2"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_fall_back_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "374-403",
          "snippet": "int xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp,\n\t\tint line1, int count1, int line2, int count2)\n{\n\t/*\n\t * This probably does not work outside Git, since\n\t * we have a very simple mmfile structure.\n\t *\n\t * Note: ideally, we would reuse the prepared environment, but\n\t * the libxdiff interface does not (yet) allow for diffing only\n\t * ranges of lines instead of the whole files.\n\t */\n\tmmfile_t subfile1, subfile2;\n\txdfenv_t env;\n\n\tsubfile1.ptr = (char *)diff_env->xdf1.recs[line1 - 1]->ptr;\n\tsubfile1.size = diff_env->xdf1.recs[line1 + count1 - 2]->ptr +\n\t\tdiff_env->xdf1.recs[line1 + count1 - 2]->size - subfile1.ptr;\n\tsubfile2.ptr = (char *)diff_env->xdf2.recs[line2 - 1]->ptr;\n\tsubfile2.size = diff_env->xdf2.recs[line2 + count2 - 2]->ptr +\n\t\tdiff_env->xdf2.recs[line2 + count2 - 2]->size - subfile2.ptr;\n\tif (xdl_do_diff(&subfile1, &subfile2, xpp, &env) < 0)\n\t\treturn -1;\n\n\tmemcpy(diff_env->xdf1.rchg + line1 - 1, env.xdf1.rchg, count1);\n\tmemcpy(diff_env->xdf2.rchg + line2 - 1, env.xdf2.rchg, count2);\n\n\txdl_free_env(&env);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp,\n\t\tint line1, int count1, int line2, int count2)\n{\n\t/*\n\t * This probably does not work outside Git, since\n\t * we have a very simple mmfile structure.\n\t *\n\t * Note: ideally, we would reuse the prepared environment, but\n\t * the libxdiff interface does not (yet) allow for diffing only\n\t * ranges of lines instead of the whole files.\n\t */\n\tmmfile_t subfile1, subfile2;\n\txdfenv_t env;\n\n\tsubfile1.ptr = (char *)diff_env->xdf1.recs[line1 - 1]->ptr;\n\tsubfile1.size = diff_env->xdf1.recs[line1 + count1 - 2]->ptr +\n\t\tdiff_env->xdf1.recs[line1 + count1 - 2]->size - subfile1.ptr;\n\tsubfile2.ptr = (char *)diff_env->xdf2.recs[line2 - 1]->ptr;\n\tsubfile2.size = diff_env->xdf2.recs[line2 + count2 - 2]->ptr +\n\t\tdiff_env->xdf2.recs[line2 + count2 - 2]->size - subfile2.ptr;\n\tif (xdl_do_diff(&subfile1, &subfile2, xpp, &env) < 0)\n\t\treturn -1;\n\n\tmemcpy(diff_env->xdf1.rchg + line1 - 1, env.xdf1.rchg, count1);\n\tmemcpy(diff_env->xdf2.rchg + line2 - 1, env.xdf2.rchg, count2);\n\n\txdl_free_env(&env);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int fall_back_to_classic_diff(struct hashmap *map,\n\t\tint line1, int count1, int line2, int count2)\n{\n\txpparam_t xpp;\n\txpp.flags = map->xpp->flags & ~XDF_DIFF_ALGORITHM_MASK;\n\n\treturn xdl_fall_back_diff(map->env, &xpp,\n\t\t\t\t  line1, count1, line2, count2);\n}"
  },
  {
    "function_name": "walk_common_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
    "lines": "234-285",
    "snippet": "static int walk_common_sequence(struct hashmap *map, struct entry *first,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tint end1 = line1 + count1, end2 = line2 + count2;\n\tint next1, next2;\n\n\tfor (;;) {\n\t\t/* Try to grow the line ranges of common lines */\n\t\tif (first) {\n\t\t\tnext1 = first->line1;\n\t\t\tnext2 = first->line2;\n\t\t\twhile (next1 > line1 && next2 > line2 &&\n\t\t\t\t\tmatch(map, next1 - 1, next2 - 1)) {\n\t\t\t\tnext1--;\n\t\t\t\tnext2--;\n\t\t\t}\n\t\t} else {\n\t\t\tnext1 = end1;\n\t\t\tnext2 = end2;\n\t\t}\n\t\twhile (line1 < next1 && line2 < next2 &&\n\t\t\t\tmatch(map, line1, line2)) {\n\t\t\tline1++;\n\t\t\tline2++;\n\t\t}\n\n\t\t/* Recurse */\n\t\tif (next1 > line1 || next2 > line2) {\n\t\t\tstruct hashmap submap;\n\n\t\t\tmemset(&submap, 0, sizeof(submap));\n\t\t\tif (patience_diff(map->file1, map->file2,\n\t\t\t\t\tmap->xpp, map->env,\n\t\t\t\t\tline1, next1 - line1,\n\t\t\t\t\tline2, next2 - line2))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!first)\n\t\t\treturn 0;\n\n\t\twhile (first->next &&\n\t\t\t\tfirst->next->line1 == first->line1 + 1 &&\n\t\t\t\tfirst->next->line2 == first->line2 + 1)\n\t\t\tfirst = first->next;\n\n\t\tline1 = first->line1 + 1;\n\t\tline2 = first->line2 + 1;\n\n\t\tfirst = first->next;\n\t}\n}",
    "includes": [
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "patience_diff",
          "args": [
            "map->file1",
            "map->file2",
            "map->xpp",
            "map->env",
            "line1",
            "next1 - line1",
            "line2",
            "next2 - line2"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "patience_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "303-347",
          "snippet": "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tstruct hashmap map;\n\tstruct entry *first;\n\tint result = 0;\n\n\t/* trivial case: one side is empty */\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&map, 0, sizeof(map));\n\tif (fill_hashmap(file1, file2, xpp, env, &map,\n\t\t\tline1, count1, line2, count2))\n\t\treturn -1;\n\n\t/* are there any matching lines at all? */\n\tif (!map.has_matches) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\txdl_free(map.entries);\n\t\treturn 0;\n\t}\n\n\tfirst = find_longest_common_sequence(&map);\n\tif (first)\n\t\tresult = walk_common_sequence(&map, first,\n\t\t\tline1, count1, line2, count2);\n\telse\n\t\tresult = fall_back_to_classic_diff(&map,\n\t\t\tline1, count1, line2, count2);\n\n\txdl_free(map.entries);\n\treturn result;\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tstruct hashmap map;\n\tstruct entry *first;\n\tint result = 0;\n\n\t/* trivial case: one side is empty */\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&map, 0, sizeof(map));\n\tif (fill_hashmap(file1, file2, xpp, env, &map,\n\t\t\tline1, count1, line2, count2))\n\t\treturn -1;\n\n\t/* are there any matching lines at all? */\n\tif (!map.has_matches) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\txdl_free(map.entries);\n\t\treturn 0;\n\t}\n\n\tfirst = find_longest_common_sequence(&map);\n\tif (first)\n\t\tresult = walk_common_sequence(&map, first,\n\t\t\tline1, count1, line2, count2);\n\telse\n\t\tresult = fall_back_to_classic_diff(&map,\n\t\t\tline1, count1, line2, count2);\n\n\txdl_free(map.entries);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&submap",
            "0",
            "sizeof(submap)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "map",
            "line1",
            "line2"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "222-228",
          "snippet": "static int match(struct hashmap *map, int line1, int line2)\n{\n\txrecord_t *record1 = map->env->xdf1.recs[line1 - 1];\n\txrecord_t *record2 = map->env->xdf2.recs[line2 - 1];\n\treturn xdl_recmatch(record1->ptr, record1->size,\n\t\trecord2->ptr, record2->size, map->xpp->flags);\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int match(struct hashmap *map, int line1, int line2)\n{\n\txrecord_t *record1 = map->env->xdf1.recs[line1 - 1];\n\txrecord_t *record2 = map->env->xdf2.recs[line2 - 1];\n\treturn xdl_recmatch(record1->ptr, record1->size,\n\t\trecord2->ptr, record2->size, map->xpp->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int walk_common_sequence(struct hashmap *map, struct entry *first,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tint end1 = line1 + count1, end2 = line2 + count2;\n\tint next1, next2;\n\n\tfor (;;) {\n\t\t/* Try to grow the line ranges of common lines */\n\t\tif (first) {\n\t\t\tnext1 = first->line1;\n\t\t\tnext2 = first->line2;\n\t\t\twhile (next1 > line1 && next2 > line2 &&\n\t\t\t\t\tmatch(map, next1 - 1, next2 - 1)) {\n\t\t\t\tnext1--;\n\t\t\t\tnext2--;\n\t\t\t}\n\t\t} else {\n\t\t\tnext1 = end1;\n\t\t\tnext2 = end2;\n\t\t}\n\t\twhile (line1 < next1 && line2 < next2 &&\n\t\t\t\tmatch(map, line1, line2)) {\n\t\t\tline1++;\n\t\t\tline2++;\n\t\t}\n\n\t\t/* Recurse */\n\t\tif (next1 > line1 || next2 > line2) {\n\t\t\tstruct hashmap submap;\n\n\t\t\tmemset(&submap, 0, sizeof(submap));\n\t\t\tif (patience_diff(map->file1, map->file2,\n\t\t\t\t\tmap->xpp, map->env,\n\t\t\t\t\tline1, next1 - line1,\n\t\t\t\t\tline2, next2 - line2))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!first)\n\t\t\treturn 0;\n\n\t\twhile (first->next &&\n\t\t\t\tfirst->next->line1 == first->line1 + 1 &&\n\t\t\t\tfirst->next->line2 == first->line2 + 1)\n\t\t\tfirst = first->next;\n\n\t\tline1 = first->line1 + 1;\n\t\tline2 = first->line2 + 1;\n\n\t\tfirst = first->next;\n\t}\n}"
  },
  {
    "function_name": "match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
    "lines": "222-228",
    "snippet": "static int match(struct hashmap *map, int line1, int line2)\n{\n\txrecord_t *record1 = map->env->xdf1.recs[line1 - 1];\n\txrecord_t *record2 = map->env->xdf2.recs[line2 - 1];\n\treturn xdl_recmatch(record1->ptr, record1->size,\n\t\trecord2->ptr, record2->size, map->xpp->flags);\n}",
    "includes": [
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_recmatch",
          "args": [
            "record1->ptr",
            "record1->size",
            "record2->ptr",
            "record2->size",
            "map->xpp->flags"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "157-223",
          "snippet": "int xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int match(struct hashmap *map, int line1, int line2)\n{\n\txrecord_t *record1 = map->env->xdf1.recs[line1 - 1];\n\txrecord_t *record2 = map->env->xdf2.recs[line2 - 1];\n\treturn xdl_recmatch(record1->ptr, record1->size,\n\t\trecord2->ptr, record2->size, map->xpp->flags);\n}"
  },
  {
    "function_name": "find_longest_common_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
    "lines": "189-220",
    "snippet": "static struct entry *find_longest_common_sequence(struct hashmap *map)\n{\n\tstruct entry **sequence = xdl_malloc(map->nr * sizeof(struct entry *));\n\tint longest = 0, i;\n\tstruct entry *entry;\n\n\tfor (entry = map->first; entry; entry = entry->next) {\n\t\tif (!entry->line2 || entry->line2 == NON_UNIQUE)\n\t\t\tcontinue;\n\t\ti = binary_search(sequence, longest, entry);\n\t\tentry->previous = i < 0 ? NULL : sequence[i];\n\t\tsequence[++i] = entry;\n\t\tif (i == longest)\n\t\t\tlongest++;\n\t}\n\n\t/* No common unique lines were found */\n\tif (!longest) {\n\t\txdl_free(sequence);\n\t\treturn NULL;\n\t}\n\n\t/* Iterate starting at the last element, adjusting the \"next\" members */\n\tentry = sequence[longest - 1];\n\tentry->next = NULL;\n\twhile (entry->previous) {\n\t\tentry->previous->next = entry;\n\t\tentry = entry->previous;\n\t}\n\txdl_free(sequence);\n\treturn entry;\n}",
    "includes": [
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [
      "#define NON_UNIQUE ULONG_MAX"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "sequence"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "binary_search",
          "args": [
            "sequence",
            "longest",
            "entry"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "binary_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "163-178",
          "snippet": "static int binary_search(struct entry **sequence, int longest,\n\t\tstruct entry *entry)\n{\n\tint left = -1, right = longest;\n\n\twhile (left + 1 < right) {\n\t\tint middle = (left + right) / 2;\n\t\t/* by construction, no two entries can be equal */\n\t\tif (sequence[middle]->line2 > entry->line2)\n\t\t\tright = middle;\n\t\telse\n\t\t\tleft = middle;\n\t}\n\t/* return the index in \"sequence\", _not_ the sequence length */\n\treturn left;\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int binary_search(struct entry **sequence, int longest,\n\t\tstruct entry *entry)\n{\n\tint left = -1, right = longest;\n\n\twhile (left + 1 < right) {\n\t\tint middle = (left + right) / 2;\n\t\t/* by construction, no two entries can be equal */\n\t\tif (sequence[middle]->line2 > entry->line2)\n\t\t\tright = middle;\n\t\telse\n\t\t\tleft = middle;\n\t}\n\t/* return the index in \"sequence\", _not_ the sequence length */\n\treturn left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "map->nr * sizeof(struct entry *)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\n#define NON_UNIQUE ULONG_MAX\n\nstatic struct entry *find_longest_common_sequence(struct hashmap *map)\n{\n\tstruct entry **sequence = xdl_malloc(map->nr * sizeof(struct entry *));\n\tint longest = 0, i;\n\tstruct entry *entry;\n\n\tfor (entry = map->first; entry; entry = entry->next) {\n\t\tif (!entry->line2 || entry->line2 == NON_UNIQUE)\n\t\t\tcontinue;\n\t\ti = binary_search(sequence, longest, entry);\n\t\tentry->previous = i < 0 ? NULL : sequence[i];\n\t\tsequence[++i] = entry;\n\t\tif (i == longest)\n\t\t\tlongest++;\n\t}\n\n\t/* No common unique lines were found */\n\tif (!longest) {\n\t\txdl_free(sequence);\n\t\treturn NULL;\n\t}\n\n\t/* Iterate starting at the last element, adjusting the \"next\" members */\n\tentry = sequence[longest - 1];\n\tentry->next = NULL;\n\twhile (entry->previous) {\n\t\tentry->previous->next = entry;\n\t\tentry = entry->previous;\n\t}\n\txdl_free(sequence);\n\treturn entry;\n}"
  },
  {
    "function_name": "binary_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
    "lines": "163-178",
    "snippet": "static int binary_search(struct entry **sequence, int longest,\n\t\tstruct entry *entry)\n{\n\tint left = -1, right = longest;\n\n\twhile (left + 1 < right) {\n\t\tint middle = (left + right) / 2;\n\t\t/* by construction, no two entries can be equal */\n\t\tif (sequence[middle]->line2 > entry->line2)\n\t\t\tright = middle;\n\t\telse\n\t\t\tleft = middle;\n\t}\n\t/* return the index in \"sequence\", _not_ the sequence length */\n\treturn left;\n}",
    "includes": [
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int binary_search(struct entry **sequence, int longest,\n\t\tstruct entry *entry)\n{\n\tint left = -1, right = longest;\n\n\twhile (left + 1 < right) {\n\t\tint middle = (left + right) / 2;\n\t\t/* by construction, no two entries can be equal */\n\t\tif (sequence[middle]->line2 > entry->line2)\n\t\t\tright = middle;\n\t\telse\n\t\t\tleft = middle;\n\t}\n\t/* return the index in \"sequence\", _not_ the sequence length */\n\treturn left;\n}"
  },
  {
    "function_name": "fill_hashmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
    "lines": "130-157",
    "snippet": "static int fill_hashmap(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tstruct hashmap *result,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tresult->file1 = file1;\n\tresult->file2 = file2;\n\tresult->xpp = xpp;\n\tresult->env = env;\n\n\t/* We know exactly how large we want the hash map */\n\tresult->alloc = count1 * 2;\n\tresult->entries = (struct entry *)\n\t\txdl_malloc(result->alloc * sizeof(struct entry));\n\tif (!result->entries)\n\t\treturn -1;\n\tmemset(result->entries, 0, result->alloc * sizeof(struct entry));\n\n\t/* First, fill with entries from the first file */\n\twhile (count1--)\n\t\tinsert_record(line1++, result, 1);\n\n\t/* Then search for matches in the second file */\n\twhile (count2--)\n\t\tinsert_record(line2++, result, 2);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_record",
          "args": [
            "line2++",
            "result",
            "2"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "insert_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
          "lines": "74-121",
          "snippet": "static void insert_record(int line, struct hashmap *map, int pass)\n{\n\txrecord_t **records = pass == 1 ?\n\t\tmap->env->xdf1.recs : map->env->xdf2.recs;\n\txrecord_t *record = records[line - 1], *other;\n\t/*\n\t * After xdl_prepare_env() (or more precisely, due to\n\t * xdl_classify_record()), the \"ha\" member of the records (AKA lines)\n\t * is _not_ the hash anymore, but a linearized version of it.  In\n\t * other words, the \"ha\" member is guaranteed to start with 0 and\n\t * the second record's ha can only be 0 or 1, etc.\n\t *\n\t * So we multiply ha by 2 in the hope that the hashing was\n\t * \"unique enough\".\n\t */\n\tint index = (int)((record->ha << 1) % map->alloc);\n\n\twhile (map->entries[index].line1) {\n\t\tother = map->env->xdf1.recs[map->entries[index].line1 - 1];\n\t\tif (map->entries[index].hash != record->ha ||\n\t\t\t\t!xdl_recmatch(record->ptr, record->size,\n\t\t\t\t\tother->ptr, other->size,\n\t\t\t\t\tmap->xpp->flags)) {\n\t\t\tif (++index >= map->alloc)\n\t\t\t\tindex = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pass == 2)\n\t\t\tmap->has_matches = 1;\n\t\tif (pass == 1 || map->entries[index].line2)\n\t\t\tmap->entries[index].line2 = NON_UNIQUE;\n\t\telse\n\t\t\tmap->entries[index].line2 = line;\n\t\treturn;\n\t}\n\tif (pass == 2)\n\t\treturn;\n\tmap->entries[index].line1 = line;\n\tmap->entries[index].hash = record->ha;\n\tif (!map->first)\n\t\tmap->first = map->entries + index;\n\tif (map->last) {\n\t\tmap->last->next = map->entries + index;\n\t\tmap->entries[index].previous = map->last;\n\t}\n\tmap->last = map->entries + index;\n\tmap->nr++;\n}",
          "includes": [
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define NON_UNIQUE ULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\n#define NON_UNIQUE ULONG_MAX\n\nstatic void insert_record(int line, struct hashmap *map, int pass)\n{\n\txrecord_t **records = pass == 1 ?\n\t\tmap->env->xdf1.recs : map->env->xdf2.recs;\n\txrecord_t *record = records[line - 1], *other;\n\t/*\n\t * After xdl_prepare_env() (or more precisely, due to\n\t * xdl_classify_record()), the \"ha\" member of the records (AKA lines)\n\t * is _not_ the hash anymore, but a linearized version of it.  In\n\t * other words, the \"ha\" member is guaranteed to start with 0 and\n\t * the second record's ha can only be 0 or 1, etc.\n\t *\n\t * So we multiply ha by 2 in the hope that the hashing was\n\t * \"unique enough\".\n\t */\n\tint index = (int)((record->ha << 1) % map->alloc);\n\n\twhile (map->entries[index].line1) {\n\t\tother = map->env->xdf1.recs[map->entries[index].line1 - 1];\n\t\tif (map->entries[index].hash != record->ha ||\n\t\t\t\t!xdl_recmatch(record->ptr, record->size,\n\t\t\t\t\tother->ptr, other->size,\n\t\t\t\t\tmap->xpp->flags)) {\n\t\t\tif (++index >= map->alloc)\n\t\t\t\tindex = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pass == 2)\n\t\t\tmap->has_matches = 1;\n\t\tif (pass == 1 || map->entries[index].line2)\n\t\t\tmap->entries[index].line2 = NON_UNIQUE;\n\t\telse\n\t\t\tmap->entries[index].line2 = line;\n\t\treturn;\n\t}\n\tif (pass == 2)\n\t\treturn;\n\tmap->entries[index].line1 = line;\n\tmap->entries[index].hash = record->ha;\n\tif (!map->first)\n\t\tmap->first = map->entries + index;\n\tif (map->last) {\n\t\tmap->last->next = map->entries + index;\n\t\tmap->entries[index].previous = map->last;\n\t}\n\tmap->last = map->entries + index;\n\tmap->nr++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "result->entries",
            "0",
            "result->alloc * sizeof(struct entry)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "result->alloc * sizeof(struct entry)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int patience_diff(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int fill_hashmap(mmfile_t *file1, mmfile_t *file2,\n\t\txpparam_t const *xpp, xdfenv_t *env,\n\t\tstruct hashmap *result,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tresult->file1 = file1;\n\tresult->file2 = file2;\n\tresult->xpp = xpp;\n\tresult->env = env;\n\n\t/* We know exactly how large we want the hash map */\n\tresult->alloc = count1 * 2;\n\tresult->entries = (struct entry *)\n\t\txdl_malloc(result->alloc * sizeof(struct entry));\n\tif (!result->entries)\n\t\treturn -1;\n\tmemset(result->entries, 0, result->alloc * sizeof(struct entry));\n\n\t/* First, fill with entries from the first file */\n\twhile (count1--)\n\t\tinsert_record(line1++, result, 1);\n\n\t/* Then search for matches in the second file */\n\twhile (count2--)\n\t\tinsert_record(line2++, result, 2);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "insert_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xpatience.c",
    "lines": "74-121",
    "snippet": "static void insert_record(int line, struct hashmap *map, int pass)\n{\n\txrecord_t **records = pass == 1 ?\n\t\tmap->env->xdf1.recs : map->env->xdf2.recs;\n\txrecord_t *record = records[line - 1], *other;\n\t/*\n\t * After xdl_prepare_env() (or more precisely, due to\n\t * xdl_classify_record()), the \"ha\" member of the records (AKA lines)\n\t * is _not_ the hash anymore, but a linearized version of it.  In\n\t * other words, the \"ha\" member is guaranteed to start with 0 and\n\t * the second record's ha can only be 0 or 1, etc.\n\t *\n\t * So we multiply ha by 2 in the hope that the hashing was\n\t * \"unique enough\".\n\t */\n\tint index = (int)((record->ha << 1) % map->alloc);\n\n\twhile (map->entries[index].line1) {\n\t\tother = map->env->xdf1.recs[map->entries[index].line1 - 1];\n\t\tif (map->entries[index].hash != record->ha ||\n\t\t\t\t!xdl_recmatch(record->ptr, record->size,\n\t\t\t\t\tother->ptr, other->size,\n\t\t\t\t\tmap->xpp->flags)) {\n\t\t\tif (++index >= map->alloc)\n\t\t\t\tindex = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pass == 2)\n\t\t\tmap->has_matches = 1;\n\t\tif (pass == 1 || map->entries[index].line2)\n\t\t\tmap->entries[index].line2 = NON_UNIQUE;\n\t\telse\n\t\t\tmap->entries[index].line2 = line;\n\t\treturn;\n\t}\n\tif (pass == 2)\n\t\treturn;\n\tmap->entries[index].line1 = line;\n\tmap->entries[index].hash = record->ha;\n\tif (!map->first)\n\t\tmap->first = map->entries + index;\n\tif (map->last) {\n\t\tmap->last->next = map->entries + index;\n\t\tmap->entries[index].previous = map->last;\n\t}\n\tmap->last = map->entries + index;\n\tmap->nr++;\n}",
    "includes": [
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [
      "#define NON_UNIQUE ULONG_MAX"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_recmatch",
          "args": [
            "record->ptr",
            "record->size",
            "other->ptr",
            "other->size",
            "map->xpp->flags"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "157-223",
          "snippet": "int xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\n#define NON_UNIQUE ULONG_MAX\n\nstatic void insert_record(int line, struct hashmap *map, int pass)\n{\n\txrecord_t **records = pass == 1 ?\n\t\tmap->env->xdf1.recs : map->env->xdf2.recs;\n\txrecord_t *record = records[line - 1], *other;\n\t/*\n\t * After xdl_prepare_env() (or more precisely, due to\n\t * xdl_classify_record()), the \"ha\" member of the records (AKA lines)\n\t * is _not_ the hash anymore, but a linearized version of it.  In\n\t * other words, the \"ha\" member is guaranteed to start with 0 and\n\t * the second record's ha can only be 0 or 1, etc.\n\t *\n\t * So we multiply ha by 2 in the hope that the hashing was\n\t * \"unique enough\".\n\t */\n\tint index = (int)((record->ha << 1) % map->alloc);\n\n\twhile (map->entries[index].line1) {\n\t\tother = map->env->xdf1.recs[map->entries[index].line1 - 1];\n\t\tif (map->entries[index].hash != record->ha ||\n\t\t\t\t!xdl_recmatch(record->ptr, record->size,\n\t\t\t\t\tother->ptr, other->size,\n\t\t\t\t\tmap->xpp->flags)) {\n\t\t\tif (++index >= map->alloc)\n\t\t\t\tindex = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pass == 2)\n\t\t\tmap->has_matches = 1;\n\t\tif (pass == 1 || map->entries[index].line2)\n\t\t\tmap->entries[index].line2 = NON_UNIQUE;\n\t\telse\n\t\t\tmap->entries[index].line2 = line;\n\t\treturn;\n\t}\n\tif (pass == 2)\n\t\treturn;\n\tmap->entries[index].line1 = line;\n\tmap->entries[index].hash = record->ha;\n\tif (!map->first)\n\t\tmap->first = map->entries + index;\n\tif (map->last) {\n\t\tmap->last->next = map->entries + index;\n\t\tmap->entries[index].previous = map->last;\n\t}\n\tmap->last = map->entries + index;\n\tmap->nr++;\n}"
  }
]