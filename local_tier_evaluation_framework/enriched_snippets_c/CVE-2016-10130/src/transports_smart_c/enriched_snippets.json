[
  {
    "function_name": "git_transport_smart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "469-514",
    "snippet": "int git_transport_smart(git_transport **out, git_remote *owner, void *param)\n{\n\ttransport_smart *t;\n\tgit_smart_subtransport_definition *definition = (git_smart_subtransport_definition *)param;\n\n\tif (!param)\n\t\treturn -1;\n\n\tt = git__calloc(1, sizeof(transport_smart));\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->parent.version = GIT_TRANSPORT_VERSION;\n\tt->parent.set_callbacks = git_smart__set_callbacks;\n\tt->parent.set_custom_headers = git_smart__set_custom_headers;\n\tt->parent.connect = git_smart__connect;\n\tt->parent.close = git_smart__close;\n\tt->parent.free = git_smart__free;\n\tt->parent.negotiate_fetch = git_smart__negotiate_fetch;\n\tt->parent.download_pack = git_smart__download_pack;\n\tt->parent.push = git_smart__push;\n\tt->parent.ls = git_smart__ls;\n\tt->parent.is_connected = git_smart__is_connected;\n\tt->parent.read_flags = git_smart__read_flags;\n\tt->parent.cancel = git_smart__cancel;\n\n\tt->owner = owner;\n\tt->rpc = definition->rpc;\n\n\tif (git_vector_init(&t->refs, 16, ref_name_cmp) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&t->heads, 16, ref_name_cmp) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\tif (definition->callback(&t->wrapped, &t->parent, definition->param) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\t*out = (git_transport *) t;\n\treturn 0;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "t"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "definition->callback",
          "args": [
            "&t->wrapped",
            "&t->parent",
            "definition->param"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&t->heads",
            "16",
            "ref_name_cmp"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "t"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(transport_smart)"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_transport_smart(git_transport **out, git_remote *owner, void *param)\n{\n\ttransport_smart *t;\n\tgit_smart_subtransport_definition *definition = (git_smart_subtransport_definition *)param;\n\n\tif (!param)\n\t\treturn -1;\n\n\tt = git__calloc(1, sizeof(transport_smart));\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->parent.version = GIT_TRANSPORT_VERSION;\n\tt->parent.set_callbacks = git_smart__set_callbacks;\n\tt->parent.set_custom_headers = git_smart__set_custom_headers;\n\tt->parent.connect = git_smart__connect;\n\tt->parent.close = git_smart__close;\n\tt->parent.free = git_smart__free;\n\tt->parent.negotiate_fetch = git_smart__negotiate_fetch;\n\tt->parent.download_pack = git_smart__download_pack;\n\tt->parent.push = git_smart__push;\n\tt->parent.ls = git_smart__ls;\n\tt->parent.is_connected = git_smart__is_connected;\n\tt->parent.read_flags = git_smart__read_flags;\n\tt->parent.cancel = git_smart__cancel;\n\n\tt->owner = owner;\n\tt->rpc = definition->rpc;\n\n\tif (git_vector_init(&t->refs, 16, ref_name_cmp) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&t->heads, 16, ref_name_cmp) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\tif (definition->callback(&t->wrapped, &t->parent, definition->param) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\t*out = (git_transport *) t;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_transport_smart_credentials",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "462-467",
    "snippet": "int git_transport_smart_credentials(git_cred **out, git_transport *transport, const char *user, int methods)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\treturn t->cred_acquire_cb(out, t->url, user, methods, t->cred_acquire_payload);\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->cred_acquire_cb",
          "args": [
            "out",
            "t->url",
            "user",
            "methods",
            "t->cred_acquire_payload"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_transport_smart_credentials(git_cred **out, git_transport *transport, const char *user, int methods)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\treturn t->cred_acquire_cb(out, t->url, user, methods, t->cred_acquire_payload);\n}"
  },
  {
    "function_name": "git_transport_smart_certificate_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "455-460",
    "snippet": "int git_transport_smart_certificate_check(git_transport *transport, git_cert *cert, int valid, const char *hostname)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\treturn t->certificate_check_cb(cert, valid, hostname, t->message_cb_payload);\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->certificate_check_cb",
          "args": [
            "cert",
            "valid",
            "hostname",
            "t->message_cb_payload"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_transport_smart_certificate_check(git_transport *transport, git_cert *cert, int valid, const char *hostname)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\treturn t->certificate_check_cb(cert, valid, hostname, t->message_cb_payload);\n}"
  },
  {
    "function_name": "ref_name_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "448-453",
    "snippet": "static int ref_name_cmp(const void *a, const void *b)\n{\n\tconst git_pkt_ref *ref_a = a, *ref_b = b;\n\n\treturn strcmp(ref_a->head.name, ref_b->head.name);\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ref_a->head.name",
            "ref_b->head.name"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int ref_name_cmp(const void *a, const void *b)\n{\n\tconst git_pkt_ref *ref_a = a, *ref_b = b;\n\n\treturn strcmp(ref_a->head.name, ref_b->head.name);\n}"
  },
  {
    "function_name": "git_smart__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "424-446",
    "snippet": "static void git_smart__free(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_vector *refs = &t->refs;\n\tunsigned int i;\n\tgit_pkt *p;\n\n\t/* Make sure that the current stream is closed, if we have one. */\n\tgit_smart__close(transport);\n\n\t/* Free the subtransport */\n\tt->wrapped->free(t->wrapped);\n\n\tgit_vector_free(&t->heads);\n\tgit_vector_foreach(refs, i, p)\n\t\tgit_pkt_free(p);\n\n\tgit_vector_free(refs);\n\n\tgit_strarray_free(&t->custom_headers);\n\n\tgit__free(t);\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "t"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strarray_free",
          "args": [
            "&t->custom_headers"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "git_strarray_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "21-34",
          "snippet": "void git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nvoid git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "refs"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_free",
          "args": [
            "p"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "476-496",
          "snippet": "void git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "refs",
            "i",
            "p"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->wrapped->free",
          "args": [
            "t->wrapped"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_smart__close",
          "args": [
            "transport"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "387-422",
          "snippet": "static int git_smart__close(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_vector *common = &t->common;\n\tunsigned int i;\n\tgit_pkt *p;\n\tint ret;\n\tgit_smart_subtransport_stream *stream;\n\tconst char flush[] = \"0000\";\n\n\t/*\n\t * If we're still connected at this point and not using RPC,\n\t * we should say goodbye by sending a flush, or git-daemon\n\t * will complain that we disconnected unexpectedly.\n\t */\n\tif (t->connected && !t->rpc &&\n\t    !t->wrapped->action(&stream, t->wrapped, t->url, GIT_SERVICE_UPLOADPACK)) {\n\t\tt->current_stream->write(t->current_stream, flush, 4);\n\t}\n\n\tret = git_smart__reset_stream(t, true);\n\n\tgit_vector_foreach(common, i, p)\n\t\tgit_pkt_free(p);\n\n\tgit_vector_free(common);\n\n\tif (t->url) {\n\t\tgit__free(t->url);\n\t\tt->url = NULL;\n\t}\n\n\tt->connected = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_smart__close(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_vector *common = &t->common;\n\tunsigned int i;\n\tgit_pkt *p;\n\tint ret;\n\tgit_smart_subtransport_stream *stream;\n\tconst char flush[] = \"0000\";\n\n\t/*\n\t * If we're still connected at this point and not using RPC,\n\t * we should say goodbye by sending a flush, or git-daemon\n\t * will complain that we disconnected unexpectedly.\n\t */\n\tif (t->connected && !t->rpc &&\n\t    !t->wrapped->action(&stream, t->wrapped, t->url, GIT_SERVICE_UPLOADPACK)) {\n\t\tt->current_stream->write(t->current_stream, flush, 4);\n\t}\n\n\tret = git_smart__reset_stream(t, true);\n\n\tgit_vector_foreach(common, i, p)\n\t\tgit_pkt_free(p);\n\n\tgit_vector_free(common);\n\n\tif (t->url) {\n\t\tgit__free(t->url);\n\t\tt->url = NULL;\n\t}\n\n\tt->connected = 0;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic void git_smart__free(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_vector *refs = &t->refs;\n\tunsigned int i;\n\tgit_pkt *p;\n\n\t/* Make sure that the current stream is closed, if we have one. */\n\tgit_smart__close(transport);\n\n\t/* Free the subtransport */\n\tt->wrapped->free(t->wrapped);\n\n\tgit_vector_free(&t->heads);\n\tgit_vector_foreach(refs, i, p)\n\t\tgit_pkt_free(p);\n\n\tgit_vector_free(refs);\n\n\tgit_strarray_free(&t->custom_headers);\n\n\tgit__free(t);\n}"
  },
  {
    "function_name": "git_smart__close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "387-422",
    "snippet": "static int git_smart__close(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_vector *common = &t->common;\n\tunsigned int i;\n\tgit_pkt *p;\n\tint ret;\n\tgit_smart_subtransport_stream *stream;\n\tconst char flush[] = \"0000\";\n\n\t/*\n\t * If we're still connected at this point and not using RPC,\n\t * we should say goodbye by sending a flush, or git-daemon\n\t * will complain that we disconnected unexpectedly.\n\t */\n\tif (t->connected && !t->rpc &&\n\t    !t->wrapped->action(&stream, t->wrapped, t->url, GIT_SERVICE_UPLOADPACK)) {\n\t\tt->current_stream->write(t->current_stream, flush, 4);\n\t}\n\n\tret = git_smart__reset_stream(t, true);\n\n\tgit_vector_foreach(common, i, p)\n\t\tgit_pkt_free(p);\n\n\tgit_vector_free(common);\n\n\tif (t->url) {\n\t\tgit__free(t->url);\n\t\tt->url = NULL;\n\t}\n\n\tt->connected = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "t->url"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "common"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_free",
          "args": [
            "p"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "476-496",
          "snippet": "void git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "common",
            "i",
            "p"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_smart__reset_stream",
          "args": [
            "t",
            "true"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__reset_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "38-50",
          "snippet": "GIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nGIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->current_stream->write",
          "args": [
            "t->current_stream",
            "flush",
            "4"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->wrapped->action",
          "args": [
            "&stream",
            "t->wrapped",
            "t->url",
            "GIT_SERVICE_UPLOADPACK"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_smart__close(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_vector *common = &t->common;\n\tunsigned int i;\n\tgit_pkt *p;\n\tint ret;\n\tgit_smart_subtransport_stream *stream;\n\tconst char flush[] = \"0000\";\n\n\t/*\n\t * If we're still connected at this point and not using RPC,\n\t * we should say goodbye by sending a flush, or git-daemon\n\t * will complain that we disconnected unexpectedly.\n\t */\n\tif (t->connected && !t->rpc &&\n\t    !t->wrapped->action(&stream, t->wrapped, t->url, GIT_SERVICE_UPLOADPACK)) {\n\t\tt->current_stream->write(t->current_stream, flush, 4);\n\t}\n\n\tret = git_smart__reset_stream(t, true);\n\n\tgit_vector_foreach(common, i, p)\n\t\tgit_pkt_free(p);\n\n\tgit_vector_free(common);\n\n\tif (t->url) {\n\t\tgit__free(t->url);\n\t\tt->url = NULL;\n\t}\n\n\tt->connected = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "git_smart__read_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "378-385",
    "snippet": "static int git_smart__read_flags(git_transport *transport, int *flags)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\t*flags = t->flags;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_smart__read_flags(git_transport *transport, int *flags)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\t*flags = t->flags;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_smart__is_connected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "371-376",
    "snippet": "static int git_smart__is_connected(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\treturn t->connected;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_smart__is_connected(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\treturn t->connected;\n}"
  },
  {
    "function_name": "git_smart__cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "364-369",
    "snippet": "static void git_smart__cancel(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\tgit_atomic_set(&t->cancelled, 1);\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_atomic_set",
          "args": [
            "&t->cancelled",
            "1"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "166-169",
          "snippet": "GIT_INLINE(void) git_atomic_set(git_atomic *a, int val)\n{\n\ta->val = val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(void) git_atomic_set(git_atomic *a, int val)\n{\n\ta->val = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic void git_smart__cancel(git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\tgit_atomic_set(&t->cancelled, 1);\n}"
  },
  {
    "function_name": "git_smart__get_push_stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "338-362",
    "snippet": "int git_smart__get_push_stream(transport_smart *t, git_smart_subtransport_stream **stream)\n{\n\tint error;\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\tif (GIT_DIRECTION_PUSH != t->direction) {\n\t\tgiterr_set(GITERR_NET, \"This operation is only valid for push\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(stream, t->wrapped, t->url, GIT_SERVICE_RECEIVEPACK)) < 0)\n\t\treturn error;\n\n\t/* If this is a stateful implementation, the stream we get back should be the same */\n\tassert(t->rpc || t->current_stream == *stream);\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = *stream;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gitno_buffer_setup_callback",
          "args": [
            "&t->buffer",
            "t->buffer_data",
            "sizeof(t->buffer_data)",
            "git_smart__recv_cb",
            "t"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_buffer_setup_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "23-35",
          "snippet": "void gitno_buffer_setup_callback(\n\tgitno_buffer *buf,\n\tchar *data,\n\tsize_t len,\n\tint (*recv)(gitno_buffer *buf), void *cb_data)\n{\n\tmemset(data, 0x0, len);\n\tbuf->data = data;\n\tbuf->len = len;\n\tbuf->offset = 0;\n\tbuf->recv = recv;\n\tbuf->cb_data = cb_data;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_buffer_setup_callback(\n\tgitno_buffer *buf,\n\tchar *data,\n\tsize_t len,\n\tint (*recv)(gitno_buffer *buf), void *cb_data)\n{\n\tmemset(data, 0x0, len);\n\tbuf->data = data;\n\tbuf->len = len;\n\tbuf->offset = 0;\n\tbuf->recv = recv;\n\tbuf->cb_data = cb_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t->rpc || t->current_stream == *stream"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->wrapped->action",
          "args": [
            "stream",
            "t->wrapped",
            "t->url",
            "GIT_SERVICE_RECEIVEPACK"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"This operation is only valid for push\""
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_smart__reset_stream",
          "args": [
            "t",
            "false"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__reset_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "38-50",
          "snippet": "GIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nGIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_smart__get_push_stream(transport_smart *t, git_smart_subtransport_stream **stream)\n{\n\tint error;\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\tif (GIT_DIRECTION_PUSH != t->direction) {\n\t\tgiterr_set(GITERR_NET, \"This operation is only valid for push\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(stream, t->wrapped, t->url, GIT_SERVICE_RECEIVEPACK)) < 0)\n\t\treturn error;\n\n\t/* If this is a stateful implementation, the stream we get back should be the same */\n\tassert(t->rpc || t->current_stream == *stream);\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = *stream;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_smart__negotiation_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "307-336",
    "snippet": "int git_smart__negotiation_step(git_transport *transport, void *data, size_t len)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_smart_subtransport_stream *stream;\n\tint error;\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\tif (GIT_DIRECTION_FETCH != t->direction) {\n\t\tgiterr_set(GITERR_NET, \"This operation is only valid for fetch\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(&stream, t->wrapped, t->url, GIT_SERVICE_UPLOADPACK)) < 0)\n\t\treturn error;\n\n\t/* If this is a stateful implementation, the stream we get back should be the same */\n\tassert(t->rpc || t->current_stream == stream);\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = stream;\n\n\tif ((error = stream->write(stream, (const char *)data, len)) < 0)\n\t\treturn error;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gitno_buffer_setup_callback",
          "args": [
            "&t->buffer",
            "t->buffer_data",
            "sizeof(t->buffer_data)",
            "git_smart__recv_cb",
            "t"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_buffer_setup_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "23-35",
          "snippet": "void gitno_buffer_setup_callback(\n\tgitno_buffer *buf,\n\tchar *data,\n\tsize_t len,\n\tint (*recv)(gitno_buffer *buf), void *cb_data)\n{\n\tmemset(data, 0x0, len);\n\tbuf->data = data;\n\tbuf->len = len;\n\tbuf->offset = 0;\n\tbuf->recv = recv;\n\tbuf->cb_data = cb_data;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_buffer_setup_callback(\n\tgitno_buffer *buf,\n\tchar *data,\n\tsize_t len,\n\tint (*recv)(gitno_buffer *buf), void *cb_data)\n{\n\tmemset(data, 0x0, len);\n\tbuf->data = data;\n\tbuf->len = len;\n\tbuf->offset = 0;\n\tbuf->recv = recv;\n\tbuf->cb_data = cb_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "stream",
            "(const char *)data",
            "len"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t->rpc || t->current_stream == stream"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->wrapped->action",
          "args": [
            "&stream",
            "t->wrapped",
            "t->url",
            "GIT_SERVICE_UPLOADPACK"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"This operation is only valid for fetch\""
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_smart__reset_stream",
          "args": [
            "t",
            "false"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__reset_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "38-50",
          "snippet": "GIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nGIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_smart__negotiation_step(git_transport *transport, void *data, size_t len)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_smart_subtransport_stream *stream;\n\tint error;\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\tif (GIT_DIRECTION_FETCH != t->direction) {\n\t\tgiterr_set(GITERR_NET, \"This operation is only valid for fetch\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(&stream, t->wrapped, t->url, GIT_SERVICE_UPLOADPACK)) < 0)\n\t\treturn error;\n\n\t/* If this is a stateful implementation, the stream we get back should be the same */\n\tassert(t->rpc || t->current_stream == stream);\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = stream;\n\n\tif ((error = stream->write(stream, (const char *)data, len)) < 0)\n\t\treturn error;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_smart__ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "292-305",
    "snippet": "static int git_smart__ls(const git_remote_head ***out, size_t *size, git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\tif (!t->have_refs) {\n\t\tgiterr_set(GITERR_NET, \"The transport has not yet loaded the refs\");\n\t\treturn -1;\n\t}\n\n\t*out = (const git_remote_head **) t->heads.contents;\n\t*size = t->heads.length;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"The transport has not yet loaded the refs\""
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_smart__ls(const git_remote_head ***out, size_t *size, git_transport *transport)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\tif (!t->have_refs) {\n\t\tgiterr_set(GITERR_NET, \"The transport has not yet loaded the refs\");\n\t\treturn -1;\n\t}\n\n\t*out = (const git_remote_head **) t->heads.contents;\n\t*size = t->heads.length;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_smart__connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "197-290",
    "snippet": "static int git_smart__connect(\n\tgit_transport *transport,\n\tconst char *url,\n\tgit_cred_acquire_cb cred_acquire_cb,\n\tvoid *cred_acquire_payload,\n\tint direction,\n\tint flags)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_smart_subtransport_stream *stream;\n\tint error;\n\tgit_pkt *pkt;\n\tgit_pkt_ref *first;\n\tgit_vector symrefs;\n\tgit_smart_service_t service;\n\n\tif (git_smart__reset_stream(t, true) < 0)\n\t\treturn -1;\n\n\tt->url = git__strdup(url);\n\tGITERR_CHECK_ALLOC(t->url);\n\n\tt->direction = direction;\n\tt->flags = flags;\n\tt->cred_acquire_cb = cred_acquire_cb;\n\tt->cred_acquire_payload = cred_acquire_payload;\n\n\tif (GIT_DIRECTION_FETCH == t->direction)\n\t\tservice = GIT_SERVICE_UPLOADPACK_LS;\n\telse if (GIT_DIRECTION_PUSH == t->direction)\n\t\tservice = GIT_SERVICE_RECEIVEPACK_LS;\n\telse {\n\t\tgiterr_set(GITERR_NET, \"Invalid direction\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(&stream, t->wrapped, t->url, service)) < 0)\n\t\treturn error;\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = stream;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\t/* 2 flushes for RPC; 1 for stateful */\n\tif ((error = git_smart__store_refs(t, t->rpc ? 2 : 1)) < 0)\n\t\treturn error;\n\n\t/* Strip the comment packet for RPC */\n\tif (t->rpc) {\n\t\tpkt = (git_pkt *)git_vector_get(&t->refs, 0);\n\n\t\tif (!pkt || GIT_PKT_COMMENT != pkt->type) {\n\t\t\tgiterr_set(GITERR_NET, \"Invalid response\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\t/* Remove the comment pkt from the list */\n\t\t\tgit_vector_remove(&t->refs, 0);\n\t\t\tgit__free(pkt);\n\t\t}\n\t}\n\n\t/* We now have loaded the refs. */\n\tt->have_refs = 1;\n\n\tfirst = (git_pkt_ref *)git_vector_get(&t->refs, 0);\n\n\tif ((error = git_vector_init(&symrefs, 1, NULL)) < 0)\n\t\treturn error;\n\n\t/* Detect capabilities */\n\tif (git_smart__detect_caps(first, &t->caps, &symrefs) < 0)\n\t\treturn -1;\n\n\t/* If the only ref in the list is capabilities^{} with OID_ZERO, remove it */\n\tif (1 == t->refs.length && !strcmp(first->head.name, \"capabilities^{}\") &&\n\t\tgit_oid_iszero(&first->head.oid)) {\n\t\tgit_vector_clear(&t->refs);\n\t\tgit_pkt_free((git_pkt *)first);\n\t}\n\n\t/* Keep a list of heads for _ls */\n\tgit_smart__update_heads(t, &symrefs);\n\n\tfree_symrefs(&symrefs);\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\t/* We're now logically connected. */\n\tt->connected = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_smart__reset_stream",
          "args": [
            "t",
            "false"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__reset_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "38-50",
          "snippet": "GIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nGIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_symrefs",
          "args": [
            "&symrefs"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "free_symrefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "184-195",
          "snippet": "static void free_symrefs(git_vector *symrefs)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(symrefs, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_free(symrefs);\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic void free_symrefs(git_vector *symrefs)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(symrefs, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_free(symrefs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_smart__update_heads",
          "args": [
            "t",
            "&symrefs"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__update_heads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "147-182",
          "snippet": "int git_smart__update_heads(transport_smart *t, git_vector *symrefs)\n{\n\tsize_t i;\n\tgit_pkt *pkt;\n\n\tgit_vector_clear(&t->heads);\n\tgit_vector_foreach(&t->refs, i, pkt) {\n\t\tgit_pkt_ref *ref = (git_pkt_ref *) pkt;\n\t\tif (pkt->type != GIT_PKT_REF)\n\t\t\tcontinue;\n\n\t\tif (symrefs) {\n\t\t\tgit_refspec *spec;\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t j;\n\t\t\tint error = 0;\n\n\t\t\tgit_vector_foreach(symrefs, j, spec) {\n\t\t\t\tgit_buf_clear(&buf);\n\t\t\t\tif (git_refspec_src_matches(spec, ref->head.name) &&\n\t\t\t\t    !(error = git_refspec_transform(&buf, spec, ref->head.name)))\n\t\t\t\t\tref->head.symref_target = git_buf_detach(&buf);\n\t\t\t}\n\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (git_vector_insert(&t->heads, &ref->head) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_smart__update_heads(transport_smart *t, git_vector *symrefs)\n{\n\tsize_t i;\n\tgit_pkt *pkt;\n\n\tgit_vector_clear(&t->heads);\n\tgit_vector_foreach(&t->refs, i, pkt) {\n\t\tgit_pkt_ref *ref = (git_pkt_ref *) pkt;\n\t\tif (pkt->type != GIT_PKT_REF)\n\t\t\tcontinue;\n\n\t\tif (symrefs) {\n\t\t\tgit_refspec *spec;\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t j;\n\t\t\tint error = 0;\n\n\t\t\tgit_vector_foreach(symrefs, j, spec) {\n\t\t\t\tgit_buf_clear(&buf);\n\t\t\t\tif (git_refspec_src_matches(spec, ref->head.name) &&\n\t\t\t\t    !(error = git_refspec_transform(&buf, spec, ref->head.name)))\n\t\t\t\t\tref->head.symref_target = git_buf_detach(&buf);\n\t\t\t}\n\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (git_vector_insert(&t->heads, &ref->head) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_free",
          "args": [
            "(git_pkt *)first"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "476-496",
          "snippet": "void git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&t->refs"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&first->head.oid"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "first->head.name",
            "\"capabilities^{}\""
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_smart__detect_caps",
          "args": [
            "first",
            "&t->caps",
            "&symrefs"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__detect_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "128-205",
          "snippet": "int git_smart__detect_caps(git_pkt_ref *pkt, transport_smart_caps *caps, git_vector *symrefs)\n{\n\tconst char *ptr;\n\n\t/* No refs or capabilites, odd but not a problem */\n\tif (pkt == NULL || pkt->capabilities == NULL)\n\t\treturn 0;\n\n\tptr = pkt->capabilities;\n\twhile (ptr != NULL && *ptr != '\\0') {\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_OFS_DELTA)) {\n\t\t\tcaps->common = caps->ofs_delta = 1;\n\t\t\tptr += strlen(GIT_CAP_OFS_DELTA);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep multi_ack_detailed before multi_ack */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK_DETAILED)) {\n\t\t\tcaps->common = caps->multi_ack_detailed = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK_DETAILED);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK)) {\n\t\t\tcaps->common = caps->multi_ack = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_INCLUDE_TAG)) {\n\t\t\tcaps->common = caps->include_tag = 1;\n\t\t\tptr += strlen(GIT_CAP_INCLUDE_TAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep side-band check after side-band-64k */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND_64K)) {\n\t\t\tcaps->common = caps->side_band_64k = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND_64K);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND)) {\n\t\t\tcaps->common = caps->side_band = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_DELETE_REFS)) {\n\t\t\tcaps->common = caps->delete_refs = 1;\n\t\t\tptr += strlen(GIT_CAP_DELETE_REFS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_THIN_PACK)) {\n\t\t\tcaps->common = caps->thin_pack = 1;\n\t\t\tptr += strlen(GIT_CAP_THIN_PACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SYMREF)) {\n\t\t\tint error;\n\n\t\t\tif ((error = append_symref(&ptr, symrefs, ptr)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We don't know this capability, so skip it */\n\t\tptr = strchr(ptr, ' ');\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nint git_smart__detect_caps(git_pkt_ref *pkt, transport_smart_caps *caps, git_vector *symrefs)\n{\n\tconst char *ptr;\n\n\t/* No refs or capabilites, odd but not a problem */\n\tif (pkt == NULL || pkt->capabilities == NULL)\n\t\treturn 0;\n\n\tptr = pkt->capabilities;\n\twhile (ptr != NULL && *ptr != '\\0') {\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_OFS_DELTA)) {\n\t\t\tcaps->common = caps->ofs_delta = 1;\n\t\t\tptr += strlen(GIT_CAP_OFS_DELTA);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep multi_ack_detailed before multi_ack */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK_DETAILED)) {\n\t\t\tcaps->common = caps->multi_ack_detailed = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK_DETAILED);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK)) {\n\t\t\tcaps->common = caps->multi_ack = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_INCLUDE_TAG)) {\n\t\t\tcaps->common = caps->include_tag = 1;\n\t\t\tptr += strlen(GIT_CAP_INCLUDE_TAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep side-band check after side-band-64k */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND_64K)) {\n\t\t\tcaps->common = caps->side_band_64k = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND_64K);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND)) {\n\t\t\tcaps->common = caps->side_band = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_DELETE_REFS)) {\n\t\t\tcaps->common = caps->delete_refs = 1;\n\t\t\tptr += strlen(GIT_CAP_DELETE_REFS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_THIN_PACK)) {\n\t\t\tcaps->common = caps->thin_pack = 1;\n\t\t\tptr += strlen(GIT_CAP_THIN_PACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SYMREF)) {\n\t\t\tint error;\n\n\t\t\tif ((error = append_symref(&ptr, symrefs, ptr)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We don't know this capability, so skip it */\n\t\tptr = strchr(ptr, ' ');\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&symrefs",
            "1",
            "NULL"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&t->refs",
            "0"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "pkt"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_remove",
          "args": [
            "&t->refs",
            "0"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "233-250",
          "snippet": "int git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Invalid response\""
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_smart__store_refs",
          "args": [
            "t",
            "t->rpc ? 2 : 1"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__store_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "22-78",
          "snippet": "int git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t/* Clear existing refs in case git_remote_connect() is called again\n\t * after git_remote_disconnect().\n\t */\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0 && !flush) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \"Remote error: %s\", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->type != GIT_PKT_FLUSH && git_vector_insert(refs, pkt) < 0)\n\t\t\treturn -1;\n\n\t\tif (pkt->type == GIT_PKT_FLUSH) {\n\t\t\tflush++;\n\t\t\tgit_pkt_free(pkt);\n\t\t}\n\t} while (flush < flushes);\n\n\treturn flush;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nint git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t/* Clear existing refs in case git_remote_connect() is called again\n\t * after git_remote_disconnect().\n\t */\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0 && !flush) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \"Remote error: %s\", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->type != GIT_PKT_FLUSH && git_vector_insert(refs, pkt) < 0)\n\t\t\treturn -1;\n\n\t\tif (pkt->type == GIT_PKT_FLUSH) {\n\t\t\tflush++;\n\t\t\tgit_pkt_free(pkt);\n\t\t}\n\t} while (flush < flushes);\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_buffer_setup_callback",
          "args": [
            "&t->buffer",
            "t->buffer_data",
            "sizeof(t->buffer_data)",
            "git_smart__recv_cb",
            "t"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_buffer_setup_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "23-35",
          "snippet": "void gitno_buffer_setup_callback(\n\tgitno_buffer *buf,\n\tchar *data,\n\tsize_t len,\n\tint (*recv)(gitno_buffer *buf), void *cb_data)\n{\n\tmemset(data, 0x0, len);\n\tbuf->data = data;\n\tbuf->len = len;\n\tbuf->offset = 0;\n\tbuf->recv = recv;\n\tbuf->cb_data = cb_data;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_buffer_setup_callback(\n\tgitno_buffer *buf,\n\tchar *data,\n\tsize_t len,\n\tint (*recv)(gitno_buffer *buf), void *cb_data)\n{\n\tmemset(data, 0x0, len);\n\tbuf->data = data;\n\tbuf->len = len;\n\tbuf->offset = 0;\n\tbuf->recv = recv;\n\tbuf->cb_data = cb_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->wrapped->action",
          "args": [
            "&stream",
            "t->wrapped",
            "t->url",
            "service"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "t->url"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "url"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_smart__connect(\n\tgit_transport *transport,\n\tconst char *url,\n\tgit_cred_acquire_cb cred_acquire_cb,\n\tvoid *cred_acquire_payload,\n\tint direction,\n\tint flags)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_smart_subtransport_stream *stream;\n\tint error;\n\tgit_pkt *pkt;\n\tgit_pkt_ref *first;\n\tgit_vector symrefs;\n\tgit_smart_service_t service;\n\n\tif (git_smart__reset_stream(t, true) < 0)\n\t\treturn -1;\n\n\tt->url = git__strdup(url);\n\tGITERR_CHECK_ALLOC(t->url);\n\n\tt->direction = direction;\n\tt->flags = flags;\n\tt->cred_acquire_cb = cred_acquire_cb;\n\tt->cred_acquire_payload = cred_acquire_payload;\n\n\tif (GIT_DIRECTION_FETCH == t->direction)\n\t\tservice = GIT_SERVICE_UPLOADPACK_LS;\n\telse if (GIT_DIRECTION_PUSH == t->direction)\n\t\tservice = GIT_SERVICE_RECEIVEPACK_LS;\n\telse {\n\t\tgiterr_set(GITERR_NET, \"Invalid direction\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(&stream, t->wrapped, t->url, service)) < 0)\n\t\treturn error;\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = stream;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\t/* 2 flushes for RPC; 1 for stateful */\n\tif ((error = git_smart__store_refs(t, t->rpc ? 2 : 1)) < 0)\n\t\treturn error;\n\n\t/* Strip the comment packet for RPC */\n\tif (t->rpc) {\n\t\tpkt = (git_pkt *)git_vector_get(&t->refs, 0);\n\n\t\tif (!pkt || GIT_PKT_COMMENT != pkt->type) {\n\t\t\tgiterr_set(GITERR_NET, \"Invalid response\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\t/* Remove the comment pkt from the list */\n\t\t\tgit_vector_remove(&t->refs, 0);\n\t\t\tgit__free(pkt);\n\t\t}\n\t}\n\n\t/* We now have loaded the refs. */\n\tt->have_refs = 1;\n\n\tfirst = (git_pkt_ref *)git_vector_get(&t->refs, 0);\n\n\tif ((error = git_vector_init(&symrefs, 1, NULL)) < 0)\n\t\treturn error;\n\n\t/* Detect capabilities */\n\tif (git_smart__detect_caps(first, &t->caps, &symrefs) < 0)\n\t\treturn -1;\n\n\t/* If the only ref in the list is capabilities^{} with OID_ZERO, remove it */\n\tif (1 == t->refs.length && !strcmp(first->head.name, \"capabilities^{}\") &&\n\t\tgit_oid_iszero(&first->head.oid)) {\n\t\tgit_vector_clear(&t->refs);\n\t\tgit_pkt_free((git_pkt *)first);\n\t}\n\n\t/* Keep a list of heads for _ls */\n\tgit_smart__update_heads(t, &symrefs);\n\n\tfree_symrefs(&symrefs);\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\t/* We're now logically connected. */\n\tt->connected = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_symrefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "184-195",
    "snippet": "static void free_symrefs(git_vector *symrefs)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(symrefs, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_free(symrefs);\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "symrefs"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "spec"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "spec"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "symrefs",
            "i",
            "spec"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic void free_symrefs(git_vector *symrefs)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(symrefs, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_free(symrefs);\n}"
  },
  {
    "function_name": "git_smart__update_heads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "147-182",
    "snippet": "int git_smart__update_heads(transport_smart *t, git_vector *symrefs)\n{\n\tsize_t i;\n\tgit_pkt *pkt;\n\n\tgit_vector_clear(&t->heads);\n\tgit_vector_foreach(&t->refs, i, pkt) {\n\t\tgit_pkt_ref *ref = (git_pkt_ref *) pkt;\n\t\tif (pkt->type != GIT_PKT_REF)\n\t\t\tcontinue;\n\n\t\tif (symrefs) {\n\t\t\tgit_refspec *spec;\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t j;\n\t\t\tint error = 0;\n\n\t\t\tgit_vector_foreach(symrefs, j, spec) {\n\t\t\t\tgit_buf_clear(&buf);\n\t\t\t\tif (git_refspec_src_matches(spec, ref->head.name) &&\n\t\t\t\t    !(error = git_refspec_transform(&buf, spec, ref->head.name)))\n\t\t\t\t\tref->head.symref_target = git_buf_detach(&buf);\n\t\t\t}\n\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (git_vector_insert(&t->heads, &ref->head) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&t->heads",
            "&ref->head"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&buf"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_transform",
          "args": [
            "&buf",
            "spec",
            "ref->head.name"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "244-258",
          "snippet": "int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_src_matches",
          "args": [
            "spec",
            "ref->head.name"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_src_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "185-191",
          "snippet": "int git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&buf"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "symrefs",
            "j",
            "spec"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&t->refs",
            "i",
            "pkt"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&t->heads"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_smart__update_heads(transport_smart *t, git_vector *symrefs)\n{\n\tsize_t i;\n\tgit_pkt *pkt;\n\n\tgit_vector_clear(&t->heads);\n\tgit_vector_foreach(&t->refs, i, pkt) {\n\t\tgit_pkt_ref *ref = (git_pkt_ref *) pkt;\n\t\tif (pkt->type != GIT_PKT_REF)\n\t\t\tcontinue;\n\n\t\tif (symrefs) {\n\t\t\tgit_refspec *spec;\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t j;\n\t\t\tint error = 0;\n\n\t\t\tgit_vector_foreach(symrefs, j, spec) {\n\t\t\t\tgit_buf_clear(&buf);\n\t\t\t\tif (git_refspec_src_matches(spec, ref->head.name) &&\n\t\t\t\t    !(error = git_refspec_transform(&buf, spec, ref->head.name)))\n\t\t\t\t\tref->head.symref_target = git_buf_detach(&buf);\n\t\t\t}\n\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (git_vector_insert(&t->heads, &ref->head) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_smart__set_custom_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "120-145",
    "snippet": "static int git_smart__set_custom_headers(\n\tgit_transport *transport,\n\tconst git_strarray *custom_headers)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tsize_t i;\n\n\tif (t->custom_headers.count)\n\t\tgit_strarray_free(&t->custom_headers);\n\n\tif (!custom_headers)\n\t\treturn 0;\n\n\tfor (i = 0; i < custom_headers->count; i++) {\n\t\tif (is_malformed_http_header(custom_headers->strings[i])) {\n\t\t\tgiterr_set(GITERR_INVALID, \"custom HTTP header '%s' is malformed\", custom_headers->strings[i]);\n\t\t\treturn -1;\n\t\t}\n\t\tif (is_forbidden_custom_header(custom_headers->strings[i])) {\n\t\t\tgiterr_set(GITERR_INVALID, \"custom HTTP header '%s' is already set by libgit2\", custom_headers->strings[i]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn git_strarray_copy(&t->custom_headers, custom_headers);\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strarray_copy",
          "args": [
            "&t->custom_headers",
            "custom_headers"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "git_strarray_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "36-65",
          "snippet": "int git_strarray_copy(git_strarray *tgt, const git_strarray *src)\n{\n\tsize_t i;\n\n\tassert(tgt && src);\n\n\tmemset(tgt, 0, sizeof(*tgt));\n\n\tif (!src->count)\n\t\treturn 0;\n\n\ttgt->strings = git__calloc(src->count, sizeof(char *));\n\tGITERR_CHECK_ALLOC(tgt->strings);\n\n\tfor (i = 0; i < src->count; ++i) {\n\t\tif (!src->strings[i])\n\t\t\tcontinue;\n\n\t\ttgt->strings[tgt->count] = git__strdup(src->strings[i]);\n\t\tif (!tgt->strings[tgt->count]) {\n\t\t\tgit_strarray_free(tgt);\n\t\t\tmemset(tgt, 0, sizeof(*tgt));\n\t\t\treturn -1;\n\t\t}\n\n\t\ttgt->count++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git_strarray_copy(git_strarray *tgt, const git_strarray *src)\n{\n\tsize_t i;\n\n\tassert(tgt && src);\n\n\tmemset(tgt, 0, sizeof(*tgt));\n\n\tif (!src->count)\n\t\treturn 0;\n\n\ttgt->strings = git__calloc(src->count, sizeof(char *));\n\tGITERR_CHECK_ALLOC(tgt->strings);\n\n\tfor (i = 0; i < src->count; ++i) {\n\t\tif (!src->strings[i])\n\t\t\tcontinue;\n\n\t\ttgt->strings[tgt->count] = git__strdup(src->strings[i]);\n\t\tif (!tgt->strings[tgt->count]) {\n\t\t\tgit_strarray_free(tgt);\n\t\t\tmemset(tgt, 0, sizeof(*tgt));\n\t\t\treturn -1;\n\t\t}\n\n\t\ttgt->count++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"custom HTTP header '%s' is already set by libgit2\"",
            "custom_headers->strings[i]"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_forbidden_custom_header",
          "args": [
            "custom_headers->strings[i]"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "is_forbidden_custom_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "107-118",
          "snippet": "static bool is_forbidden_custom_header(const char *custom_header)\n{\n\tunsigned long i;\n\tint name_len = http_header_name_length(custom_header);\n\n\t// Disallow headers that we set\n\tfor (i = 0; i < ARRAY_SIZE(forbidden_custom_headers); i++)\n\t\tif (strncmp(forbidden_custom_headers[i], custom_header, name_len) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *forbidden_custom_headers[] = {\n\t\"User-Agent\",\n\t\"Host\",\n\t\"Accept\",\n\t\"Content-Type\",\n\t\"Transfer-Encoding\",\n\t\"Content-Length\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic char *forbidden_custom_headers[] = {\n\t\"User-Agent\",\n\t\"Host\",\n\t\"Accept\",\n\t\"Content-Type\",\n\t\"Transfer-Encoding\",\n\t\"Content-Length\",\n};\n\nstatic bool is_forbidden_custom_header(const char *custom_header)\n{\n\tunsigned long i;\n\tint name_len = http_header_name_length(custom_header);\n\n\t// Disallow headers that we set\n\tfor (i = 0; i < ARRAY_SIZE(forbidden_custom_headers); i++)\n\t\tif (strncmp(forbidden_custom_headers[i], custom_header, name_len) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_malformed_http_header",
          "args": [
            "custom_headers->strings[i]"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "is_malformed_http_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "77-96",
          "snippet": "static bool is_malformed_http_header(const char *http_header)\n{\n\tconst char *c;\n\tint name_len;\n\n\t// Disallow \\r and \\n\n\tc = strchr(http_header, '\\r');\n\tif (c)\n\t\treturn true;\n\tc = strchr(http_header, '\\n');\n\tif (c)\n\t\treturn true;\n\n\t// Require a header name followed by :\n\tname_len = http_header_name_length(http_header);\n\tif (name_len < 1)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic bool is_malformed_http_header(const char *http_header)\n{\n\tconst char *c;\n\tint name_len;\n\n\t// Disallow \\r and \\n\n\tc = strchr(http_header, '\\r');\n\tif (c)\n\t\treturn true;\n\tc = strchr(http_header, '\\n');\n\tif (c)\n\t\treturn true;\n\n\t// Require a header name followed by :\n\tname_len = http_header_name_length(http_header);\n\tif (name_len < 1)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strarray_free",
          "args": [
            "&t->custom_headers"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "git_strarray_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "21-34",
          "snippet": "void git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nvoid git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_smart__set_custom_headers(\n\tgit_transport *transport,\n\tconst git_strarray *custom_headers)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tsize_t i;\n\n\tif (t->custom_headers.count)\n\t\tgit_strarray_free(&t->custom_headers);\n\n\tif (!custom_headers)\n\t\treturn 0;\n\n\tfor (i = 0; i < custom_headers->count; i++) {\n\t\tif (is_malformed_http_header(custom_headers->strings[i])) {\n\t\t\tgiterr_set(GITERR_INVALID, \"custom HTTP header '%s' is malformed\", custom_headers->strings[i]);\n\t\t\treturn -1;\n\t\t}\n\t\tif (is_forbidden_custom_header(custom_headers->strings[i])) {\n\t\t\tgiterr_set(GITERR_INVALID, \"custom HTTP header '%s' is already set by libgit2\", custom_headers->strings[i]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn git_strarray_copy(&t->custom_headers, custom_headers);\n}"
  },
  {
    "function_name": "is_forbidden_custom_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "107-118",
    "snippet": "static bool is_forbidden_custom_header(const char *custom_header)\n{\n\tunsigned long i;\n\tint name_len = http_header_name_length(custom_header);\n\n\t// Disallow headers that we set\n\tfor (i = 0; i < ARRAY_SIZE(forbidden_custom_headers); i++)\n\t\tif (strncmp(forbidden_custom_headers[i], custom_header, name_len) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *forbidden_custom_headers[] = {\n\t\"User-Agent\",\n\t\"Host\",\n\t\"Accept\",\n\t\"Content-Type\",\n\t\"Transfer-Encoding\",\n\t\"Content-Length\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "forbidden_custom_headers[i]",
            "custom_header",
            "name_len"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "forbidden_custom_headers"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_header_name_length",
          "args": [
            "custom_header"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "http_header_name_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "69-75",
          "snippet": "static int http_header_name_length(const char *http_header)\n{\n\tconst char *colon = strchr(http_header, ':');\n\tif (!colon)\n\t\treturn 0;\n\treturn colon - http_header;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int http_header_name_length(const char *http_header)\n{\n\tconst char *colon = strchr(http_header, ':');\n\tif (!colon)\n\t\treturn 0;\n\treturn colon - http_header;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic char *forbidden_custom_headers[] = {\n\t\"User-Agent\",\n\t\"Host\",\n\t\"Accept\",\n\t\"Content-Type\",\n\t\"Transfer-Encoding\",\n\t\"Content-Length\",\n};\n\nstatic bool is_forbidden_custom_header(const char *custom_header)\n{\n\tunsigned long i;\n\tint name_len = http_header_name_length(custom_header);\n\n\t// Disallow headers that we set\n\tfor (i = 0; i < ARRAY_SIZE(forbidden_custom_headers); i++)\n\t\tif (strncmp(forbidden_custom_headers[i], custom_header, name_len) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "is_malformed_http_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "77-96",
    "snippet": "static bool is_malformed_http_header(const char *http_header)\n{\n\tconst char *c;\n\tint name_len;\n\n\t// Disallow \\r and \\n\n\tc = strchr(http_header, '\\r');\n\tif (c)\n\t\treturn true;\n\tc = strchr(http_header, '\\n');\n\tif (c)\n\t\treturn true;\n\n\t// Require a header name followed by :\n\tname_len = http_header_name_length(http_header);\n\tif (name_len < 1)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_header_name_length",
          "args": [
            "http_header"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "http_header_name_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "69-75",
          "snippet": "static int http_header_name_length(const char *http_header)\n{\n\tconst char *colon = strchr(http_header, ':');\n\tif (!colon)\n\t\treturn 0;\n\treturn colon - http_header;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int http_header_name_length(const char *http_header)\n{\n\tconst char *colon = strchr(http_header, ':');\n\tif (!colon)\n\t\treturn 0;\n\treturn colon - http_header;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "http_header",
            "'\\n'"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "http_header",
            "'\\r'"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic bool is_malformed_http_header(const char *http_header)\n{\n\tconst char *c;\n\tint name_len;\n\n\t// Disallow \\r and \\n\n\tc = strchr(http_header, '\\r');\n\tif (c)\n\t\treturn true;\n\tc = strchr(http_header, '\\n');\n\tif (c)\n\t\treturn true;\n\n\t// Require a header name followed by :\n\tname_len = http_header_name_length(http_header);\n\tif (name_len < 1)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "http_header_name_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "69-75",
    "snippet": "static int http_header_name_length(const char *http_header)\n{\n\tconst char *colon = strchr(http_header, ':');\n\tif (!colon)\n\t\treturn 0;\n\treturn colon - http_header;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "http_header",
            "':'"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int http_header_name_length(const char *http_header)\n{\n\tconst char *colon = strchr(http_header, ':');\n\tif (!colon)\n\t\treturn 0;\n\treturn colon - http_header;\n}"
  },
  {
    "function_name": "git_smart__set_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "52-67",
    "snippet": "static int git_smart__set_callbacks(\n\tgit_transport *transport,\n\tgit_transport_message_cb progress_cb,\n\tgit_transport_message_cb error_cb,\n\tgit_transport_certificate_check_cb certificate_check_cb,\n\tvoid *message_cb_payload)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\tt->progress_cb = progress_cb;\n\tt->error_cb = error_cb;\n\tt->certificate_check_cb = certificate_check_cb;\n\tt->message_cb_payload = message_cb_payload;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_smart__set_callbacks(\n\tgit_transport *transport,\n\tgit_transport_message_cb progress_cb,\n\tgit_transport_message_cb error_cb,\n\tgit_transport_certificate_check_cb certificate_check_cb,\n\tvoid *message_cb_payload)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\n\tt->progress_cb = progress_cb;\n\tt->error_cb = error_cb;\n\tt->certificate_check_cb = certificate_check_cb;\n\tt->message_cb_payload = message_cb_payload;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_smart__reset_stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "38-50",
    "snippet": "GIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->wrapped->close",
          "args": [
            "t->wrapped"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->current_stream->free",
          "args": [
            "t->current_stream"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nGIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)\n{\n\tif (t->current_stream) {\n\t\tt->current_stream->free(t->current_stream);\n\t\tt->current_stream = NULL;\n\t}\n\n\tif (close_subtransport &&\n\t\tt->wrapped->close(t->wrapped) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_smart__recv_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
    "lines": "12-36",
    "snippet": "static int git_smart__recv_cb(gitno_buffer *buf)\n{\n\ttransport_smart *t = (transport_smart *) buf->cb_data;\n\tsize_t old_len, bytes_read;\n\tint error;\n\n\tassert(t->current_stream);\n\n\told_len = buf->offset;\n\n\tif ((error = t->current_stream->read(t->current_stream, buf->data + buf->offset, buf->len - buf->offset, &bytes_read)) < 0)\n\t\treturn error;\n\n\tbuf->offset += bytes_read;\n\n\tif (t->packetsize_cb && !t->cancelled.val) {\n\t\terror = t->packetsize_cb(bytes_read, t->packetsize_payload);\n\t\tif (error) {\n\t\t\tgit_atomic_set(&t->cancelled, 1);\n\t\t\treturn GIT_EUSER;\n\t\t}\n\t}\n\n\treturn (int)(buf->offset - old_len);\n}",
    "includes": [
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_atomic_set",
          "args": [
            "&t->cancelled",
            "1"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "166-169",
          "snippet": "GIT_INLINE(void) git_atomic_set(git_atomic *a, int val)\n{\n\ta->val = val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(void) git_atomic_set(git_atomic *a, int val)\n{\n\ta->val = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->packetsize_cb",
          "args": [
            "bytes_read",
            "t->packetsize_payload"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->current_stream->read",
          "args": [
            "t->current_stream",
            "buf->data + buf->offset",
            "buf->len - buf->offset",
            "&bytes_read"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t->current_stream"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_smart__recv_cb(gitno_buffer *buf)\n{\n\ttransport_smart *t = (transport_smart *) buf->cb_data;\n\tsize_t old_len, bytes_read;\n\tint error;\n\n\tassert(t->current_stream);\n\n\told_len = buf->offset;\n\n\tif ((error = t->current_stream->read(t->current_stream, buf->data + buf->offset, buf->len - buf->offset, &bytes_read)) < 0)\n\t\treturn error;\n\n\tbuf->offset += bytes_read;\n\n\tif (t->packetsize_cb && !t->cancelled.val) {\n\t\terror = t->packetsize_cb(bytes_read, t->packetsize_payload);\n\t\tif (error) {\n\t\t\tgit_atomic_set(&t->cancelled, 1);\n\t\t\treturn GIT_EUSER;\n\t\t}\n\t}\n\n\treturn (int)(buf->offset - old_len);\n}"
  }
]