[
  {
    "function_name": "git_smart_subtransport_http",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "1056-1081",
    "snippet": "int git_smart_subtransport_http(git_smart_subtransport **out, git_transport *owner, void *param)\n{\n\thttp_subtransport *t;\n\n\tGIT_UNUSED(param);\n\n\tif (!out)\n\t\treturn -1;\n\n\tt = git__calloc(sizeof(http_subtransport), 1);\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->owner = (transport_smart *)owner;\n\tt->parent.action = http_action;\n\tt->parent.close = http_close;\n\tt->parent.free = http_free;\n\n\tt->settings.on_header_field = on_header_field;\n\tt->settings.on_header_value = on_header_value;\n\tt->settings.on_headers_complete = on_headers_complete;\n\tt->settings.on_body = on_body_fill_buffer;\n\tt->settings.on_message_complete = on_message_complete;\n\n\t*out = (git_smart_subtransport *) t;\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "t"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "sizeof(http_subtransport)",
            "1"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "param"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nint git_smart_subtransport_http(git_smart_subtransport **out, git_transport *owner, void *param)\n{\n\thttp_subtransport *t;\n\n\tGIT_UNUSED(param);\n\n\tif (!out)\n\t\treturn -1;\n\n\tt = git__calloc(sizeof(http_subtransport), 1);\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->owner = (transport_smart *)owner;\n\tt->parent.action = http_action;\n\tt->parent.close = http_close;\n\tt->parent.free = http_free;\n\n\tt->settings.on_header_field = on_header_field;\n\tt->settings.on_header_value = on_header_value;\n\tt->settings.on_headers_complete = on_headers_complete;\n\tt->settings.on_body = on_body_fill_buffer;\n\tt->settings.on_message_complete = on_message_complete;\n\n\t*out = (git_smart_subtransport *) t;\n\treturn 0;\n}"
  },
  {
    "function_name": "http_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "1046-1054",
    "snippet": "static void http_free(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\n\thttp_close(subtransport);\n\n\tgit_vector_free(&t->auth_contexts);\n\tgit__free(t);\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "t"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&t->auth_contexts"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_close",
          "args": [
            "subtransport"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "http_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "1009-1044",
          "snippet": "static int http_close(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\tgit_http_auth_context *context;\n\tsize_t i;\n\n\tclear_parser_state(t);\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t}\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\tgit_vector_foreach(&t->auth_contexts, i, context) {\n\t\tif (context->free)\n\t\t\tcontext->free(context);\n\t}\n\n\tgit_vector_clear(&t->auth_contexts);\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_close(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\tgit_http_auth_context *context;\n\tsize_t i;\n\n\tclear_parser_state(t);\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t}\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\tgit_vector_foreach(&t->auth_contexts, i, context) {\n\t\tif (context->free)\n\t\t\tcontext->free(context);\n\t}\n\n\tgit_vector_clear(&t->auth_contexts);\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic void http_free(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\n\thttp_close(subtransport);\n\n\tgit_vector_free(&t->auth_contexts);\n\tgit__free(t);\n}"
  },
  {
    "function_name": "http_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "1009-1044",
    "snippet": "static int http_close(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\tgit_http_auth_context *context;\n\tsize_t i;\n\n\tclear_parser_state(t);\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t}\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\tgit_vector_foreach(&t->auth_contexts, i, context) {\n\t\tif (context->free)\n\t\t\tcontext->free(context);\n\t}\n\n\tgit_vector_clear(&t->auth_contexts);\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&t->connection_data",
            "0x0",
            "sizeof(gitno_connection_data)"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gitno_connection_data_free_ptrs",
          "args": [
            "&t->connection_data"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_connection_data_free_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "200-207",
          "snippet": "void gitno_connection_data_free_ptrs(gitno_connection_data *d)\n{\n\tgit__free(d->host); d->host = NULL;\n\tgit__free(d->port); d->port = NULL;\n\tgit__free(d->path); d->path = NULL;\n\tgit__free(d->user); d->user = NULL;\n\tgit__free(d->pass); d->pass = NULL;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_connection_data_free_ptrs(gitno_connection_data *d)\n{\n\tgit__free(d->host); d->host = NULL;\n\tgit__free(d->port); d->port = NULL;\n\tgit__free(d->path); d->path = NULL;\n\tgit__free(d->user); d->user = NULL;\n\tgit__free(d->pass); d->pass = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&t->auth_contexts"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context->free",
          "args": [
            "context"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&t->auth_contexts",
            "i",
            "context"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->url_cred->free",
          "args": [
            "t->url_cred"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->cred->free",
          "args": [
            "t->cred"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_stream_free",
          "args": [
            "t->io"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "63-69",
          "snippet": "GIT_INLINE(void) git_stream_free(git_stream *st)\n{\n\tif (!st)\n\t\treturn;\n\n\tst->free(st);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) git_stream_free(git_stream *st)\n{\n\tif (!st)\n\t\treturn;\n\n\tst->free(st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_close",
          "args": [
            "t->io"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "58-61",
          "snippet": "GIT_INLINE(int) git_stream_close(git_stream *st)\n{\n\treturn st->close(st);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_stream_close(git_stream *st)\n{\n\treturn st->close(st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_parser_state",
          "args": [
            "t"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "clear_parser_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "503-528",
          "snippet": "static void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_close(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\tgit_http_auth_context *context;\n\tsize_t i;\n\n\tclear_parser_state(t);\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t}\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\tgit_vector_foreach(&t->auth_contexts, i, context) {\n\t\tif (context->free)\n\t\t\tcontext->free(context);\n\t}\n\n\tgit_vector_clear(&t->auth_contexts);\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "http_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "972-1007",
    "snippet": "static int http_action(\n\tgit_smart_subtransport_stream **stream,\n\tgit_smart_subtransport *subtransport,\n\tconst char *url,\n\tgit_smart_service_t action)\n{\n\thttp_subtransport *t = (http_subtransport *)subtransport;\n\tint ret;\n\n\tif (!stream)\n\t\treturn -1;\n\n\tif ((!t->connection_data.host || !t->connection_data.port || !t->connection_data.path) &&\n\t\t (ret = gitno_connection_data_from_url(&t->connection_data, url, NULL)) < 0)\n\t\treturn ret;\n\n\tif ((ret = http_connect(t)) < 0)\n\t\treturn ret;\n\n\tswitch (action) {\n\tcase GIT_SERVICE_UPLOADPACK_LS:\n\t\treturn http_uploadpack_ls(t, stream);\n\n\tcase GIT_SERVICE_UPLOADPACK:\n\t\treturn http_uploadpack(t, stream);\n\n\tcase GIT_SERVICE_RECEIVEPACK_LS:\n\t\treturn http_receivepack_ls(t, stream);\n\n\tcase GIT_SERVICE_RECEIVEPACK:\n\t\treturn http_receivepack(t, stream);\n\t}\n\n\t*stream = NULL;\n\treturn -1;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_receivepack",
          "args": [
            "t",
            "stream"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "http_receivepack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "950-970",
          "snippet": "static int http_receivepack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\t/* Use Transfer-Encoding: chunked for this request */\n\ts->chunked = 1;\n\ts->parent.write = http_stream_write_chunked;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_receivepack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\t/* Use Transfer-Encoding: chunked for this request */\n\ts->chunked = 1;\n\ts->parent.write = http_stream_write_chunked;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_receivepack_ls",
          "args": [
            "t",
            "stream"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "http_receivepack_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "932-948",
          "snippet": "static int http_receivepack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_receivepack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_uploadpack",
          "args": [
            "t",
            "stream"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "http_uploadpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "914-930",
          "snippet": "static int http_uploadpack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_uploadpack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_uploadpack_ls",
          "args": [
            "t",
            "stream"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "http_uploadpack_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "896-912",
          "snippet": "static int http_uploadpack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_uploadpack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_connect",
          "args": [
            "t"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "http_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "558-627",
          "snippet": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_connection_data_from_url",
          "args": [
            "&t->connection_data",
            "url",
            "NULL"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_connection_data_from_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "125-198",
          "snippet": "int gitno_connection_data_from_url(\n\t\tgitno_connection_data *data,\n\t\tconst char *url,\n\t\tconst char *service_suffix)\n{\n\tint error = -1;\n\tconst char *default_port = NULL, *path_search_start = NULL;\n\tchar *original_host = NULL;\n\n\t/* service_suffix is optional */\n\tassert(data && url);\n\n\t/* Save these for comparison later */\n\toriginal_host = data->host;\n\tdata->host = NULL;\n\tgitno_connection_data_free_ptrs(data);\n\n\tif (!git__prefixcmp(url, prefix_http)) {\n\t\tpath_search_start = url + strlen(prefix_http);\n\t\tdefault_port = \"80\";\n\n\t\tif (data->use_ssl) {\n\t\t\tgiterr_set(GITERR_NET, \"Redirect from HTTPS to HTTP is not allowed\");\n\t\t\tgoto cleanup;\n\t\t}\n\t} else if (!git__prefixcmp(url, prefix_https)) {\n\t\tpath_search_start = url + strlen(prefix_https);\n\t\tdefault_port = \"443\";\n\t\tdata->use_ssl = true;\n\t} else if (url[0] == '/')\n\t\tdefault_port = data->use_ssl ? \"443\" : \"80\";\n\n\tif (!default_port) {\n\t\tgiterr_set(GITERR_NET, \"Unrecognized URL prefix\");\n\t\tgoto cleanup;\n\t}\n\n\terror = gitno_extract_url_parts(\n\t\t&data->host, &data->port, &data->path, &data->user, &data->pass,\n\t\turl, default_port);\n\n\tif (url[0] == '/') {\n\t\t/* Relative redirect; reuse original host name and port */\n\t\tpath_search_start = url;\n\t\tgit__free(data->host);\n\t\tdata->host = original_host;\n\t\toriginal_host = NULL;\n\t}\n\n\tif (!error) {\n\t\tconst char *path = strchr(path_search_start, '/');\n\t\tsize_t pathlen = strlen(path);\n\t\tsize_t suffixlen = service_suffix ? strlen(service_suffix) : 0;\n\n\t\tif (suffixlen &&\n\t\t    !memcmp(path + pathlen - suffixlen, service_suffix, suffixlen)) {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strndup(path, pathlen - suffixlen);\n\t\t} else {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strdup(path);\n\t\t}\n\n\t\t/* Check for errors in the resulting data */\n\t\tif (original_host && url[0] != '/' && strcmp(original_host, data->host)) {\n\t\t\tgiterr_set(GITERR_NET, \"Cross host redirect not allowed\");\n\t\t\terror = -1;\n\t\t}\n\t}\n\ncleanup:\n\tif (original_host) git__free(original_host);\n\treturn error;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prefix_http = \"http://\";",
            "static const char *prefix_https = \"https://\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nstatic const char *prefix_http = \"http://\";\nstatic const char *prefix_https = \"https://\";\n\nint gitno_connection_data_from_url(\n\t\tgitno_connection_data *data,\n\t\tconst char *url,\n\t\tconst char *service_suffix)\n{\n\tint error = -1;\n\tconst char *default_port = NULL, *path_search_start = NULL;\n\tchar *original_host = NULL;\n\n\t/* service_suffix is optional */\n\tassert(data && url);\n\n\t/* Save these for comparison later */\n\toriginal_host = data->host;\n\tdata->host = NULL;\n\tgitno_connection_data_free_ptrs(data);\n\n\tif (!git__prefixcmp(url, prefix_http)) {\n\t\tpath_search_start = url + strlen(prefix_http);\n\t\tdefault_port = \"80\";\n\n\t\tif (data->use_ssl) {\n\t\t\tgiterr_set(GITERR_NET, \"Redirect from HTTPS to HTTP is not allowed\");\n\t\t\tgoto cleanup;\n\t\t}\n\t} else if (!git__prefixcmp(url, prefix_https)) {\n\t\tpath_search_start = url + strlen(prefix_https);\n\t\tdefault_port = \"443\";\n\t\tdata->use_ssl = true;\n\t} else if (url[0] == '/')\n\t\tdefault_port = data->use_ssl ? \"443\" : \"80\";\n\n\tif (!default_port) {\n\t\tgiterr_set(GITERR_NET, \"Unrecognized URL prefix\");\n\t\tgoto cleanup;\n\t}\n\n\terror = gitno_extract_url_parts(\n\t\t&data->host, &data->port, &data->path, &data->user, &data->pass,\n\t\turl, default_port);\n\n\tif (url[0] == '/') {\n\t\t/* Relative redirect; reuse original host name and port */\n\t\tpath_search_start = url;\n\t\tgit__free(data->host);\n\t\tdata->host = original_host;\n\t\toriginal_host = NULL;\n\t}\n\n\tif (!error) {\n\t\tconst char *path = strchr(path_search_start, '/');\n\t\tsize_t pathlen = strlen(path);\n\t\tsize_t suffixlen = service_suffix ? strlen(service_suffix) : 0;\n\n\t\tif (suffixlen &&\n\t\t    !memcmp(path + pathlen - suffixlen, service_suffix, suffixlen)) {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strndup(path, pathlen - suffixlen);\n\t\t} else {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strdup(path);\n\t\t}\n\n\t\t/* Check for errors in the resulting data */\n\t\tif (original_host && url[0] != '/' && strcmp(original_host, data->host)) {\n\t\t\tgiterr_set(GITERR_NET, \"Cross host redirect not allowed\");\n\t\t\terror = -1;\n\t\t}\n\t}\n\ncleanup:\n\tif (original_host) git__free(original_host);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_action(\n\tgit_smart_subtransport_stream **stream,\n\tgit_smart_subtransport *subtransport,\n\tconst char *url,\n\tgit_smart_service_t action)\n{\n\thttp_subtransport *t = (http_subtransport *)subtransport;\n\tint ret;\n\n\tif (!stream)\n\t\treturn -1;\n\n\tif ((!t->connection_data.host || !t->connection_data.port || !t->connection_data.path) &&\n\t\t (ret = gitno_connection_data_from_url(&t->connection_data, url, NULL)) < 0)\n\t\treturn ret;\n\n\tif ((ret = http_connect(t)) < 0)\n\t\treturn ret;\n\n\tswitch (action) {\n\tcase GIT_SERVICE_UPLOADPACK_LS:\n\t\treturn http_uploadpack_ls(t, stream);\n\n\tcase GIT_SERVICE_UPLOADPACK:\n\t\treturn http_uploadpack(t, stream);\n\n\tcase GIT_SERVICE_RECEIVEPACK_LS:\n\t\treturn http_receivepack_ls(t, stream);\n\n\tcase GIT_SERVICE_RECEIVEPACK:\n\t\treturn http_receivepack(t, stream);\n\t}\n\n\t*stream = NULL;\n\treturn -1;\n}"
  },
  {
    "function_name": "http_receivepack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "950-970",
    "snippet": "static int http_receivepack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\t/* Use Transfer-Encoding: chunked for this request */\n\ts->chunked = 1;\n\ts->parent.write = http_stream_write_chunked;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_stream_alloc",
          "args": [
            "t",
            "stream"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "http_stream_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "876-894",
          "snippet": "static int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_receivepack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\t/* Use Transfer-Encoding: chunked for this request */\n\ts->chunked = 1;\n\ts->parent.write = http_stream_write_chunked;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "http_receivepack_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "932-948",
    "snippet": "static int http_receivepack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_stream_alloc",
          "args": [
            "t",
            "stream"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "http_stream_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "876-894",
          "snippet": "static int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_receivepack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "http_uploadpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "914-930",
    "snippet": "static int http_uploadpack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_stream_alloc",
          "args": [
            "t",
            "stream"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "http_stream_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "876-894",
          "snippet": "static int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_uploadpack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "http_uploadpack_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "896-912",
    "snippet": "static int http_uploadpack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_stream_alloc",
          "args": [
            "t",
            "stream"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "http_stream_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "876-894",
          "snippet": "static int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_uploadpack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "http_stream_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "876-894",
    "snippet": "static int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "s"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "sizeof(http_stream)",
            "1"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}"
  },
  {
    "function_name": "http_stream_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "863-874",
    "snippet": "static void http_stream_free(git_smart_subtransport_stream *stream)\n{\n\thttp_stream *s = (http_stream *)stream;\n\n\tif (s->chunk_buffer)\n\t\tgit__free(s->chunk_buffer);\n\n\tif (s->redirect_url)\n\t\tgit__free(s->redirect_url);\n\n\tgit__free(s);\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "s"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic void http_stream_free(git_smart_subtransport_stream *stream)\n{\n\thttp_stream *s = (http_stream *)stream;\n\n\tif (s->chunk_buffer)\n\t\tgit__free(s->chunk_buffer);\n\n\tif (s->redirect_url)\n\t\tgit__free(s->redirect_url);\n\n\tgit__free(s);\n}"
  },
  {
    "function_name": "http_stream_write_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "826-861",
    "snippet": "static int http_stream_write_single(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf request = GIT_BUF_INIT;\n\n\tassert(t->connected);\n\n\tif (s->sent_request) {\n\t\tgiterr_set(GITERR_NET, \"Subtransport configured for only one write\");\n\t\treturn -1;\n\t}\n\n\tclear_parser_state(t);\n\n\tif (gen_request(&request, s, len) < 0)\n\t\treturn -1;\n\n\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0)\n\t\tgoto on_error;\n\n\tif (len && git_stream_write(t->io, buffer, len, 0) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&request);\n\ts->sent_request = 1;\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&request);\n\treturn -1;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&request"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_write",
          "args": [
            "t->io",
            "buffer",
            "len",
            "0"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "53-56",
          "snippet": "GIT_INLINE(ssize_t) git_stream_write(git_stream *st, const char *data, size_t len, int flags)\n{\n\treturn st->write(st, data, len, flags);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_stream_write(git_stream *st, const char *data, size_t len, int flags)\n{\n\treturn st->write(st, data, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_request",
          "args": [
            "&request",
            "s",
            "len"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "gen_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "200-240",
          "snippet": "static int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/1.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/1.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_parser_state",
          "args": [
            "t"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "clear_parser_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "503-528",
          "snippet": "static void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Subtransport configured for only one write\""
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t->connected"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWNING_SUBTRANSPORT",
          "args": [
            "s"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_stream_write_single(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf request = GIT_BUF_INIT;\n\n\tassert(t->connected);\n\n\tif (s->sent_request) {\n\t\tgiterr_set(GITERR_NET, \"Subtransport configured for only one write\");\n\t\treturn -1;\n\t}\n\n\tclear_parser_state(t);\n\n\tif (gen_request(&request, s, len) < 0)\n\t\treturn -1;\n\n\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0)\n\t\tgoto on_error;\n\n\tif (len && git_stream_write(t->io, buffer, len, 0) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&request);\n\ts->sent_request = 1;\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&request);\n\treturn -1;\n}"
  },
  {
    "function_name": "http_stream_write_chunked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "755-824",
    "snippet": "static int http_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\n\tassert(t->connected);\n\n\t/* Send the request, if necessary */\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CHUNK_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(t->io, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = min(CHUNK_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CHUNK_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CHUNK_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define CHUNK_SIZE\t4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->chunk_buffer",
            "buffer",
            "len"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_chunk",
          "args": [
            "t->io",
            "s->chunk_buffer",
            "s->chunk_buffer_len"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "http_stream_write_chunked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "755-824",
          "snippet": "static int http_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\n\tassert(t->connected);\n\n\t/* Send the request, if necessary */\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CHUNK_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(t->io, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = min(CHUNK_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CHUNK_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CHUNK_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->chunk_buffer + s->chunk_buffer_len",
            "buffer",
            "count"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "CHUNK_SIZE"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "CHUNK_SIZE - s->chunk_buffer_len",
            "len"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "homing_search_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "130-143",
          "snippet": "static int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&request"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_write",
          "args": [
            "t->io",
            "request.ptr",
            "request.size",
            "0"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "53-56",
          "snippet": "GIT_INLINE(ssize_t) git_stream_write(git_stream *st, const char *data, size_t len, int flags)\n{\n\treturn st->write(st, data, len, flags);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_stream_write(git_stream *st, const char *data, size_t len, int flags)\n{\n\treturn st->write(st, data, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_request",
          "args": [
            "&request",
            "s",
            "0"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "gen_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "200-240",
          "snippet": "static int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/1.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/1.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_parser_state",
          "args": [
            "t"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "clear_parser_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "503-528",
          "snippet": "static void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t->connected"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWNING_SUBTRANSPORT",
          "args": [
            "s"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\n#define CHUNK_SIZE\t4096\n\nstatic int http_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\n\tassert(t->connected);\n\n\t/* Send the request, if necessary */\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CHUNK_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(t->io, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = min(CHUNK_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CHUNK_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CHUNK_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "http_stream_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "629-753",
    "snippet": "static int http_stream_read(\n\tgit_smart_subtransport_stream *stream,\n\tchar *buffer,\n\tsize_t buf_size,\n\tsize_t *bytes_read)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tparser_context ctx;\n\tsize_t bytes_parsed;\n\nreplay:\n\t*bytes_read = 0;\n\n\tassert(t->connected);\n\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (!s->received_response) {\n\t\tif (s->chunked) {\n\t\t\tassert(s->verb == post_verb);\n\n\t\t\t/* Flush, if necessary */\n\t\t\tif (s->chunk_buffer_len > 0 &&\n\t\t\t\twrite_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Write the final chunk. */\n\t\t\tif (git_stream_write(t->io, \"0\\r\\n\\r\\n\", 5, 0) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\ts->received_response = 1;\n\t}\n\n\twhile (!*bytes_read && !t->parse_finished) {\n\t\tsize_t data_offset;\n\t\tint error;\n\n\t\t/*\n\t\t * Make the parse_buffer think it's as full of data as\n\t\t * the buffer, so it won't try to recv more data than\n\t\t * we can put into it.\n\t\t *\n\t\t * data_offset is the actual data offset from which we\n\t\t * should tell the parser to start reading.\n\t\t */\n\t\tif (buf_size >= t->parse_buffer.len) {\n\t\t\tt->parse_buffer.offset = 0;\n\t\t} else {\n\t\t\tt->parse_buffer.offset = t->parse_buffer.len - buf_size;\n\t\t}\n\n\t\tdata_offset = t->parse_buffer.offset;\n\n\t\tif (gitno_recv(&t->parse_buffer) < 0)\n\t\t\treturn -1;\n\n\t\t/* This call to http_parser_execute will result in invocations of the\n\t\t * on_* family of callbacks. The most interesting of these is\n\t\t * on_body_fill_buffer, which is called when data is ready to be copied\n\t\t * into the target buffer. We need to marshal the buffer, buf_size, and\n\t\t * bytes_read parameters to this callback. */\n\t\tctx.t = t;\n\t\tctx.s = s;\n\t\tctx.buffer = buffer;\n\t\tctx.buf_size = buf_size;\n\t\tctx.bytes_read = bytes_read;\n\n\t\t/* Set the context, call the parser, then unset the context. */\n\t\tt->parser.data = &ctx;\n\n\t\tbytes_parsed = http_parser_execute(&t->parser,\n\t\t\t&t->settings,\n\t\t\tt->parse_buffer.data + data_offset,\n\t\t\tt->parse_buffer.offset - data_offset);\n\n\t\tt->parser.data = NULL;\n\n\t\t/* If there was a handled authentication failure, then parse_error\n\t\t * will have signaled us that we should replay the request. */\n\t\tif (PARSE_ERROR_REPLAY == t->parse_error) {\n\t\t\ts->sent_request = 0;\n\n\t\t\tif ((error = http_connect(t)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tgoto replay;\n\t\t}\n\n\t\tif (t->parse_error == PARSE_ERROR_EXT) {\n\t\t\treturn t->error;\n\t\t}\n\n\t\tif (t->parse_error < 0)\n\t\t\treturn -1;\n\n\t\tif (bytes_parsed != t->parse_buffer.offset - data_offset) {\n\t\t\tgiterr_set(GITERR_NET,\n\t\t\t\t\"HTTP parser error: %s\",\n\t\t\t\thttp_errno_description((enum http_errno)t->parser.http_errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define PARSE_ERROR_EXT         -3",
      "#define PARSE_ERROR_REPLAY\t-2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"HTTP parser error: %s\"",
            "http_errno_description((enum http_errno)t->parser.http_errno)"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_errno_description",
          "args": [
            "(enum http_errno)t->parser.http_errno"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_connect",
          "args": [
            "t"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "http_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "558-627",
          "snippet": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_parser_execute",
          "args": [
            "&t->parser",
            "&t->settings",
            "t->parse_buffer.data + data_offset",
            "t->parse_buffer.offset - data_offset"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gitno_recv",
          "args": [
            "&t->parse_buffer"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "18-21",
          "snippet": "int gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nint gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_write",
          "args": [
            "t->io",
            "\"0\\r\\n\\r\\n\"",
            "5",
            "0"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "53-56",
          "snippet": "GIT_INLINE(ssize_t) git_stream_write(git_stream *st, const char *data, size_t len, int flags)\n{\n\treturn st->write(st, data, len, flags);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_stream_write(git_stream *st, const char *data, size_t len, int flags)\n{\n\treturn st->write(st, data, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_chunk",
          "args": [
            "t->io",
            "s->chunk_buffer",
            "s->chunk_buffer_len"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "http_stream_write_chunked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "755-824",
          "snippet": "static int http_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\n\tassert(t->connected);\n\n\t/* Send the request, if necessary */\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CHUNK_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(t->io, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = min(CHUNK_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CHUNK_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CHUNK_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [
            "#define CHUNK_SIZE\t4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\n#define CHUNK_SIZE\t4096\n\nstatic int http_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\n\tassert(t->connected);\n\n\t/* Send the request, if necessary */\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CHUNK_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(t->io, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = min(CHUNK_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CHUNK_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CHUNK_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "s->verb == post_verb"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&request"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_request",
          "args": [
            "&request",
            "s",
            "0"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "gen_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "200-240",
          "snippet": "static int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/1.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/1.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_parser_state",
          "args": [
            "t"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "clear_parser_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "503-528",
          "snippet": "static void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t->connected"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWNING_SUBTRANSPORT",
          "args": [
            "s"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\n#define PARSE_ERROR_EXT         -3\n#define PARSE_ERROR_REPLAY\t-2\n\nstatic int http_stream_read(\n\tgit_smart_subtransport_stream *stream,\n\tchar *buffer,\n\tsize_t buf_size,\n\tsize_t *bytes_read)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tparser_context ctx;\n\tsize_t bytes_parsed;\n\nreplay:\n\t*bytes_read = 0;\n\n\tassert(t->connected);\n\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (!s->received_response) {\n\t\tif (s->chunked) {\n\t\t\tassert(s->verb == post_verb);\n\n\t\t\t/* Flush, if necessary */\n\t\t\tif (s->chunk_buffer_len > 0 &&\n\t\t\t\twrite_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Write the final chunk. */\n\t\t\tif (git_stream_write(t->io, \"0\\r\\n\\r\\n\", 5, 0) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\ts->received_response = 1;\n\t}\n\n\twhile (!*bytes_read && !t->parse_finished) {\n\t\tsize_t data_offset;\n\t\tint error;\n\n\t\t/*\n\t\t * Make the parse_buffer think it's as full of data as\n\t\t * the buffer, so it won't try to recv more data than\n\t\t * we can put into it.\n\t\t *\n\t\t * data_offset is the actual data offset from which we\n\t\t * should tell the parser to start reading.\n\t\t */\n\t\tif (buf_size >= t->parse_buffer.len) {\n\t\t\tt->parse_buffer.offset = 0;\n\t\t} else {\n\t\t\tt->parse_buffer.offset = t->parse_buffer.len - buf_size;\n\t\t}\n\n\t\tdata_offset = t->parse_buffer.offset;\n\n\t\tif (gitno_recv(&t->parse_buffer) < 0)\n\t\t\treturn -1;\n\n\t\t/* This call to http_parser_execute will result in invocations of the\n\t\t * on_* family of callbacks. The most interesting of these is\n\t\t * on_body_fill_buffer, which is called when data is ready to be copied\n\t\t * into the target buffer. We need to marshal the buffer, buf_size, and\n\t\t * bytes_read parameters to this callback. */\n\t\tctx.t = t;\n\t\tctx.s = s;\n\t\tctx.buffer = buffer;\n\t\tctx.buf_size = buf_size;\n\t\tctx.bytes_read = bytes_read;\n\n\t\t/* Set the context, call the parser, then unset the context. */\n\t\tt->parser.data = &ctx;\n\n\t\tbytes_parsed = http_parser_execute(&t->parser,\n\t\t\t&t->settings,\n\t\t\tt->parse_buffer.data + data_offset,\n\t\t\tt->parse_buffer.offset - data_offset);\n\n\t\tt->parser.data = NULL;\n\n\t\t/* If there was a handled authentication failure, then parse_error\n\t\t * will have signaled us that we should replay the request. */\n\t\tif (PARSE_ERROR_REPLAY == t->parse_error) {\n\t\t\ts->sent_request = 0;\n\n\t\t\tif ((error = http_connect(t)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tgoto replay;\n\t\t}\n\n\t\tif (t->parse_error == PARSE_ERROR_EXT) {\n\t\t\treturn t->error;\n\t\t}\n\n\t\tif (t->parse_error < 0)\n\t\t\treturn -1;\n\n\t\tif (bytes_parsed != t->parse_buffer.offset - data_offset) {\n\t\t\tgiterr_set(GITERR_NET,\n\t\t\t\t\"HTTP parser error: %s\",\n\t\t\t\thttp_errno_description((enum http_errno)t->parser.http_errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "http_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "558-627",
    "snippet": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"user cancelled certificate check\""
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_last",
          "args": [],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "134-137",
          "snippet": "const git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->owner->certificate_check_cb",
          "args": [
            "cert",
            "is_valid",
            "t->connection_data.host",
            "t->owner->message_cb_payload"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_certificate",
          "args": [
            "&cert",
            "t->io"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_certificate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "23-31",
          "snippet": "GIT_INLINE(int) git_stream_certificate(git_cert **out, git_stream *st)\n{\n\tif (!st->encrypted) {\n\t\tgiterr_set(GITERR_INVALID, \"an unencrypted stream does not have a certificate\");\n\t\treturn -1;\n\t}\n\n\treturn st->certificate(out, st);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_stream_certificate(git_cert **out, git_stream *st)\n{\n\tif (!st->encrypted) {\n\t\tgiterr_set(GITERR_INVALID, \"an unencrypted stream does not have a certificate\");\n\t\treturn -1;\n\t}\n\n\treturn st->certificate(out, st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_is_encrypted",
          "args": [
            "t->io"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_is_encrypted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "18-21",
          "snippet": "GIT_INLINE(int) git_stream_is_encrypted(git_stream *st)\n{\n\treturn st->encrypted;\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_stream_is_encrypted(git_stream *st)\n{\n\treturn st->encrypted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_connect",
          "args": [
            "t->io"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "13-16",
          "snippet": "GIT_INLINE(int) git_stream_connect(git_stream *st)\n{\n\treturn st->connect(st);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_stream_connect(git_stream *st)\n{\n\treturn st->connect(st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "proxy_url"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_set_proxy",
          "args": [
            "t->io",
            "proxy_url"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_set_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "38-46",
          "snippet": "GIT_INLINE(int) git_stream_set_proxy(git_stream *st, const char *proxy_url)\n{\n\tif (!st->proxy_support) {\n\t\tgiterr_set(GITERR_INVALID, \"proxy not supported on this stream\");\n\t\treturn -1;\n\t}\n\n\treturn st->set_proxy(st, proxy_url);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_stream_set_proxy(git_stream *st, const char *proxy_url)\n{\n\tif (!st->proxy_support) {\n\t\tgiterr_set(GITERR_INVALID, \"proxy not supported on this stream\");\n\t\treturn -1;\n\t}\n\n\treturn st->set_proxy(st, proxy_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__get_http_proxy",
          "args": [
            "t->owner->owner",
            "!!t->connection_data.use_ssl",
            "&proxy_url"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__get_http_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "769-836",
          "snippet": "int git_remote__get_http_proxy(git_remote *remote, bool use_ssl, char **proxy_url)\n{\n\tgit_config *cfg;\n\tgit_config_entry *ce = NULL;\n\tgit_buf val = GIT_BUF_INIT;\n\tint error;\n\n\tassert(remote);\n\n\tif (!proxy_url || !remote->repo)\n\t\treturn -1;\n\n\t*proxy_url = NULL;\n\n\tif ((error = git_repository_config__weakptr(&cfg, remote->repo)) < 0)\n\t\treturn error;\n\n\t/* Go through the possible sources for proxy configuration, from most specific\n\t * to least specific. */\n\n\t/* remote.<name>.proxy config setting */\n\tif (remote->name && remote->name[0]) {\n\t\tgit_buf buf = GIT_BUF_INIT;\n\n\t\tif ((error = git_buf_printf(&buf, \"remote.%s.proxy\", remote->name)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\t\tgit_buf_free(&buf);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ce && ce->value) {\n\t\t\t*proxy_url = git__strdup(ce->value);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* http.proxy config setting */\n\tif ((error = git_config__lookup_entry(&ce, cfg, \"http.proxy\", false)) < 0)\n\t\treturn error;\n\n\tif (ce && ce->value) {\n\t\t*proxy_url = git__strdup(ce->value);\n\t\tgoto found;\n\t}\n\n\t/* HTTP_PROXY / HTTPS_PROXY environment variables */\n\terror = git__getenv(&val, use_ssl ? \"HTTPS_PROXY\" : \"HTTP_PROXY\");\n\n\tif (error < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\treturn error;\n\t}\n\n\t*proxy_url = git_buf_detach(&val);\n\nfound:\n\tGITERR_CHECK_ALLOC(*proxy_url);\n\tgit_config_entry_free(ce);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote__get_http_proxy(git_remote *remote, bool use_ssl, char **proxy_url)\n{\n\tgit_config *cfg;\n\tgit_config_entry *ce = NULL;\n\tgit_buf val = GIT_BUF_INIT;\n\tint error;\n\n\tassert(remote);\n\n\tif (!proxy_url || !remote->repo)\n\t\treturn -1;\n\n\t*proxy_url = NULL;\n\n\tif ((error = git_repository_config__weakptr(&cfg, remote->repo)) < 0)\n\t\treturn error;\n\n\t/* Go through the possible sources for proxy configuration, from most specific\n\t * to least specific. */\n\n\t/* remote.<name>.proxy config setting */\n\tif (remote->name && remote->name[0]) {\n\t\tgit_buf buf = GIT_BUF_INIT;\n\n\t\tif ((error = git_buf_printf(&buf, \"remote.%s.proxy\", remote->name)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\t\tgit_buf_free(&buf);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ce && ce->value) {\n\t\t\t*proxy_url = git__strdup(ce->value);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* http.proxy config setting */\n\tif ((error = git_config__lookup_entry(&ce, cfg, \"http.proxy\", false)) < 0)\n\t\treturn error;\n\n\tif (ce && ce->value) {\n\t\t*proxy_url = git__strdup(ce->value);\n\t\tgoto found;\n\t}\n\n\t/* HTTP_PROXY / HTTPS_PROXY environment variables */\n\terror = git__getenv(&val, use_ssl ? \"HTTPS_PROXY\" : \"HTTP_PROXY\");\n\n\tif (error < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\treturn error;\n\t}\n\n\t*proxy_url = git_buf_detach(&val);\n\nfound:\n\tGITERR_CHECK_ALLOC(*proxy_url);\n\tgit_config_entry_free(ce);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_supports_proxy",
          "args": [
            "t->io"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_supports_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "33-36",
          "snippet": "GIT_INLINE(int) git_stream_supports_proxy(git_stream *st)\n{\n\treturn st->proxy_support;\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_stream_supports_proxy(git_stream *st)\n{\n\treturn st->proxy_support;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "t->io",
            "GIT_STREAM_VERSION",
            "\"git_stream\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_socket_stream_new",
          "args": [
            "&t->io",
            "t->connection_data.host",
            "t->connection_data.port"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "git_socket_stream_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/socket_stream.c",
          "lines": "185-212",
          "snippet": "int git_socket_stream_new(git_stream **out, const char *host, const char *port)\n{\n\tgit_socket_stream *st;\n\n\tassert(out && host);\n\n\tst = git__calloc(1, sizeof(git_socket_stream));\n\tGITERR_CHECK_ALLOC(st);\n\n\tst->host = git__strdup(host);\n\tGITERR_CHECK_ALLOC(st->host);\n\n\tif (port) {\n\t\tst->port = git__strdup(port);\n\t\tGITERR_CHECK_ALLOC(st->port);\n\t}\n\n\tst->parent.version = GIT_STREAM_VERSION;\n\tst->parent.connect = socket_connect;\n\tst->parent.write = socket_write;\n\tst->parent.read = socket_read;\n\tst->parent.close = socket_close;\n\tst->parent.free = socket_free;\n\tst->s = INVALID_SOCKET;\n\n\t*out = (git_stream *) st;\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <ws2tcpip.h>",
            "#\tinclude <winsock2.h>",
            "#       include <arpa/inet.h>",
            "#\tinclude <netinet/in.h>",
            "#\tinclude <netdb.h>",
            "#\tinclude <sys/time.h>",
            "#\tinclude <sys/select.h>",
            "#\tinclude <sys/socket.h>",
            "#\tinclude <sys/types.h>",
            "#include \"socket_stream.h\"",
            "#include \"stream.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <ws2tcpip.h>\n#\tinclude <winsock2.h>\n#       include <arpa/inet.h>\n#\tinclude <netinet/in.h>\n#\tinclude <netdb.h>\n#\tinclude <sys/time.h>\n#\tinclude <sys/select.h>\n#\tinclude <sys/socket.h>\n#\tinclude <sys/types.h>\n#include \"socket_stream.h\"\n#include \"stream.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_socket_stream_new(git_stream **out, const char *host, const char *port)\n{\n\tgit_socket_stream *st;\n\n\tassert(out && host);\n\n\tst = git__calloc(1, sizeof(git_socket_stream));\n\tGITERR_CHECK_ALLOC(st);\n\n\tst->host = git__strdup(host);\n\tGITERR_CHECK_ALLOC(st->host);\n\n\tif (port) {\n\t\tst->port = git__strdup(port);\n\t\tGITERR_CHECK_ALLOC(st->port);\n\t}\n\n\tst->parent.version = GIT_STREAM_VERSION;\n\tst->parent.connect = socket_connect;\n\tst->parent.write = socket_write;\n\tst->parent.read = socket_read;\n\tst->parent.close = socket_close;\n\tst->parent.free = socket_free;\n\tst->s = INVALID_SOCKET;\n\n\t*out = (git_stream *) st;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_curl_stream_new",
          "args": [
            "&t->io",
            "t->connection_data.host",
            "t->connection_data.port"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "git_curl_stream_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/curl_stream.c",
          "lines": "251-259",
          "snippet": "int git_curl_stream_new(git_stream **out, const char *host, const char *port)\n{\n\tGIT_UNUSED(out);\n\tGIT_UNUSED(host);\n\tGIT_UNUSED(port);\n\n\tgiterr_set(GITERR_NET, \"curl is not supported in this version\");\n\treturn -1;\n}",
          "includes": [
            "#include \"stream.h\"",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"stream.h\"",
            "#include <curl/curl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stream.h\"\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"stream.h\"\n#include <curl/curl.h>\n\nint git_curl_stream_new(git_stream **out, const char *host, const char *port)\n{\n\tGIT_UNUSED(out);\n\tGIT_UNUSED(host);\n\tGIT_UNUSED(port);\n\n\tgiterr_set(GITERR_NET, \"curl is not supported in this version\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tls_stream_new",
          "args": [
            "&t->io",
            "t->connection_data.host",
            "t->connection_data.port"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "git_tls_stream_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tls_stream.c",
          "lines": "23-41",
          "snippet": "int git_tls_stream_new(git_stream **out, const char *host, const char *port)\n{\n\n\tif (tls_ctor)\n\t\treturn tls_ctor(out, host, port);\n\n#ifdef GIT_SECURE_TRANSPORT\n\treturn git_stransport_stream_new(out, host, port);\n#elif defined(GIT_OPENSSL)\n\treturn git_openssl_stream_new(out, host, port);\n#else\n\tGIT_UNUSED(out);\n\tGIT_UNUSED(host);\n\tGIT_UNUSED(port);\n\n\tgiterr_set(GITERR_SSL, \"there is no TLS stream available\");\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include \"stransport_stream.h\"",
            "#include \"openssl_stream.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_stream_cb tls_ctor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stransport_stream.h\"\n#include \"openssl_stream.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nstatic git_stream_cb tls_ctor;\n\nint git_tls_stream_new(git_stream **out, const char *host, const char *port)\n{\n\n\tif (tls_ctor)\n\t\treturn tls_ctor(out, host, port);\n\n#ifdef GIT_SECURE_TRANSPORT\n\treturn git_stransport_stream_new(out, host, port);\n#elif defined(GIT_OPENSSL)\n\treturn git_openssl_stream_new(out, host, port);\n#else\n\tGIT_UNUSED(out);\n\tGIT_UNUSED(host);\n\tGIT_UNUSED(port);\n\n\tgiterr_set(GITERR_SSL, \"there is no TLS stream available\");\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_free",
          "args": [
            "t->io"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "63-69",
          "snippet": "GIT_INLINE(void) git_stream_free(git_stream *st)\n{\n\tif (!st)\n\t\treturn;\n\n\tst->free(st);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) git_stream_free(git_stream *st)\n{\n\tif (!st)\n\t\treturn;\n\n\tst->free(st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_close",
          "args": [
            "t->io"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "58-61",
          "snippet": "GIT_INLINE(int) git_stream_close(git_stream *st)\n{\n\treturn st->close(st);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_stream_close(git_stream *st)\n{\n\treturn st->close(st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_should_keep_alive",
          "args": [
            "&t->parser"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "write_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "530-556",
    "snippet": "static int write_chunk(git_stream *io, const char *buffer, size_t len)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* Chunk header */\n\tgit_buf_printf(&buf, \"%\" PRIxZ \"\\r\\n\", len);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tif (git_stream_write(io, buf.ptr, buf.size, 0) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&buf);\n\n\t/* Chunk body */\n\tif (len > 0 && git_stream_write(io, buffer, len, 0) < 0)\n\t\treturn -1;\n\n\t/* Chunk footer */\n\tif (git_stream_write(io, \"\\r\\n\", 2, 0) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_stream_write",
          "args": [
            "io",
            "\"\\r\\n\"",
            "2",
            "0"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "53-56",
          "snippet": "GIT_INLINE(ssize_t) git_stream_write(git_stream *st, const char *data, size_t len, int flags)\n{\n\treturn st->write(st, data, len, flags);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_stream_write(git_stream *st, const char *data, size_t len, int flags)\n{\n\treturn st->write(st, data, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&buf"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"%\" PRIxZ \"\\r\\n\"",
            "len"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int write_chunk(git_stream *io, const char *buffer, size_t len)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* Chunk header */\n\tgit_buf_printf(&buf, \"%\" PRIxZ \"\\r\\n\", len);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tif (git_stream_write(io, buf.ptr, buf.size, 0) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&buf);\n\n\t/* Chunk body */\n\tif (len > 0 && git_stream_write(io, buffer, len, 0) < 0)\n\t\treturn -1;\n\n\t/* Chunk footer */\n\tif (git_stream_write(io, \"\\r\\n\", 2, 0) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_parser_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "503-528",
    "snippet": "static void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&t->www_authenticate"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "t->location"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "&t->parse_header_value",
            "0"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&t->parse_header_value"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_buffer_setup_fromstream",
          "args": [
            "t->io",
            "&t->parse_buffer",
            "t->parse_buffer_data",
            "sizeof(t->parse_buffer_data)"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_buffer_setup_fromstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "50-58",
          "snippet": "void gitno_buffer_setup_fromstream(git_stream *st, gitno_buffer *buf, char *data, size_t len)\n{\n\tmemset(data, 0x0, len);\n\tbuf->data = data;\n\tbuf->len = len;\n\tbuf->offset = 0;\n\tbuf->recv = recv_stream;\n\tbuf->cb_data = st;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_buffer_setup_fromstream(git_stream *st, gitno_buffer *buf, char *data, size_t len)\n{\n\tmemset(data, 0x0, len);\n\tbuf->data = data;\n\tbuf->len = len;\n\tbuf->offset = 0;\n\tbuf->recv = recv_stream;\n\tbuf->cb_data = st;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_parser_init",
          "args": [
            "&t->parser",
            "HTTP_RESPONSE"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}"
  },
  {
    "function_name": "on_body_fill_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "478-501",
    "snippet": "static int on_body_fill_buffer(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\t/* If our goal is to replay the request (either an auth failure or\n\t * a redirect) then don't bother buffering since we're ignoring the\n\t * content anyway.\n\t */\n\tif (t->parse_error == PARSE_ERROR_REPLAY)\n\t\treturn 0;\n\n\tif (ctx->buf_size < len) {\n\t\tgiterr_set(GITERR_NET, \"Can't fit data in the buffer\");\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\tmemcpy(ctx->buffer, str, len);\n\t*(ctx->bytes_read) += len;\n\tctx->buffer += len;\n\tctx->buf_size -= len;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define PARSE_ERROR_REPLAY\t-2",
      "#define PARSE_ERROR_GENERIC\t-1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ctx->buffer",
            "str",
            "len"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Can't fit data in the buffer\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\n#define PARSE_ERROR_REPLAY\t-2\n#define PARSE_ERROR_GENERIC\t-1\n\nstatic int on_body_fill_buffer(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\t/* If our goal is to replay the request (either an auth failure or\n\t * a redirect) then don't bother buffering since we're ignoring the\n\t * content anyway.\n\t */\n\tif (t->parse_error == PARSE_ERROR_REPLAY)\n\t\treturn 0;\n\n\tif (ctx->buf_size < len) {\n\t\tgiterr_set(GITERR_NET, \"Can't fit data in the buffer\");\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\tmemcpy(ctx->buffer, str, len);\n\t*(ctx->bytes_read) += len;\n\tctx->buffer += len;\n\tctx->buf_size -= len;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "on_message_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "468-476",
    "snippet": "static int on_message_complete(http_parser *parser)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\tt->parse_finished = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int on_message_complete(http_parser *parser)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\tt->parse_finished = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "on_headers_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "332-466",
    "snippet": "static int on_headers_complete(http_parser *parser)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\thttp_stream *s = ctx->s;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0, no_callback = 0, allowed_auth_types = 0;\n\n\t/* Both parse_header_name and parse_header_value are populated\n\t * and ready for consumption. */\n\tif (VALUE == t->last_cb)\n\t\tif (on_header_ready(t) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Capture authentication headers which may be a 401 (authentication\n\t * is not complete) or a 200 (simply informing us that auth *is*\n\t * complete.)\n\t */\n\tif (parse_authenticate_response(&t->www_authenticate, t,\n\t\t\t&allowed_auth_types) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Check for an authentication failure. */\n\tif (parser->status_code == 401 && get_verb == s->verb) {\n\t\tif (!t->owner->cred_acquire_cb) {\n\t\t\tno_callback = 1;\n\t\t} else {\n\t\t\tif (allowed_auth_types) {\n\t\t\t\tif (t->cred) {\n\t\t\t\t\tt->cred->free(t->cred);\n\t\t\t\t\tt->cred = NULL;\n\t\t\t\t}\n\n\t\t\t\terror = t->owner->cred_acquire_cb(&t->cred,\n\t\t\t\t\t\t\t\t  t->owner->url,\n\t\t\t\t\t\t\t\t  t->connection_data.user,\n\t\t\t\t\t\t\t\t  allowed_auth_types,\n\t\t\t\t\t\t\t\t  t->owner->cred_acquire_payload);\n\n\t\t\t\tif (error == GIT_PASSTHROUGH) {\n\t\t\t\t\tno_callback = 1;\n\t\t\t\t} else if (error < 0) {\n\t\t\t\t\tt->error = error;\n\t\t\t\t\treturn t->parse_error = PARSE_ERROR_EXT;\n\t\t\t\t} else {\n\t\t\t\t\tassert(t->cred);\n\n\t\t\t\t\tif (!(t->cred->credtype & allowed_auth_types)) {\n\t\t\t\t\t\tgiterr_set(GITERR_NET, \"credentials callback returned an invalid cred type\");\n\t\t\t\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Successfully acquired a credential. */\n\t\t\t\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (no_callback) {\n\t\t\tgiterr_set(GITERR_NET, \"authentication required but no callback set\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\t}\n\n\t/* Check for a redirect.\n\t * Right now we only permit a redirect to the same hostname. */\n\tif ((parser->status_code == 301 ||\n\t     parser->status_code == 302 ||\n\t     (parser->status_code == 303 && get_verb == s->verb) ||\n\t     parser->status_code == 307) &&\n\t    t->location) {\n\n\t\tif (s->redirect_count >= 7) {\n\t\t\tgiterr_set(GITERR_NET, \"Too many redirects\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\n\t\tif (gitno_connection_data_from_url(&t->connection_data, t->location, s->service_url) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t\t/* Set the redirect URL on the stream. This is a transfer of\n\t\t * ownership of the memory. */\n\t\tif (s->redirect_url)\n\t\t\tgit__free(s->redirect_url);\n\n\t\ts->redirect_url = t->location;\n\t\tt->location = NULL;\n\n\t\tt->connected = 0;\n\t\ts->redirect_count++;\n\n\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\treturn 0;\n\t}\n\n\t/* Check for a 200 HTTP status code. */\n\tif (parser->status_code != 200) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Unexpected HTTP status code: %d\",\n\t\t\tparser->status_code);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The response must contain a Content-Type header. */\n\tif (!t->content_type) {\n\t\tgiterr_set(GITERR_NET, \"No Content-Type header in response\");\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The Content-Type header must match our expectation. */\n\tif (get_verb == s->verb)\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-advertisement\",\n\t\t\tctx->s->service);\n\telse\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-result\",\n\t\t\tctx->s->service);\n\n\tif (git_buf_oom(&buf))\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tif (strcmp(t->content_type, git_buf_cstr(&buf))) {\n\t\tgit_buf_free(&buf);\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Invalid Content-Type: %s\",\n\t\t\tt->content_type);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define PARSE_ERROR_EXT         -3",
      "#define PARSE_ERROR_REPLAY\t-2",
      "#define PARSE_ERROR_GENERIC\t-1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Invalid Content-Type: %s\"",
            "t->content_type"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "t->content_type",
            "git_buf_cstr(&buf)"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&buf"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"application/x-git-%s-result\"",
            "ctx->s->service"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"No Content-Type header in response\""
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "s->redirect_url"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_connection_data_from_url",
          "args": [
            "&t->connection_data",
            "t->location",
            "s->service_url"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_connection_data_from_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "125-198",
          "snippet": "int gitno_connection_data_from_url(\n\t\tgitno_connection_data *data,\n\t\tconst char *url,\n\t\tconst char *service_suffix)\n{\n\tint error = -1;\n\tconst char *default_port = NULL, *path_search_start = NULL;\n\tchar *original_host = NULL;\n\n\t/* service_suffix is optional */\n\tassert(data && url);\n\n\t/* Save these for comparison later */\n\toriginal_host = data->host;\n\tdata->host = NULL;\n\tgitno_connection_data_free_ptrs(data);\n\n\tif (!git__prefixcmp(url, prefix_http)) {\n\t\tpath_search_start = url + strlen(prefix_http);\n\t\tdefault_port = \"80\";\n\n\t\tif (data->use_ssl) {\n\t\t\tgiterr_set(GITERR_NET, \"Redirect from HTTPS to HTTP is not allowed\");\n\t\t\tgoto cleanup;\n\t\t}\n\t} else if (!git__prefixcmp(url, prefix_https)) {\n\t\tpath_search_start = url + strlen(prefix_https);\n\t\tdefault_port = \"443\";\n\t\tdata->use_ssl = true;\n\t} else if (url[0] == '/')\n\t\tdefault_port = data->use_ssl ? \"443\" : \"80\";\n\n\tif (!default_port) {\n\t\tgiterr_set(GITERR_NET, \"Unrecognized URL prefix\");\n\t\tgoto cleanup;\n\t}\n\n\terror = gitno_extract_url_parts(\n\t\t&data->host, &data->port, &data->path, &data->user, &data->pass,\n\t\turl, default_port);\n\n\tif (url[0] == '/') {\n\t\t/* Relative redirect; reuse original host name and port */\n\t\tpath_search_start = url;\n\t\tgit__free(data->host);\n\t\tdata->host = original_host;\n\t\toriginal_host = NULL;\n\t}\n\n\tif (!error) {\n\t\tconst char *path = strchr(path_search_start, '/');\n\t\tsize_t pathlen = strlen(path);\n\t\tsize_t suffixlen = service_suffix ? strlen(service_suffix) : 0;\n\n\t\tif (suffixlen &&\n\t\t    !memcmp(path + pathlen - suffixlen, service_suffix, suffixlen)) {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strndup(path, pathlen - suffixlen);\n\t\t} else {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strdup(path);\n\t\t}\n\n\t\t/* Check for errors in the resulting data */\n\t\tif (original_host && url[0] != '/' && strcmp(original_host, data->host)) {\n\t\t\tgiterr_set(GITERR_NET, \"Cross host redirect not allowed\");\n\t\t\terror = -1;\n\t\t}\n\t}\n\ncleanup:\n\tif (original_host) git__free(original_host);\n\treturn error;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prefix_http = \"http://\";",
            "static const char *prefix_https = \"https://\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nstatic const char *prefix_http = \"http://\";\nstatic const char *prefix_https = \"https://\";\n\nint gitno_connection_data_from_url(\n\t\tgitno_connection_data *data,\n\t\tconst char *url,\n\t\tconst char *service_suffix)\n{\n\tint error = -1;\n\tconst char *default_port = NULL, *path_search_start = NULL;\n\tchar *original_host = NULL;\n\n\t/* service_suffix is optional */\n\tassert(data && url);\n\n\t/* Save these for comparison later */\n\toriginal_host = data->host;\n\tdata->host = NULL;\n\tgitno_connection_data_free_ptrs(data);\n\n\tif (!git__prefixcmp(url, prefix_http)) {\n\t\tpath_search_start = url + strlen(prefix_http);\n\t\tdefault_port = \"80\";\n\n\t\tif (data->use_ssl) {\n\t\t\tgiterr_set(GITERR_NET, \"Redirect from HTTPS to HTTP is not allowed\");\n\t\t\tgoto cleanup;\n\t\t}\n\t} else if (!git__prefixcmp(url, prefix_https)) {\n\t\tpath_search_start = url + strlen(prefix_https);\n\t\tdefault_port = \"443\";\n\t\tdata->use_ssl = true;\n\t} else if (url[0] == '/')\n\t\tdefault_port = data->use_ssl ? \"443\" : \"80\";\n\n\tif (!default_port) {\n\t\tgiterr_set(GITERR_NET, \"Unrecognized URL prefix\");\n\t\tgoto cleanup;\n\t}\n\n\terror = gitno_extract_url_parts(\n\t\t&data->host, &data->port, &data->path, &data->user, &data->pass,\n\t\turl, default_port);\n\n\tif (url[0] == '/') {\n\t\t/* Relative redirect; reuse original host name and port */\n\t\tpath_search_start = url;\n\t\tgit__free(data->host);\n\t\tdata->host = original_host;\n\t\toriginal_host = NULL;\n\t}\n\n\tif (!error) {\n\t\tconst char *path = strchr(path_search_start, '/');\n\t\tsize_t pathlen = strlen(path);\n\t\tsize_t suffixlen = service_suffix ? strlen(service_suffix) : 0;\n\n\t\tif (suffixlen &&\n\t\t    !memcmp(path + pathlen - suffixlen, service_suffix, suffixlen)) {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strndup(path, pathlen - suffixlen);\n\t\t} else {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strdup(path);\n\t\t}\n\n\t\t/* Check for errors in the resulting data */\n\t\tif (original_host && url[0] != '/' && strcmp(original_host, data->host)) {\n\t\t\tgiterr_set(GITERR_NET, \"Cross host redirect not allowed\");\n\t\t\terror = -1;\n\t\t}\n\t}\n\ncleanup:\n\tif (original_host) git__free(original_host);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t->cred"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->owner->cred_acquire_cb",
          "args": [
            "&t->cred",
            "t->owner->url",
            "t->connection_data.user",
            "allowed_auth_types",
            "t->owner->cred_acquire_payload"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->cred->free",
          "args": [
            "t->cred"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_authenticate_response",
          "args": [
            "&t->www_authenticate",
            "t",
            "&allowed_auth_types"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "parse_authenticate_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "242-265",
          "snippet": "static int parse_authenticate_response(\n\tgit_vector *www_authenticate,\n\thttp_subtransport *t,\n\tint *allowed_types)\n{\n\tgit_http_auth_context *context;\n\tchar *challenge;\n\tsize_t i;\n\n\tgit_vector_foreach(www_authenticate, i, challenge) {\n\t\tif (auth_context_match(&context, t, challenge_match, challenge) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\tcontinue;\n\n\t\tif (context->set_challenge &&\n\t\t\tcontext->set_challenge(context, challenge) < 0)\n\t\t\treturn -1;\n\n\t\t*allowed_types |= context->credtypes;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int parse_authenticate_response(\n\tgit_vector *www_authenticate,\n\thttp_subtransport *t,\n\tint *allowed_types)\n{\n\tgit_http_auth_context *context;\n\tchar *challenge;\n\tsize_t i;\n\n\tgit_vector_foreach(www_authenticate, i, challenge) {\n\t\tif (auth_context_match(&context, t, challenge_match, challenge) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\tcontinue;\n\n\t\tif (context->set_challenge &&\n\t\t\tcontext->set_challenge(context, challenge) < 0)\n\t\t\treturn -1;\n\n\t\t*allowed_types |= context->credtypes;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_header_ready",
          "args": [
            "t"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "on_header_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "267-292",
          "snippet": "static int on_header_ready(http_subtransport *t)\n{\n\tgit_buf *name = &t->parse_header_name;\n\tgit_buf *value = &t->parse_header_value;\n\n\tif (!strcasecmp(\"Content-Type\", git_buf_cstr(name))) {\n\t\tif (!t->content_type) {\n\t\t\tt->content_type = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->content_type);\n\t\t}\n\t}\n\telse if (!strcasecmp(\"WWW-Authenticate\", git_buf_cstr(name))) {\n\t\tchar *dup = git__strdup(git_buf_cstr(value));\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tgit_vector_insert(&t->www_authenticate, dup);\n\t}\n\telse if (!strcasecmp(\"Location\", git_buf_cstr(name))) {\n\t\tif (!t->location) {\n\t\t\tt->location = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->location);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int on_header_ready(http_subtransport *t)\n{\n\tgit_buf *name = &t->parse_header_name;\n\tgit_buf *value = &t->parse_header_value;\n\n\tif (!strcasecmp(\"Content-Type\", git_buf_cstr(name))) {\n\t\tif (!t->content_type) {\n\t\t\tt->content_type = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->content_type);\n\t\t}\n\t}\n\telse if (!strcasecmp(\"WWW-Authenticate\", git_buf_cstr(name))) {\n\t\tchar *dup = git__strdup(git_buf_cstr(value));\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tgit_vector_insert(&t->www_authenticate, dup);\n\t}\n\telse if (!strcasecmp(\"Location\", git_buf_cstr(name))) {\n\t\tif (!t->location) {\n\t\t\tt->location = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->location);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\n#define PARSE_ERROR_EXT         -3\n#define PARSE_ERROR_REPLAY\t-2\n#define PARSE_ERROR_GENERIC\t-1\n\nstatic int on_headers_complete(http_parser *parser)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\thttp_stream *s = ctx->s;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0, no_callback = 0, allowed_auth_types = 0;\n\n\t/* Both parse_header_name and parse_header_value are populated\n\t * and ready for consumption. */\n\tif (VALUE == t->last_cb)\n\t\tif (on_header_ready(t) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Capture authentication headers which may be a 401 (authentication\n\t * is not complete) or a 200 (simply informing us that auth *is*\n\t * complete.)\n\t */\n\tif (parse_authenticate_response(&t->www_authenticate, t,\n\t\t\t&allowed_auth_types) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Check for an authentication failure. */\n\tif (parser->status_code == 401 && get_verb == s->verb) {\n\t\tif (!t->owner->cred_acquire_cb) {\n\t\t\tno_callback = 1;\n\t\t} else {\n\t\t\tif (allowed_auth_types) {\n\t\t\t\tif (t->cred) {\n\t\t\t\t\tt->cred->free(t->cred);\n\t\t\t\t\tt->cred = NULL;\n\t\t\t\t}\n\n\t\t\t\terror = t->owner->cred_acquire_cb(&t->cred,\n\t\t\t\t\t\t\t\t  t->owner->url,\n\t\t\t\t\t\t\t\t  t->connection_data.user,\n\t\t\t\t\t\t\t\t  allowed_auth_types,\n\t\t\t\t\t\t\t\t  t->owner->cred_acquire_payload);\n\n\t\t\t\tif (error == GIT_PASSTHROUGH) {\n\t\t\t\t\tno_callback = 1;\n\t\t\t\t} else if (error < 0) {\n\t\t\t\t\tt->error = error;\n\t\t\t\t\treturn t->parse_error = PARSE_ERROR_EXT;\n\t\t\t\t} else {\n\t\t\t\t\tassert(t->cred);\n\n\t\t\t\t\tif (!(t->cred->credtype & allowed_auth_types)) {\n\t\t\t\t\t\tgiterr_set(GITERR_NET, \"credentials callback returned an invalid cred type\");\n\t\t\t\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Successfully acquired a credential. */\n\t\t\t\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (no_callback) {\n\t\t\tgiterr_set(GITERR_NET, \"authentication required but no callback set\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\t}\n\n\t/* Check for a redirect.\n\t * Right now we only permit a redirect to the same hostname. */\n\tif ((parser->status_code == 301 ||\n\t     parser->status_code == 302 ||\n\t     (parser->status_code == 303 && get_verb == s->verb) ||\n\t     parser->status_code == 307) &&\n\t    t->location) {\n\n\t\tif (s->redirect_count >= 7) {\n\t\t\tgiterr_set(GITERR_NET, \"Too many redirects\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\n\t\tif (gitno_connection_data_from_url(&t->connection_data, t->location, s->service_url) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t\t/* Set the redirect URL on the stream. This is a transfer of\n\t\t * ownership of the memory. */\n\t\tif (s->redirect_url)\n\t\t\tgit__free(s->redirect_url);\n\n\t\ts->redirect_url = t->location;\n\t\tt->location = NULL;\n\n\t\tt->connected = 0;\n\t\ts->redirect_count++;\n\n\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\treturn 0;\n\t}\n\n\t/* Check for a 200 HTTP status code. */\n\tif (parser->status_code != 200) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Unexpected HTTP status code: %d\",\n\t\t\tparser->status_code);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The response must contain a Content-Type header. */\n\tif (!t->content_type) {\n\t\tgiterr_set(GITERR_NET, \"No Content-Type header in response\");\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The Content-Type header must match our expectation. */\n\tif (get_verb == s->verb)\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-advertisement\",\n\t\t\tctx->s->service);\n\telse\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-result\",\n\t\t\tctx->s->service);\n\n\tif (git_buf_oom(&buf))\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tif (strcmp(t->content_type, git_buf_cstr(&buf))) {\n\t\tgit_buf_free(&buf);\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Invalid Content-Type: %s\",\n\t\t\tt->content_type);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "on_header_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "315-330",
    "snippet": "static int on_header_value(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\tassert(NONE != t->last_cb);\n\n\tif (FIELD == t->last_cb)\n\t\tgit_buf_clear(&t->parse_header_value);\n\n\tif (git_buf_put(&t->parse_header_value, str, len) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tt->last_cb = VALUE;\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define PARSE_ERROR_GENERIC\t-1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&t->parse_header_value",
            "str",
            "len"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&t->parse_header_value"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "NONE != t->last_cb"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\n#define PARSE_ERROR_GENERIC\t-1\n\nstatic int on_header_value(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\tassert(NONE != t->last_cb);\n\n\tif (FIELD == t->last_cb)\n\t\tgit_buf_clear(&t->parse_header_value);\n\n\tif (git_buf_put(&t->parse_header_value, str, len) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tt->last_cb = VALUE;\n\treturn 0;\n}"
  },
  {
    "function_name": "on_header_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "294-313",
    "snippet": "static int on_header_field(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\t/* Both parse_header_name and parse_header_value are populated\n\t * and ready for consumption */\n\tif (VALUE == t->last_cb)\n\t\tif (on_header_ready(t) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tif (NONE == t->last_cb || VALUE == t->last_cb)\n\t\tgit_buf_clear(&t->parse_header_name);\n\n\tif (git_buf_put(&t->parse_header_name, str, len) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tt->last_cb = FIELD;\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define PARSE_ERROR_GENERIC\t-1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&t->parse_header_name",
            "str",
            "len"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&t->parse_header_name"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_header_ready",
          "args": [
            "t"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "on_header_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "267-292",
          "snippet": "static int on_header_ready(http_subtransport *t)\n{\n\tgit_buf *name = &t->parse_header_name;\n\tgit_buf *value = &t->parse_header_value;\n\n\tif (!strcasecmp(\"Content-Type\", git_buf_cstr(name))) {\n\t\tif (!t->content_type) {\n\t\t\tt->content_type = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->content_type);\n\t\t}\n\t}\n\telse if (!strcasecmp(\"WWW-Authenticate\", git_buf_cstr(name))) {\n\t\tchar *dup = git__strdup(git_buf_cstr(value));\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tgit_vector_insert(&t->www_authenticate, dup);\n\t}\n\telse if (!strcasecmp(\"Location\", git_buf_cstr(name))) {\n\t\tif (!t->location) {\n\t\t\tt->location = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->location);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int on_header_ready(http_subtransport *t)\n{\n\tgit_buf *name = &t->parse_header_name;\n\tgit_buf *value = &t->parse_header_value;\n\n\tif (!strcasecmp(\"Content-Type\", git_buf_cstr(name))) {\n\t\tif (!t->content_type) {\n\t\t\tt->content_type = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->content_type);\n\t\t}\n\t}\n\telse if (!strcasecmp(\"WWW-Authenticate\", git_buf_cstr(name))) {\n\t\tchar *dup = git__strdup(git_buf_cstr(value));\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tgit_vector_insert(&t->www_authenticate, dup);\n\t}\n\telse if (!strcasecmp(\"Location\", git_buf_cstr(name))) {\n\t\tif (!t->location) {\n\t\t\tt->location = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->location);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\n#define PARSE_ERROR_GENERIC\t-1\n\nstatic int on_header_field(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\t/* Both parse_header_name and parse_header_value are populated\n\t * and ready for consumption */\n\tif (VALUE == t->last_cb)\n\t\tif (on_header_ready(t) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tif (NONE == t->last_cb || VALUE == t->last_cb)\n\t\tgit_buf_clear(&t->parse_header_name);\n\n\tif (git_buf_put(&t->parse_header_name, str, len) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tt->last_cb = FIELD;\n\treturn 0;\n}"
  },
  {
    "function_name": "on_header_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "267-292",
    "snippet": "static int on_header_ready(http_subtransport *t)\n{\n\tgit_buf *name = &t->parse_header_name;\n\tgit_buf *value = &t->parse_header_value;\n\n\tif (!strcasecmp(\"Content-Type\", git_buf_cstr(name))) {\n\t\tif (!t->content_type) {\n\t\t\tt->content_type = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->content_type);\n\t\t}\n\t}\n\telse if (!strcasecmp(\"WWW-Authenticate\", git_buf_cstr(name))) {\n\t\tchar *dup = git__strdup(git_buf_cstr(value));\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tgit_vector_insert(&t->www_authenticate, dup);\n\t}\n\telse if (!strcasecmp(\"Location\", git_buf_cstr(name))) {\n\t\tif (!t->location) {\n\t\t\tt->location = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->location);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "t->location"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "git_buf_cstr(value)"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "value"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "\"Location\"",
            "git_buf_cstr(name)"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&t->www_authenticate",
            "dup"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "dup"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "t->content_type"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int on_header_ready(http_subtransport *t)\n{\n\tgit_buf *name = &t->parse_header_name;\n\tgit_buf *value = &t->parse_header_value;\n\n\tif (!strcasecmp(\"Content-Type\", git_buf_cstr(name))) {\n\t\tif (!t->content_type) {\n\t\t\tt->content_type = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->content_type);\n\t\t}\n\t}\n\telse if (!strcasecmp(\"WWW-Authenticate\", git_buf_cstr(name))) {\n\t\tchar *dup = git__strdup(git_buf_cstr(value));\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tgit_vector_insert(&t->www_authenticate, dup);\n\t}\n\telse if (!strcasecmp(\"Location\", git_buf_cstr(name))) {\n\t\tif (!t->location) {\n\t\t\tt->location = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->location);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_authenticate_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "242-265",
    "snippet": "static int parse_authenticate_response(\n\tgit_vector *www_authenticate,\n\thttp_subtransport *t,\n\tint *allowed_types)\n{\n\tgit_http_auth_context *context;\n\tchar *challenge;\n\tsize_t i;\n\n\tgit_vector_foreach(www_authenticate, i, challenge) {\n\t\tif (auth_context_match(&context, t, challenge_match, challenge) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\tcontinue;\n\n\t\tif (context->set_challenge &&\n\t\t\tcontext->set_challenge(context, challenge) < 0)\n\t\t\treturn -1;\n\n\t\t*allowed_types |= context->credtypes;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context->set_challenge",
          "args": [
            "context",
            "challenge"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_context_match",
          "args": [
            "&context",
            "t",
            "challenge_match",
            "challenge"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "auth_context_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "121-163",
          "snippet": "static int auth_context_match(\n\tgit_http_auth_context **out,\n\thttp_subtransport *t,\n\tbool (*scheme_match)(git_http_auth_scheme *scheme, void *data),\n\tvoid *data)\n{\n\tgit_http_auth_scheme *scheme = NULL;\n\tgit_http_auth_context *context = NULL, *c;\n\tsize_t i;\n\n\t*out = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(auth_schemes); i++) {\n\t\tif (scheme_match(&auth_schemes[i], data)) {\n\t\t\tscheme = &auth_schemes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!scheme)\n\t\treturn 0;\n\n\t/* See if authentication has already started for this scheme */\n\tgit_vector_foreach(&t->auth_contexts, i, c) {\n\t\tif (c->type == scheme->type) {\n\t\t\tcontext = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!context) {\n\t\tif (scheme->init_context(&context, &t->connection_data) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\treturn 0;\n\t\telse if (git_vector_insert(&t->auth_contexts, context) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*out = context;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int auth_context_match(\n\tgit_http_auth_context **out,\n\thttp_subtransport *t,\n\tbool (*scheme_match)(git_http_auth_scheme *scheme, void *data),\n\tvoid *data)\n{\n\tgit_http_auth_scheme *scheme = NULL;\n\tgit_http_auth_context *context = NULL, *c;\n\tsize_t i;\n\n\t*out = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(auth_schemes); i++) {\n\t\tif (scheme_match(&auth_schemes[i], data)) {\n\t\t\tscheme = &auth_schemes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!scheme)\n\t\treturn 0;\n\n\t/* See if authentication has already started for this scheme */\n\tgit_vector_foreach(&t->auth_contexts, i, c) {\n\t\tif (c->type == scheme->type) {\n\t\t\tcontext = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!context) {\n\t\tif (scheme->init_context(&context, &t->connection_data) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\treturn 0;\n\t\telse if (git_vector_insert(&t->auth_contexts, context) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*out = context;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "www_authenticate",
            "i",
            "challenge"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int parse_authenticate_response(\n\tgit_vector *www_authenticate,\n\thttp_subtransport *t,\n\tint *allowed_types)\n{\n\tgit_http_auth_context *context;\n\tchar *challenge;\n\tsize_t i;\n\n\tgit_vector_foreach(www_authenticate, i, challenge) {\n\t\tif (auth_context_match(&context, t, challenge_match, challenge) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\tcontinue;\n\n\t\tif (context->set_challenge &&\n\t\t\tcontext->set_challenge(context, challenge) < 0)\n\t\t\treturn -1;\n\n\t\t*allowed_types |= context->credtypes;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gen_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "200-240",
    "snippet": "static int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/1.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "buf"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "buf",
            "\"\\r\\n\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_credentials",
          "args": [
            "buf",
            "t"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "apply_credentials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "165-188",
          "snippet": "static int apply_credentials(git_buf *buf, http_subtransport *t)\n{\n\tgit_cred *cred = t->cred;\n\tgit_http_auth_context *context;\n\n\t/* Apply the credentials given to us in the URL */\n\tif (!cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred,\n\t\t\t\tt->connection_data.user, t->connection_data.pass) < 0)\n\t\t\treturn -1;\n\n\t\tcred = t->url_cred;\n\t}\n\n\tif (!cred)\n\t\treturn 0;\n\n\t/* Get or create a context for the best scheme for this cred type */\n\tif (auth_context_match(&context, t, credtype_match, &cred->credtype) < 0)\n\t\treturn -1;\n\n\treturn context->next_token(buf, context, cred);\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int apply_credentials(git_buf *buf, http_subtransport *t)\n{\n\tgit_cred *cred = t->cred;\n\tgit_http_auth_context *context;\n\n\t/* Apply the credentials given to us in the URL */\n\tif (!cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred,\n\t\t\t\tt->connection_data.user, t->connection_data.pass) < 0)\n\t\t\treturn -1;\n\n\t\tcred = t->url_cred;\n\t}\n\n\tif (!cred)\n\t\treturn 0;\n\n\t/* Get or create a context for the best scheme for this cred type */\n\tif (auth_context_match(&context, t, credtype_match, &cred->credtype) < 0)\n\t\treturn -1;\n\n\treturn context->next_token(buf, context, cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "buf",
            "\"%s\\r\\n\"",
            "t->owner->custom_headers.strings[i]"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_agent",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "user_agent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "190-198",
          "snippet": "static const char *user_agent(void)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tif (custom)\n\t\treturn custom;\n\n\treturn \"libgit2 \" LIBGIT2_VERSION;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic const char *user_agent(void)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tif (custom)\n\t\treturn custom;\n\n\treturn \"libgit2 \" LIBGIT2_VERSION;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OWNING_SUBTRANSPORT",
          "args": [
            "s"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/1.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "user_agent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "190-198",
    "snippet": "static const char *user_agent(void)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tif (custom)\n\t\treturn custom;\n\n\treturn \"libgit2 \" LIBGIT2_VERSION;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_libgit2__user_agent",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "git_libgit2__user_agent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/settings.c",
          "lines": "76-79",
          "snippet": "const char *git_libgit2__user_agent()\n{\n\treturn git__user_agent;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"global.h\"",
            "#include \"cache.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\"",
            "#include <git2.h>",
            "# include <openssl/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *git__user_agent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"global.h\"\n#include \"cache.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n#include <git2.h>\n# include <openssl/err.h>\n\nextern char *git__user_agent;\n\nconst char *git_libgit2__user_agent()\n{\n\treturn git__user_agent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic const char *user_agent(void)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tif (custom)\n\t\treturn custom;\n\n\treturn \"libgit2 \" LIBGIT2_VERSION;\n}"
  },
  {
    "function_name": "apply_credentials",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "165-188",
    "snippet": "static int apply_credentials(git_buf *buf, http_subtransport *t)\n{\n\tgit_cred *cred = t->cred;\n\tgit_http_auth_context *context;\n\n\t/* Apply the credentials given to us in the URL */\n\tif (!cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred,\n\t\t\t\tt->connection_data.user, t->connection_data.pass) < 0)\n\t\t\treturn -1;\n\n\t\tcred = t->url_cred;\n\t}\n\n\tif (!cred)\n\t\treturn 0;\n\n\t/* Get or create a context for the best scheme for this cred type */\n\tif (auth_context_match(&context, t, credtype_match, &cred->credtype) < 0)\n\t\treturn -1;\n\n\treturn context->next_token(buf, context, cred);\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context->next_token",
          "args": [
            "buf",
            "context",
            "cred"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_context_match",
          "args": [
            "&context",
            "t",
            "credtype_match",
            "&cred->credtype"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "auth_context_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
          "lines": "121-163",
          "snippet": "static int auth_context_match(\n\tgit_http_auth_context **out,\n\thttp_subtransport *t,\n\tbool (*scheme_match)(git_http_auth_scheme *scheme, void *data),\n\tvoid *data)\n{\n\tgit_http_auth_scheme *scheme = NULL;\n\tgit_http_auth_context *context = NULL, *c;\n\tsize_t i;\n\n\t*out = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(auth_schemes); i++) {\n\t\tif (scheme_match(&auth_schemes[i], data)) {\n\t\t\tscheme = &auth_schemes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!scheme)\n\t\treturn 0;\n\n\t/* See if authentication has already started for this scheme */\n\tgit_vector_foreach(&t->auth_contexts, i, c) {\n\t\tif (c->type == scheme->type) {\n\t\t\tcontext = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!context) {\n\t\tif (scheme->init_context(&context, &t->connection_data) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\treturn 0;\n\t\telse if (git_vector_insert(&t->auth_contexts, context) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*out = context;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"curl_stream.h\"",
            "#include \"socket_stream.h\"",
            "#include \"tls_stream.h\"",
            "#include \"auth_negotiate.h\"",
            "#include \"auth.h\"",
            "#include \"smart.h\"",
            "#include \"remote.h\"",
            "#include \"global.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"http_parser.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int auth_context_match(\n\tgit_http_auth_context **out,\n\thttp_subtransport *t,\n\tbool (*scheme_match)(git_http_auth_scheme *scheme, void *data),\n\tvoid *data)\n{\n\tgit_http_auth_scheme *scheme = NULL;\n\tgit_http_auth_context *context = NULL, *c;\n\tsize_t i;\n\n\t*out = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(auth_schemes); i++) {\n\t\tif (scheme_match(&auth_schemes[i], data)) {\n\t\t\tscheme = &auth_schemes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!scheme)\n\t\treturn 0;\n\n\t/* See if authentication has already started for this scheme */\n\tgit_vector_foreach(&t->auth_contexts, i, c) {\n\t\tif (c->type == scheme->type) {\n\t\t\tcontext = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!context) {\n\t\tif (scheme->init_context(&context, &t->connection_data) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\treturn 0;\n\t\telse if (git_vector_insert(&t->auth_contexts, context) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*out = context;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_cred_userpass_plaintext_new",
          "args": [
            "&t->url_cred",
            "t->connection_data.user",
            "t->connection_data.pass"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "git_cred_userpass_plaintext_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/cred.c",
          "lines": "79-110",
          "snippet": "int git_cred_userpass_plaintext_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *password)\n{\n\tgit_cred_userpass_plaintext *c;\n\n\tassert(cred && username && password);\n\n\tc = git__malloc(sizeof(git_cred_userpass_plaintext));\n\tGITERR_CHECK_ALLOC(c);\n\n\tc->parent.credtype = GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\tc->parent.free = plaintext_free;\n\tc->username = git__strdup(username);\n\n\tif (!c->username) {\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\tc->password = git__strdup(password);\n\n\tif (!c->password) {\n\t\tgit__free(c->username);\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\t*cred = &c->parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/cred_helpers.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/cred_helpers.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);\n\nint git_cred_userpass_plaintext_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *password)\n{\n\tgit_cred_userpass_plaintext *c;\n\n\tassert(cred && username && password);\n\n\tc = git__malloc(sizeof(git_cred_userpass_plaintext));\n\tGITERR_CHECK_ALLOC(c);\n\n\tc->parent.credtype = GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\tc->parent.free = plaintext_free;\n\tc->username = git__strdup(username);\n\n\tif (!c->username) {\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\tc->password = git__strdup(password);\n\n\tif (!c->password) {\n\t\tgit__free(c->username);\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\t*cred = &c->parent;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int apply_credentials(git_buf *buf, http_subtransport *t)\n{\n\tgit_cred *cred = t->cred;\n\tgit_http_auth_context *context;\n\n\t/* Apply the credentials given to us in the URL */\n\tif (!cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred,\n\t\t\t\tt->connection_data.user, t->connection_data.pass) < 0)\n\t\t\treturn -1;\n\n\t\tcred = t->url_cred;\n\t}\n\n\tif (!cred)\n\t\treturn 0;\n\n\t/* Get or create a context for the best scheme for this cred type */\n\tif (auth_context_match(&context, t, credtype_match, &cred->credtype) < 0)\n\t\treturn -1;\n\n\treturn context->next_token(buf, context, cred);\n}"
  },
  {
    "function_name": "auth_context_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "121-163",
    "snippet": "static int auth_context_match(\n\tgit_http_auth_context **out,\n\thttp_subtransport *t,\n\tbool (*scheme_match)(git_http_auth_scheme *scheme, void *data),\n\tvoid *data)\n{\n\tgit_http_auth_scheme *scheme = NULL;\n\tgit_http_auth_context *context = NULL, *c;\n\tsize_t i;\n\n\t*out = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(auth_schemes); i++) {\n\t\tif (scheme_match(&auth_schemes[i], data)) {\n\t\t\tscheme = &auth_schemes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!scheme)\n\t\treturn 0;\n\n\t/* See if authentication has already started for this scheme */\n\tgit_vector_foreach(&t->auth_contexts, i, c) {\n\t\tif (c->type == scheme->type) {\n\t\t\tcontext = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!context) {\n\t\tif (scheme->init_context(&context, &t->connection_data) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\treturn 0;\n\t\telse if (git_vector_insert(&t->auth_contexts, context) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*out = context;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&t->auth_contexts",
            "context"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scheme->init_context",
          "args": [
            "&context",
            "&t->connection_data"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&t->auth_contexts",
            "i",
            "c"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scheme_match",
          "args": [
            "&auth_schemes[i]",
            "data"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "auth_schemes"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int auth_context_match(\n\tgit_http_auth_context **out,\n\thttp_subtransport *t,\n\tbool (*scheme_match)(git_http_auth_scheme *scheme, void *data),\n\tvoid *data)\n{\n\tgit_http_auth_scheme *scheme = NULL;\n\tgit_http_auth_context *context = NULL, *c;\n\tsize_t i;\n\n\t*out = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(auth_schemes); i++) {\n\t\tif (scheme_match(&auth_schemes[i], data)) {\n\t\t\tscheme = &auth_schemes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!scheme)\n\t\treturn 0;\n\n\t/* See if authentication has already started for this scheme */\n\tgit_vector_foreach(&t->auth_contexts, i, c) {\n\t\tif (c->type == scheme->type) {\n\t\t\tcontext = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!context) {\n\t\tif (scheme->init_context(&context, &t->connection_data) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\treturn 0;\n\t\telse if (git_vector_insert(&t->auth_contexts, context) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*out = context;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "challenge_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "110-119",
    "snippet": "static bool challenge_match(git_http_auth_scheme *scheme, void *data)\n{\n\tconst char *scheme_name = scheme->name;\n\tconst char *challenge = (const char *)data;\n\tsize_t scheme_len;\n\n\tscheme_len = strlen(scheme_name);\n\treturn (strncasecmp(challenge, scheme_name, scheme_len) == 0 &&\n\t\t(challenge[scheme_len] == '\\0' || challenge[scheme_len] == ' '));\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "challenge",
            "scheme_name",
            "scheme_len"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncasecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "214-225",
          "snippet": "int git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "scheme_name"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic bool challenge_match(git_http_auth_scheme *scheme, void *data)\n{\n\tconst char *scheme_name = scheme->name;\n\tconst char *challenge = (const char *)data;\n\tsize_t scheme_len;\n\n\tscheme_len = strlen(scheme_name);\n\treturn (strncasecmp(challenge, scheme_name, scheme_len) == 0 &&\n\t\t(challenge[scheme_len] == '\\0' || challenge[scheme_len] == ' '));\n}"
  },
  {
    "function_name": "credtype_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
    "lines": "103-108",
    "snippet": "static bool credtype_match(git_http_auth_scheme *scheme, void *data)\n{\n\tunsigned int credtype = *(unsigned int *)data;\n\n\treturn !!(scheme->credtypes & credtype);\n}",
    "includes": [
      "#include \"curl_stream.h\"",
      "#include \"socket_stream.h\"",
      "#include \"tls_stream.h\"",
      "#include \"auth_negotiate.h\"",
      "#include \"auth.h\"",
      "#include \"smart.h\"",
      "#include \"remote.h\"",
      "#include \"global.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"http_parser.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic bool credtype_match(git_http_auth_scheme *scheme, void *data)\n{\n\tunsigned int credtype = *(unsigned int *)data;\n\n\treturn !!(scheme->credtypes & credtype);\n}"
  }
]