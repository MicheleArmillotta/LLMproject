[
  {
    "function_name": "git_path_normalize_slashes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1703-1717",
    "snippet": "int git_path_normalize_slashes(git_buf *out, const char *path)\n{\n\tint error;\n\tchar *p;\n\n\tif ((error = git_buf_puts(out, path)) < 0)\n\t\treturn error;\n\n\tfor (p = out->ptr; *p; p++) {\n\t\tif (*p == '\\\\')\n\t\t\t*p = '/';\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "out",
            "path"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_normalize_slashes(git_buf *out, const char *path)\n{\n\tint error;\n\tchar *p;\n\n\tif ((error = git_buf_puts(out, path)) < 0)\n\t\treturn error;\n\n\tfor (p = out->ptr; *p; p++) {\n\t\tif (*p == '\\\\')\n\t\t\t*p = '/';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1677-1701",
    "snippet": "bool git_path_isvalid(\n\tgit_repository *repo,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tconst char *start, *c;\n\n\t/* Upgrade the \".git\" checks based on platform */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT))\n\t\tflags = dotgit_flags(repo, flags);\n\n\tfor (start = c = path; *c; c++) {\n\t\tif (!verify_char(*c, flags))\n\t\t\treturn false;\n\n\t\tif (*c == '/') {\n\t\t\tif (!verify_component(repo, start, (c - start), flags))\n\t\t\t\treturn false;\n\n\t\t\tstart = c+1;\n\t\t}\n\t}\n\n\treturn verify_component(repo, start, (c - start), flags);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify_component",
          "args": [
            "repo",
            "start",
            "(c - start)",
            "flags"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "verify_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1588-1646",
          "snippet": "static bool verify_component(\n\tgit_repository *repo,\n\tconst char *component,\n\tsize_t len,\n\tunsigned int flags)\n{\n\tif (len == 0)\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAVERSAL) &&\n\t\tlen == 1 && component[0] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAVERSAL) &&\n\t\tlen == 2 && component[0] == '.' && component[1] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_DOT) && component[len-1] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_SPACE) && component[len-1] == ' ')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_COLON) && component[len-1] == ':')\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_DOS_PATHS) {\n\t\tif (!verify_dospath(component, len, \"CON\", false) ||\n\t\t\t!verify_dospath(component, len, \"PRN\", false) ||\n\t\t\t!verify_dospath(component, len, \"AUX\", false) ||\n\t\t\t!verify_dospath(component, len, \"NUL\", false) ||\n\t\t\t!verify_dospath(component, len, \"COM\", true)  ||\n\t\t\t!verify_dospath(component, len, \"LPT\", true))\n\t\t\treturn false;\n\t}\n\n\tif (flags & GIT_PATH_REJECT_DOT_GIT_HFS &&\n\t\t!verify_dotgit_hfs(component, len))\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_DOT_GIT_NTFS &&\n\t\t!verify_dotgit_ntfs(repo, component, len))\n\t\treturn false;\n\n\t/* don't bother rerunning the `.git` test if we ran the HFS or NTFS\n\t * specific tests, they would have already rejected `.git`.\n\t */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT_HFS) == 0 &&\n\t\t(flags & GIT_PATH_REJECT_DOT_GIT_NTFS) == 0 &&\n\t\t(flags & GIT_PATH_REJECT_DOT_GIT_LITERAL) &&\n\t\tlen == 4 &&\n\t\tcomponent[0] == '.' &&\n\t\t(component[1] == 'g' || component[1] == 'G') &&\n\t\t(component[2] == 'i' || component[2] == 'I') &&\n\t\t(component[3] == 't' || component[3] == 'T'))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool verify_component(\n\tgit_repository *repo,\n\tconst char *component,\n\tsize_t len,\n\tunsigned int flags)\n{\n\tif (len == 0)\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAVERSAL) &&\n\t\tlen == 1 && component[0] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAVERSAL) &&\n\t\tlen == 2 && component[0] == '.' && component[1] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_DOT) && component[len-1] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_SPACE) && component[len-1] == ' ')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_COLON) && component[len-1] == ':')\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_DOS_PATHS) {\n\t\tif (!verify_dospath(component, len, \"CON\", false) ||\n\t\t\t!verify_dospath(component, len, \"PRN\", false) ||\n\t\t\t!verify_dospath(component, len, \"AUX\", false) ||\n\t\t\t!verify_dospath(component, len, \"NUL\", false) ||\n\t\t\t!verify_dospath(component, len, \"COM\", true)  ||\n\t\t\t!verify_dospath(component, len, \"LPT\", true))\n\t\t\treturn false;\n\t}\n\n\tif (flags & GIT_PATH_REJECT_DOT_GIT_HFS &&\n\t\t!verify_dotgit_hfs(component, len))\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_DOT_GIT_NTFS &&\n\t\t!verify_dotgit_ntfs(repo, component, len))\n\t\treturn false;\n\n\t/* don't bother rerunning the `.git` test if we ran the HFS or NTFS\n\t * specific tests, they would have already rejected `.git`.\n\t */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT_HFS) == 0 &&\n\t\t(flags & GIT_PATH_REJECT_DOT_GIT_NTFS) == 0 &&\n\t\t(flags & GIT_PATH_REJECT_DOT_GIT_LITERAL) &&\n\t\tlen == 4 &&\n\t\tcomponent[0] == '.' &&\n\t\t(component[1] == 'g' || component[1] == 'G') &&\n\t\t(component[2] == 'i' || component[2] == 'I') &&\n\t\t(component[3] == 't' || component[3] == 'T'))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_char",
          "args": [
            "*c",
            "flags"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "verify_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1552-1577",
          "snippet": "GIT_INLINE(bool) verify_char(unsigned char c, unsigned int flags)\n{\n\tif ((flags & GIT_PATH_REJECT_BACKSLASH) && c == '\\\\')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_SLASH) && c == '/')\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_NT_CHARS) {\n\t\tif (c < 32)\n\t\t\treturn false;\n\n\t\tswitch (c) {\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase ':':\n\t\tcase '\"':\n\t\tcase '|':\n\t\tcase '?':\n\t\tcase '*':\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) verify_char(unsigned char c, unsigned int flags)\n{\n\tif ((flags & GIT_PATH_REJECT_BACKSLASH) && c == '\\\\')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_SLASH) && c == '/')\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_NT_CHARS) {\n\t\tif (c < 32)\n\t\t\treturn false;\n\n\t\tswitch (c) {\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase ':':\n\t\tcase '\"':\n\t\tcase '|':\n\t\tcase '?':\n\t\tcase '*':\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dotgit_flags",
          "args": [
            "repo",
            "flags"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "dotgit_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1648-1675",
          "snippet": "GIT_INLINE(unsigned int) dotgit_flags(\n\tgit_repository *repo,\n\tunsigned int flags)\n{\n\tint protectHFS = 0, protectNTFS = 0;\n\n\tflags |= GIT_PATH_REJECT_DOT_GIT_LITERAL;\n\n#ifdef __APPLE__\n\tprotectHFS = 1;\n#endif\n\n#ifdef GIT_WIN32\n\tprotectNTFS = 1;\n#endif\n\n\tif (repo && !protectHFS)\n\t\tgit_repository__cvar(&protectHFS, repo, GIT_CVAR_PROTECTHFS);\n\tif (protectHFS)\n\t\tflags |= GIT_PATH_REJECT_DOT_GIT_HFS;\n\n\tif (repo && !protectNTFS)\n\t\tgit_repository__cvar(&protectNTFS, repo, GIT_CVAR_PROTECTNTFS);\n\tif (protectNTFS)\n\t\tflags |= GIT_PATH_REJECT_DOT_GIT_NTFS;\n\n\treturn flags;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nGIT_INLINE(unsigned int) dotgit_flags(\n\tgit_repository *repo,\n\tunsigned int flags)\n{\n\tint protectHFS = 0, protectNTFS = 0;\n\n\tflags |= GIT_PATH_REJECT_DOT_GIT_LITERAL;\n\n#ifdef __APPLE__\n\tprotectHFS = 1;\n#endif\n\n#ifdef GIT_WIN32\n\tprotectNTFS = 1;\n#endif\n\n\tif (repo && !protectHFS)\n\t\tgit_repository__cvar(&protectHFS, repo, GIT_CVAR_PROTECTHFS);\n\tif (protectHFS)\n\t\tflags |= GIT_PATH_REJECT_DOT_GIT_HFS;\n\n\tif (repo && !protectNTFS)\n\t\tgit_repository__cvar(&protectNTFS, repo, GIT_CVAR_PROTECTNTFS);\n\tif (protectNTFS)\n\t\tflags |= GIT_PATH_REJECT_DOT_GIT_NTFS;\n\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isvalid(\n\tgit_repository *repo,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tconst char *start, *c;\n\n\t/* Upgrade the \".git\" checks based on platform */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT))\n\t\tflags = dotgit_flags(repo, flags);\n\n\tfor (start = c = path; *c; c++) {\n\t\tif (!verify_char(*c, flags))\n\t\t\treturn false;\n\n\t\tif (*c == '/') {\n\t\t\tif (!verify_component(repo, start, (c - start), flags))\n\t\t\t\treturn false;\n\n\t\t\tstart = c+1;\n\t\t}\n\t}\n\n\treturn verify_component(repo, start, (c - start), flags);\n}"
  },
  {
    "function_name": "dotgit_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1648-1675",
    "snippet": "GIT_INLINE(unsigned int) dotgit_flags(\n\tgit_repository *repo,\n\tunsigned int flags)\n{\n\tint protectHFS = 0, protectNTFS = 0;\n\n\tflags |= GIT_PATH_REJECT_DOT_GIT_LITERAL;\n\n#ifdef __APPLE__\n\tprotectHFS = 1;\n#endif\n\n#ifdef GIT_WIN32\n\tprotectNTFS = 1;\n#endif\n\n\tif (repo && !protectHFS)\n\t\tgit_repository__cvar(&protectHFS, repo, GIT_CVAR_PROTECTHFS);\n\tif (protectHFS)\n\t\tflags |= GIT_PATH_REJECT_DOT_GIT_HFS;\n\n\tif (repo && !protectNTFS)\n\t\tgit_repository__cvar(&protectNTFS, repo, GIT_CVAR_PROTECTNTFS);\n\tif (protectNTFS)\n\t\tflags |= GIT_PATH_REJECT_DOT_GIT_NTFS;\n\n\treturn flags;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&protectNTFS",
            "repo",
            "GIT_CVAR_PROTECTNTFS"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nGIT_INLINE(unsigned int) dotgit_flags(\n\tgit_repository *repo,\n\tunsigned int flags)\n{\n\tint protectHFS = 0, protectNTFS = 0;\n\n\tflags |= GIT_PATH_REJECT_DOT_GIT_LITERAL;\n\n#ifdef __APPLE__\n\tprotectHFS = 1;\n#endif\n\n#ifdef GIT_WIN32\n\tprotectNTFS = 1;\n#endif\n\n\tif (repo && !protectHFS)\n\t\tgit_repository__cvar(&protectHFS, repo, GIT_CVAR_PROTECTHFS);\n\tif (protectHFS)\n\t\tflags |= GIT_PATH_REJECT_DOT_GIT_HFS;\n\n\tif (repo && !protectNTFS)\n\t\tgit_repository__cvar(&protectNTFS, repo, GIT_CVAR_PROTECTNTFS);\n\tif (protectNTFS)\n\t\tflags |= GIT_PATH_REJECT_DOT_GIT_NTFS;\n\n\treturn flags;\n}"
  },
  {
    "function_name": "verify_component",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1588-1646",
    "snippet": "static bool verify_component(\n\tgit_repository *repo,\n\tconst char *component,\n\tsize_t len,\n\tunsigned int flags)\n{\n\tif (len == 0)\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAVERSAL) &&\n\t\tlen == 1 && component[0] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAVERSAL) &&\n\t\tlen == 2 && component[0] == '.' && component[1] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_DOT) && component[len-1] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_SPACE) && component[len-1] == ' ')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_COLON) && component[len-1] == ':')\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_DOS_PATHS) {\n\t\tif (!verify_dospath(component, len, \"CON\", false) ||\n\t\t\t!verify_dospath(component, len, \"PRN\", false) ||\n\t\t\t!verify_dospath(component, len, \"AUX\", false) ||\n\t\t\t!verify_dospath(component, len, \"NUL\", false) ||\n\t\t\t!verify_dospath(component, len, \"COM\", true)  ||\n\t\t\t!verify_dospath(component, len, \"LPT\", true))\n\t\t\treturn false;\n\t}\n\n\tif (flags & GIT_PATH_REJECT_DOT_GIT_HFS &&\n\t\t!verify_dotgit_hfs(component, len))\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_DOT_GIT_NTFS &&\n\t\t!verify_dotgit_ntfs(repo, component, len))\n\t\treturn false;\n\n\t/* don't bother rerunning the `.git` test if we ran the HFS or NTFS\n\t * specific tests, they would have already rejected `.git`.\n\t */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT_HFS) == 0 &&\n\t\t(flags & GIT_PATH_REJECT_DOT_GIT_NTFS) == 0 &&\n\t\t(flags & GIT_PATH_REJECT_DOT_GIT_LITERAL) &&\n\t\tlen == 4 &&\n\t\tcomponent[0] == '.' &&\n\t\t(component[1] == 'g' || component[1] == 'G') &&\n\t\t(component[2] == 'i' || component[2] == 'I') &&\n\t\t(component[3] == 't' || component[3] == 'T'))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify_dotgit_ntfs",
          "args": [
            "repo",
            "component",
            "len"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "verify_dotgit_ntfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1517-1550",
          "snippet": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/* Reject paths like \".git\\\" */\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/* Reject paths like \".git\\\" */\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_dotgit_hfs",
          "args": [
            "component",
            "len"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "verify_dotgit_hfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1505-1515",
          "snippet": "static bool verify_dotgit_hfs(const char *path, size_t len)\n{\n\tif (next_hfs_char(&path, &len) != '.' ||\n\t\tnext_hfs_char(&path, &len) != 'g' ||\n\t\tnext_hfs_char(&path, &len) != 'i' ||\n\t\tnext_hfs_char(&path, &len) != 't' ||\n\t\tnext_hfs_char(&path, &len) != 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool verify_dotgit_hfs(const char *path, size_t len)\n{\n\tif (next_hfs_char(&path, &len) != '.' ||\n\t\tnext_hfs_char(&path, &len) != 'g' ||\n\t\tnext_hfs_char(&path, &len) != 'i' ||\n\t\tnext_hfs_char(&path, &len) != 't' ||\n\t\tnext_hfs_char(&path, &len) != 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_dospath",
          "args": [
            "component",
            "len",
            "\"LPT\"",
            "true"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "verify_dospath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1445-1462",
          "snippet": "GIT_INLINE(bool) verify_dospath(\n\tconst char *component,\n\tsize_t len,\n\tconst char dospath[3],\n\tbool trailing_num)\n{\n\tsize_t last = trailing_num ? 4 : 3;\n\n\tif (len < last || git__strncasecmp(component, dospath, 3) != 0)\n\t\treturn true;\n\n\tif (trailing_num && (component[3] < '1' || component[3] > '9'))\n\t\treturn true;\n\n\treturn (len > last &&\n\t\tcomponent[last] != '.' &&\n\t\tcomponent[last] != ':');\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) verify_dospath(\n\tconst char *component,\n\tsize_t len,\n\tconst char dospath[3],\n\tbool trailing_num)\n{\n\tsize_t last = trailing_num ? 4 : 3;\n\n\tif (len < last || git__strncasecmp(component, dospath, 3) != 0)\n\t\treturn true;\n\n\tif (trailing_num && (component[3] < '1' || component[3] > '9'))\n\t\treturn true;\n\n\treturn (len > last &&\n\t\tcomponent[last] != '.' &&\n\t\tcomponent[last] != ':');\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool verify_component(\n\tgit_repository *repo,\n\tconst char *component,\n\tsize_t len,\n\tunsigned int flags)\n{\n\tif (len == 0)\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAVERSAL) &&\n\t\tlen == 1 && component[0] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAVERSAL) &&\n\t\tlen == 2 && component[0] == '.' && component[1] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_DOT) && component[len-1] == '.')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_SPACE) && component[len-1] == ' ')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_TRAILING_COLON) && component[len-1] == ':')\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_DOS_PATHS) {\n\t\tif (!verify_dospath(component, len, \"CON\", false) ||\n\t\t\t!verify_dospath(component, len, \"PRN\", false) ||\n\t\t\t!verify_dospath(component, len, \"AUX\", false) ||\n\t\t\t!verify_dospath(component, len, \"NUL\", false) ||\n\t\t\t!verify_dospath(component, len, \"COM\", true)  ||\n\t\t\t!verify_dospath(component, len, \"LPT\", true))\n\t\t\treturn false;\n\t}\n\n\tif (flags & GIT_PATH_REJECT_DOT_GIT_HFS &&\n\t\t!verify_dotgit_hfs(component, len))\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_DOT_GIT_NTFS &&\n\t\t!verify_dotgit_ntfs(repo, component, len))\n\t\treturn false;\n\n\t/* don't bother rerunning the `.git` test if we ran the HFS or NTFS\n\t * specific tests, they would have already rejected `.git`.\n\t */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT_HFS) == 0 &&\n\t\t(flags & GIT_PATH_REJECT_DOT_GIT_NTFS) == 0 &&\n\t\t(flags & GIT_PATH_REJECT_DOT_GIT_LITERAL) &&\n\t\tlen == 4 &&\n\t\tcomponent[0] == '.' &&\n\t\t(component[1] == 'g' || component[1] == 'G') &&\n\t\t(component[2] == 'i' || component[2] == 'I') &&\n\t\t(component[3] == 't' || component[3] == 'T'))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "verify_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1552-1577",
    "snippet": "GIT_INLINE(bool) verify_char(unsigned char c, unsigned int flags)\n{\n\tif ((flags & GIT_PATH_REJECT_BACKSLASH) && c == '\\\\')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_SLASH) && c == '/')\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_NT_CHARS) {\n\t\tif (c < 32)\n\t\t\treturn false;\n\n\t\tswitch (c) {\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase ':':\n\t\tcase '\"':\n\t\tcase '|':\n\t\tcase '?':\n\t\tcase '*':\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) verify_char(unsigned char c, unsigned int flags)\n{\n\tif ((flags & GIT_PATH_REJECT_BACKSLASH) && c == '\\\\')\n\t\treturn false;\n\n\tif ((flags & GIT_PATH_REJECT_SLASH) && c == '/')\n\t\treturn false;\n\n\tif (flags & GIT_PATH_REJECT_NT_CHARS) {\n\t\tif (c < 32)\n\t\t\treturn false;\n\n\t\tswitch (c) {\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase ':':\n\t\tcase '\"':\n\t\tcase '|':\n\t\tcase '?':\n\t\tcase '*':\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "verify_dotgit_ntfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1517-1550",
    "snippet": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/* Reject paths like \".git\\\" */\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "path",
            "r->ptr",
            "r->size"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncasecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "214-225",
          "snippet": "int git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__reserved_names",
          "args": [
            "&reserved",
            "&reserved_len",
            "repo",
            "true"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__reserved_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "969-983",
          "snippet": "bool git_repository__reserved_names(\n\tgit_buf **out, size_t *outlen, git_repository *repo, bool include_ntfs)\n{\n\tGIT_UNUSED(repo);\n\n\tif (include_ntfs) {\n\t\t*out = git_repository__reserved_names_win32;\n\t\t*outlen = git_repository__reserved_names_win32_len;\n\t} else {\n\t\t*out = git_repository__reserved_names_posix;\n\t\t*outlen = git_repository__reserved_names_posix_len;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "git_buf git_repository__reserved_names_win32[] = {\n\t{ DOT_GIT, 0, CONST_STRLEN(DOT_GIT) },\n\t{ GIT_DIR_SHORTNAME, 0, CONST_STRLEN(GIT_DIR_SHORTNAME) }\n};",
            "size_t git_repository__reserved_names_win32_len = 2;",
            "git_buf git_repository__reserved_names_posix[] = {\n\t{ DOT_GIT, 0, CONST_STRLEN(DOT_GIT) },\n};",
            "size_t git_repository__reserved_names_posix_len = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\ngit_buf git_repository__reserved_names_win32[] = {\n\t{ DOT_GIT, 0, CONST_STRLEN(DOT_GIT) },\n\t{ GIT_DIR_SHORTNAME, 0, CONST_STRLEN(GIT_DIR_SHORTNAME) }\n};\nsize_t git_repository__reserved_names_win32_len = 2;\ngit_buf git_repository__reserved_names_posix[] = {\n\t{ DOT_GIT, 0, CONST_STRLEN(DOT_GIT) },\n};\nsize_t git_repository__reserved_names_posix_len = 1;\n\nbool git_repository__reserved_names(\n\tgit_buf **out, size_t *outlen, git_repository *repo, bool include_ntfs)\n{\n\tGIT_UNUSED(repo);\n\n\tif (include_ntfs) {\n\t\t*out = git_repository__reserved_names_win32;\n\t\t*outlen = git_repository__reserved_names_win32_len;\n\t} else {\n\t\t*out = git_repository__reserved_names_posix;\n\t\t*outlen = git_repository__reserved_names_posix_len;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/* Reject paths like \".git\\\" */\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "verify_dotgit_hfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1505-1515",
    "snippet": "static bool verify_dotgit_hfs(const char *path, size_t len)\n{\n\tif (next_hfs_char(&path, &len) != '.' ||\n\t\tnext_hfs_char(&path, &len) != 'g' ||\n\t\tnext_hfs_char(&path, &len) != 'i' ||\n\t\tnext_hfs_char(&path, &len) != 't' ||\n\t\tnext_hfs_char(&path, &len) != 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_hfs_char",
          "args": [
            "&path",
            "&len"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "next_hfs_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1464-1503",
          "snippet": "static int32_t next_hfs_char(const char **in, size_t *len)\n{\n\twhile (*len) {\n\t\tint32_t codepoint;\n\t\tint cp_len = git__utf8_iterate((const uint8_t *)(*in), (int)(*len), &codepoint);\n\t\tif (cp_len < 0)\n\t\t\treturn -1;\n\n\t\t(*in) += cp_len;\n\t\t(*len) -= cp_len;\n\n\t\t/* these code points are ignored completely */\n\t\tswitch (codepoint) {\n\t\tcase 0x200c: /* ZERO WIDTH NON-JOINER */\n\t\tcase 0x200d: /* ZERO WIDTH JOINER */\n\t\tcase 0x200e: /* LEFT-TO-RIGHT MARK */\n\t\tcase 0x200f: /* RIGHT-TO-LEFT MARK */\n\t\tcase 0x202a: /* LEFT-TO-RIGHT EMBEDDING */\n\t\tcase 0x202b: /* RIGHT-TO-LEFT EMBEDDING */\n\t\tcase 0x202c: /* POP DIRECTIONAL FORMATTING */\n\t\tcase 0x202d: /* LEFT-TO-RIGHT OVERRIDE */\n\t\tcase 0x202e: /* RIGHT-TO-LEFT OVERRIDE */\n\t\tcase 0x206a: /* INHIBIT SYMMETRIC SWAPPING */\n\t\tcase 0x206b: /* ACTIVATE SYMMETRIC SWAPPING */\n\t\tcase 0x206c: /* INHIBIT ARABIC FORM SHAPING */\n\t\tcase 0x206d: /* ACTIVATE ARABIC FORM SHAPING */\n\t\tcase 0x206e: /* NATIONAL DIGIT SHAPES */\n\t\tcase 0x206f: /* NOMINAL DIGIT SHAPES */\n\t\tcase 0xfeff: /* ZERO WIDTH NO-BREAK SPACE */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* fold into lowercase -- this will only fold characters in\n\t\t * the ASCII range, which is perfectly fine, because the\n\t\t * git folder name can only be composed of ascii characters\n\t\t */\n\t\treturn git__tolower(codepoint);\n\t}\n\treturn 0; /* NULL byte -- end of string */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int32_t next_hfs_char(const char **in, size_t *len)\n{\n\twhile (*len) {\n\t\tint32_t codepoint;\n\t\tint cp_len = git__utf8_iterate((const uint8_t *)(*in), (int)(*len), &codepoint);\n\t\tif (cp_len < 0)\n\t\t\treturn -1;\n\n\t\t(*in) += cp_len;\n\t\t(*len) -= cp_len;\n\n\t\t/* these code points are ignored completely */\n\t\tswitch (codepoint) {\n\t\tcase 0x200c: /* ZERO WIDTH NON-JOINER */\n\t\tcase 0x200d: /* ZERO WIDTH JOINER */\n\t\tcase 0x200e: /* LEFT-TO-RIGHT MARK */\n\t\tcase 0x200f: /* RIGHT-TO-LEFT MARK */\n\t\tcase 0x202a: /* LEFT-TO-RIGHT EMBEDDING */\n\t\tcase 0x202b: /* RIGHT-TO-LEFT EMBEDDING */\n\t\tcase 0x202c: /* POP DIRECTIONAL FORMATTING */\n\t\tcase 0x202d: /* LEFT-TO-RIGHT OVERRIDE */\n\t\tcase 0x202e: /* RIGHT-TO-LEFT OVERRIDE */\n\t\tcase 0x206a: /* INHIBIT SYMMETRIC SWAPPING */\n\t\tcase 0x206b: /* ACTIVATE SYMMETRIC SWAPPING */\n\t\tcase 0x206c: /* INHIBIT ARABIC FORM SHAPING */\n\t\tcase 0x206d: /* ACTIVATE ARABIC FORM SHAPING */\n\t\tcase 0x206e: /* NATIONAL DIGIT SHAPES */\n\t\tcase 0x206f: /* NOMINAL DIGIT SHAPES */\n\t\tcase 0xfeff: /* ZERO WIDTH NO-BREAK SPACE */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* fold into lowercase -- this will only fold characters in\n\t\t * the ASCII range, which is perfectly fine, because the\n\t\t * git folder name can only be composed of ascii characters\n\t\t */\n\t\treturn git__tolower(codepoint);\n\t}\n\treturn 0; /* NULL byte -- end of string */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool verify_dotgit_hfs(const char *path, size_t len)\n{\n\tif (next_hfs_char(&path, &len) != '.' ||\n\t\tnext_hfs_char(&path, &len) != 'g' ||\n\t\tnext_hfs_char(&path, &len) != 'i' ||\n\t\tnext_hfs_char(&path, &len) != 't' ||\n\t\tnext_hfs_char(&path, &len) != 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "next_hfs_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1464-1503",
    "snippet": "static int32_t next_hfs_char(const char **in, size_t *len)\n{\n\twhile (*len) {\n\t\tint32_t codepoint;\n\t\tint cp_len = git__utf8_iterate((const uint8_t *)(*in), (int)(*len), &codepoint);\n\t\tif (cp_len < 0)\n\t\t\treturn -1;\n\n\t\t(*in) += cp_len;\n\t\t(*len) -= cp_len;\n\n\t\t/* these code points are ignored completely */\n\t\tswitch (codepoint) {\n\t\tcase 0x200c: /* ZERO WIDTH NON-JOINER */\n\t\tcase 0x200d: /* ZERO WIDTH JOINER */\n\t\tcase 0x200e: /* LEFT-TO-RIGHT MARK */\n\t\tcase 0x200f: /* RIGHT-TO-LEFT MARK */\n\t\tcase 0x202a: /* LEFT-TO-RIGHT EMBEDDING */\n\t\tcase 0x202b: /* RIGHT-TO-LEFT EMBEDDING */\n\t\tcase 0x202c: /* POP DIRECTIONAL FORMATTING */\n\t\tcase 0x202d: /* LEFT-TO-RIGHT OVERRIDE */\n\t\tcase 0x202e: /* RIGHT-TO-LEFT OVERRIDE */\n\t\tcase 0x206a: /* INHIBIT SYMMETRIC SWAPPING */\n\t\tcase 0x206b: /* ACTIVATE SYMMETRIC SWAPPING */\n\t\tcase 0x206c: /* INHIBIT ARABIC FORM SHAPING */\n\t\tcase 0x206d: /* ACTIVATE ARABIC FORM SHAPING */\n\t\tcase 0x206e: /* NATIONAL DIGIT SHAPES */\n\t\tcase 0x206f: /* NOMINAL DIGIT SHAPES */\n\t\tcase 0xfeff: /* ZERO WIDTH NO-BREAK SPACE */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* fold into lowercase -- this will only fold characters in\n\t\t * the ASCII range, which is perfectly fine, because the\n\t\t * git folder name can only be composed of ascii characters\n\t\t */\n\t\treturn git__tolower(codepoint);\n\t}\n\treturn 0; /* NULL byte -- end of string */\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__tolower",
          "args": [
            "codepoint"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "git__tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "285-288",
          "snippet": "GIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__utf8_iterate",
          "args": [
            "(const uint8_t *)(*in)",
            "(int)(*len)",
            "&codepoint"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf8_iterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "730-766",
          "snippet": "int git__utf8_iterate(const uint8_t *str, int str_len, int32_t *dst)\n{\n\tint length;\n\tint32_t uc = -1;\n\n\t*dst = -1;\n\tlength = git__utf8_charlen(str, str_len);\n\tif (length < 0)\n\t\treturn -1;\n\n\tswitch (length) {\n\t\tcase 1:\n\t\t\tuc = str[0];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tuc = ((str[0] & 0x1F) <<  6) + (str[1] & 0x3F);\n\t\t\tif (uc < 0x80) uc = -1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tuc = ((str[0] & 0x0F) << 12) + ((str[1] & 0x3F) <<  6)\n\t\t\t\t+ (str[2] & 0x3F);\n\t\t\tif (uc < 0x800 || (uc >= 0xD800 && uc < 0xE000) ||\n\t\t\t\t\t(uc >= 0xFDD0 && uc < 0xFDF0)) uc = -1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tuc = ((str[0] & 0x07) << 18) + ((str[1] & 0x3F) << 12)\n\t\t\t\t+ ((str[2] & 0x3F) <<  6) + (str[3] & 0x3F);\n\t\t\tif (uc < 0x10000 || uc >= 0x110000) uc = -1;\n\t\t\tbreak;\n\t}\n\n\tif (uc < 0 || ((uc & 0xFFFF) >= 0xFFFE))\n\t\treturn -1;\n\n\t*dst = uc;\n\treturn length;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__utf8_iterate(const uint8_t *str, int str_len, int32_t *dst)\n{\n\tint length;\n\tint32_t uc = -1;\n\n\t*dst = -1;\n\tlength = git__utf8_charlen(str, str_len);\n\tif (length < 0)\n\t\treturn -1;\n\n\tswitch (length) {\n\t\tcase 1:\n\t\t\tuc = str[0];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tuc = ((str[0] & 0x1F) <<  6) + (str[1] & 0x3F);\n\t\t\tif (uc < 0x80) uc = -1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tuc = ((str[0] & 0x0F) << 12) + ((str[1] & 0x3F) <<  6)\n\t\t\t\t+ (str[2] & 0x3F);\n\t\t\tif (uc < 0x800 || (uc >= 0xD800 && uc < 0xE000) ||\n\t\t\t\t\t(uc >= 0xFDD0 && uc < 0xFDF0)) uc = -1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tuc = ((str[0] & 0x07) << 18) + ((str[1] & 0x3F) << 12)\n\t\t\t\t+ ((str[2] & 0x3F) <<  6) + (str[3] & 0x3F);\n\t\t\tif (uc < 0x10000 || uc >= 0x110000) uc = -1;\n\t\t\tbreak;\n\t}\n\n\tif (uc < 0 || ((uc & 0xFFFF) >= 0xFFFE))\n\t\treturn -1;\n\n\t*dst = uc;\n\treturn length;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int32_t next_hfs_char(const char **in, size_t *len)\n{\n\twhile (*len) {\n\t\tint32_t codepoint;\n\t\tint cp_len = git__utf8_iterate((const uint8_t *)(*in), (int)(*len), &codepoint);\n\t\tif (cp_len < 0)\n\t\t\treturn -1;\n\n\t\t(*in) += cp_len;\n\t\t(*len) -= cp_len;\n\n\t\t/* these code points are ignored completely */\n\t\tswitch (codepoint) {\n\t\tcase 0x200c: /* ZERO WIDTH NON-JOINER */\n\t\tcase 0x200d: /* ZERO WIDTH JOINER */\n\t\tcase 0x200e: /* LEFT-TO-RIGHT MARK */\n\t\tcase 0x200f: /* RIGHT-TO-LEFT MARK */\n\t\tcase 0x202a: /* LEFT-TO-RIGHT EMBEDDING */\n\t\tcase 0x202b: /* RIGHT-TO-LEFT EMBEDDING */\n\t\tcase 0x202c: /* POP DIRECTIONAL FORMATTING */\n\t\tcase 0x202d: /* LEFT-TO-RIGHT OVERRIDE */\n\t\tcase 0x202e: /* RIGHT-TO-LEFT OVERRIDE */\n\t\tcase 0x206a: /* INHIBIT SYMMETRIC SWAPPING */\n\t\tcase 0x206b: /* ACTIVATE SYMMETRIC SWAPPING */\n\t\tcase 0x206c: /* INHIBIT ARABIC FORM SHAPING */\n\t\tcase 0x206d: /* ACTIVATE ARABIC FORM SHAPING */\n\t\tcase 0x206e: /* NATIONAL DIGIT SHAPES */\n\t\tcase 0x206f: /* NOMINAL DIGIT SHAPES */\n\t\tcase 0xfeff: /* ZERO WIDTH NO-BREAK SPACE */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* fold into lowercase -- this will only fold characters in\n\t\t * the ASCII range, which is perfectly fine, because the\n\t\t * git folder name can only be composed of ascii characters\n\t\t */\n\t\treturn git__tolower(codepoint);\n\t}\n\treturn 0; /* NULL byte -- end of string */\n}"
  },
  {
    "function_name": "verify_dospath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1445-1462",
    "snippet": "GIT_INLINE(bool) verify_dospath(\n\tconst char *component,\n\tsize_t len,\n\tconst char dospath[3],\n\tbool trailing_num)\n{\n\tsize_t last = trailing_num ? 4 : 3;\n\n\tif (len < last || git__strncasecmp(component, dospath, 3) != 0)\n\t\treturn true;\n\n\tif (trailing_num && (component[3] < '1' || component[3] > '9'))\n\t\treturn true;\n\n\treturn (len > last &&\n\t\tcomponent[last] != '.' &&\n\t\tcomponent[last] != ':');\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strncasecmp",
          "args": [
            "component",
            "dospath",
            "3"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncasecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "214-225",
          "snippet": "int git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) verify_dospath(\n\tconst char *component,\n\tsize_t len,\n\tconst char dospath[3],\n\tbool trailing_num)\n{\n\tsize_t last = trailing_num ? 4 : 3;\n\n\tif (len < last || git__strncasecmp(component, dospath, 3) != 0)\n\t\treturn true;\n\n\tif (trailing_num && (component[3] < '1' || component[3] > '9'))\n\t\treturn true;\n\n\treturn (len > last &&\n\t\tcomponent[last] != '.' &&\n\t\tcomponent[last] != ':');\n}"
  },
  {
    "function_name": "git_path_from_url_or_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1434-1440",
    "snippet": "int git_path_from_url_or_path(git_buf *local_path_out, const char *url_or_path)\n{\n\tif (git_path_is_local_file_url(url_or_path))\n\t\treturn git_path_fromurl(local_path_out, url_or_path);\n\telse\n\t\treturn git_buf_sets(local_path_out, url_or_path);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "local_path_out",
            "url_or_path"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_fromurl",
          "args": [
            "local_path_out",
            "url_or_path"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_fromurl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "421-437",
          "snippet": "int git_path_fromurl(git_buf *local_path_out, const char *file_url)\n{\n\tint offset;\n\n\tassert(local_path_out && file_url);\n\n\tif ((offset = local_file_url_prefixlen(file_url)) < 0 ||\n\t\tfile_url[offset] == '\\0' || file_url[offset] == '/')\n\t\treturn error_invalid_local_file_uri(file_url);\n\n#ifndef GIT_WIN32\n\toffset--;\t/* A *nix absolute path starts with a forward slash */\n#endif\n\n\tgit_buf_clear(local_path_out);\n\treturn git__percent_decode(local_path_out, file_url + offset);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_fromurl(git_buf *local_path_out, const char *file_url)\n{\n\tint offset;\n\n\tassert(local_path_out && file_url);\n\n\tif ((offset = local_file_url_prefixlen(file_url)) < 0 ||\n\t\tfile_url[offset] == '\\0' || file_url[offset] == '/')\n\t\treturn error_invalid_local_file_uri(file_url);\n\n#ifndef GIT_WIN32\n\toffset--;\t/* A *nix absolute path starts with a forward slash */\n#endif\n\n\tgit_buf_clear(local_path_out);\n\treturn git__percent_decode(local_path_out, file_url + offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_is_local_file_url",
          "args": [
            "url_or_path"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_is_local_file_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "416-419",
          "snippet": "bool git_path_is_local_file_url(const char *file_url)\n{\n\treturn (local_file_url_prefixlen(file_url) > 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_is_local_file_url(const char *file_url)\n{\n\treturn (local_file_url_prefixlen(file_url) > 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_from_url_or_path(git_buf *local_path_out, const char *url_or_path)\n{\n\tif (git_path_is_local_file_url(url_or_path))\n\t\treturn git_path_fromurl(local_path_out, url_or_path);\n\telse\n\t\treturn git_buf_sets(local_path_out, url_or_path);\n}"
  },
  {
    "function_name": "git_path_dirload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1397-1432",
    "snippet": "int git_path_dirload(\n\tgit_vector *contents,\n\tconst char *path,\n\tsize_t prefix_len,\n\tuint32_t flags)\n{\n\tgit_path_diriter iter = GIT_PATH_DIRITER_INIT;\n\tconst char *name;\n\tsize_t name_len;\n\tchar *dup;\n\tint error;\n\n\tassert(contents && path);\n\n\tif ((error = git_path_diriter_init(&iter, path, flags)) < 0)\n\t\treturn error;\n\n\twhile ((error = git_path_diriter_next(&iter)) == 0) {\n\t\tif ((error = git_path_diriter_fullpath(&name, &name_len, &iter)) < 0)\n\t\t\tbreak;\n\n\t\tassert(name_len > prefix_len);\n\n\t\tdup = git__strndup(name + prefix_len, name_len - prefix_len);\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tif ((error = git_vector_insert(contents, dup)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_path_diriter_free(&iter);\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_diriter_free",
          "args": [
            "&iter"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_diriter_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1378-1393",
          "snippet": "void git_path_diriter_free(git_path_diriter *diriter)\n{\n\tif (diriter == NULL)\n\t\treturn;\n\n\tif (diriter->dir) {\n\t\tclosedir(diriter->dir);\n\t\tdiriter->dir = NULL;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&diriter->ic);\n#endif\n\n\tgit_buf_free(&diriter->path);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_diriter_free(git_path_diriter *diriter)\n{\n\tif (diriter == NULL)\n\t\treturn;\n\n\tif (diriter->dir) {\n\t\tclosedir(diriter->dir);\n\t\tdiriter->dir = NULL;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&diriter->ic);\n#endif\n\n\tgit_buf_free(&diriter->path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "contents",
            "dup"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "dup"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "name + prefix_len",
            "name_len - prefix_len"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name_len > prefix_len"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_diriter_fullpath",
          "args": [
            "&name",
            "&name_len",
            "&iter"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_diriter_fullpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1359-1369",
          "snippet": "int git_path_diriter_fullpath(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\t*out = diriter->path.ptr;\n\t*out_len = diriter->path.size;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_fullpath(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\t*out = diriter->path.ptr;\n\t*out_len = diriter->path.size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_diriter_next",
          "args": [
            "&iter"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_diriter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1299-1343",
          "snippet": "int git_path_diriter_next(git_path_diriter *diriter)\n{\n\tstruct dirent *de;\n\tconst char *filename;\n\tsize_t filename_len;\n\tbool skip_dot = !(diriter->flags & GIT_PATH_DIR_INCLUDE_DOT_AND_DOTDOT);\n\tint error = 0;\n\n\tassert(diriter);\n\n\terrno = 0;\n\n\tdo {\n\t\tif ((de = readdir(diriter->dir)) == NULL) {\n\t\t\tif (!errno)\n\t\t\t\treturn GIT_ITEROVER;\n\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Could not read directory '%s'\", diriter->path);\n\t\t\treturn -1;\n\t\t}\n\t} while (skip_dot && git_path_is_dot_or_dotdot(de->d_name));\n\n\tfilename = de->d_name;\n\tfilename_len = strlen(filename);\n\n#ifdef GIT_USE_ICONV\n\tif ((diriter->flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0 &&\n\t\t(error = git_path_iconv(&diriter->ic, &filename, &filename_len)) < 0)\n\t\treturn error;\n#endif\n\n\tgit_buf_truncate(&diriter->path, diriter->parent_len);\n\n\tif (diriter->parent_len > 0 &&\n\t\tdiriter->path.ptr[diriter->parent_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path, '/');\n\n\tgit_buf_put(&diriter->path, filename, filename_len);\n\n\tif (git_buf_oom(&diriter->path))\n\t\treturn -1;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_next(git_path_diriter *diriter)\n{\n\tstruct dirent *de;\n\tconst char *filename;\n\tsize_t filename_len;\n\tbool skip_dot = !(diriter->flags & GIT_PATH_DIR_INCLUDE_DOT_AND_DOTDOT);\n\tint error = 0;\n\n\tassert(diriter);\n\n\terrno = 0;\n\n\tdo {\n\t\tif ((de = readdir(diriter->dir)) == NULL) {\n\t\t\tif (!errno)\n\t\t\t\treturn GIT_ITEROVER;\n\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Could not read directory '%s'\", diriter->path);\n\t\t\treturn -1;\n\t\t}\n\t} while (skip_dot && git_path_is_dot_or_dotdot(de->d_name));\n\n\tfilename = de->d_name;\n\tfilename_len = strlen(filename);\n\n#ifdef GIT_USE_ICONV\n\tif ((diriter->flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0 &&\n\t\t(error = git_path_iconv(&diriter->ic, &filename, &filename_len)) < 0)\n\t\treturn error;\n#endif\n\n\tgit_buf_truncate(&diriter->path, diriter->parent_len);\n\n\tif (diriter->parent_len > 0 &&\n\t\tdiriter->path.ptr[diriter->parent_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path, '/');\n\n\tgit_buf_put(&diriter->path, filename, filename_len);\n\n\tif (git_buf_oom(&diriter->path))\n\t\treturn -1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_diriter_init",
          "args": [
            "&iter",
            "path",
            "flags"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_diriter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1262-1297",
          "snippet": "int git_path_diriter_init(\n\tgit_path_diriter *diriter,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tassert(diriter && path);\n\n\tmemset(diriter, 0, sizeof(git_path_diriter));\n\n\tif (git_buf_puts(&diriter->path, path) < 0)\n\t\treturn -1;\n\n\tgit_path_trim_slashes(&diriter->path);\n\n\tif (diriter->path.size == 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((diriter->dir = opendir(diriter->path.ptr)) == NULL) {\n\t\tgit_buf_free(&diriter->path);\n\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&diriter->ic);\n#endif\n\n\tdiriter->parent_len = diriter->path.size;\n\tdiriter->flags = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_init(\n\tgit_path_diriter *diriter,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tassert(diriter && path);\n\n\tmemset(diriter, 0, sizeof(git_path_diriter));\n\n\tif (git_buf_puts(&diriter->path, path) < 0)\n\t\treturn -1;\n\n\tgit_path_trim_slashes(&diriter->path);\n\n\tif (diriter->path.size == 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((diriter->dir = opendir(diriter->path.ptr)) == NULL) {\n\t\tgit_buf_free(&diriter->path);\n\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&diriter->ic);\n#endif\n\n\tdiriter->parent_len = diriter->path.size;\n\tdiriter->flags = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "contents && path"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirload(\n\tgit_vector *contents,\n\tconst char *path,\n\tsize_t prefix_len,\n\tuint32_t flags)\n{\n\tgit_path_diriter iter = GIT_PATH_DIRITER_INIT;\n\tconst char *name;\n\tsize_t name_len;\n\tchar *dup;\n\tint error;\n\n\tassert(contents && path);\n\n\tif ((error = git_path_diriter_init(&iter, path, flags)) < 0)\n\t\treturn error;\n\n\twhile ((error = git_path_diriter_next(&iter)) == 0) {\n\t\tif ((error = git_path_diriter_fullpath(&name, &name_len, &iter)) < 0)\n\t\t\tbreak;\n\n\t\tassert(name_len > prefix_len);\n\n\t\tdup = git__strndup(name + prefix_len, name_len - prefix_len);\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tif ((error = git_vector_insert(contents, dup)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_path_diriter_free(&iter);\n\treturn error;\n}"
  },
  {
    "function_name": "git_path_diriter_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1378-1393",
    "snippet": "void git_path_diriter_free(git_path_diriter *diriter)\n{\n\tif (diriter == NULL)\n\t\treturn;\n\n\tif (diriter->dir) {\n\t\tclosedir(diriter->dir);\n\t\tdiriter->dir = NULL;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&diriter->ic);\n#endif\n\n\tgit_buf_free(&diriter->path);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&diriter->path"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_iconv_clear",
          "args": [
            "&diriter->ic"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_iconv_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "894-901",
          "snippet": "void git_path_iconv_clear(git_path_iconv_t *ic)\n{\n\tif (ic) {\n\t\tif (ic->map != (iconv_t)-1)\n\t\t\ticonv_close(ic->map);\n\t\tgit_buf_free(&ic->buf);\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_iconv_clear(git_path_iconv_t *ic)\n{\n\tif (ic) {\n\t\tif (ic->map != (iconv_t)-1)\n\t\t\ticonv_close(ic->map);\n\t\tgit_buf_free(&ic->buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "diriter->dir"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "git__closedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
          "lines": "106-118",
          "snippet": "int git__closedir(git__DIR *d)\n{\n\tif (!d)\n\t\treturn 0;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t}\n\n\tgit__free(d);\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n\nint git__closedir(git__DIR *d)\n{\n\tif (!d)\n\t\treturn 0;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t}\n\n\tgit__free(d);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_diriter_free(git_path_diriter *diriter)\n{\n\tif (diriter == NULL)\n\t\treturn;\n\n\tif (diriter->dir) {\n\t\tclosedir(diriter->dir);\n\t\tdiriter->dir = NULL;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&diriter->ic);\n#endif\n\n\tgit_buf_free(&diriter->path);\n}"
  },
  {
    "function_name": "git_path_diriter_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1371-1376",
    "snippet": "int git_path_diriter_stat(struct stat *out, git_path_diriter *diriter)\n{\n\tassert(out && diriter);\n\n\treturn git_path_lstat(diriter->path.ptr, out);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_lstat",
          "args": [
            "diriter->path.ptr",
            "out"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "634-640",
          "snippet": "int git_path_lstat(const char *path, struct stat *st)\n{\n\tif (p_lstat(path, st) == 0)\n\t\treturn 0;\n\n\treturn git_path_set_error(errno, path, \"stat\");\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_lstat(const char *path, struct stat *st)\n{\n\tif (p_lstat(path, st) == 0)\n\t\treturn 0;\n\n\treturn git_path_set_error(errno, path, \"stat\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && diriter"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_stat(struct stat *out, git_path_diriter *diriter)\n{\n\tassert(out && diriter);\n\n\treturn git_path_lstat(diriter->path.ptr, out);\n}"
  },
  {
    "function_name": "git_path_diriter_fullpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1359-1369",
    "snippet": "int git_path_diriter_fullpath(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\t*out = diriter->path.ptr;\n\t*out_len = diriter->path.size;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && out_len && diriter"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_fullpath(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\t*out = diriter->path.ptr;\n\t*out_len = diriter->path.size;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_diriter_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1345-1357",
    "snippet": "int git_path_diriter_filename(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\tassert(diriter->path.size > diriter->parent_len);\n\n\t*out = &diriter->path.ptr[diriter->parent_len+1];\n\t*out_len = diriter->path.size - diriter->parent_len - 1;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diriter->path.size > diriter->parent_len"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && out_len && diriter"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_filename(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\tassert(diriter->path.size > diriter->parent_len);\n\n\t*out = &diriter->path.ptr[diriter->parent_len+1];\n\t*out_len = diriter->path.size - diriter->parent_len - 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_diriter_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1299-1343",
    "snippet": "int git_path_diriter_next(git_path_diriter *diriter)\n{\n\tstruct dirent *de;\n\tconst char *filename;\n\tsize_t filename_len;\n\tbool skip_dot = !(diriter->flags & GIT_PATH_DIR_INCLUDE_DOT_AND_DOTDOT);\n\tint error = 0;\n\n\tassert(diriter);\n\n\terrno = 0;\n\n\tdo {\n\t\tif ((de = readdir(diriter->dir)) == NULL) {\n\t\t\tif (!errno)\n\t\t\t\treturn GIT_ITEROVER;\n\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Could not read directory '%s'\", diriter->path);\n\t\t\treturn -1;\n\t\t}\n\t} while (skip_dot && git_path_is_dot_or_dotdot(de->d_name));\n\n\tfilename = de->d_name;\n\tfilename_len = strlen(filename);\n\n#ifdef GIT_USE_ICONV\n\tif ((diriter->flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0 &&\n\t\t(error = git_path_iconv(&diriter->ic, &filename, &filename_len)) < 0)\n\t\treturn error;\n#endif\n\n\tgit_buf_truncate(&diriter->path, diriter->parent_len);\n\n\tif (diriter->parent_len > 0 &&\n\t\tdiriter->path.ptr[diriter->parent_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path, '/');\n\n\tgit_buf_put(&diriter->path, filename, filename_len);\n\n\tif (git_buf_oom(&diriter->path))\n\t\treturn -1;\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&diriter->path"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&diriter->path",
            "filename",
            "filename_len"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "&diriter->path",
            "'/'"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "&diriter->path",
            "diriter->parent_len"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_iconv",
          "args": [
            "&diriter->ic",
            "&filename",
            "&filename_len"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_iconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "903-955",
          "snippet": "int git_path_iconv(git_path_iconv_t *ic, const char **in, size_t *inlen)\n{\n\tchar *nfd = (char*)*in, *nfc;\n\tsize_t nfdlen = *inlen, nfclen, wantlen = nfdlen, alloclen, rv;\n\tint retry = 1;\n\n\tif (!ic || ic->map == (iconv_t)-1 ||\n\t\t!git_path_has_non_ascii(*in, *inlen))\n\t\treturn 0;\n\n\tgit_buf_clear(&ic->buf);\n\n\twhile (1) {\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, wantlen, 1);\n\t\tif (git_buf_grow(&ic->buf, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tnfc    = ic->buf.ptr   + ic->buf.size;\n\t\tnfclen = ic->buf.asize - ic->buf.size;\n\n\t\trv = iconv(ic->map, &nfd, &nfdlen, &nfc, &nfclen);\n\n\t\tic->buf.size = (nfc - ic->buf.ptr);\n\n\t\tif (rv != (size_t)-1)\n\t\t\tbreak;\n\n\t\t/* if we cannot convert the data (probably because iconv thinks\n\t\t * it is not valid UTF-8 source data), then use original data\n\t\t */\n\t\tif (errno != E2BIG)\n\t\t\treturn 0;\n\n\t\t/* make space for 2x the remaining data to be converted\n\t\t * (with per retry overhead to avoid infinite loops)\n\t\t */\n\t\twantlen = ic->buf.size + max(nfclen, nfdlen) * 2 + (size_t)(retry * 4);\n\n\t\tif (retry++ > 4)\n\t\t\tgoto fail;\n\t}\n\n\tic->buf.ptr[ic->buf.size] = '\\0';\n\n\t*in    = ic->buf.ptr;\n\t*inlen = ic->buf.size;\n\n\treturn 0;\n\nfail:\n\tgiterr_set(GITERR_OS, \"Unable to convert unicode path data\");\n\treturn -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_iconv(git_path_iconv_t *ic, const char **in, size_t *inlen)\n{\n\tchar *nfd = (char*)*in, *nfc;\n\tsize_t nfdlen = *inlen, nfclen, wantlen = nfdlen, alloclen, rv;\n\tint retry = 1;\n\n\tif (!ic || ic->map == (iconv_t)-1 ||\n\t\t!git_path_has_non_ascii(*in, *inlen))\n\t\treturn 0;\n\n\tgit_buf_clear(&ic->buf);\n\n\twhile (1) {\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, wantlen, 1);\n\t\tif (git_buf_grow(&ic->buf, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tnfc    = ic->buf.ptr   + ic->buf.size;\n\t\tnfclen = ic->buf.asize - ic->buf.size;\n\n\t\trv = iconv(ic->map, &nfd, &nfdlen, &nfc, &nfclen);\n\n\t\tic->buf.size = (nfc - ic->buf.ptr);\n\n\t\tif (rv != (size_t)-1)\n\t\t\tbreak;\n\n\t\t/* if we cannot convert the data (probably because iconv thinks\n\t\t * it is not valid UTF-8 source data), then use original data\n\t\t */\n\t\tif (errno != E2BIG)\n\t\t\treturn 0;\n\n\t\t/* make space for 2x the remaining data to be converted\n\t\t * (with per retry overhead to avoid infinite loops)\n\t\t */\n\t\twantlen = ic->buf.size + max(nfclen, nfdlen) * 2 + (size_t)(retry * 4);\n\n\t\tif (retry++ > 4)\n\t\t\tgoto fail;\n\t}\n\n\tic->buf.ptr[ic->buf.size] = '\\0';\n\n\t*in    = ic->buf.ptr;\n\t*inlen = ic->buf.size;\n\n\treturn 0;\n\nfail:\n\tgiterr_set(GITERR_OS, \"Unable to convert unicode path data\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_is_dot_or_dotdot",
          "args": [
            "de->d_name"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_is_dot_or_dotdotW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "100-105",
          "snippet": "GIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not read directory '%s'\"",
            "diriter->path"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "diriter->dir"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "git__readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
          "lines": "74-80",
          "snippet": "struct git__dirent *git__readdir(git__DIR *d)\n{\n\tstruct git__dirent *result;\n\tif (git__readdir_ext(d, &d->entry, &result, NULL) < 0)\n\t\treturn NULL;\n\treturn result;\n}",
          "includes": [
            "#include \"posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n\nstruct git__dirent *git__readdir(git__DIR *d)\n{\n\tstruct git__dirent *result;\n\tif (git__readdir_ext(d, &d->entry, &result, NULL) < 0)\n\t\treturn NULL;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diriter"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_next(git_path_diriter *diriter)\n{\n\tstruct dirent *de;\n\tconst char *filename;\n\tsize_t filename_len;\n\tbool skip_dot = !(diriter->flags & GIT_PATH_DIR_INCLUDE_DOT_AND_DOTDOT);\n\tint error = 0;\n\n\tassert(diriter);\n\n\terrno = 0;\n\n\tdo {\n\t\tif ((de = readdir(diriter->dir)) == NULL) {\n\t\t\tif (!errno)\n\t\t\t\treturn GIT_ITEROVER;\n\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Could not read directory '%s'\", diriter->path);\n\t\t\treturn -1;\n\t\t}\n\t} while (skip_dot && git_path_is_dot_or_dotdot(de->d_name));\n\n\tfilename = de->d_name;\n\tfilename_len = strlen(filename);\n\n#ifdef GIT_USE_ICONV\n\tif ((diriter->flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0 &&\n\t\t(error = git_path_iconv(&diriter->ic, &filename, &filename_len)) < 0)\n\t\treturn error;\n#endif\n\n\tgit_buf_truncate(&diriter->path, diriter->parent_len);\n\n\tif (diriter->parent_len > 0 &&\n\t\tdiriter->path.ptr[diriter->parent_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path, '/');\n\n\tgit_buf_put(&diriter->path, filename, filename_len);\n\n\tif (git_buf_oom(&diriter->path))\n\t\treturn -1;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_path_diriter_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1262-1297",
    "snippet": "int git_path_diriter_init(\n\tgit_path_diriter *diriter,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tassert(diriter && path);\n\n\tmemset(diriter, 0, sizeof(git_path_diriter));\n\n\tif (git_buf_puts(&diriter->path, path) < 0)\n\t\treturn -1;\n\n\tgit_path_trim_slashes(&diriter->path);\n\n\tif (diriter->path.size == 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((diriter->dir = opendir(diriter->path.ptr)) == NULL) {\n\t\tgit_buf_free(&diriter->path);\n\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&diriter->ic);\n#endif\n\n\tdiriter->parent_len = diriter->path.size;\n\tdiriter->flags = flags;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_iconv_init_precompose",
          "args": [
            "&diriter->ic"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_iconv_init_precompose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "887-892",
          "snippet": "int git_path_iconv_init_precompose(git_path_iconv_t *ic)\n{\n\tgit_buf_init(&ic->buf, 0);\n\tic->map = iconv_open(GIT_PATH_REPO_ENCODING, GIT_PATH_NATIVE_ENCODING);\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_iconv_init_precompose(git_path_iconv_t *ic)\n{\n\tgit_buf_init(&ic->buf, 0);\n\tic->map = iconv_open(GIT_PATH_REPO_ENCODING, GIT_PATH_NATIVE_ENCODING);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to open directory '%s'\"",
            "path"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&diriter->path"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "diriter->path.ptr"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "git__opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
          "lines": "10-38",
          "snippet": "git__DIR *git__opendir(const char *dir)\n{\n\tgit_win32_path filter_w;\n\tgit__DIR *new = NULL;\n\tsize_t dirlen, alloclen;\n\n\tif (!dir || !git_win32__findfirstfile_filter(filter_w, dir))\n\t\treturn NULL;\n\n\tdirlen = strlen(dir);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, sizeof(*new), dirlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1) ||\n\t\t!(new = git__calloc(1, alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(new->dir, dir, dirlen);\n\n\tnew->h = FindFirstFileW(filter_w, &new->f);\n\n\tif (new->h == INVALID_HANDLE_VALUE) {\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", dir);\n\t\tgit__free(new);\n\t\treturn NULL;\n\t}\n\n\tnew->first = 1;\n\treturn new;\n}",
          "includes": [
            "#include \"posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n\ngit__DIR *git__opendir(const char *dir)\n{\n\tgit_win32_path filter_w;\n\tgit__DIR *new = NULL;\n\tsize_t dirlen, alloclen;\n\n\tif (!dir || !git_win32__findfirstfile_filter(filter_w, dir))\n\t\treturn NULL;\n\n\tdirlen = strlen(dir);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, sizeof(*new), dirlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1) ||\n\t\t!(new = git__calloc(1, alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(new->dir, dir, dirlen);\n\n\tnew->h = FindFirstFileW(filter_w, &new->f);\n\n\tif (new->h == INVALID_HANDLE_VALUE) {\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", dir);\n\t\tgit__free(new);\n\t\treturn NULL;\n\t}\n\n\tnew->first = 1;\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_trim_slashes",
          "args": [
            "&diriter->path"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_trim_slashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "265-277",
          "snippet": "void git_path_trim_slashes(git_buf *path)\n{\n\tint ceiling = git_path_root(path->ptr) + 1;\n\tassert(ceiling >= 0);\n\n\twhile (path->size > (size_t)ceiling) {\n\t\tif (path->ptr[path->size-1] != '/')\n\t\t\tbreak;\n\n\t\tpath->ptr[path->size-1] = '\\0';\n\t\tpath->size--;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_trim_slashes(git_buf *path)\n{\n\tint ceiling = git_path_root(path->ptr) + 1;\n\tassert(ceiling >= 0);\n\n\twhile (path->size > (size_t)ceiling) {\n\t\tif (path->ptr[path->size-1] != '/')\n\t\t\tbreak;\n\n\t\tpath->ptr[path->size-1] = '\\0';\n\t\tpath->size--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&diriter->path",
            "path"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "diriter",
            "0",
            "sizeof(git_path_diriter)"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diriter && path"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_init(\n\tgit_path_diriter *diriter,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tassert(diriter && path);\n\n\tmemset(diriter, 0, sizeof(git_path_diriter));\n\n\tif (git_buf_puts(&diriter->path, path) < 0)\n\t\treturn -1;\n\n\tgit_path_trim_slashes(&diriter->path);\n\n\tif (diriter->path.size == 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((diriter->dir = opendir(diriter->path.ptr)) == NULL) {\n\t\tgit_buf_free(&diriter->path);\n\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&diriter->ic);\n#endif\n\n\tdiriter->parent_len = diriter->path.size;\n\tdiriter->flags = flags;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_diriter_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1247-1258",
    "snippet": "void git_path_diriter_free(git_path_diriter *diriter)\n{\n\tif (diriter == NULL)\n\t\treturn;\n\n\tgit_buf_free(&diriter->path_utf8);\n\n\tif (diriter->handle != INVALID_HANDLE_VALUE) {\n\t\tFindClose(diriter->handle);\n\t\tdiriter->handle = INVALID_HANDLE_VALUE;\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FindClose",
          "args": [
            "diriter->handle"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&diriter->path_utf8"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_diriter_free(git_path_diriter *diriter)\n{\n\tif (diriter == NULL)\n\t\treturn;\n\n\tgit_buf_free(&diriter->path_utf8);\n\n\tif (diriter->handle != INVALID_HANDLE_VALUE) {\n\t\tFindClose(diriter->handle);\n\t\tdiriter->handle = INVALID_HANDLE_VALUE;\n\t}\n}"
  },
  {
    "function_name": "git_path_diriter_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1238-1245",
    "snippet": "int git_path_diriter_stat(struct stat *out, git_path_diriter *diriter)\n{\n\tassert(out && diriter);\n\n\treturn git_win32__file_attribute_to_stat(out,\n\t\t(WIN32_FILE_ATTRIBUTE_DATA *)&diriter->current,\n\t\tdiriter->path);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_win32__file_attribute_to_stat",
          "args": [
            "out",
            "(WIN32_FILE_ATTRIBUTE_DATA *)&diriter->current",
            "diriter->path"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__file_attribute_to_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.h",
          "lines": "155-184",
          "snippet": "GIT_INLINE(int) git_win32__file_attribute_to_stat(\n\tstruct stat *st,\n\tconst WIN32_FILE_ATTRIBUTE_DATA *attrdata,\n\tconst wchar_t *path)\n{\n\tgit_win32__stat_init(st,\n\t\tattrdata->dwFileAttributes,\n\t\tattrdata->nFileSizeHigh,\n\t\tattrdata->nFileSizeLow,\n\t\tattrdata->ftCreationTime,\n\t\tattrdata->ftLastAccessTime,\n\t\tattrdata->ftLastWriteTime);\n\n\tif (attrdata->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT && path) {\n\t\tgit_win32_path target;\n\n\t\tif (git_win32_path_readlink_w(target, path) >= 0) {\n\t\t\tst->st_mode = (st->st_mode & ~S_IFMT) | S_IFLNK;\n\n\t\t\t/* st_size gets the UTF-8 length of the target name, in bytes,\n\t\t\t * not counting the NULL terminator */\n\t\t\tif ((st->st_size = git__utf16_to_8(NULL, 0, target)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Could not convert reparse point name for '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"path_w32.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"path_w32.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n\nGIT_INLINE(int) git_win32__file_attribute_to_stat(\n\tstruct stat *st,\n\tconst WIN32_FILE_ATTRIBUTE_DATA *attrdata,\n\tconst wchar_t *path)\n{\n\tgit_win32__stat_init(st,\n\t\tattrdata->dwFileAttributes,\n\t\tattrdata->nFileSizeHigh,\n\t\tattrdata->nFileSizeLow,\n\t\tattrdata->ftCreationTime,\n\t\tattrdata->ftLastAccessTime,\n\t\tattrdata->ftLastWriteTime);\n\n\tif (attrdata->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT && path) {\n\t\tgit_win32_path target;\n\n\t\tif (git_win32_path_readlink_w(target, path) >= 0) {\n\t\t\tst->st_mode = (st->st_mode & ~S_IFMT) | S_IFLNK;\n\n\t\t\t/* st_size gets the UTF-8 length of the target name, in bytes,\n\t\t\t * not counting the NULL terminator */\n\t\t\tif ((st->st_size = git__utf16_to_8(NULL, 0, target)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Could not convert reparse point name for '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && diriter"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_stat(struct stat *out, git_path_diriter *diriter)\n{\n\tassert(out && diriter);\n\n\treturn git_win32__file_attribute_to_stat(out,\n\t\t(WIN32_FILE_ATTRIBUTE_DATA *)&diriter->current,\n\t\tdiriter->path);\n}"
  },
  {
    "function_name": "git_path_diriter_fullpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1226-1236",
    "snippet": "int git_path_diriter_fullpath(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\t*out = diriter->path_utf8.ptr;\n\t*out_len = diriter->path_utf8.size;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && out_len && diriter"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_fullpath(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\t*out = diriter->path_utf8.ptr;\n\t*out_len = diriter->path_utf8.size;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_diriter_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1212-1224",
    "snippet": "int git_path_diriter_filename(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\tassert(diriter->path_utf8.size > diriter->parent_utf8_len);\n\n\t*out = &diriter->path_utf8.ptr[diriter->parent_utf8_len+1];\n\t*out_len = diriter->path_utf8.size - diriter->parent_utf8_len - 1;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diriter->path_utf8.size > diriter->parent_utf8_len"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && out_len && diriter"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_filename(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\tassert(diriter->path_utf8.size > diriter->parent_utf8_len);\n\n\t*out = &diriter->path_utf8.ptr[diriter->parent_utf8_len+1];\n\t*out_len = diriter->path_utf8.size - diriter->parent_utf8_len - 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_diriter_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1192-1210",
    "snippet": "int git_path_diriter_next(git_path_diriter *diriter)\n{\n\tbool skip_dot = !(diriter->flags & GIT_PATH_DIR_INCLUDE_DOT_AND_DOTDOT);\n\n\tdo {\n\t\t/* Our first time through, we already have the data from\n\t\t * FindFirstFileW.  Use it, otherwise get the next file.\n\t\t */\n\t\tif (!diriter->needs_next)\n\t\t\tdiriter->needs_next = 1;\n\t\telse if (!FindNextFileW(diriter->handle, &diriter->current))\n\t\t\treturn GIT_ITEROVER;\n\t} while (skip_dot && git_path_is_dot_or_dotdotW(diriter->current.cFileName));\n\n\tif (diriter_update_paths(diriter) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diriter_update_paths",
          "args": [
            "diriter"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "diriter_update_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1156-1190",
          "snippet": "static int diriter_update_paths(git_path_diriter *diriter)\n{\n\tsize_t filename_len, path_len;\n\n\tfilename_len = wcslen(diriter->current.cFileName);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&path_len, diriter->parent_len, filename_len) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&path_len, path_len, 2))\n\t\treturn -1;\n\n\tif (path_len > GIT_WIN_PATH_UTF16) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"invalid path '%.*ls\\\\%ls' (path too long)\",\n\t\t\tdiriter->parent_len, diriter->path, diriter->current.cFileName);\n\t\treturn -1;\n\t}\n\n\tdiriter->path[diriter->parent_len] = L'\\\\';\n\tmemcpy(&diriter->path[diriter->parent_len+1],\n\t\tdiriter->current.cFileName, filename_len * sizeof(wchar_t));\n\tdiriter->path[path_len-1] = L'\\0';\n\n\tgit_buf_truncate(&diriter->path_utf8, diriter->parent_utf8_len);\n\n\tif (diriter->parent_utf8_len > 0 &&\n\t\tdiriter->path_utf8.ptr[diriter->parent_utf8_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path_utf8, '/');\n\n\tgit_buf_put_w(&diriter->path_utf8, diriter->current.cFileName, filename_len);\n\n\tif (git_buf_oom(&diriter->path_utf8))\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int diriter_update_paths(git_path_diriter *diriter)\n{\n\tsize_t filename_len, path_len;\n\n\tfilename_len = wcslen(diriter->current.cFileName);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&path_len, diriter->parent_len, filename_len) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&path_len, path_len, 2))\n\t\treturn -1;\n\n\tif (path_len > GIT_WIN_PATH_UTF16) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"invalid path '%.*ls\\\\%ls' (path too long)\",\n\t\t\tdiriter->parent_len, diriter->path, diriter->current.cFileName);\n\t\treturn -1;\n\t}\n\n\tdiriter->path[diriter->parent_len] = L'\\\\';\n\tmemcpy(&diriter->path[diriter->parent_len+1],\n\t\tdiriter->current.cFileName, filename_len * sizeof(wchar_t));\n\tdiriter->path[path_len-1] = L'\\0';\n\n\tgit_buf_truncate(&diriter->path_utf8, diriter->parent_utf8_len);\n\n\tif (diriter->parent_utf8_len > 0 &&\n\t\tdiriter->path_utf8.ptr[diriter->parent_utf8_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path_utf8, '/');\n\n\tgit_buf_put_w(&diriter->path_utf8, diriter->current.cFileName, filename_len);\n\n\tif (git_buf_oom(&diriter->path_utf8))\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_is_dot_or_dotdotW",
          "args": [
            "diriter->current.cFileName"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_is_dot_or_dotdotW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "100-105",
          "snippet": "GIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindNextFileW",
          "args": [
            "diriter->handle",
            "&diriter->current"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_next(git_path_diriter *diriter)\n{\n\tbool skip_dot = !(diriter->flags & GIT_PATH_DIR_INCLUDE_DOT_AND_DOTDOT);\n\n\tdo {\n\t\t/* Our first time through, we already have the data from\n\t\t * FindFirstFileW.  Use it, otherwise get the next file.\n\t\t */\n\t\tif (!diriter->needs_next)\n\t\t\tdiriter->needs_next = 1;\n\t\telse if (!FindNextFileW(diriter->handle, &diriter->current))\n\t\t\treturn GIT_ITEROVER;\n\t} while (skip_dot && git_path_is_dot_or_dotdotW(diriter->current.cFileName));\n\n\tif (diriter_update_paths(diriter) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "diriter_update_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1156-1190",
    "snippet": "static int diriter_update_paths(git_path_diriter *diriter)\n{\n\tsize_t filename_len, path_len;\n\n\tfilename_len = wcslen(diriter->current.cFileName);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&path_len, diriter->parent_len, filename_len) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&path_len, path_len, 2))\n\t\treturn -1;\n\n\tif (path_len > GIT_WIN_PATH_UTF16) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"invalid path '%.*ls\\\\%ls' (path too long)\",\n\t\t\tdiriter->parent_len, diriter->path, diriter->current.cFileName);\n\t\treturn -1;\n\t}\n\n\tdiriter->path[diriter->parent_len] = L'\\\\';\n\tmemcpy(&diriter->path[diriter->parent_len+1],\n\t\tdiriter->current.cFileName, filename_len * sizeof(wchar_t));\n\tdiriter->path[path_len-1] = L'\\0';\n\n\tgit_buf_truncate(&diriter->path_utf8, diriter->parent_utf8_len);\n\n\tif (diriter->parent_utf8_len > 0 &&\n\t\tdiriter->path_utf8.ptr[diriter->parent_utf8_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path_utf8, '/');\n\n\tgit_buf_put_w(&diriter->path_utf8, diriter->current.cFileName, filename_len);\n\n\tif (git_buf_oom(&diriter->path_utf8))\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&diriter->path_utf8"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put_w",
          "args": [
            "&diriter->path_utf8",
            "diriter->current.cFileName",
            "filename_len"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put_w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_buffer.c",
          "lines": "23-54",
          "snippet": "int git_buf_put_w(git_buf *buf, const wchar_t *string_w, size_t len_w)\n{\n\tint utf8_len, utf8_write_len;\n\tsize_t new_size;\n\n\tif (!len_w)\n\t\treturn 0;\n\n\tassert(string_w);\n\n\t/* Measure the string necessary for conversion */\n\tif ((utf8_len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, string_w, len_w, NULL, 0, NULL, NULL)) == 0)\n\t\treturn 0;\n\n\tassert(utf8_len > 0);\n\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, (size_t)utf8_len);\n\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\n\tif (git_buf_grow(buf, new_size) < 0)\n\t\treturn -1;\n\n\tif ((utf8_write_len = WideCharToMultiByte(\n\t\t\tCP_UTF8, WC_ERR_INVALID_CHARS, string_w, len_w, &buf->ptr[buf->size], utf8_len, NULL, NULL)) == 0)\n\t\treturn handle_wc_error();\n\n\tassert(utf8_write_len == utf8_len);\n\n\tbuf->size += utf8_write_len;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"../buffer.h\"",
            "#include \"w32_buffer.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"../buffer.h\"\n#include \"w32_buffer.h\"\n#include \"common.h\"\n\nint git_buf_put_w(git_buf *buf, const wchar_t *string_w, size_t len_w)\n{\n\tint utf8_len, utf8_write_len;\n\tsize_t new_size;\n\n\tif (!len_w)\n\t\treturn 0;\n\n\tassert(string_w);\n\n\t/* Measure the string necessary for conversion */\n\tif ((utf8_len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, string_w, len_w, NULL, 0, NULL, NULL)) == 0)\n\t\treturn 0;\n\n\tassert(utf8_len > 0);\n\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, (size_t)utf8_len);\n\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\n\tif (git_buf_grow(buf, new_size) < 0)\n\t\treturn -1;\n\n\tif ((utf8_write_len = WideCharToMultiByte(\n\t\t\tCP_UTF8, WC_ERR_INVALID_CHARS, string_w, len_w, &buf->ptr[buf->size], utf8_len, NULL, NULL)) == 0)\n\t\treturn handle_wc_error();\n\n\tassert(utf8_write_len == utf8_len);\n\n\tbuf->size += utf8_write_len;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "&diriter->path_utf8",
            "'/'"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "&diriter->path_utf8",
            "diriter->parent_utf8_len"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&diriter->path[diriter->parent_len+1]",
            "diriter->current.cFileName",
            "filename_len * sizeof(wchar_t)"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_FILESYSTEM",
            "\"invalid path '%.*ls\\\\%ls' (path too long)\"",
            "diriter->parent_len",
            "diriter->path",
            "diriter->current.cFileName"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&path_len",
            "path_len",
            "2"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&path_len",
            "diriter->parent_len",
            "filename_len"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcslen",
          "args": [
            "diriter->current.cFileName"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int diriter_update_paths(git_path_diriter *diriter)\n{\n\tsize_t filename_len, path_len;\n\n\tfilename_len = wcslen(diriter->current.cFileName);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&path_len, diriter->parent_len, filename_len) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&path_len, path_len, 2))\n\t\treturn -1;\n\n\tif (path_len > GIT_WIN_PATH_UTF16) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"invalid path '%.*ls\\\\%ls' (path too long)\",\n\t\t\tdiriter->parent_len, diriter->path, diriter->current.cFileName);\n\t\treturn -1;\n\t}\n\n\tdiriter->path[diriter->parent_len] = L'\\\\';\n\tmemcpy(&diriter->path[diriter->parent_len+1],\n\t\tdiriter->current.cFileName, filename_len * sizeof(wchar_t));\n\tdiriter->path[path_len-1] = L'\\0';\n\n\tgit_buf_truncate(&diriter->path_utf8, diriter->parent_utf8_len);\n\n\tif (diriter->parent_utf8_len > 0 &&\n\t\tdiriter->path_utf8.ptr[diriter->parent_utf8_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path_utf8, '/');\n\n\tgit_buf_put_w(&diriter->path_utf8, diriter->current.cFileName, filename_len);\n\n\tif (git_buf_oom(&diriter->path_utf8))\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_diriter_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1105-1154",
    "snippet": "int git_path_diriter_init(\n\tgit_path_diriter *diriter,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tgit_win32_path path_filter;\n\tgit_buf hack = {0};\n\n\tstatic int is_win7_or_later = -1;\n\tif (is_win7_or_later < 0)\n\t\tis_win7_or_later = git_has_win32_version(6, 1, 0);\n\n\tassert(diriter && path);\n\n\tmemset(diriter, 0, sizeof(git_path_diriter));\n\tdiriter->handle = INVALID_HANDLE_VALUE;\n\n\tif (git_buf_puts(&diriter->path_utf8, path) < 0)\n\t\treturn -1;\n\n\tgit_path_trim_slashes(&diriter->path_utf8);\n\n\tif (diriter->path_utf8.size == 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((diriter->parent_len = git_win32_path_from_utf8(diriter->path, diriter->path_utf8.ptr)) < 0 ||\n\t\t\t!git_win32__findfirstfile_filter(path_filter, diriter->path_utf8.ptr)) {\n\t\tgiterr_set(GITERR_OS, \"Could not parse the directory path '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tdiriter->handle = FindFirstFileExW(\n\t\tpath_filter,\n\t\tis_win7_or_later ? FindExInfoBasic : FindExInfoStandard,\n\t\t&diriter->current,\n\t\tFindExSearchNameMatch,\n\t\tNULL,\n\t\tis_win7_or_later ? FIND_FIRST_EX_LARGE_FETCH : 0);\n\n\tif (diriter->handle == INVALID_HANDLE_VALUE) {\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tdiriter->parent_utf8_len = diriter->path_utf8.size;\n\tdiriter->flags = flags;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not open directory '%s'\"",
            "path"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindFirstFileExW",
          "args": [
            "path_filter",
            "is_win7_or_later ? FindExInfoBasic : FindExInfoStandard",
            "&diriter->current",
            "FindExSearchNameMatch",
            "NULL",
            "is_win7_or_later ? FIND_FIRST_EX_LARGE_FETCH : 0"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32__findfirstfile_filter",
          "args": [
            "path_filter",
            "diriter->path_utf8.ptr"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__findfirstfile_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
          "lines": "18-43",
          "snippet": "bool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}",
          "includes": [
            "#include \"w32_util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_util.h\"\n\nbool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "diriter->path",
            "diriter->path_utf8.ptr"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_trim_slashes",
          "args": [
            "&diriter->path_utf8"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_trim_slashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "265-277",
          "snippet": "void git_path_trim_slashes(git_buf *path)\n{\n\tint ceiling = git_path_root(path->ptr) + 1;\n\tassert(ceiling >= 0);\n\n\twhile (path->size > (size_t)ceiling) {\n\t\tif (path->ptr[path->size-1] != '/')\n\t\t\tbreak;\n\n\t\tpath->ptr[path->size-1] = '\\0';\n\t\tpath->size--;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_trim_slashes(git_buf *path)\n{\n\tint ceiling = git_path_root(path->ptr) + 1;\n\tassert(ceiling >= 0);\n\n\twhile (path->size > (size_t)ceiling) {\n\t\tif (path->ptr[path->size-1] != '/')\n\t\t\tbreak;\n\n\t\tpath->ptr[path->size-1] = '\\0';\n\t\tpath->size--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&diriter->path_utf8",
            "path"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "diriter",
            "0",
            "sizeof(git_path_diriter)"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diriter && path"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_has_win32_version",
          "args": [
            "6",
            "1",
            "0"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "git_has_win32_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/version.h",
          "lines": "12-35",
          "snippet": "GIT_INLINE(int) git_has_win32_version(int major, int minor, int service_pack)\n{\n\tOSVERSIONINFOEX version_test = {0};\n\tDWORD version_test_mask;\n\tDWORDLONG version_condition_mask = 0;\n\t\n\tversion_test.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\n\tversion_test.dwMajorVersion = major;\n\tversion_test.dwMinorVersion = minor;\n\tversion_test.wServicePackMajor = (WORD)service_pack;\n\tversion_test.wServicePackMinor = 0;\n\n\tversion_test_mask = (VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR);\n\n\tVER_SET_CONDITION(version_condition_mask, VER_MAJORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_MINORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_SERVICEPACKMINOR, VER_GREATER_EQUAL);\n\n\tif (!VerifyVersionInfo(&version_test, version_test_mask, version_condition_mask))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <windows.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n\nGIT_INLINE(int) git_has_win32_version(int major, int minor, int service_pack)\n{\n\tOSVERSIONINFOEX version_test = {0};\n\tDWORD version_test_mask;\n\tDWORDLONG version_condition_mask = 0;\n\t\n\tversion_test.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\n\tversion_test.dwMajorVersion = major;\n\tversion_test.dwMinorVersion = minor;\n\tversion_test.wServicePackMajor = (WORD)service_pack;\n\tversion_test.wServicePackMinor = 0;\n\n\tversion_test_mask = (VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR);\n\n\tVER_SET_CONDITION(version_condition_mask, VER_MAJORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_MINORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_SERVICEPACKMINOR, VER_GREATER_EQUAL);\n\n\tif (!VerifyVersionInfo(&version_test, version_test_mask, version_condition_mask))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_init(\n\tgit_path_diriter *diriter,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tgit_win32_path path_filter;\n\tgit_buf hack = {0};\n\n\tstatic int is_win7_or_later = -1;\n\tif (is_win7_or_later < 0)\n\t\tis_win7_or_later = git_has_win32_version(6, 1, 0);\n\n\tassert(diriter && path);\n\n\tmemset(diriter, 0, sizeof(git_path_diriter));\n\tdiriter->handle = INVALID_HANDLE_VALUE;\n\n\tif (git_buf_puts(&diriter->path_utf8, path) < 0)\n\t\treturn -1;\n\n\tgit_path_trim_slashes(&diriter->path_utf8);\n\n\tif (diriter->path_utf8.size == 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((diriter->parent_len = git_win32_path_from_utf8(diriter->path, diriter->path_utf8.ptr)) < 0 ||\n\t\t\t!git_win32__findfirstfile_filter(path_filter, diriter->path_utf8.ptr)) {\n\t\tgiterr_set(GITERR_OS, \"Could not parse the directory path '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tdiriter->handle = FindFirstFileExW(\n\t\tpath_filter,\n\t\tis_win7_or_later ? FindExInfoBasic : FindExInfoStandard,\n\t\t&diriter->current,\n\t\tFindExSearchNameMatch,\n\t\tNULL,\n\t\tis_win7_or_later ? FIND_FIRST_EX_LARGE_FETCH : 0);\n\n\tif (diriter->handle == INVALID_HANDLE_VALUE) {\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tdiriter->parent_utf8_len = diriter->path_utf8.size;\n\tdiriter->flags = flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_direach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1023-1094",
    "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_iconv_clear",
          "args": [
            "&ic"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_iconv_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "894-901",
          "snippet": "void git_path_iconv_clear(git_path_iconv_t *ic)\n{\n\tif (ic) {\n\t\tif (ic->map != (iconv_t)-1)\n\t\t\ticonv_close(ic->map);\n\t\tgit_buf_free(&ic->buf);\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_iconv_clear(git_path_iconv_t *ic)\n{\n\tif (ic) {\n\t\tif (ic->map != (iconv_t)-1)\n\t\t\ticonv_close(ic->map);\n\t\tgit_buf_free(&ic->buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "git__closedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
          "lines": "106-118",
          "snippet": "int git__closedir(git__DIR *d)\n{\n\tif (!d)\n\t\treturn 0;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t}\n\n\tgit__free(d);\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n\nint git__closedir(git__DIR *d)\n{\n\tif (!d)\n\t\treturn 0;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t}\n\n\tgit__free(d);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_last",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "134-137",
          "snippet": "const git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "path",
            "wd_len"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "arg",
            "path"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_fnmatch__match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "355-429",
          "snippet": "bool git_attr_fnmatch__match(\n\tgit_attr_fnmatch *match,\n\tgit_attr_path *path)\n{\n\tconst char *relpath = path->path;\n\tconst char *filename;\n\tint flags = 0;\n\n\t/*\n\t * If the rule was generated in a subdirectory, we must only\n\t * use it for paths inside that directory. We can thus return\n\t * a non-match if the prefixes don't match.\n\t */\n\tif (match->containing_dir) {\n\t\tif (match->flags & GIT_ATTR_FNMATCH_ICASE) {\n\t\t\tif (git__strncasecmp(path->path, match->containing_dir, match->containing_dir_length))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (git__prefixcmp(path->path, match->containing_dir))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trelpath += match->containing_dir_length;\n\t}\n\n\tif (match->flags & GIT_ATTR_FNMATCH_ICASE)\n\t\tflags |= FNM_CASEFOLD;\n\tif (match->flags & GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\tflags |= FNM_LEADING_DIR;\n\n\tif (match->flags & GIT_ATTR_FNMATCH_FULLPATH) {\n\t\tfilename = relpath;\n\t\tflags |= FNM_PATHNAME;\n\t} else {\n\t\tfilename = path->basename;\n\n\t\tif (path->is_dir)\n\t\t\tflags |= FNM_LEADING_DIR;\n\t}\n\n\tif ((match->flags & GIT_ATTR_FNMATCH_DIRECTORY) && !path->is_dir) {\n\t\tbool samename;\n\n\t\t/* for attribute checks or root ignore checks, fail match */\n\t\tif (!(match->flags & GIT_ATTR_FNMATCH_IGNORE) ||\n\t\t\tpath->basename == path->path)\n\t\t\treturn false;\n\n\t\tflags |= FNM_LEADING_DIR;\n\n\t\t/* fail match if this is a file with same name as ignored folder */\n\t\tsamename = (match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strcasecmp(match->pattern, relpath) :\n\t\t\t!strcmp(match->pattern, relpath);\n\n\t\tif (samename)\n\t\t\treturn false;\n\n\t\treturn (p_fnmatch(match->pattern, relpath, flags) != FNM_NOMATCH);\n\t}\n\n\t/* if path is a directory prefix of a negated pattern, then match */\n\tif ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) && path->is_dir) {\n\t\tsize_t pathlen = strlen(relpath);\n\t\tbool prefixed = (pathlen <= match->length) &&\n\t\t\t((match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strncasecmp(match->pattern, relpath, pathlen) :\n\t\t\t!strncmp(match->pattern, relpath, pathlen));\n\n\t\tif (prefixed && git_path_at_end_of_segment(&match->pattern[pathlen]))\n\t\t\treturn true;\n\t}\n\n\treturn (p_fnmatch(match->pattern, filename, flags) != FNM_NOMATCH);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);",
            "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nbool git_attr_fnmatch__match(\n\tgit_attr_fnmatch *match,\n\tgit_attr_path *path)\n{\n\tconst char *relpath = path->path;\n\tconst char *filename;\n\tint flags = 0;\n\n\t/*\n\t * If the rule was generated in a subdirectory, we must only\n\t * use it for paths inside that directory. We can thus return\n\t * a non-match if the prefixes don't match.\n\t */\n\tif (match->containing_dir) {\n\t\tif (match->flags & GIT_ATTR_FNMATCH_ICASE) {\n\t\t\tif (git__strncasecmp(path->path, match->containing_dir, match->containing_dir_length))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (git__prefixcmp(path->path, match->containing_dir))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trelpath += match->containing_dir_length;\n\t}\n\n\tif (match->flags & GIT_ATTR_FNMATCH_ICASE)\n\t\tflags |= FNM_CASEFOLD;\n\tif (match->flags & GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\tflags |= FNM_LEADING_DIR;\n\n\tif (match->flags & GIT_ATTR_FNMATCH_FULLPATH) {\n\t\tfilename = relpath;\n\t\tflags |= FNM_PATHNAME;\n\t} else {\n\t\tfilename = path->basename;\n\n\t\tif (path->is_dir)\n\t\t\tflags |= FNM_LEADING_DIR;\n\t}\n\n\tif ((match->flags & GIT_ATTR_FNMATCH_DIRECTORY) && !path->is_dir) {\n\t\tbool samename;\n\n\t\t/* for attribute checks or root ignore checks, fail match */\n\t\tif (!(match->flags & GIT_ATTR_FNMATCH_IGNORE) ||\n\t\t\tpath->basename == path->path)\n\t\t\treturn false;\n\n\t\tflags |= FNM_LEADING_DIR;\n\n\t\t/* fail match if this is a file with same name as ignored folder */\n\t\tsamename = (match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strcasecmp(match->pattern, relpath) :\n\t\t\t!strcmp(match->pattern, relpath);\n\n\t\tif (samename)\n\t\t\treturn false;\n\n\t\treturn (p_fnmatch(match->pattern, relpath, flags) != FNM_NOMATCH);\n\t}\n\n\t/* if path is a directory prefix of a negated pattern, then match */\n\tif ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) && path->is_dir) {\n\t\tsize_t pathlen = strlen(relpath);\n\t\tbool prefixed = (pathlen <= match->length) &&\n\t\t\t((match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strncasecmp(match->pattern, relpath, pathlen) :\n\t\t\t!strncmp(match->pattern, relpath, pathlen));\n\n\t\tif (prefixed && git_path_at_end_of_segment(&match->pattern[pathlen]))\n\t\t\treturn true;\n\t}\n\n\treturn (p_fnmatch(match->pattern, filename, flags) != FNM_NOMATCH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "path",
            "de_path",
            "de_len"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_iconv",
          "args": [
            "&ic",
            "&de_path",
            "&de_len"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_iconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "903-955",
          "snippet": "int git_path_iconv(git_path_iconv_t *ic, const char **in, size_t *inlen)\n{\n\tchar *nfd = (char*)*in, *nfc;\n\tsize_t nfdlen = *inlen, nfclen, wantlen = nfdlen, alloclen, rv;\n\tint retry = 1;\n\n\tif (!ic || ic->map == (iconv_t)-1 ||\n\t\t!git_path_has_non_ascii(*in, *inlen))\n\t\treturn 0;\n\n\tgit_buf_clear(&ic->buf);\n\n\twhile (1) {\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, wantlen, 1);\n\t\tif (git_buf_grow(&ic->buf, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tnfc    = ic->buf.ptr   + ic->buf.size;\n\t\tnfclen = ic->buf.asize - ic->buf.size;\n\n\t\trv = iconv(ic->map, &nfd, &nfdlen, &nfc, &nfclen);\n\n\t\tic->buf.size = (nfc - ic->buf.ptr);\n\n\t\tif (rv != (size_t)-1)\n\t\t\tbreak;\n\n\t\t/* if we cannot convert the data (probably because iconv thinks\n\t\t * it is not valid UTF-8 source data), then use original data\n\t\t */\n\t\tif (errno != E2BIG)\n\t\t\treturn 0;\n\n\t\t/* make space for 2x the remaining data to be converted\n\t\t * (with per retry overhead to avoid infinite loops)\n\t\t */\n\t\twantlen = ic->buf.size + max(nfclen, nfdlen) * 2 + (size_t)(retry * 4);\n\n\t\tif (retry++ > 4)\n\t\t\tgoto fail;\n\t}\n\n\tic->buf.ptr[ic->buf.size] = '\\0';\n\n\t*in    = ic->buf.ptr;\n\t*inlen = ic->buf.size;\n\n\treturn 0;\n\nfail:\n\tgiterr_set(GITERR_OS, \"Unable to convert unicode path data\");\n\treturn -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_iconv(git_path_iconv_t *ic, const char **in, size_t *inlen)\n{\n\tchar *nfd = (char*)*in, *nfc;\n\tsize_t nfdlen = *inlen, nfclen, wantlen = nfdlen, alloclen, rv;\n\tint retry = 1;\n\n\tif (!ic || ic->map == (iconv_t)-1 ||\n\t\t!git_path_has_non_ascii(*in, *inlen))\n\t\treturn 0;\n\n\tgit_buf_clear(&ic->buf);\n\n\twhile (1) {\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, wantlen, 1);\n\t\tif (git_buf_grow(&ic->buf, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tnfc    = ic->buf.ptr   + ic->buf.size;\n\t\tnfclen = ic->buf.asize - ic->buf.size;\n\n\t\trv = iconv(ic->map, &nfd, &nfdlen, &nfc, &nfclen);\n\n\t\tic->buf.size = (nfc - ic->buf.ptr);\n\n\t\tif (rv != (size_t)-1)\n\t\t\tbreak;\n\n\t\t/* if we cannot convert the data (probably because iconv thinks\n\t\t * it is not valid UTF-8 source data), then use original data\n\t\t */\n\t\tif (errno != E2BIG)\n\t\t\treturn 0;\n\n\t\t/* make space for 2x the remaining data to be converted\n\t\t * (with per retry overhead to avoid infinite loops)\n\t\t */\n\t\twantlen = ic->buf.size + max(nfclen, nfdlen) * 2 + (size_t)(retry * 4);\n\n\t\tif (retry++ > 4)\n\t\t\tgoto fail;\n\t}\n\n\tic->buf.ptr[ic->buf.size] = '\\0';\n\n\t*in    = ic->buf.ptr;\n\t*inlen = ic->buf.size;\n\n\treturn 0;\n\nfail:\n\tgiterr_set(GITERR_OS, \"Unable to convert unicode path data\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_is_dot_or_dotdot",
          "args": [
            "de_path"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_is_dot_or_dotdotW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "100-105",
          "snippet": "GIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "de_path"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "git__readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
          "lines": "74-80",
          "snippet": "struct git__dirent *git__readdir(git__DIR *d)\n{\n\tstruct git__dirent *result;\n\tif (git__readdir_ext(d, &d->entry, &result, NULL) < 0)\n\t\treturn NULL;\n\treturn result;\n}",
          "includes": [
            "#include \"posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n\nstruct git__dirent *git__readdir(git__DIR *d)\n{\n\tstruct git__dirent *result;\n\tif (git__readdir_ext(d, &d->entry, &result, NULL) < 0)\n\t\treturn NULL;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_iconv_init_precompose",
          "args": [
            "&ic"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_iconv_init_precompose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "887-892",
          "snippet": "int git_path_iconv_init_precompose(git_path_iconv_t *ic)\n{\n\tgit_buf_init(&ic->buf, 0);\n\tic->map = iconv_open(GIT_PATH_REPO_ENCODING, GIT_PATH_NATIVE_ENCODING);\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_iconv_init_precompose(git_path_iconv_t *ic)\n{\n\tgit_buf_init(&ic->buf, 0);\n\tic->map = iconv_open(GIT_PATH_REPO_ENCODING, GIT_PATH_NATIVE_ENCODING);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to open directory '%s'\"",
            "path->ptr"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "path->ptr"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "git__opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
          "lines": "10-38",
          "snippet": "git__DIR *git__opendir(const char *dir)\n{\n\tgit_win32_path filter_w;\n\tgit__DIR *new = NULL;\n\tsize_t dirlen, alloclen;\n\n\tif (!dir || !git_win32__findfirstfile_filter(filter_w, dir))\n\t\treturn NULL;\n\n\tdirlen = strlen(dir);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, sizeof(*new), dirlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1) ||\n\t\t!(new = git__calloc(1, alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(new->dir, dir, dirlen);\n\n\tnew->h = FindFirstFileW(filter_w, &new->f);\n\n\tif (new->h == INVALID_HANDLE_VALUE) {\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", dir);\n\t\tgit__free(new);\n\t\treturn NULL;\n\t}\n\n\tnew->first = 1;\n\treturn new;\n}",
          "includes": [
            "#include \"posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n\ngit__DIR *git__opendir(const char *dir)\n{\n\tgit_win32_path filter_w;\n\tgit__DIR *new = NULL;\n\tsize_t dirlen, alloclen;\n\n\tif (!dir || !git_win32__findfirstfile_filter(filter_w, dir))\n\t\treturn NULL;\n\n\tdirlen = strlen(dir);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, sizeof(*new), dirlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1) ||\n\t\t!(new = git__calloc(1, alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(new->dir, dir, dirlen);\n\n\tnew->h = FindFirstFileW(filter_w, &new->f);\n\n\tif (new->h == INVALID_HANDLE_VALUE) {\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", dir);\n\t\tgit__free(new);\n\t\treturn NULL;\n\t}\n\n\tnew->first = 1;\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "path"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "path"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "flags"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_path_does_fs_decompose_unicode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "1009-1013",
    "snippet": "bool git_path_does_fs_decompose_unicode(const char *root)\n{\n\tGIT_UNUSED(root);\n\treturn false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "root"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_does_fs_decompose_unicode(const char *root)\n{\n\tGIT_UNUSED(root);\n\treturn false;\n}"
  },
  {
    "function_name": "git_path_does_fs_decompose_unicode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "969-1005",
    "snippet": "bool git_path_does_fs_decompose_unicode(const char *root)\n{\n\tgit_buf path = GIT_BUF_INIT;\n\tint fd;\n\tbool found_decomposed = false;\n\tchar tmp[6];\n\n\t/* Create a file using a precomposed path and then try to find it\n\t * using the decomposed name.  If the lookup fails, then we will mark\n\t * that we should precompose unicode for this repository.\n\t */\n\tif (git_buf_joinpath(&path, root, nfc_file) < 0 ||\n\t\t(fd = p_mkstemp(path.ptr)) < 0)\n\t\tgoto done;\n\tp_close(fd);\n\n\t/* record trailing digits generated by mkstemp */\n\tmemcpy(tmp, path.ptr + path.size - sizeof(tmp), sizeof(tmp));\n\n\t/* try to look up as NFD path */\n\tif (git_buf_joinpath(&path, root, nfd_file) < 0)\n\t\tgoto done;\n\tmemcpy(path.ptr + path.size - sizeof(tmp), tmp, sizeof(tmp));\n\n\tfound_decomposed = git_path_exists(path.ptr);\n\n\t/* remove temporary file (using original precomposed path) */\n\tif (git_buf_joinpath(&path, root, nfc_file) < 0)\n\t\tgoto done;\n\tmemcpy(path.ptr + path.size - sizeof(tmp), tmp, sizeof(tmp));\n\n\t(void)p_unlink(path.ptr);\n\ndone:\n\tgit_buf_free(&path);\n\treturn found_decomposed;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "path.ptr"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "path.ptr + path.size - sizeof(tmp)",
            "tmp",
            "sizeof(tmp)"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "root",
            "nfc_file"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "path.ptr"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "path.ptr + path.size - sizeof(tmp)",
            "tmp",
            "sizeof(tmp)"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "path.ptr + path.size - sizeof(tmp)",
            "sizeof(tmp)"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_mkstemp",
          "args": [
            "path.ptr"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "p_mkstemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "561-572",
          "snippet": "int p_mkstemp(char *tmp_path)\n{\n#if defined(_MSC_VER) && _MSC_VER >= 1500\n\tif (_mktemp_s(tmp_path, strlen(tmp_path) + 1) != 0)\n\t\treturn -1;\n#else\n\tif (_mktemp(tmp_path) == NULL)\n\t\treturn -1;\n#endif\n\n\treturn p_open(tmp_path, O_RDWR | O_CREAT | O_EXCL, 0744); //-V536\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_mkstemp(char *tmp_path)\n{\n#if defined(_MSC_VER) && _MSC_VER >= 1500\n\tif (_mktemp_s(tmp_path, strlen(tmp_path) + 1) != 0)\n\t\treturn -1;\n#else\n\tif (_mktemp(tmp_path) == NULL)\n\t\treturn -1;\n#endif\n\n\treturn p_open(tmp_path, O_RDWR | O_CREAT | O_EXCL, 0744); //-V536\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_does_fs_decompose_unicode(const char *root)\n{\n\tgit_buf path = GIT_BUF_INIT;\n\tint fd;\n\tbool found_decomposed = false;\n\tchar tmp[6];\n\n\t/* Create a file using a precomposed path and then try to find it\n\t * using the decomposed name.  If the lookup fails, then we will mark\n\t * that we should precompose unicode for this repository.\n\t */\n\tif (git_buf_joinpath(&path, root, nfc_file) < 0 ||\n\t\t(fd = p_mkstemp(path.ptr)) < 0)\n\t\tgoto done;\n\tp_close(fd);\n\n\t/* record trailing digits generated by mkstemp */\n\tmemcpy(tmp, path.ptr + path.size - sizeof(tmp), sizeof(tmp));\n\n\t/* try to look up as NFD path */\n\tif (git_buf_joinpath(&path, root, nfd_file) < 0)\n\t\tgoto done;\n\tmemcpy(path.ptr + path.size - sizeof(tmp), tmp, sizeof(tmp));\n\n\tfound_decomposed = git_path_exists(path.ptr);\n\n\t/* remove temporary file (using original precomposed path) */\n\tif (git_buf_joinpath(&path, root, nfc_file) < 0)\n\t\tgoto done;\n\tmemcpy(path.ptr + path.size - sizeof(tmp), tmp, sizeof(tmp));\n\n\t(void)p_unlink(path.ptr);\n\ndone:\n\tgit_buf_free(&path);\n\treturn found_decomposed;\n}"
  },
  {
    "function_name": "git_path_iconv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "903-955",
    "snippet": "int git_path_iconv(git_path_iconv_t *ic, const char **in, size_t *inlen)\n{\n\tchar *nfd = (char*)*in, *nfc;\n\tsize_t nfdlen = *inlen, nfclen, wantlen = nfdlen, alloclen, rv;\n\tint retry = 1;\n\n\tif (!ic || ic->map == (iconv_t)-1 ||\n\t\t!git_path_has_non_ascii(*in, *inlen))\n\t\treturn 0;\n\n\tgit_buf_clear(&ic->buf);\n\n\twhile (1) {\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, wantlen, 1);\n\t\tif (git_buf_grow(&ic->buf, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tnfc    = ic->buf.ptr   + ic->buf.size;\n\t\tnfclen = ic->buf.asize - ic->buf.size;\n\n\t\trv = iconv(ic->map, &nfd, &nfdlen, &nfc, &nfclen);\n\n\t\tic->buf.size = (nfc - ic->buf.ptr);\n\n\t\tif (rv != (size_t)-1)\n\t\t\tbreak;\n\n\t\t/* if we cannot convert the data (probably because iconv thinks\n\t\t * it is not valid UTF-8 source data), then use original data\n\t\t */\n\t\tif (errno != E2BIG)\n\t\t\treturn 0;\n\n\t\t/* make space for 2x the remaining data to be converted\n\t\t * (with per retry overhead to avoid infinite loops)\n\t\t */\n\t\twantlen = ic->buf.size + max(nfclen, nfdlen) * 2 + (size_t)(retry * 4);\n\n\t\tif (retry++ > 4)\n\t\t\tgoto fail;\n\t}\n\n\tic->buf.ptr[ic->buf.size] = '\\0';\n\n\t*in    = ic->buf.ptr;\n\t*inlen = ic->buf.size;\n\n\treturn 0;\n\nfail:\n\tgiterr_set(GITERR_OS, \"Unable to convert unicode path data\");\n\treturn -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Unable to convert unicode path data\""
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nfclen",
            "nfdlen"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "git_cache_set_max_object_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cache.c",
          "lines": "35-44",
          "snippet": "int git_cache_set_max_object_size(git_otype type, size_t size)\n{\n\tif (type < 0 || (size_t)type >= ARRAY_SIZE(git_cache__max_object_size)) {\n\t\tgiterr_set(GITERR_INVALID, \"type out of range\");\n\t\treturn -1;\n\t}\n\n\tgit_cache__max_object_size[type] = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"object.h\"",
            "#include \"odb.h\"",
            "#include \"cache.h\"",
            "#include \"util.h\"",
            "#include \"thread-utils.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t git_cache__max_object_size[8] = {\n\t0,     /* GIT_OBJ__EXT1 */\n\t4096,  /* GIT_OBJ_COMMIT */\n\t4096,  /* GIT_OBJ_TREE */\n\t0,     /* GIT_OBJ_BLOB */\n\t4096,  /* GIT_OBJ_TAG */\n\t0,     /* GIT_OBJ__EXT2 */\n\t0,     /* GIT_OBJ_OFS_DELTA */\n\t0      /* GIT_OBJ_REF_DELTA */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"object.h\"\n#include \"odb.h\"\n#include \"cache.h\"\n#include \"util.h\"\n#include \"thread-utils.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic size_t git_cache__max_object_size[8] = {\n\t0,     /* GIT_OBJ__EXT1 */\n\t4096,  /* GIT_OBJ_COMMIT */\n\t4096,  /* GIT_OBJ_TREE */\n\t0,     /* GIT_OBJ_BLOB */\n\t4096,  /* GIT_OBJ_TAG */\n\t0,     /* GIT_OBJ__EXT2 */\n\t0,     /* GIT_OBJ_OFS_DELTA */\n\t0      /* GIT_OBJ_REF_DELTA */\n};\n\nint git_cache_set_max_object_size(git_otype type, size_t size)\n{\n\tif (type < 0 || (size_t)type >= ARRAY_SIZE(git_cache__max_object_size)) {\n\t\tgiterr_set(GITERR_INVALID, \"type out of range\");\n\t\treturn -1;\n\t}\n\n\tgit_cache__max_object_size[type] = size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iconv",
          "args": [
            "ic->map",
            "&nfd",
            "&nfdlen",
            "&nfc",
            "&nfclen"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "&ic->buf",
            "alloclen"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "wantlen",
            "1"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&ic->buf"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_has_non_ascii",
          "args": [
            "*in",
            "*inlen"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_has_non_ascii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "874-883",
          "snippet": "bool git_path_has_non_ascii(const char *path, size_t pathlen)\n{\n\tconst uint8_t *scan = (const uint8_t *)path, *end;\n\n\tfor (end = scan + pathlen; scan < end; ++scan)\n\t\tif (*scan & 0x80)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_has_non_ascii(const char *path, size_t pathlen)\n{\n\tconst uint8_t *scan = (const uint8_t *)path, *end;\n\n\tfor (end = scan + pathlen; scan < end; ++scan)\n\t\tif (*scan & 0x80)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_iconv(git_path_iconv_t *ic, const char **in, size_t *inlen)\n{\n\tchar *nfd = (char*)*in, *nfc;\n\tsize_t nfdlen = *inlen, nfclen, wantlen = nfdlen, alloclen, rv;\n\tint retry = 1;\n\n\tif (!ic || ic->map == (iconv_t)-1 ||\n\t\t!git_path_has_non_ascii(*in, *inlen))\n\t\treturn 0;\n\n\tgit_buf_clear(&ic->buf);\n\n\twhile (1) {\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, wantlen, 1);\n\t\tif (git_buf_grow(&ic->buf, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tnfc    = ic->buf.ptr   + ic->buf.size;\n\t\tnfclen = ic->buf.asize - ic->buf.size;\n\n\t\trv = iconv(ic->map, &nfd, &nfdlen, &nfc, &nfclen);\n\n\t\tic->buf.size = (nfc - ic->buf.ptr);\n\n\t\tif (rv != (size_t)-1)\n\t\t\tbreak;\n\n\t\t/* if we cannot convert the data (probably because iconv thinks\n\t\t * it is not valid UTF-8 source data), then use original data\n\t\t */\n\t\tif (errno != E2BIG)\n\t\t\treturn 0;\n\n\t\t/* make space for 2x the remaining data to be converted\n\t\t * (with per retry overhead to avoid infinite loops)\n\t\t */\n\t\twantlen = ic->buf.size + max(nfclen, nfdlen) * 2 + (size_t)(retry * 4);\n\n\t\tif (retry++ > 4)\n\t\t\tgoto fail;\n\t}\n\n\tic->buf.ptr[ic->buf.size] = '\\0';\n\n\t*in    = ic->buf.ptr;\n\t*inlen = ic->buf.size;\n\n\treturn 0;\n\nfail:\n\tgiterr_set(GITERR_OS, \"Unable to convert unicode path data\");\n\treturn -1;\n}"
  },
  {
    "function_name": "git_path_iconv_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "894-901",
    "snippet": "void git_path_iconv_clear(git_path_iconv_t *ic)\n{\n\tif (ic) {\n\t\tif (ic->map != (iconv_t)-1)\n\t\t\ticonv_close(ic->map);\n\t\tgit_buf_free(&ic->buf);\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ic->buf"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iconv_close",
          "args": [
            "ic->map"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_iconv_clear(git_path_iconv_t *ic)\n{\n\tif (ic) {\n\t\tif (ic->map != (iconv_t)-1)\n\t\t\ticonv_close(ic->map);\n\t\tgit_buf_free(&ic->buf);\n\t}\n}"
  },
  {
    "function_name": "git_path_iconv_init_precompose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "887-892",
    "snippet": "int git_path_iconv_init_precompose(git_path_iconv_t *ic)\n{\n\tgit_buf_init(&ic->buf, 0);\n\tic->map = iconv_open(GIT_PATH_REPO_ENCODING, GIT_PATH_NATIVE_ENCODING);\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iconv_open",
          "args": [
            "GIT_PATH_REPO_ENCODING",
            "GIT_PATH_NATIVE_ENCODING"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "&ic->buf",
            "0"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_iconv_init_precompose(git_path_iconv_t *ic)\n{\n\tgit_buf_init(&ic->buf, 0);\n\tic->map = iconv_open(GIT_PATH_REPO_ENCODING, GIT_PATH_NATIVE_ENCODING);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_has_non_ascii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "874-883",
    "snippet": "bool git_path_has_non_ascii(const char *path, size_t pathlen)\n{\n\tconst uint8_t *scan = (const uint8_t *)path, *end;\n\n\tfor (end = scan + pathlen; scan < end; ++scan)\n\t\tif (*scan & 0x80)\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_has_non_ascii(const char *path, size_t pathlen)\n{\n\tconst uint8_t *scan = (const uint8_t *)path, *end;\n\n\tfor (end = scan + pathlen; scan < end; ++scan)\n\t\tif (*scan & 0x80)\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "git_path_make_relative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "813-872",
    "snippet": "int git_path_make_relative(git_buf *path, const char *parent)\n{\n\tconst char *p, *q, *p_dirsep, *q_dirsep;\n\tsize_t plen = path->size, newlen, alloclen, depth = 1, i, offset;\n\n\tfor (p_dirsep = p = path->ptr, q_dirsep = q = parent; *p && *q; p++, q++) {\n\t\tif (*p == '/' && *q == '/') {\n\t\t\tp_dirsep = p;\n\t\t\tq_dirsep = q;\n\t\t}\n\t\telse if (*p != *q)\n\t\t\tbreak;\n\t}\n\n\t/* need at least 1 common path segment */\n\tif ((p_dirsep == path->ptr || q_dirsep == parent) &&\n\t\t(*p_dirsep != '/' || *q_dirsep != '/')) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"%s is not a parent of %s\", parent, path->ptr);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (*p == '/' && !*q)\n\t\tp++;\n\telse if (!*p && *q == '/')\n\t\tq++;\n\telse if (!*p && !*q)\n\t\treturn git_buf_clear(path), 0;\n\telse {\n\t\tp = p_dirsep + 1;\n\t\tq = q_dirsep + 1;\n\t}\n\n\tplen -= (p - path->ptr);\n\n\tif (!*q)\n\t\treturn git_buf_set(path, p, plen);\n\n\tfor (; (q = strchr(q, '/')) && *(q + 1); q++)\n\t\tdepth++;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&newlen, depth, 3);\n\tGITERR_CHECK_ALLOC_ADD(&newlen, newlen, plen);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, newlen, 1);\n\n\t/* save the offset as we might realllocate the pointer */\n\toffset = p - path->ptr;\n\tif (git_buf_try_grow(path, alloclen, 1) < 0)\n\t\treturn -1;\n\tp = path->ptr + offset;\n\n\tmemmove(path->ptr + (depth * 3), p, plen + 1);\n\n\tfor (i = 0; i < depth; i++)\n\t\tmemcpy(path->ptr + (i * 3), \"../\", 3);\n\n\tpath->size = newlen;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "path->ptr + (i * 3)",
            "\"../\"",
            "3"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "path->ptr + (depth * 3)",
            "p",
            "plen + 1"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_try_grow",
          "args": [
            "path",
            "alloclen",
            "1"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_try_grow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "35-99",
          "snippet": "int git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];",
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\nchar git_buf__oom[1];\n\nint git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "newlen",
            "1"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&newlen",
            "newlen",
            "plen"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&newlen",
            "depth",
            "3"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "q",
            "'/'"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "path",
            "p",
            "plen"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "path"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"%s is not a parent of %s\"",
            "parent",
            "path->ptr"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_make_relative(git_buf *path, const char *parent)\n{\n\tconst char *p, *q, *p_dirsep, *q_dirsep;\n\tsize_t plen = path->size, newlen, alloclen, depth = 1, i, offset;\n\n\tfor (p_dirsep = p = path->ptr, q_dirsep = q = parent; *p && *q; p++, q++) {\n\t\tif (*p == '/' && *q == '/') {\n\t\t\tp_dirsep = p;\n\t\t\tq_dirsep = q;\n\t\t}\n\t\telse if (*p != *q)\n\t\t\tbreak;\n\t}\n\n\t/* need at least 1 common path segment */\n\tif ((p_dirsep == path->ptr || q_dirsep == parent) &&\n\t\t(*p_dirsep != '/' || *q_dirsep != '/')) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"%s is not a parent of %s\", parent, path->ptr);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (*p == '/' && !*q)\n\t\tp++;\n\telse if (!*p && *q == '/')\n\t\tq++;\n\telse if (!*p && !*q)\n\t\treturn git_buf_clear(path), 0;\n\telse {\n\t\tp = p_dirsep + 1;\n\t\tq = q_dirsep + 1;\n\t}\n\n\tplen -= (p - path->ptr);\n\n\tif (!*q)\n\t\treturn git_buf_set(path, p, plen);\n\n\tfor (; (q = strchr(q, '/')) && *(q + 1); q++)\n\t\tdepth++;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&newlen, depth, 3);\n\tGITERR_CHECK_ALLOC_ADD(&newlen, newlen, plen);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, newlen, 1);\n\n\t/* save the offset as we might realllocate the pointer */\n\toffset = p - path->ptr;\n\tif (git_buf_try_grow(path, alloclen, 1) < 0)\n\t\treturn -1;\n\tp = path->ptr + offset;\n\n\tmemmove(path->ptr + (depth * 3), p, plen + 1);\n\n\tfor (i = 0; i < depth; i++)\n\t\tmemcpy(path->ptr + (i * 3), \"../\", 3);\n\n\tpath->size = newlen;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "788-811",
    "snippet": "int git_path_cmp(\n\tconst char *name1, size_t len1, int isdir1,\n\tconst char *name2, size_t len2, int isdir2,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\tunsigned char c1, c2;\n\tsize_t len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = compare(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\n\tc1 = name1[len];\n\tc2 = name2[len];\n\n\tif (c1 == '\\0' && isdir1)\n\t\tc1 = '/';\n\n\tif (c2 == '\\0' && isdir2)\n\t\tc2 = '/';\n\n\treturn (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compare",
          "args": [
            "name1",
            "name2",
            "len"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "git___compare_and_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "187-195",
          "snippet": "GIT_INLINE(void *) git___compare_and_swap(\n\tvoid * volatile *ptr, void *oldval, void *newval)\n{\n\tif (*ptr == oldval)\n\t\t*ptr = newval;\n\telse\n\t\toldval = newval;\n\treturn oldval;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(void *) git___compare_and_swap(\n\tvoid * volatile *ptr, void *oldval, void *newval)\n{\n\tif (*ptr == oldval)\n\t\t*ptr = newval;\n\telse\n\t\toldval = newval;\n\treturn oldval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_cmp(\n\tconst char *name1, size_t len1, int isdir1,\n\tconst char *name2, size_t len2, int isdir2,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\tunsigned char c1, c2;\n\tsize_t len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = compare(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\n\tc1 = name1[len];\n\tc2 = name2[len];\n\n\tif (c1 == '\\0' && isdir1)\n\t\tc1 = '/';\n\n\tif (c2 == '\\0' && isdir2)\n\t\tc2 = '/';\n\n\treturn (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;\n}"
  },
  {
    "function_name": "git_path_apply_relative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "782-786",
    "snippet": "int git_path_apply_relative(git_buf *target, const char *relpath)\n{\n\tgit_buf_joinpath(target, git_buf_cstr(target), relpath);\n\treturn git_path_resolve_relative(target, 0);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_resolve_relative",
          "args": [
            "target",
            "0"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_resolve_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "703-780",
          "snippet": "int git_path_resolve_relative(git_buf *path, size_t ceiling)\n{\n\tchar *base, *to, *from, *next;\n\tsize_t len;\n\n\tGITERR_CHECK_ALLOC_BUF(path);\n\n\tif (ceiling > path->size)\n\t\tceiling = path->size;\n\n\t/* recognize drive prefixes, etc. that should not be backed over */\n\tif (ceiling == 0)\n\t\tceiling = git_path_root(path->ptr) + 1;\n\n\t/* recognize URL prefixes that should not be backed over */\n\tif (ceiling == 0) {\n\t\tfor (next = path->ptr; *next && git__isalpha(*next); ++next);\n\t\tif (next[0] == ':' && next[1] == '/' && next[2] == '/')\n\t\t\tceiling = (next + 3) - path->ptr;\n\t}\n\n\tbase = to = from = path->ptr + ceiling;\n\n\twhile (*from) {\n\t\tfor (next = from; *next && *next != '/'; ++next);\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == '.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == '.' && from[1] == '.') {\n\t\t\t/* error out if trying to up one from a hard base */\n\t\t\tif (to == base && ceiling != 0) {\n\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\"Cannot strip root component off url\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* no more path segments to strip,\n\t\t\t * use '../' as a new base path */\n\t\t\tif (to == base) {\n\t\t\t\tif (*next == '/')\n\t\t\t\t\tlen++;\n\n\t\t\t\tif (to != from)\n\t\t\t\t\tmemmove(to, from, len);\n\n\t\t\t\tto += len;\n\t\t\t\t/* this is now the base, can't back up from a\n\t\t\t\t * relative prefix */\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == '/') to--;\n\t\t\t\twhile (to > base && to[-1] != '/') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == '/' && *from != '/')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == '/') from++;\n\t}\n\n\t*to = '\\0';\n\n\tpath->size = to - path->ptr;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_resolve_relative(git_buf *path, size_t ceiling)\n{\n\tchar *base, *to, *from, *next;\n\tsize_t len;\n\n\tGITERR_CHECK_ALLOC_BUF(path);\n\n\tif (ceiling > path->size)\n\t\tceiling = path->size;\n\n\t/* recognize drive prefixes, etc. that should not be backed over */\n\tif (ceiling == 0)\n\t\tceiling = git_path_root(path->ptr) + 1;\n\n\t/* recognize URL prefixes that should not be backed over */\n\tif (ceiling == 0) {\n\t\tfor (next = path->ptr; *next && git__isalpha(*next); ++next);\n\t\tif (next[0] == ':' && next[1] == '/' && next[2] == '/')\n\t\t\tceiling = (next + 3) - path->ptr;\n\t}\n\n\tbase = to = from = path->ptr + ceiling;\n\n\twhile (*from) {\n\t\tfor (next = from; *next && *next != '/'; ++next);\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == '.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == '.' && from[1] == '.') {\n\t\t\t/* error out if trying to up one from a hard base */\n\t\t\tif (to == base && ceiling != 0) {\n\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\"Cannot strip root component off url\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* no more path segments to strip,\n\t\t\t * use '../' as a new base path */\n\t\t\tif (to == base) {\n\t\t\t\tif (*next == '/')\n\t\t\t\t\tlen++;\n\n\t\t\t\tif (to != from)\n\t\t\t\t\tmemmove(to, from, len);\n\n\t\t\t\tto += len;\n\t\t\t\t/* this is now the base, can't back up from a\n\t\t\t\t * relative prefix */\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == '/') to--;\n\t\t\t\twhile (to > base && to[-1] != '/') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == '/' && *from != '/')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == '/') from++;\n\t}\n\n\t*to = '\\0';\n\n\tpath->size = to - path->ptr;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "target",
            "git_buf_cstr(target)",
            "relpath"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "target"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_apply_relative(git_buf *target, const char *relpath)\n{\n\tgit_buf_joinpath(target, git_buf_cstr(target), relpath);\n\treturn git_path_resolve_relative(target, 0);\n}"
  },
  {
    "function_name": "git_path_resolve_relative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "703-780",
    "snippet": "int git_path_resolve_relative(git_buf *path, size_t ceiling)\n{\n\tchar *base, *to, *from, *next;\n\tsize_t len;\n\n\tGITERR_CHECK_ALLOC_BUF(path);\n\n\tif (ceiling > path->size)\n\t\tceiling = path->size;\n\n\t/* recognize drive prefixes, etc. that should not be backed over */\n\tif (ceiling == 0)\n\t\tceiling = git_path_root(path->ptr) + 1;\n\n\t/* recognize URL prefixes that should not be backed over */\n\tif (ceiling == 0) {\n\t\tfor (next = path->ptr; *next && git__isalpha(*next); ++next);\n\t\tif (next[0] == ':' && next[1] == '/' && next[2] == '/')\n\t\t\tceiling = (next + 3) - path->ptr;\n\t}\n\n\tbase = to = from = path->ptr + ceiling;\n\n\twhile (*from) {\n\t\tfor (next = from; *next && *next != '/'; ++next);\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == '.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == '.' && from[1] == '.') {\n\t\t\t/* error out if trying to up one from a hard base */\n\t\t\tif (to == base && ceiling != 0) {\n\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\"Cannot strip root component off url\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* no more path segments to strip,\n\t\t\t * use '../' as a new base path */\n\t\t\tif (to == base) {\n\t\t\t\tif (*next == '/')\n\t\t\t\t\tlen++;\n\n\t\t\t\tif (to != from)\n\t\t\t\t\tmemmove(to, from, len);\n\n\t\t\t\tto += len;\n\t\t\t\t/* this is now the base, can't back up from a\n\t\t\t\t * relative prefix */\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == '/') to--;\n\t\t\t\twhile (to > base && to[-1] != '/') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == '/' && *from != '/')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == '/') from++;\n\t}\n\n\t*to = '\\0';\n\n\tpath->size = to - path->ptr;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "to",
            "from",
            "len"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "to",
            "from",
            "len"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Cannot strip root component off url\""
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isalpha",
          "args": [
            "*next"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "git__isalpha",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "444-447",
          "snippet": "GIT_INLINE(bool) git__isalpha(int c)\n{\n\treturn ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isalpha(int c)\n{\n\treturn ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "path->ptr"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_BUF",
          "args": [
            "path"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_resolve_relative(git_buf *path, size_t ceiling)\n{\n\tchar *base, *to, *from, *next;\n\tsize_t len;\n\n\tGITERR_CHECK_ALLOC_BUF(path);\n\n\tif (ceiling > path->size)\n\t\tceiling = path->size;\n\n\t/* recognize drive prefixes, etc. that should not be backed over */\n\tif (ceiling == 0)\n\t\tceiling = git_path_root(path->ptr) + 1;\n\n\t/* recognize URL prefixes that should not be backed over */\n\tif (ceiling == 0) {\n\t\tfor (next = path->ptr; *next && git__isalpha(*next); ++next);\n\t\tif (next[0] == ':' && next[1] == '/' && next[2] == '/')\n\t\t\tceiling = (next + 3) - path->ptr;\n\t}\n\n\tbase = to = from = path->ptr + ceiling;\n\n\twhile (*from) {\n\t\tfor (next = from; *next && *next != '/'; ++next);\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == '.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == '.' && from[1] == '.') {\n\t\t\t/* error out if trying to up one from a hard base */\n\t\t\tif (to == base && ceiling != 0) {\n\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\"Cannot strip root component off url\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* no more path segments to strip,\n\t\t\t * use '../' as a new base path */\n\t\t\tif (to == base) {\n\t\t\t\tif (*next == '/')\n\t\t\t\t\tlen++;\n\n\t\t\t\tif (to != from)\n\t\t\t\t\tmemmove(to, from, len);\n\n\t\t\t\tto += len;\n\t\t\t\t/* this is now the base, can't back up from a\n\t\t\t\t * relative prefix */\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == '/') to--;\n\t\t\t\twhile (to > base && to[-1] != '/') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == '/' && *from != '/')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == '/') from++;\n\t}\n\n\t*to = '\\0';\n\n\tpath->size = to - path->ptr;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_find_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "683-701",
    "snippet": "int git_path_find_dir(git_buf *dir, const char *path, const char *base)\n{\n\tint error = git_path_join_unrooted(dir, path, base, NULL);\n\n\tif (!error) {\n\t\tchar buf[GIT_PATH_MAX];\n\t\tif (p_realpath(dir->ptr, buf) != NULL)\n\t\t\terror = git_buf_sets(dir, buf);\n\t}\n\n\t/* call dirname if this is not a directory */\n\tif (!error) /* && git_path_isdir(dir->ptr) == false) */\n\t\terror = (git_path_dirname_r(dir, dir->ptr) < 0) ? -1 : 0;\n\n\tif (!error)\n\t\terror = git_path_to_dir(dir);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "dir"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_dirname_r",
          "args": [
            "dir",
            "dir->ptr"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_dirname_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "117-178",
          "snippet": "int git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "dir",
            "buf"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_realpath",
          "args": [
            "dir->ptr",
            "buf"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "p_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/unix/realpath.c",
          "lines": "16-29",
          "snippet": "char *p_realpath(const char *pathname, char *resolved)\n{\n\tchar *ret;\n\tif ((ret = realpath(pathname, resolved)) == NULL)\n\t\treturn NULL;\n\n#ifdef __OpenBSD__\n\t/* The OpenBSD realpath function behaves differently,\n\t * figure out if the file exists */\n\tif (access(ret, F_OK) < 0)\n\t\tret = NULL;\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <git2/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <git2/common.h>\n\nchar *p_realpath(const char *pathname, char *resolved)\n{\n\tchar *ret;\n\tif ((ret = realpath(pathname, resolved)) == NULL)\n\t\treturn NULL;\n\n#ifdef __OpenBSD__\n\t/* The OpenBSD realpath function behaves differently,\n\t * figure out if the file exists */\n\tif (access(ret, F_OK) < 0)\n\t\tret = NULL;\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_join_unrooted",
          "args": [
            "dir",
            "path",
            "base",
            "NULL"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_join_unrooted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "279-307",
          "snippet": "int git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_find_dir(git_buf *dir, const char *path, const char *base)\n{\n\tint error = git_path_join_unrooted(dir, path, base, NULL);\n\n\tif (!error) {\n\t\tchar buf[GIT_PATH_MAX];\n\t\tif (p_realpath(dir->ptr, buf) != NULL)\n\t\t\terror = git_buf_sets(dir, buf);\n\t}\n\n\t/* call dirname if this is not a directory */\n\tif (!error) /* && git_path_isdir(dir->ptr) == false) */\n\t\terror = (git_path_dirname_r(dir, dir->ptr) < 0) ? -1 : 0;\n\n\tif (!error)\n\t\terror = git_path_to_dir(dir);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_path_contains_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "678-681",
    "snippet": "bool git_path_contains_file(git_buf *base, const char *file)\n{\n\treturn _check_dir_contents(base, file, &git_path_isfile);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_check_dir_contents",
          "args": [
            "base",
            "file",
            "&git_path_isfile"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "_check_dir_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "642-666",
          "snippet": "static bool _check_dir_contents(\n\tgit_buf *dir,\n\tconst char *sub,\n\tbool (*predicate)(const char *))\n{\n\tbool result;\n\tsize_t dir_size = git_buf_len(dir);\n\tsize_t sub_size = strlen(sub);\n\tsize_t alloc_size;\n\n\t/* leave base valid even if we could not make space for subdir */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, dir_size, sub_size) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloc_size, alloc_size, 2) ||\n\t\tgit_buf_try_grow(dir, alloc_size, false) < 0)\n\t\treturn false;\n\n\t/* save excursion */\n\tgit_buf_joinpath(dir, dir->ptr, sub);\n\n\tresult = predicate(dir->ptr);\n\n\t/* restore path */\n\tgit_buf_truncate(dir, dir_size);\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool _check_dir_contents(\n\tgit_buf *dir,\n\tconst char *sub,\n\tbool (*predicate)(const char *))\n{\n\tbool result;\n\tsize_t dir_size = git_buf_len(dir);\n\tsize_t sub_size = strlen(sub);\n\tsize_t alloc_size;\n\n\t/* leave base valid even if we could not make space for subdir */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, dir_size, sub_size) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloc_size, alloc_size, 2) ||\n\t\tgit_buf_try_grow(dir, alloc_size, false) < 0)\n\t\treturn false;\n\n\t/* save excursion */\n\tgit_buf_joinpath(dir, dir->ptr, sub);\n\n\tresult = predicate(dir->ptr);\n\n\t/* restore path */\n\tgit_buf_truncate(dir, dir_size);\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_contains_file(git_buf *base, const char *file)\n{\n\treturn _check_dir_contents(base, file, &git_path_isfile);\n}"
  },
  {
    "function_name": "git_path_contains_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "673-676",
    "snippet": "bool git_path_contains_dir(git_buf *base, const char *subdir)\n{\n\treturn _check_dir_contents(base, subdir, &git_path_isdir);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_check_dir_contents",
          "args": [
            "base",
            "subdir",
            "&git_path_isdir"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "_check_dir_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "642-666",
          "snippet": "static bool _check_dir_contents(\n\tgit_buf *dir,\n\tconst char *sub,\n\tbool (*predicate)(const char *))\n{\n\tbool result;\n\tsize_t dir_size = git_buf_len(dir);\n\tsize_t sub_size = strlen(sub);\n\tsize_t alloc_size;\n\n\t/* leave base valid even if we could not make space for subdir */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, dir_size, sub_size) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloc_size, alloc_size, 2) ||\n\t\tgit_buf_try_grow(dir, alloc_size, false) < 0)\n\t\treturn false;\n\n\t/* save excursion */\n\tgit_buf_joinpath(dir, dir->ptr, sub);\n\n\tresult = predicate(dir->ptr);\n\n\t/* restore path */\n\tgit_buf_truncate(dir, dir_size);\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool _check_dir_contents(\n\tgit_buf *dir,\n\tconst char *sub,\n\tbool (*predicate)(const char *))\n{\n\tbool result;\n\tsize_t dir_size = git_buf_len(dir);\n\tsize_t sub_size = strlen(sub);\n\tsize_t alloc_size;\n\n\t/* leave base valid even if we could not make space for subdir */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, dir_size, sub_size) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloc_size, alloc_size, 2) ||\n\t\tgit_buf_try_grow(dir, alloc_size, false) < 0)\n\t\treturn false;\n\n\t/* save excursion */\n\tgit_buf_joinpath(dir, dir->ptr, sub);\n\n\tresult = predicate(dir->ptr);\n\n\t/* restore path */\n\tgit_buf_truncate(dir, dir_size);\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_contains_dir(git_buf *base, const char *subdir)\n{\n\treturn _check_dir_contents(base, subdir, &git_path_isdir);\n}"
  },
  {
    "function_name": "git_path_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "668-671",
    "snippet": "bool git_path_contains(git_buf *dir, const char *item)\n{\n\treturn _check_dir_contents(dir, item, &git_path_exists);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_check_dir_contents",
          "args": [
            "dir",
            "item",
            "&git_path_exists"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "_check_dir_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "642-666",
          "snippet": "static bool _check_dir_contents(\n\tgit_buf *dir,\n\tconst char *sub,\n\tbool (*predicate)(const char *))\n{\n\tbool result;\n\tsize_t dir_size = git_buf_len(dir);\n\tsize_t sub_size = strlen(sub);\n\tsize_t alloc_size;\n\n\t/* leave base valid even if we could not make space for subdir */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, dir_size, sub_size) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloc_size, alloc_size, 2) ||\n\t\tgit_buf_try_grow(dir, alloc_size, false) < 0)\n\t\treturn false;\n\n\t/* save excursion */\n\tgit_buf_joinpath(dir, dir->ptr, sub);\n\n\tresult = predicate(dir->ptr);\n\n\t/* restore path */\n\tgit_buf_truncate(dir, dir_size);\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool _check_dir_contents(\n\tgit_buf *dir,\n\tconst char *sub,\n\tbool (*predicate)(const char *))\n{\n\tbool result;\n\tsize_t dir_size = git_buf_len(dir);\n\tsize_t sub_size = strlen(sub);\n\tsize_t alloc_size;\n\n\t/* leave base valid even if we could not make space for subdir */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, dir_size, sub_size) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloc_size, alloc_size, 2) ||\n\t\tgit_buf_try_grow(dir, alloc_size, false) < 0)\n\t\treturn false;\n\n\t/* save excursion */\n\tgit_buf_joinpath(dir, dir->ptr, sub);\n\n\tresult = predicate(dir->ptr);\n\n\t/* restore path */\n\tgit_buf_truncate(dir, dir_size);\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_contains(git_buf *dir, const char *item)\n{\n\treturn _check_dir_contents(dir, item, &git_path_exists);\n}"
  },
  {
    "function_name": "_check_dir_contents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "642-666",
    "snippet": "static bool _check_dir_contents(\n\tgit_buf *dir,\n\tconst char *sub,\n\tbool (*predicate)(const char *))\n{\n\tbool result;\n\tsize_t dir_size = git_buf_len(dir);\n\tsize_t sub_size = strlen(sub);\n\tsize_t alloc_size;\n\n\t/* leave base valid even if we could not make space for subdir */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, dir_size, sub_size) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloc_size, alloc_size, 2) ||\n\t\tgit_buf_try_grow(dir, alloc_size, false) < 0)\n\t\treturn false;\n\n\t/* save excursion */\n\tgit_buf_joinpath(dir, dir->ptr, sub);\n\n\tresult = predicate(dir->ptr);\n\n\t/* restore path */\n\tgit_buf_truncate(dir, dir_size);\n\treturn result;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "dir",
            "dir_size"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "predicate",
          "args": [
            "dir->ptr"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "dir",
            "dir->ptr",
            "sub"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_try_grow",
          "args": [
            "dir",
            "alloc_size",
            "false"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_try_grow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "35-99",
          "snippet": "int git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];",
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\nchar git_buf__oom[1];\n\nint git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloc_size",
            "alloc_size",
            "2"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloc_size",
            "dir_size",
            "sub_size"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sub"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "dir"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool _check_dir_contents(\n\tgit_buf *dir,\n\tconst char *sub,\n\tbool (*predicate)(const char *))\n{\n\tbool result;\n\tsize_t dir_size = git_buf_len(dir);\n\tsize_t sub_size = strlen(sub);\n\tsize_t alloc_size;\n\n\t/* leave base valid even if we could not make space for subdir */\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_size, dir_size, sub_size) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloc_size, alloc_size, 2) ||\n\t\tgit_buf_try_grow(dir, alloc_size, false) < 0)\n\t\treturn false;\n\n\t/* save excursion */\n\tgit_buf_joinpath(dir, dir->ptr, sub);\n\n\tresult = predicate(dir->ptr);\n\n\t/* restore path */\n\tgit_buf_truncate(dir, dir_size);\n\treturn result;\n}"
  },
  {
    "function_name": "git_path_lstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "634-640",
    "snippet": "int git_path_lstat(const char *path, struct stat *st)\n{\n\tif (p_lstat(path, st) == 0)\n\t\treturn 0;\n\n\treturn git_path_set_error(errno, path, \"stat\");\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_set_error",
          "args": [
            "errno",
            "path",
            "\"stat\""
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "611-632",
          "snippet": "int git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_lstat",
          "args": [
            "path",
            "st"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "p_lstat_posixly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "208-211",
          "snippet": "int p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_lstat(const char *path, struct stat *st)\n{\n\tif (p_lstat(path, st) == 0)\n\t\treturn 0;\n\n\treturn git_path_set_error(errno, path, \"stat\");\n}"
  },
  {
    "function_name": "git_path_set_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "611-632",
    "snippet": "int git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not %s '%s'\"",
            "action",
            "path"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "git_path_is_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "591-607",
    "snippet": "bool git_path_is_empty_dir(const char *path)\n{\n\tint error;\n\tgit_buf dir = GIT_BUF_INIT;\n\n\tif (!git_path_isdir(path))\n\t\treturn false;\n\n\tif ((error = git_buf_sets(&dir, path)) != 0)\n\t\tgiterr_clear();\n\telse\n\t\terror = git_path_direach(&dir, 0, path_found_entry, NULL);\n\n\tgit_buf_free(&dir);\n\n\treturn !error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&dir"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_direach",
          "args": [
            "&dir",
            "0",
            "path_found_entry",
            "NULL"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_direach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1023-1094",
          "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&dir",
            "path"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "path"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_is_empty_dir(const char *path)\n{\n\tint error;\n\tgit_buf dir = GIT_BUF_INIT;\n\n\tif (!git_path_isdir(path))\n\t\treturn false;\n\n\tif ((error = git_buf_sets(&dir, path)) != 0)\n\t\tgiterr_clear();\n\telse\n\t\terror = git_path_direach(&dir, 0, path_found_entry, NULL);\n\n\tgit_buf_free(&dir);\n\n\treturn !error;\n}"
  },
  {
    "function_name": "path_found_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "585-589",
    "snippet": "static int path_found_entry(void *payload, git_buf *path)\n{\n\tGIT_UNUSED(payload);\n\treturn !git_path_is_dot_or_dotdot(path->ptr);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_is_dot_or_dotdot",
          "args": [
            "path->ptr"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_is_dot_or_dotdotW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "100-105",
          "snippet": "GIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int path_found_entry(void *payload, git_buf *path)\n{\n\tGIT_UNUSED(payload);\n\treturn !git_path_is_dot_or_dotdot(path->ptr);\n}"
  },
  {
    "function_name": "git_path_is_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "542-581",
    "snippet": "bool git_path_is_empty_dir(const char *path)\n{\n\tgit_win32_path filter_w;\n\tbool empty = false;\n\n\tif (git_win32__findfirstfile_filter(filter_w, path)) {\n\t\tWIN32_FIND_DATAW findData;\n\t\tHANDLE hFind = FindFirstFileW(filter_w, &findData);\n\n\t\t/* FindFirstFile will fail if there are no children to the given\n\t\t * path, which can happen if the given path is a file (and obviously\n\t\t * has no children) or if the given path is an empty mount point.\n\t\t * (Most directories have at least directory entries '.' and '..',\n\t\t * but ridiculously another volume mounted in another drive letter's\n\t\t * path space do not, and thus have nothing to enumerate.)  If\n\t\t * FindFirstFile fails, check if this is a directory-like thing\n\t\t * (a mount point).\n\t\t */\n\t\tif (hFind == INVALID_HANDLE_VALUE)\n\t\t\treturn git_path_isdir(path);\n\n\t\t/* If the find handle was created successfully, then it's a directory */\n\t\tempty = true;\n\n\t\tdo {\n\t\t\t/* Allow the enumeration to return . and .. and still be considered\n\t\t\t * empty. In the special case of drive roots (i.e. C:\\) where . and\n\t\t\t * .. do not occur, we can still consider the path to be an empty\n\t\t\t * directory if there's nothing there. */\n\t\t\tif (!git_path_is_dot_or_dotdotW(findData.cFileName)) {\n\t\t\t\tempty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (FindNextFileW(hFind, &findData));\n\n\t\tFindClose(hFind);\n\t}\n\n\treturn empty;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FindClose",
          "args": [
            "hFind"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FindNextFileW",
          "args": [
            "hFind",
            "&findData"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_is_dot_or_dotdotW",
          "args": [
            "findData.cFileName"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_is_dot_or_dotdotW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "100-105",
          "snippet": "GIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_path_is_dot_or_dotdotW(const wchar_t *name)\n{\n\treturn (name[0] == L'.' &&\n\t\t\t  (name[1] == L'\\0' ||\n\t\t\t\t(name[1] == L'.' && name[2] == L'\\0')));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "path"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindFirstFileW",
          "args": [
            "filter_w",
            "&findData"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32__findfirstfile_filter",
          "args": [
            "filter_w",
            "path"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__findfirstfile_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
          "lines": "18-43",
          "snippet": "bool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}",
          "includes": [
            "#include \"w32_util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_util.h\"\n\nbool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_is_empty_dir(const char *path)\n{\n\tgit_win32_path filter_w;\n\tbool empty = false;\n\n\tif (git_win32__findfirstfile_filter(filter_w, path)) {\n\t\tWIN32_FIND_DATAW findData;\n\t\tHANDLE hFind = FindFirstFileW(filter_w, &findData);\n\n\t\t/* FindFirstFile will fail if there are no children to the given\n\t\t * path, which can happen if the given path is a file (and obviously\n\t\t * has no children) or if the given path is an empty mount point.\n\t\t * (Most directories have at least directory entries '.' and '..',\n\t\t * but ridiculously another volume mounted in another drive letter's\n\t\t * path space do not, and thus have nothing to enumerate.)  If\n\t\t * FindFirstFile fails, check if this is a directory-like thing\n\t\t * (a mount point).\n\t\t */\n\t\tif (hFind == INVALID_HANDLE_VALUE)\n\t\t\treturn git_path_isdir(path);\n\n\t\t/* If the find handle was created successfully, then it's a directory */\n\t\tempty = true;\n\n\t\tdo {\n\t\t\t/* Allow the enumeration to return . and .. and still be considered\n\t\t\t * empty. In the special case of drive roots (i.e. C:\\) where . and\n\t\t\t * .. do not occur, we can still consider the path to be an empty\n\t\t\t * directory if there's nothing there. */\n\t\t\tif (!git_path_is_dot_or_dotdotW(findData.cFileName)) {\n\t\t\t\tempty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (FindNextFileW(hFind, &findData));\n\n\t\tFindClose(hFind);\n\t}\n\n\treturn empty;\n}"
  },
  {
    "function_name": "git_path_islink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "529-538",
    "snippet": "bool git_path_islink(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_lstat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISLNK(st.st_mode) != 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st.st_mode"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_lstat",
          "args": [
            "path",
            "&st"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "p_lstat_posixly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "208-211",
          "snippet": "int p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_islink(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_lstat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISLNK(st.st_mode) != 0;\n}"
  },
  {
    "function_name": "git_path_isfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "518-527",
    "snippet": "bool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "path",
            "&st"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}"
  },
  {
    "function_name": "git_path_isdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "509-516",
    "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "path",
            "&st"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
  },
  {
    "function_name": "git_path_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "503-507",
    "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_access",
          "args": [
            "path",
            "F_OK"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "p_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "574-582",
          "snippet": "int p_access(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _waccess(buf, mode & WIN32_MODE_MASK);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [
            "#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\n#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)\n\nint p_access(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _waccess(buf, mode & WIN32_MODE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
  },
  {
    "function_name": "git_path_walk_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "439-501",
    "snippet": "int git_path_walk_up(\n\tgit_buf *path,\n\tconst char *ceiling,\n\tint (*cb)(void *data, const char *),\n\tvoid *data)\n{\n\tint error = 0;\n\tgit_buf iter;\n\tssize_t stop = 0, scan;\n\tchar oldc = '\\0';\n\n\tassert(path && cb);\n\n\tif (ceiling != NULL) {\n\t\tif (git__prefixcmp(path->ptr, ceiling) == 0)\n\t\t\tstop = (ssize_t)strlen(ceiling);\n\t\telse\n\t\t\tstop = git_buf_len(path);\n\t}\n\tscan = git_buf_len(path);\n\n\t/* empty path: yield only once */\n\tif (!scan) {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t\treturn error;\n\t}\n\n\titer.ptr = path->ptr;\n\titer.size = git_buf_len(path);\n\titer.asize = path->asize;\n\n\twhile (scan >= stop) {\n\t\terror = cb(data, iter.ptr);\n\t\titer.ptr[scan] = oldc;\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\n\t\tscan = git_buf_rfind_next(&iter, '/');\n\t\tif (scan >= 0) {\n\t\t\tscan++;\n\t\t\toldc = iter.ptr[scan];\n\t\t\titer.size = scan;\n\t\t\titer.ptr[scan] = '\\0';\n\t\t}\n\t}\n\n\tif (scan >= 0)\n\t\titer.ptr[scan] = oldc;\n\n\t/* relative path: yield for the last component */\n\tif (!error && stop == 0 && iter.ptr[0] != '/') {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "data",
            "\"\""
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_load__cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "193-226",
          "snippet": "static int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_load__cb(void *_data, git_buf *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_load__cb(void *_data, git_buf *path);\n\nstatic int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rfind_next",
          "args": [
            "&iter",
            "'/'"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rfind_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "150-156",
          "snippet": "GIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "path"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ceiling"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "path->ptr",
            "ceiling"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path && cb"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_walk_up(\n\tgit_buf *path,\n\tconst char *ceiling,\n\tint (*cb)(void *data, const char *),\n\tvoid *data)\n{\n\tint error = 0;\n\tgit_buf iter;\n\tssize_t stop = 0, scan;\n\tchar oldc = '\\0';\n\n\tassert(path && cb);\n\n\tif (ceiling != NULL) {\n\t\tif (git__prefixcmp(path->ptr, ceiling) == 0)\n\t\t\tstop = (ssize_t)strlen(ceiling);\n\t\telse\n\t\t\tstop = git_buf_len(path);\n\t}\n\tscan = git_buf_len(path);\n\n\t/* empty path: yield only once */\n\tif (!scan) {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t\treturn error;\n\t}\n\n\titer.ptr = path->ptr;\n\titer.size = git_buf_len(path);\n\titer.asize = path->asize;\n\n\twhile (scan >= stop) {\n\t\terror = cb(data, iter.ptr);\n\t\titer.ptr[scan] = oldc;\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\n\t\tscan = git_buf_rfind_next(&iter, '/');\n\t\tif (scan >= 0) {\n\t\t\tscan++;\n\t\t\toldc = iter.ptr[scan];\n\t\t\titer.size = scan;\n\t\t\titer.ptr[scan] = '\\0';\n\t\t}\n\t}\n\n\tif (scan >= 0)\n\t\titer.ptr[scan] = oldc;\n\n\t/* relative path: yield for the last component */\n\tif (!error && stop == 0 && iter.ptr[0] != '/') {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_path_fromurl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "421-437",
    "snippet": "int git_path_fromurl(git_buf *local_path_out, const char *file_url)\n{\n\tint offset;\n\n\tassert(local_path_out && file_url);\n\n\tif ((offset = local_file_url_prefixlen(file_url)) < 0 ||\n\t\tfile_url[offset] == '\\0' || file_url[offset] == '/')\n\t\treturn error_invalid_local_file_uri(file_url);\n\n#ifndef GIT_WIN32\n\toffset--;\t/* A *nix absolute path starts with a forward slash */\n#endif\n\n\tgit_buf_clear(local_path_out);\n\treturn git__percent_decode(local_path_out, file_url + offset);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__percent_decode",
          "args": [
            "local_path_out",
            "file_url + offset"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "git__percent_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "361-394",
          "snippet": "int git__percent_decode(git_buf *decoded_out, const char *input)\n{\n\tint len, hi, lo, i;\n\tassert(decoded_out && input);\n\n\tlen = (int)strlen(input);\n\tgit_buf_clear(decoded_out);\n\n\tfor(i = 0; i < len; i++)\n\t{\n\t\tchar c = input[i];\n\n\t\tif (c != '%')\n\t\t\tgoto append;\n\n\t\tif (i >= len - 2)\n\t\t\tgoto append;\n\n\t\thi = git__fromhex(input[i + 1]);\n\t\tlo = git__fromhex(input[i + 2]);\n\n\t\tif (hi < 0 || lo < 0)\n\t\t\tgoto append;\n\n\t\tc = (char)(hi << 4 | lo);\n\t\ti += 2;\n\nappend:\n\t\tif (git_buf_putc(decoded_out, c) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git__percent_decode(git_buf *decoded_out, const char *input)\n{\n\tint len, hi, lo, i;\n\tassert(decoded_out && input);\n\n\tlen = (int)strlen(input);\n\tgit_buf_clear(decoded_out);\n\n\tfor(i = 0; i < len; i++)\n\t{\n\t\tchar c = input[i];\n\n\t\tif (c != '%')\n\t\t\tgoto append;\n\n\t\tif (i >= len - 2)\n\t\t\tgoto append;\n\n\t\thi = git__fromhex(input[i + 1]);\n\t\tlo = git__fromhex(input[i + 2]);\n\n\t\tif (hi < 0 || lo < 0)\n\t\t\tgoto append;\n\n\t\tc = (char)(hi << 4 | lo);\n\t\ti += 2;\n\nappend:\n\t\tif (git_buf_putc(decoded_out, c) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "local_path_out"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "error_invalid_local_file_uri",
          "args": [
            "file_url"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "error_invalid_local_file_uri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "396-400",
          "snippet": "static int error_invalid_local_file_uri(const char *uri)\n{\n\tgiterr_set(GITERR_CONFIG, \"'%s' is not a valid local file URI\", uri);\n\treturn -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int error_invalid_local_file_uri(const char *uri)\n{\n\tgiterr_set(GITERR_CONFIG, \"'%s' is not a valid local file URI\", uri);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_file_url_prefixlen",
          "args": [
            "file_url"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "local_file_url_prefixlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "402-414",
          "snippet": "static int local_file_url_prefixlen(const char *file_url)\n{\n\tint len = -1;\n\n\tif (git__prefixcmp(file_url, \"file://\") == 0) {\n\t\tif (file_url[7] == '/')\n\t\t\tlen = 8;\n\t\telse if (git__prefixcmp(file_url + 7, \"localhost/\") == 0)\n\t\t\tlen = 17;\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int local_file_url_prefixlen(const char *file_url)\n{\n\tint len = -1;\n\n\tif (git__prefixcmp(file_url, \"file://\") == 0) {\n\t\tif (file_url[7] == '/')\n\t\t\tlen = 8;\n\t\telse if (git__prefixcmp(file_url + 7, \"localhost/\") == 0)\n\t\t\tlen = 17;\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "local_path_out && file_url"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_fromurl(git_buf *local_path_out, const char *file_url)\n{\n\tint offset;\n\n\tassert(local_path_out && file_url);\n\n\tif ((offset = local_file_url_prefixlen(file_url)) < 0 ||\n\t\tfile_url[offset] == '\\0' || file_url[offset] == '/')\n\t\treturn error_invalid_local_file_uri(file_url);\n\n#ifndef GIT_WIN32\n\toffset--;\t/* A *nix absolute path starts with a forward slash */\n#endif\n\n\tgit_buf_clear(local_path_out);\n\treturn git__percent_decode(local_path_out, file_url + offset);\n}"
  },
  {
    "function_name": "git_path_is_local_file_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "416-419",
    "snippet": "bool git_path_is_local_file_url(const char *file_url)\n{\n\treturn (local_file_url_prefixlen(file_url) > 0);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_file_url_prefixlen",
          "args": [
            "file_url"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "local_file_url_prefixlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "402-414",
          "snippet": "static int local_file_url_prefixlen(const char *file_url)\n{\n\tint len = -1;\n\n\tif (git__prefixcmp(file_url, \"file://\") == 0) {\n\t\tif (file_url[7] == '/')\n\t\t\tlen = 8;\n\t\telse if (git__prefixcmp(file_url + 7, \"localhost/\") == 0)\n\t\t\tlen = 17;\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int local_file_url_prefixlen(const char *file_url)\n{\n\tint len = -1;\n\n\tif (git__prefixcmp(file_url, \"file://\") == 0) {\n\t\tif (file_url[7] == '/')\n\t\t\tlen = 8;\n\t\telse if (git__prefixcmp(file_url + 7, \"localhost/\") == 0)\n\t\t\tlen = 17;\n\t}\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_is_local_file_url(const char *file_url)\n{\n\treturn (local_file_url_prefixlen(file_url) > 0);\n}"
  },
  {
    "function_name": "local_file_url_prefixlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "402-414",
    "snippet": "static int local_file_url_prefixlen(const char *file_url)\n{\n\tint len = -1;\n\n\tif (git__prefixcmp(file_url, \"file://\") == 0) {\n\t\tif (file_url[7] == '/')\n\t\t\tlen = 8;\n\t\telse if (git__prefixcmp(file_url + 7, \"localhost/\") == 0)\n\t\t\tlen = 17;\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "file_url + 7",
            "\"localhost/\""
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int local_file_url_prefixlen(const char *file_url)\n{\n\tint len = -1;\n\n\tif (git__prefixcmp(file_url, \"file://\") == 0) {\n\t\tif (file_url[7] == '/')\n\t\t\tlen = 8;\n\t\telse if (git__prefixcmp(file_url + 7, \"localhost/\") == 0)\n\t\t\tlen = 17;\n\t}\n\n\treturn len;\n}"
  },
  {
    "function_name": "error_invalid_local_file_uri",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "396-400",
    "snippet": "static int error_invalid_local_file_uri(const char *uri)\n{\n\tgiterr_set(GITERR_CONFIG, \"'%s' is not a valid local file URI\", uri);\n\treturn -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"'%s' is not a valid local file URI\"",
            "uri"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic int error_invalid_local_file_uri(const char *uri)\n{\n\tgiterr_set(GITERR_CONFIG, \"'%s' is not a valid local file URI\", uri);\n\treturn -1;\n}"
  },
  {
    "function_name": "git__percent_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "361-394",
    "snippet": "int git__percent_decode(git_buf *decoded_out, const char *input)\n{\n\tint len, hi, lo, i;\n\tassert(decoded_out && input);\n\n\tlen = (int)strlen(input);\n\tgit_buf_clear(decoded_out);\n\n\tfor(i = 0; i < len; i++)\n\t{\n\t\tchar c = input[i];\n\n\t\tif (c != '%')\n\t\t\tgoto append;\n\n\t\tif (i >= len - 2)\n\t\t\tgoto append;\n\n\t\thi = git__fromhex(input[i + 1]);\n\t\tlo = git__fromhex(input[i + 2]);\n\n\t\tif (hi < 0 || lo < 0)\n\t\t\tgoto append;\n\n\t\tc = (char)(hi << 4 | lo);\n\t\ti += 2;\n\nappend:\n\t\tif (git_buf_putc(decoded_out, c) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "decoded_out",
            "c"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__fromhex",
          "args": [
            "input[i + 2]"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "git__fromhex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "408-411",
          "snippet": "GIT_INLINE(int) git__fromhex(char h)\n{\n\treturn from_hex[(unsigned char) h];\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(int) git__fromhex(char h)\n{\n\treturn from_hex[(unsigned char) h];\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "decoded_out"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "input"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "decoded_out && input"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git__percent_decode(git_buf *decoded_out, const char *input)\n{\n\tint len, hi, lo, i;\n\tassert(decoded_out && input);\n\n\tlen = (int)strlen(input);\n\tgit_buf_clear(decoded_out);\n\n\tfor(i = 0; i < len; i++)\n\t{\n\t\tchar c = input[i];\n\n\t\tif (c != '%')\n\t\t\tgoto append;\n\n\t\tif (i >= len - 2)\n\t\t\tgoto append;\n\n\t\thi = git__fromhex(input[i + 1]);\n\t\tlo = git__fromhex(input[i + 2]);\n\n\t\tif (hi < 0 || lo < 0)\n\t\t\tgoto append;\n\n\t\tc = (char)(hi << 4 | lo);\n\t\ti += 2;\n\nappend:\n\t\tif (git_buf_putc(decoded_out, c) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_string_to_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "351-359",
    "snippet": "void git_path_string_to_dir(char* path, size_t size)\n{\n\tsize_t end = strlen(path);\n\n\tif (end && path[end - 1] != '/' && end < size) {\n\t\tpath[end] = '/';\n\t\tpath[end + 1] = '\\0';\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_string_to_dir(char* path, size_t size)\n{\n\tsize_t end = strlen(path);\n\n\tif (end && path[end - 1] != '/' && end < size) {\n\t\tpath[end] = '/';\n\t\tpath[end + 1] = '\\0';\n\t}\n}"
  },
  {
    "function_name": "git_path_to_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "341-349",
    "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "path"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "path",
            "'/'"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "path"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
  },
  {
    "function_name": "git_path_prettify_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "335-339",
    "snippet": "int git_path_prettify_dir(git_buf *path_out, const char *path, const char *base)\n{\n\tint error = git_path_prettify(path_out, path, base);\n\treturn (error < 0) ? error : git_path_to_dir(path_out);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "path_out"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_prettify",
          "args": [
            "path_out",
            "path",
            "base"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_prettify_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "335-339",
          "snippet": "int git_path_prettify_dir(git_buf *path_out, const char *path, const char *base)\n{\n\tint error = git_path_prettify(path_out, path, base);\n\treturn (error < 0) ? error : git_path_to_dir(path_out);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_prettify_dir(git_buf *path_out, const char *path, const char *base)\n{\n\tint error = git_path_prettify(path_out, path, base);\n\treturn (error < 0) ? error : git_path_to_dir(path_out);\n}"
  },
  {
    "function_name": "git_path_prettify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "309-333",
    "snippet": "int git_path_prettify(git_buf *path_out, const char *path, const char *base)\n{\n\tchar buf[GIT_PATH_MAX];\n\n\tassert(path && path_out);\n\n\t/* construct path if needed */\n\tif (base != NULL && git_path_root(path) < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\t\tpath = path_out->ptr;\n\t}\n\n\tif (p_realpath(path, buf) == NULL) {\n\t\t/* giterr_set resets the errno when dealing with a GITERR_OS kind of error */\n\t\tint error = (errno == ENOENT || errno == ENOTDIR) ? GIT_ENOTFOUND : -1;\n\t\tgiterr_set(GITERR_OS, \"Failed to resolve path '%s'\", path);\n\n\t\tgit_buf_clear(path_out);\n\n\t\treturn error;\n\t}\n\n\treturn git_buf_sets(path_out, buf);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "path_out",
            "buf"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "path_out"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to resolve path '%s'\"",
            "path"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_realpath",
          "args": [
            "path",
            "buf"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "p_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/unix/realpath.c",
          "lines": "16-29",
          "snippet": "char *p_realpath(const char *pathname, char *resolved)\n{\n\tchar *ret;\n\tif ((ret = realpath(pathname, resolved)) == NULL)\n\t\treturn NULL;\n\n#ifdef __OpenBSD__\n\t/* The OpenBSD realpath function behaves differently,\n\t * figure out if the file exists */\n\tif (access(ret, F_OK) < 0)\n\t\tret = NULL;\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <git2/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <git2/common.h>\n\nchar *p_realpath(const char *pathname, char *resolved)\n{\n\tchar *ret;\n\tif ((ret = realpath(pathname, resolved)) == NULL)\n\t\treturn NULL;\n\n#ifdef __OpenBSD__\n\t/* The OpenBSD realpath function behaves differently,\n\t * figure out if the file exists */\n\tif (access(ret, F_OK) < 0)\n\t\tret = NULL;\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "path_out",
            "base",
            "path"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "path"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path && path_out"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_prettify(git_buf *path_out, const char *path, const char *base)\n{\n\tchar buf[GIT_PATH_MAX];\n\n\tassert(path && path_out);\n\n\t/* construct path if needed */\n\tif (base != NULL && git_path_root(path) < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\t\tpath = path_out->ptr;\n\t}\n\n\tif (p_realpath(path, buf) == NULL) {\n\t\t/* giterr_set resets the errno when dealing with a GITERR_OS kind of error */\n\t\tint error = (errno == ENOENT || errno == ENOTDIR) ? GIT_ENOTFOUND : -1;\n\t\tgiterr_set(GITERR_OS, \"Failed to resolve path '%s'\", path);\n\n\t\tgit_buf_clear(path_out);\n\n\t\treturn error;\n\t}\n\n\treturn git_buf_sets(path_out, buf);\n}"
  },
  {
    "function_name": "git_path_join_unrooted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "279-307",
    "snippet": "int git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_equal_or_prefixed",
          "args": [
            "base",
            "path",
            "&root"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_equal_or_prefixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "344-377",
          "snippet": "GIT_INLINE(int) git_path_equal_or_prefixed(\n\tconst char *parent,\n\tconst char *child,\n\tssize_t *prefixlen)\n{\n\tconst char *p = parent, *c = child;\n\tint lastslash = 0;\n\n\twhile (*p && *c) {\n\t\tlastslash = (*p == '/');\n\n\t\tif (*p++ != *c++)\n\t\t\treturn GIT_PATH_NOTEQUAL;\n\t}\n\n\tif (*p != '\\0')\n\t\treturn GIT_PATH_NOTEQUAL;\n\n\tif (*c == '\\0') {\n\t\tif (prefixlen)\n\t\t\t*prefixlen = p - parent;\n\n\t\treturn GIT_PATH_EQUAL;\n\t}\n\n\tif (*c == '/' || lastslash) {\n\t\tif (prefixlen)\n\t\t\t*prefixlen = (p - parent) - lastslash;\n\n\t\treturn GIT_PATH_PREFIX;\n\t}\n\n\treturn GIT_PATH_NOTEQUAL;\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_path_equal_or_prefixed(\n\tconst char *parent,\n\tconst char *child,\n\tssize_t *prefixlen)\n{\n\tconst char *p = parent, *c = child;\n\tint lastslash = 0;\n\n\twhile (*p && *c) {\n\t\tlastslash = (*p == '/');\n\n\t\tif (*p++ != *c++)\n\t\t\treturn GIT_PATH_NOTEQUAL;\n\t}\n\n\tif (*p != '\\0')\n\t\treturn GIT_PATH_NOTEQUAL;\n\n\tif (*c == '\\0') {\n\t\tif (prefixlen)\n\t\t\t*prefixlen = p - parent;\n\n\t\treturn GIT_PATH_EQUAL;\n\t}\n\n\tif (*c == '/' || lastslash) {\n\t\tif (prefixlen)\n\t\t\t*prefixlen = (p - parent) - lastslash;\n\n\t\treturn GIT_PATH_PREFIX;\n\t}\n\n\treturn GIT_PATH_NOTEQUAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "path_out",
            "path"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "base"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "path_out",
            "base",
            "path"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "path"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path && path_out"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_trim_slashes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "265-277",
    "snippet": "void git_path_trim_slashes(git_buf *path)\n{\n\tint ceiling = git_path_root(path->ptr) + 1;\n\tassert(ceiling >= 0);\n\n\twhile (path->size > (size_t)ceiling) {\n\t\tif (path->ptr[path->size-1] != '/')\n\t\t\tbreak;\n\n\t\tpath->ptr[path->size-1] = '\\0';\n\t\tpath->size--;\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ceiling >= 0"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "path->ptr"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_trim_slashes(git_buf *path)\n{\n\tint ceiling = git_path_root(path->ptr) + 1;\n\tassert(ceiling >= 0);\n\n\twhile (path->size > (size_t)ceiling) {\n\t\tif (path->ptr[path->size-1] != '/')\n\t\t\tbreak;\n\n\t\tpath->ptr[path->size-1] = '\\0';\n\t\tpath->size--;\n\t}\n}"
  },
  {
    "function_name": "git_path_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "238-263",
    "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOOKS_LIKE_DRIVE_PREFIX",
          "args": [
            "path"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
  },
  {
    "function_name": "git_path_topdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "220-236",
    "snippet": "const char *git_path_topdir(const char *path)\n{\n\tsize_t len;\n\tssize_t i;\n\n\tassert(path);\n\tlen = strlen(path);\n\n\tif (!len || path[len - 1] != '/')\n\t\treturn NULL;\n\n\tfor (i = (ssize_t)len - 2; i >= 0; --i)\n\t\tif (path[i] == '/')\n\t\t\tbreak;\n\n\treturn &path[i + 1];\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nconst char *git_path_topdir(const char *path)\n{\n\tsize_t len;\n\tssize_t i;\n\n\tassert(path);\n\tlen = strlen(path);\n\n\tif (!len || path[len - 1] != '/')\n\t\treturn NULL;\n\n\tfor (i = (ssize_t)len - 2; i >= 0; --i)\n\t\tif (path[i] == '/')\n\t\t\tbreak;\n\n\treturn &path[i + 1];\n}"
  },
  {
    "function_name": "git_path_basename_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "205-218",
    "snippet": "size_t git_path_basename_offset(git_buf *buffer)\n{\n\tssize_t slash;\n\n\tif (!buffer || buffer->size <= 0)\n\t\treturn 0;\n\n\tslash = git_buf_rfind_next(buffer, '/');\n\n\tif (slash >= 0 && buffer->ptr[slash] == '/')\n\t\treturn (size_t)(slash + 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_rfind_next",
          "args": [
            "buffer",
            "'/'"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rfind_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "150-156",
          "snippet": "GIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nsize_t git_path_basename_offset(git_buf *buffer)\n{\n\tssize_t slash;\n\n\tif (!buffer || buffer->size <= 0)\n\t\treturn 0;\n\n\tslash = git_buf_rfind_next(buffer, '/');\n\n\tif (slash >= 0 && buffer->ptr[slash] == '/')\n\t\treturn (size_t)(slash + 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_path_basename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "193-203",
    "snippet": "char *git_path_basename(const char *path)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *basename;\n\n\tgit_path_basename_r(&buf, path);\n\tbasename = git_buf_detach(&buf);\n\tgit_buf_free(&buf); /* avoid memleak if error occurs */\n\n\treturn basename;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&buf"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_basename_r",
          "args": [
            "&buf",
            "path"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_basename_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "72-111",
          "snippet": "int git_path_basename_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp, *startp;\n\tint len, result;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tstartp = \".\";\n\t\tlen\t\t= 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* All slashes becomes \"/\" */\n\tif (endp == path && *endp == '/') {\n\t\tstartp = \"/\";\n\t\tlen\t= 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Find the start of the base */\n\tstartp = endp;\n\twhile (startp > path && *(startp - 1) != '/')\n\t\tstartp--;\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - startp + 1);\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, startp, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_basename_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp, *startp;\n\tint len, result;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tstartp = \".\";\n\t\tlen\t\t= 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* All slashes becomes \"/\" */\n\tif (endp == path && *endp == '/') {\n\t\tstartp = \"/\";\n\t\tlen\t= 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Find the start of the base */\n\tstartp = endp;\n\twhile (startp > path && *(startp - 1) != '/')\n\t\tstartp--;\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - startp + 1);\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, startp, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nchar *git_path_basename(const char *path)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *basename;\n\n\tgit_path_basename_r(&buf, path);\n\tbasename = git_buf_detach(&buf);\n\tgit_buf_free(&buf); /* avoid memleak if error occurs */\n\n\treturn basename;\n}"
  },
  {
    "function_name": "git_path_dirname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "181-191",
    "snippet": "char *git_path_dirname(const char *path)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *dirname;\n\n\tgit_path_dirname_r(&buf, path);\n\tdirname = git_buf_detach(&buf);\n\tgit_buf_free(&buf); /* avoid memleak if error occurs */\n\n\treturn dirname;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&buf"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_dirname_r",
          "args": [
            "&buf",
            "path"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_dirname_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "117-178",
          "snippet": "int git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nchar *git_path_dirname(const char *path)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *dirname;\n\n\tgit_path_dirname_r(&buf, path);\n\tdirname = git_buf_detach(&buf);\n\tgit_buf_free(&buf); /* avoid memleak if error occurs */\n\n\treturn dirname;\n}"
  },
  {
    "function_name": "git_path_dirname_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "117-178",
    "snippet": "int git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "buffer",
            "path",
            "len"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "looks_like_network_computer_name",
          "args": [
            "path",
            "len"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "looks_like_network_computer_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "25-39",
          "snippet": "static bool looks_like_network_computer_name(const char *path, int pos)\n{\n\tif (pos < 3)\n\t\treturn false;\n\n\tif (path[0] != '/' || path[1] != '/')\n\t\treturn false;\n\n\twhile (pos-- > 2) {\n\t\tif (path[pos] == '/')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool looks_like_network_computer_name(const char *path, int pos)\n{\n\tif (pos < 3)\n\t\treturn false;\n\n\tif (path[0] != '/' || path[1] != '/')\n\t\treturn false;\n\n\twhile (pos-- > 2) {\n\t\tif (path[pos] == '/')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOOKS_LIKE_DRIVE_PREFIX",
          "args": [
            "path"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
  },
  {
    "function_name": "git_path_basename_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "72-111",
    "snippet": "int git_path_basename_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp, *startp;\n\tint len, result;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tstartp = \".\";\n\t\tlen\t\t= 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* All slashes becomes \"/\" */\n\tif (endp == path && *endp == '/') {\n\t\tstartp = \"/\";\n\t\tlen\t= 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Find the start of the base */\n\tstartp = endp;\n\twhile (startp > path && *(startp - 1) != '/')\n\t\tstartp--;\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - startp + 1);\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, startp, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "buffer",
            "startp",
            "len"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_basename_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp, *startp;\n\tint len, result;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tstartp = \".\";\n\t\tlen\t\t= 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* All slashes becomes \"/\" */\n\tif (endp == path && *endp == '/') {\n\t\tstartp = \"/\";\n\t\tlen\t= 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Find the start of the base */\n\tstartp = endp;\n\twhile (startp > path && *(startp - 1) != '/')\n\t\tstartp--;\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - startp + 1);\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, startp, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
  },
  {
    "function_name": "looks_like_network_computer_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
    "lines": "25-39",
    "snippet": "static bool looks_like_network_computer_name(const char *path, int pos)\n{\n\tif (pos < 3)\n\t\treturn false;\n\n\tif (path[0] != '/' || path[1] != '/')\n\t\treturn false;\n\n\twhile (pos-- > 2) {\n\t\tif (path[pos] == '/')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <dirent.h>",
      "#include \"win32/version.h\"",
      "#include \"win32/w32_util.h\"",
      "#include \"win32/w32_buffer.h\"",
      "#include \"win32/posix.h\"",
      "#include \"repository.h\"",
      "#include \"posix.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool looks_like_network_computer_name(const char *path, int pos)\n{\n\tif (pos < 3)\n\t\treturn false;\n\n\tif (path[0] != '/' || path[1] != '/')\n\t\treturn false;\n\n\twhile (pos-- > 2) {\n\t\tif (path[pos] == '/')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  }
]