[
  {
    "function_name": "git_blob_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "126-129",
    "snippet": "git_repository *git_blob_owner(const git_blob *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "(const git_object *)obj"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_blob_owner(const git_blob *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
  },
  {
    "function_name": "git_blob_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "121-124",
    "snippet": "const git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "(const git_object *)obj"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
  },
  {
    "function_name": "git_blob_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "116-119",
    "snippet": "void git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "(git_object *)obj"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
  },
  {
    "function_name": "git_blob_lookup_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "111-114",
    "snippet": "int git_blob_lookup_prefix(git_blob **out, git_repository *repo, const git_oid *id, size_t len)\n{\n\treturn git_object_lookup_prefix((git_object **)out, repo, id, len, GIT_OBJ_BLOB);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup_prefix",
          "args": [
            "(git_object **)out",
            "repo",
            "id",
            "len",
            "GIT_OBJ_BLOB"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "110-195",
          "snippet": "int git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_blob_lookup_prefix(git_blob **out, git_repository *repo, const git_oid *id, size_t len)\n{\n\treturn git_object_lookup_prefix((git_object **)out, repo, id, len, GIT_OBJ_BLOB);\n}"
  },
  {
    "function_name": "git_blob_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "106-109",
    "snippet": "int git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "(git_object **)out",
            "repo",
            "id",
            "GIT_OBJ_BLOB"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}"
  },
  {
    "function_name": "git_tag_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "98-101",
    "snippet": "git_repository *git_tag_owner(const git_tag *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "(const git_object *)obj"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_tag_owner(const git_tag *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
  },
  {
    "function_name": "git_tag_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "93-96",
    "snippet": "const git_oid *git_tag_id(const git_tag *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "(const git_object *)obj"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_tag_id(const git_tag *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
  },
  {
    "function_name": "git_tag_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "88-91",
    "snippet": "void git_tag_free(git_tag *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "(git_object *)obj"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tag_free(git_tag *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
  },
  {
    "function_name": "git_tag_lookup_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "83-86",
    "snippet": "int git_tag_lookup_prefix(git_tag **out, git_repository *repo, const git_oid *id, size_t len)\n{\n\treturn git_object_lookup_prefix((git_object **)out, repo, id, len, GIT_OBJ_TAG);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup_prefix",
          "args": [
            "(git_object **)out",
            "repo",
            "id",
            "len",
            "GIT_OBJ_TAG"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "110-195",
          "snippet": "int git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tag_lookup_prefix(git_tag **out, git_repository *repo, const git_oid *id, size_t len)\n{\n\treturn git_object_lookup_prefix((git_object **)out, repo, id, len, GIT_OBJ_TAG);\n}"
  },
  {
    "function_name": "git_tag_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "78-81",
    "snippet": "int git_tag_lookup(git_tag **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TAG);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "(git_object **)out",
            "repo",
            "id",
            "GIT_OBJ_TAG"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tag_lookup(git_tag **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TAG);\n}"
  },
  {
    "function_name": "git_tree_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "69-72",
    "snippet": "git_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "(const git_object *)obj"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
  },
  {
    "function_name": "git_tree_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "64-67",
    "snippet": "const git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "(const git_object *)obj"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
  },
  {
    "function_name": "git_tree_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "59-62",
    "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "(git_object *)obj"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
  },
  {
    "function_name": "git_tree_lookup_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "54-57",
    "snippet": "int git_tree_lookup_prefix(git_tree **out, git_repository *repo, const git_oid *id, size_t len)\n{\n\treturn git_object_lookup_prefix((git_object **)out, repo, id, len, GIT_OBJ_TREE);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup_prefix",
          "args": [
            "(git_object **)out",
            "repo",
            "id",
            "len",
            "GIT_OBJ_TREE"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "110-195",
          "snippet": "int git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tree_lookup_prefix(git_tree **out, git_repository *repo, const git_oid *id, size_t len)\n{\n\treturn git_object_lookup_prefix((git_object **)out, repo, id, len, GIT_OBJ_TREE);\n}"
  },
  {
    "function_name": "git_tree_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "49-52",
    "snippet": "int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "(git_object **)out",
            "repo",
            "id",
            "GIT_OBJ_TREE"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}"
  },
  {
    "function_name": "git_commit_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "40-43",
    "snippet": "git_repository *git_commit_owner(const git_commit *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "(const git_object *)obj"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_commit_owner(const git_commit *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
  },
  {
    "function_name": "git_commit_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "35-38",
    "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "(const git_object *)obj"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
  },
  {
    "function_name": "git_commit_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "30-33",
    "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "(git_object *)obj"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
  },
  {
    "function_name": "git_commit_lookup_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "25-28",
    "snippet": "int git_commit_lookup_prefix(git_commit **out, git_repository *repo, const git_oid *id, size_t len)\n{\n\treturn git_object_lookup_prefix((git_object **)out, repo, id, len, GIT_OBJ_COMMIT);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup_prefix",
          "args": [
            "(git_object **)out",
            "repo",
            "id",
            "len",
            "GIT_OBJ_COMMIT"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "110-195",
          "snippet": "int git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup_prefix(git_commit **out, git_repository *repo, const git_oid *id, size_t len)\n{\n\treturn git_object_lookup_prefix((git_object **)out, repo, id, len, GIT_OBJ_COMMIT);\n}"
  },
  {
    "function_name": "git_commit_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
    "lines": "20-23",
    "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "(git_object **)out",
            "repo",
            "id",
            "GIT_OBJ_COMMIT"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
  }
]