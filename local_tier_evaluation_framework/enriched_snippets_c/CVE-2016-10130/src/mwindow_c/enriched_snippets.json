[
  {
    "function_name": "git_mwindow_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "416-429",
    "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_THREAD",
            "\"unable to lock mwindow mutex\""
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
  },
  {
    "function_name": "git_mwindow_file_deregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "397-414",
    "snippet": "void git_mwindow_file_deregister(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow_file *cur;\n\tsize_t i;\n\n\tif (git_mutex_lock(&git__mwindow_mutex))\n\t\treturn;\n\n\tgit_vector_foreach(&ctl->windowfiles, i, cur) {\n\t\tif (cur == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\treturn;\n\t\t}\n\t}\n\tgit_mutex_unlock(&git__mwindow_mutex);\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_mwindow_ctl mem_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_remove",
          "args": [
            "&ctl->windowfiles",
            "i"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "233-250",
          "snippet": "int git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&ctl->windowfiles",
            "i",
            "cur"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nvoid git_mwindow_file_deregister(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow_file *cur;\n\tsize_t i;\n\n\tif (git_mutex_lock(&git__mwindow_mutex))\n\t\treturn;\n\n\tgit_vector_foreach(&ctl->windowfiles, i, cur) {\n\t\tif (cur == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\treturn;\n\t\t}\n\t}\n\tgit_mutex_unlock(&git__mwindow_mutex);\n}"
  },
  {
    "function_name": "git_mwindow_file_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "375-395",
    "snippet": "int git_mwindow_file_register(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tint ret;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tif (ctl->windowfiles.length == 0 &&\n\t    git_vector_init(&ctl->windowfiles, 8, NULL) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn -1;\n\t}\n\n\tret = git_vector_insert(&ctl->windowfiles, mwf);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_mwindow_ctl mem_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&ctl->windowfiles",
            "mwf"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&ctl->windowfiles",
            "8",
            "NULL"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_THREAD",
            "\"unable to lock mwindow mutex\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nint git_mwindow_file_register(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tint ret;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tif (ctl->windowfiles.length == 0 &&\n\t    git_vector_init(&ctl->windowfiles, 8, NULL) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn -1;\n\t}\n\n\tret = git_vector_insert(&ctl->windowfiles, mwf);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "git_mwindow_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "318-373",
    "snippet": "unsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_mwindow_ctl mem_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_window",
          "args": [
            "mwf",
            "mwf->fd",
            "mwf->size",
            "offset"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "new_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "253-312",
          "snippet": "static git_mwindow *new_window(\n\tgit_mwindow_file *mwf,\n\tgit_file fd,\n\tgit_off_t size,\n\tgit_off_t offset)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t walign = git_mwindow__window_size / 2;\n\tgit_off_t len;\n\tgit_mwindow *w;\n\n\tw = git__malloc(sizeof(*w));\n\n\tif (w == NULL)\n\t\treturn NULL;\n\n\tmemset(w, 0x0, sizeof(*w));\n\tw->offset = (offset / walign) * walign;\n\n\tlen = size - w->offset;\n\tif (len > (git_off_t)git_mwindow__window_size)\n\t\tlen = (git_off_t)git_mwindow__window_size;\n\n\tctl->mapped += (size_t)len;\n\n\twhile (git_mwindow__mapped_limit < ctl->mapped &&\n\t\t\tgit_mwindow_close_lru(mwf) == 0) /* nop */;\n\n\t/*\n\t * We treat `mapped_limit` as a soft limit. If we can't find a\n\t * window to close and are above the limit, we still mmap the new\n\t * window.\n\t */\n\n\tif (git_futils_mmap_ro(&w->window_map, fd, w->offset, (size_t)len) < 0) {\n\t\t/*\n\t\t * The first error might be down to memory fragmentation even if\n\t\t * we're below our soft limits, so free up what we can and try again.\n\t\t */\n\n\t\twhile (git_mwindow_close_lru(mwf) == 0)\n\t\t\t/* nop */;\n\n\t\tif (git_futils_mmap_ro(&w->window_map, fd, w->offset, (size_t)len) < 0) {\n\t\t\tgit__free(w);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tctl->mmap_calls++;\n\tctl->open_windows++;\n\n\tif (ctl->mapped > ctl->peak_mapped)\n\t\tctl->peak_mapped = ctl->mapped;\n\n\tif (ctl->open_windows > ctl->peak_open_windows)\n\t\tctl->peak_open_windows = ctl->open_windows;\n\n\treturn w;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "size_t git_mwindow__window_size = DEFAULT_WINDOW_SIZE;",
            "size_t git_mwindow__mapped_limit = DEFAULT_MAPPED_LIMIT;",
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nsize_t git_mwindow__window_size = DEFAULT_WINDOW_SIZE;\nsize_t git_mwindow__mapped_limit = DEFAULT_MAPPED_LIMIT;\nstatic git_mwindow_ctl mem_ctl;\n\nstatic git_mwindow *new_window(\n\tgit_mwindow_file *mwf,\n\tgit_file fd,\n\tgit_off_t size,\n\tgit_off_t offset)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t walign = git_mwindow__window_size / 2;\n\tgit_off_t len;\n\tgit_mwindow *w;\n\n\tw = git__malloc(sizeof(*w));\n\n\tif (w == NULL)\n\t\treturn NULL;\n\n\tmemset(w, 0x0, sizeof(*w));\n\tw->offset = (offset / walign) * walign;\n\n\tlen = size - w->offset;\n\tif (len > (git_off_t)git_mwindow__window_size)\n\t\tlen = (git_off_t)git_mwindow__window_size;\n\n\tctl->mapped += (size_t)len;\n\n\twhile (git_mwindow__mapped_limit < ctl->mapped &&\n\t\t\tgit_mwindow_close_lru(mwf) == 0) /* nop */;\n\n\t/*\n\t * We treat `mapped_limit` as a soft limit. If we can't find a\n\t * window to close and are above the limit, we still mmap the new\n\t * window.\n\t */\n\n\tif (git_futils_mmap_ro(&w->window_map, fd, w->offset, (size_t)len) < 0) {\n\t\t/*\n\t\t * The first error might be down to memory fragmentation even if\n\t\t * we're below our soft limits, so free up what we can and try again.\n\t\t */\n\n\t\twhile (git_mwindow_close_lru(mwf) == 0)\n\t\t\t/* nop */;\n\n\t\tif (git_futils_mmap_ro(&w->window_map, fd, w->offset, (size_t)len) < 0) {\n\t\t\tgit__free(w);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tctl->mmap_calls++;\n\tctl->open_windows++;\n\n\tif (ctl->mapped > ctl->peak_mapped)\n\t\tctl->peak_mapped = ctl->mapped;\n\n\tif (ctl->open_windows > ctl->peak_open_windows)\n\t\tctl->peak_open_windows = ctl->open_windows;\n\n\treturn w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_contains",
          "args": [
            "w",
            "offset + extra"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "177-182",
          "snippet": "int git_mwindow_contains(git_mwindow *win, git_off_t offset)\n{\n\tgit_off_t win_off = win->offset;\n\treturn win_off <= offset\n\t\t&& offset <= (git_off_t)(win_off + win->window_map.len);\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nint git_mwindow_contains(git_mwindow *win, git_off_t offset)\n{\n\tgit_off_t win_off = win->offset;\n\treturn win_off <= offset\n\t\t&& offset <= (git_off_t)(win_off + win->window_map.len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_THREAD",
            "\"unable to lock mwindow mutex\""
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nunsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}"
  },
  {
    "function_name": "new_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "253-312",
    "snippet": "static git_mwindow *new_window(\n\tgit_mwindow_file *mwf,\n\tgit_file fd,\n\tgit_off_t size,\n\tgit_off_t offset)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t walign = git_mwindow__window_size / 2;\n\tgit_off_t len;\n\tgit_mwindow *w;\n\n\tw = git__malloc(sizeof(*w));\n\n\tif (w == NULL)\n\t\treturn NULL;\n\n\tmemset(w, 0x0, sizeof(*w));\n\tw->offset = (offset / walign) * walign;\n\n\tlen = size - w->offset;\n\tif (len > (git_off_t)git_mwindow__window_size)\n\t\tlen = (git_off_t)git_mwindow__window_size;\n\n\tctl->mapped += (size_t)len;\n\n\twhile (git_mwindow__mapped_limit < ctl->mapped &&\n\t\t\tgit_mwindow_close_lru(mwf) == 0) /* nop */;\n\n\t/*\n\t * We treat `mapped_limit` as a soft limit. If we can't find a\n\t * window to close and are above the limit, we still mmap the new\n\t * window.\n\t */\n\n\tif (git_futils_mmap_ro(&w->window_map, fd, w->offset, (size_t)len) < 0) {\n\t\t/*\n\t\t * The first error might be down to memory fragmentation even if\n\t\t * we're below our soft limits, so free up what we can and try again.\n\t\t */\n\n\t\twhile (git_mwindow_close_lru(mwf) == 0)\n\t\t\t/* nop */;\n\n\t\tif (git_futils_mmap_ro(&w->window_map, fd, w->offset, (size_t)len) < 0) {\n\t\t\tgit__free(w);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tctl->mmap_calls++;\n\tctl->open_windows++;\n\n\tif (ctl->mapped > ctl->peak_mapped)\n\t\tctl->peak_mapped = ctl->mapped;\n\n\tif (ctl->open_windows > ctl->peak_open_windows)\n\t\tctl->peak_open_windows = ctl->open_windows;\n\n\treturn w;\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "size_t git_mwindow__window_size = DEFAULT_WINDOW_SIZE;",
      "size_t git_mwindow__mapped_limit = DEFAULT_MAPPED_LIMIT;",
      "static git_mwindow_ctl mem_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "w"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mmap_ro",
          "args": [
            "&w->window_map",
            "fd",
            "w->offset",
            "(size_t)len"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mmap_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "269-272",
          "snippet": "int git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_close_lru",
          "args": [
            "mwf"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "215-250",
          "snippet": "static int git_mwindow_close_lru(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\tgit_mwindow *lru_w = NULL, *lru_l = NULL, **list = &mwf->windows;\n\n\t/* FIXME: Does this give us any advantage? */\n\tif(mwf->windows)\n\t\tgit_mwindow_scan_lru(mwf, &lru_w, &lru_l);\n\n\tfor (i = 0; i < ctl->windowfiles.length; ++i) {\n\t\tgit_mwindow *last = lru_w;\n\t\tgit_mwindow_file *cur = git_vector_get(&ctl->windowfiles, i);\n\t\tgit_mwindow_scan_lru(cur, &lru_w, &lru_l);\n\t\tif (lru_w != last)\n\t\t\tlist = &cur->windows;\n\t}\n\n\tif (!lru_w) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close memory window. Couldn't find LRU\");\n\t\treturn -1;\n\t}\n\n\tctl->mapped -= lru_w->window_map.len;\n\tgit_futils_mmap_free(&lru_w->window_map);\n\n\tif (lru_l)\n\t\tlru_l->next = lru_w->next;\n\telse\n\t\t*list = lru_w->next;\n\n\tgit__free(lru_w);\n\tctl->open_windows--;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nstatic int git_mwindow_close_lru(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\tgit_mwindow *lru_w = NULL, *lru_l = NULL, **list = &mwf->windows;\n\n\t/* FIXME: Does this give us any advantage? */\n\tif(mwf->windows)\n\t\tgit_mwindow_scan_lru(mwf, &lru_w, &lru_l);\n\n\tfor (i = 0; i < ctl->windowfiles.length; ++i) {\n\t\tgit_mwindow *last = lru_w;\n\t\tgit_mwindow_file *cur = git_vector_get(&ctl->windowfiles, i);\n\t\tgit_mwindow_scan_lru(cur, &lru_w, &lru_l);\n\t\tif (lru_w != last)\n\t\t\tlist = &cur->windows;\n\t}\n\n\tif (!lru_w) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close memory window. Couldn't find LRU\");\n\t\treturn -1;\n\t}\n\n\tctl->mapped -= lru_w->window_map.len;\n\tgit_futils_mmap_free(&lru_w->window_map);\n\n\tif (lru_l)\n\t\tlru_l->next = lru_w->next;\n\telse\n\t\t*list = lru_w->next;\n\n\tgit__free(lru_w);\n\tctl->open_windows--;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "w",
            "0x0",
            "sizeof(*w)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "sizeof(*w)"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nsize_t git_mwindow__window_size = DEFAULT_WINDOW_SIZE;\nsize_t git_mwindow__mapped_limit = DEFAULT_MAPPED_LIMIT;\nstatic git_mwindow_ctl mem_ctl;\n\nstatic git_mwindow *new_window(\n\tgit_mwindow_file *mwf,\n\tgit_file fd,\n\tgit_off_t size,\n\tgit_off_t offset)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t walign = git_mwindow__window_size / 2;\n\tgit_off_t len;\n\tgit_mwindow *w;\n\n\tw = git__malloc(sizeof(*w));\n\n\tif (w == NULL)\n\t\treturn NULL;\n\n\tmemset(w, 0x0, sizeof(*w));\n\tw->offset = (offset / walign) * walign;\n\n\tlen = size - w->offset;\n\tif (len > (git_off_t)git_mwindow__window_size)\n\t\tlen = (git_off_t)git_mwindow__window_size;\n\n\tctl->mapped += (size_t)len;\n\n\twhile (git_mwindow__mapped_limit < ctl->mapped &&\n\t\t\tgit_mwindow_close_lru(mwf) == 0) /* nop */;\n\n\t/*\n\t * We treat `mapped_limit` as a soft limit. If we can't find a\n\t * window to close and are above the limit, we still mmap the new\n\t * window.\n\t */\n\n\tif (git_futils_mmap_ro(&w->window_map, fd, w->offset, (size_t)len) < 0) {\n\t\t/*\n\t\t * The first error might be down to memory fragmentation even if\n\t\t * we're below our soft limits, so free up what we can and try again.\n\t\t */\n\n\t\twhile (git_mwindow_close_lru(mwf) == 0)\n\t\t\t/* nop */;\n\n\t\tif (git_futils_mmap_ro(&w->window_map, fd, w->offset, (size_t)len) < 0) {\n\t\t\tgit__free(w);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tctl->mmap_calls++;\n\tctl->open_windows++;\n\n\tif (ctl->mapped > ctl->peak_mapped)\n\t\tctl->peak_mapped = ctl->mapped;\n\n\tif (ctl->open_windows > ctl->peak_open_windows)\n\t\tctl->peak_open_windows = ctl->open_windows;\n\n\treturn w;\n}"
  },
  {
    "function_name": "git_mwindow_close_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "215-250",
    "snippet": "static int git_mwindow_close_lru(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\tgit_mwindow *lru_w = NULL, *lru_l = NULL, **list = &mwf->windows;\n\n\t/* FIXME: Does this give us any advantage? */\n\tif(mwf->windows)\n\t\tgit_mwindow_scan_lru(mwf, &lru_w, &lru_l);\n\n\tfor (i = 0; i < ctl->windowfiles.length; ++i) {\n\t\tgit_mwindow *last = lru_w;\n\t\tgit_mwindow_file *cur = git_vector_get(&ctl->windowfiles, i);\n\t\tgit_mwindow_scan_lru(cur, &lru_w, &lru_l);\n\t\tif (lru_w != last)\n\t\t\tlist = &cur->windows;\n\t}\n\n\tif (!lru_w) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close memory window. Couldn't find LRU\");\n\t\treturn -1;\n\t}\n\n\tctl->mapped -= lru_w->window_map.len;\n\tgit_futils_mmap_free(&lru_w->window_map);\n\n\tif (lru_l)\n\t\tlru_l->next = lru_w->next;\n\telse\n\t\t*list = lru_w->next;\n\n\tgit__free(lru_w);\n\tctl->open_windows--;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_mwindow_ctl mem_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "lru_w"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mmap_free",
          "args": [
            "&lru_w->window_map"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "294-297",
          "snippet": "void git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to close memory window. Couldn't find LRU\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_scan_lru",
          "args": [
            "cur",
            "&lru_w",
            "&lru_l"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_scan_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "187-208",
          "snippet": "static void git_mwindow_scan_lru(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **lru_w,\n\tgit_mwindow **lru_l)\n{\n\tgit_mwindow *w, *w_l;\n\n\tfor (w_l = NULL, w = mwf->windows; w; w = w->next) {\n\t\tif (!w->inuse_cnt) {\n\t\t\t/*\n\t\t\t * If the current one is more recent than the last one,\n\t\t\t * store it in the output parameter. If lru_w is NULL,\n\t\t\t * it's the first loop, so store it as well.\n\t\t\t */\n\t\t\tif (!*lru_w || w->last_used < (*lru_w)->last_used) {\n\t\t\t\t*lru_w = w;\n\t\t\t\t*lru_l = w_l;\n\t\t\t}\n\t\t}\n\t\tw_l = w;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic void git_mwindow_scan_lru(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **lru_w,\n\tgit_mwindow **lru_l)\n{\n\tgit_mwindow *w, *w_l;\n\n\tfor (w_l = NULL, w = mwf->windows; w; w = w->next) {\n\t\tif (!w->inuse_cnt) {\n\t\t\t/*\n\t\t\t * If the current one is more recent than the last one,\n\t\t\t * store it in the output parameter. If lru_w is NULL,\n\t\t\t * it's the first loop, so store it as well.\n\t\t\t */\n\t\t\tif (!*lru_w || w->last_used < (*lru_w)->last_used) {\n\t\t\t\t*lru_w = w;\n\t\t\t\t*lru_l = w_l;\n\t\t\t}\n\t\t}\n\t\tw_l = w;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&ctl->windowfiles",
            "i"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nstatic int git_mwindow_close_lru(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\tgit_mwindow *lru_w = NULL, *lru_l = NULL, **list = &mwf->windows;\n\n\t/* FIXME: Does this give us any advantage? */\n\tif(mwf->windows)\n\t\tgit_mwindow_scan_lru(mwf, &lru_w, &lru_l);\n\n\tfor (i = 0; i < ctl->windowfiles.length; ++i) {\n\t\tgit_mwindow *last = lru_w;\n\t\tgit_mwindow_file *cur = git_vector_get(&ctl->windowfiles, i);\n\t\tgit_mwindow_scan_lru(cur, &lru_w, &lru_l);\n\t\tif (lru_w != last)\n\t\t\tlist = &cur->windows;\n\t}\n\n\tif (!lru_w) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close memory window. Couldn't find LRU\");\n\t\treturn -1;\n\t}\n\n\tctl->mapped -= lru_w->window_map.len;\n\tgit_futils_mmap_free(&lru_w->window_map);\n\n\tif (lru_l)\n\t\tlru_l->next = lru_w->next;\n\telse\n\t\t*list = lru_w->next;\n\n\tgit__free(lru_w);\n\tctl->open_windows--;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_mwindow_scan_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "187-208",
    "snippet": "static void git_mwindow_scan_lru(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **lru_w,\n\tgit_mwindow **lru_l)\n{\n\tgit_mwindow *w, *w_l;\n\n\tfor (w_l = NULL, w = mwf->windows; w; w = w->next) {\n\t\tif (!w->inuse_cnt) {\n\t\t\t/*\n\t\t\t * If the current one is more recent than the last one,\n\t\t\t * store it in the output parameter. If lru_w is NULL,\n\t\t\t * it's the first loop, so store it as well.\n\t\t\t */\n\t\t\tif (!*lru_w || w->last_used < (*lru_w)->last_used) {\n\t\t\t\t*lru_w = w;\n\t\t\t\t*lru_l = w_l;\n\t\t\t}\n\t\t}\n\t\tw_l = w;\n\t}\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic void git_mwindow_scan_lru(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **lru_w,\n\tgit_mwindow **lru_l)\n{\n\tgit_mwindow *w, *w_l;\n\n\tfor (w_l = NULL, w = mwf->windows; w; w = w->next) {\n\t\tif (!w->inuse_cnt) {\n\t\t\t/*\n\t\t\t * If the current one is more recent than the last one,\n\t\t\t * store it in the output parameter. If lru_w is NULL,\n\t\t\t * it's the first loop, so store it as well.\n\t\t\t */\n\t\t\tif (!*lru_w || w->last_used < (*lru_w)->last_used) {\n\t\t\t\t*lru_w = w;\n\t\t\t\t*lru_l = w_l;\n\t\t\t}\n\t\t}\n\t\tw_l = w;\n\t}\n}"
  },
  {
    "function_name": "git_mwindow_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "177-182",
    "snippet": "int git_mwindow_contains(git_mwindow *win, git_off_t offset)\n{\n\tgit_off_t win_off = win->offset;\n\treturn win_off <= offset\n\t\t&& offset <= (git_off_t)(win_off + win->window_map.len);\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "win_off + win->window_map.len"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nint git_mwindow_contains(git_mwindow *win, git_off_t offset)\n{\n\tgit_off_t win_off = win->offset;\n\treturn win_off <= offset\n\t\t&& offset <= (git_off_t)(win_off + win->window_map.len);\n}"
  },
  {
    "function_name": "git_mwindow_free_all_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "140-172",
    "snippet": "void git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_mwindow_ctl mem_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "w"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mmap_free",
          "args": [
            "&w->window_map"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "294-297",
          "snippet": "void git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "w->inuse_cnt == 0"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&ctl->windowfiles"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_remove",
          "args": [
            "&ctl->windowfiles",
            "i"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "233-250",
          "snippet": "int git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&ctl->windowfiles",
            "i"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nvoid git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}"
  },
  {
    "function_name": "git_mwindow_free_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "124-134",
    "snippet": "void git_mwindow_free_all(git_mwindow_file *mwf)\n{\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn;\n\t}\n\n\tgit_mwindow_free_all_locked(mwf);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_free_all_locked",
          "args": [
            "mwf"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_free_all_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "140-172",
          "snippet": "void git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nvoid git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_THREAD",
            "\"unable to lock mwindow mutex\""
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_free_all(git_mwindow_file *mwf)\n{\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn;\n\t}\n\n\tgit_mwindow_free_all_locked(mwf);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n}"
  },
  {
    "function_name": "git_mwindow_put_pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "99-122",
    "snippet": "void git_mwindow_put_pack(struct git_pack_file *pack)\n{\n\tint count;\n\tgit_strmap_iter pos;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0)\n\t\treturn;\n\n\t/* put before get would be a corrupted state */\n\tassert(git__pack_cache);\n\n\tpos = git_strmap_lookup_index(git__pack_cache, pack->pack_name);\n\t/* if we cannot find it, the state is corrupted */\n\tassert(git_strmap_valid_index(git__pack_cache, pos));\n\n\tcount = git_atomic_dec(&pack->refcount);\n\tif (count == 0) {\n\t\tgit_strmap_delete_at(git__pack_cache, pos);\n\t\tgit_packfile_free(pack);\n\t}\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn;\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "git_strmap *git__pack_cache = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_free",
          "args": [
            "pack"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "988-1007",
          "snippet": "void git_packfile_free(struct git_pack_file *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tcache_free(&p->bases);\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mwindow_free_all_locked(&p->mwf);\n\t\tp_close(p->mwf.fd);\n\t}\n\n\tpack_index_free(p);\n\n\tgit__free(p->bad_object_sha1);\n\n\tgit_mutex_free(&p->lock);\n\tgit_mutex_free(&p->bases.lock);\n\tgit__free(p);\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nvoid git_packfile_free(struct git_pack_file *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tcache_free(&p->bases);\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mwindow_free_all_locked(&p->mwf);\n\t\tp_close(p->mwf.fd);\n\t}\n\n\tpack_index_free(p);\n\n\tgit__free(p->bad_object_sha1);\n\n\tgit_mutex_free(&p->lock);\n\tgit_mutex_free(&p->bases.lock);\n\tgit__free(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_delete_at",
          "args": [
            "git__pack_cache",
            "pos"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_atomic_dec",
          "args": [
            "&pack->refcount"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "182-185",
          "snippet": "GIT_INLINE(int) git_atomic_dec(git_atomic *a)\n{\n\treturn --a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_dec(git_atomic *a)\n{\n\treturn --a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_strmap_valid_index(git__pack_cache, pos)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "git__pack_cache",
            "pos"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "git__pack_cache",
            "pack->pack_name"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git__pack_cache"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\ngit_strmap *git__pack_cache = NULL;\n\nvoid git_mwindow_put_pack(struct git_pack_file *pack)\n{\n\tint count;\n\tgit_strmap_iter pos;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0)\n\t\treturn;\n\n\t/* put before get would be a corrupted state */\n\tassert(git__pack_cache);\n\n\tpos = git_strmap_lookup_index(git__pack_cache, pack->pack_name);\n\t/* if we cannot find it, the state is corrupted */\n\tassert(git_strmap_valid_index(git__pack_cache, pos));\n\n\tcount = git_atomic_dec(&pack->refcount);\n\tif (count == 0) {\n\t\tgit_strmap_delete_at(git__pack_cache, pos);\n\t\tgit_packfile_free(pack);\n\t}\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn;\n}"
  },
  {
    "function_name": "git_mwindow_get_pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "52-97",
    "snippet": "int git_mwindow_get_pack(struct git_pack_file **out, const char *path)\n{\n\tint error;\n\tchar *packname;\n\tgit_strmap_iter pos;\n\tstruct git_pack_file *pack;\n\n\tif ((error = git_packfile__name(&packname, path)) < 0)\n\t\treturn error;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tpos = git_strmap_lookup_index(git__pack_cache, packname);\n\tgit__free(packname);\n\n\tif (git_strmap_valid_index(git__pack_cache, pos)) {\n\t\tpack = git_strmap_value_at(git__pack_cache, pos);\n\t\tgit_atomic_inc(&pack->refcount);\n\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*out = pack;\n\t\treturn 0;\n\t}\n\n\t/* If we didn't find it, we need to create it */\n\tif ((error = git_packfile_alloc(&pack, path)) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn error;\n\t}\n\n\tgit_atomic_inc(&pack->refcount);\n\n\tgit_strmap_insert(git__pack_cache, pack->pack_name, pack, error);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\tif (error < 0) {\n\t\tgit_packfile_free(pack);\n\t\treturn -1;\n\t}\n\n\t*out = pack;\n\treturn 0;\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "git_strmap *git__pack_cache = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_packfile_free",
          "args": [
            "pack"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "988-1007",
          "snippet": "void git_packfile_free(struct git_pack_file *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tcache_free(&p->bases);\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mwindow_free_all_locked(&p->mwf);\n\t\tp_close(p->mwf.fd);\n\t}\n\n\tpack_index_free(p);\n\n\tgit__free(p->bad_object_sha1);\n\n\tgit_mutex_free(&p->lock);\n\tgit_mutex_free(&p->bases.lock);\n\tgit__free(p);\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nvoid git_packfile_free(struct git_pack_file *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tcache_free(&p->bases);\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mwindow_free_all_locked(&p->mwf);\n\t\tp_close(p->mwf.fd);\n\t}\n\n\tpack_index_free(p);\n\n\tgit__free(p->bad_object_sha1);\n\n\tgit_mutex_free(&p->lock);\n\tgit_mutex_free(&p->bases.lock);\n\tgit__free(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_insert",
          "args": [
            "git__pack_cache",
            "pack->pack_name",
            "pack",
            "error"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_atomic_inc",
          "args": [
            "&pack->refcount"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "171-174",
          "snippet": "GIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_alloc",
          "args": [
            "&pack",
            "path"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1107-1168",
          "snippet": "int git_packfile_alloc(struct git_pack_file **pack_out, const char *path)\n{\n\tstruct stat st;\n\tstruct git_pack_file *p;\n\tsize_t path_len = path ? strlen(path) : 0, alloc_len;\n\n\t*pack_out = NULL;\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*p), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tp = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(p);\n\n\tmemcpy(p->pack_name, path, path_len + 1);\n\n\t/*\n\t * Make sure a corresponding .pack file exists and that\n\t * the index looks sane.\n\t */\n\tif (git__suffixcmp(path, \".idx\") == 0) {\n\t\tsize_t root_len = path_len - strlen(\".idx\");\n\n\t\tmemcpy(p->pack_name + root_len, \".keep\", sizeof(\".keep\"));\n\t\tif (git_path_exists(p->pack_name) == true)\n\t\t\tp->pack_keep = 1;\n\n\t\tmemcpy(p->pack_name + root_len, \".pack\", sizeof(\".pack\"));\n\t}\n\n\tif (p_stat(p->pack_name, &st) < 0 || !S_ISREG(st.st_mode)) {\n\t\tgit__free(p);\n\t\treturn git_odb__error_notfound(\"packfile not found\", NULL, 0);\n\t}\n\n\t/* ok, it looks sane as far as we can check without\n\t * actually mapping the pack file.\n\t */\n\tp->mwf.fd = -1;\n\tp->mwf.size = st.st_size;\n\tp->pack_local = 1;\n\tp->mtime = (git_time_t)st.st_mtime;\n\tp->index_version = -1;\n\n\tif (git_mutex_init(&p->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize packfile mutex\");\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (cache_init(&p->bases) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*pack_out = p;\n\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_alloc(struct git_pack_file **pack_out, const char *path)\n{\n\tstruct stat st;\n\tstruct git_pack_file *p;\n\tsize_t path_len = path ? strlen(path) : 0, alloc_len;\n\n\t*pack_out = NULL;\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*p), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tp = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(p);\n\n\tmemcpy(p->pack_name, path, path_len + 1);\n\n\t/*\n\t * Make sure a corresponding .pack file exists and that\n\t * the index looks sane.\n\t */\n\tif (git__suffixcmp(path, \".idx\") == 0) {\n\t\tsize_t root_len = path_len - strlen(\".idx\");\n\n\t\tmemcpy(p->pack_name + root_len, \".keep\", sizeof(\".keep\"));\n\t\tif (git_path_exists(p->pack_name) == true)\n\t\t\tp->pack_keep = 1;\n\n\t\tmemcpy(p->pack_name + root_len, \".pack\", sizeof(\".pack\"));\n\t}\n\n\tif (p_stat(p->pack_name, &st) < 0 || !S_ISREG(st.st_mode)) {\n\t\tgit__free(p);\n\t\treturn git_odb__error_notfound(\"packfile not found\", NULL, 0);\n\t}\n\n\t/* ok, it looks sane as far as we can check without\n\t * actually mapping the pack file.\n\t */\n\tp->mwf.fd = -1;\n\tp->mwf.size = st.st_size;\n\tp->pack_local = 1;\n\tp->mtime = (git_time_t)st.st_mtime;\n\tp->index_version = -1;\n\n\tif (git_mutex_init(&p->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize packfile mutex\");\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (cache_init(&p->bases) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*pack_out = p;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "git__pack_cache",
            "pos"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "git__pack_cache",
            "pos"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "packname"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "git__pack_cache",
            "packname"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to lock mwindow mutex\""
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&git__mwindow_mutex"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile__name",
          "args": [
            "&packname",
            "path"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile__name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1090-1105",
          "snippet": "int git_packfile__name(char **out, const char *path)\n{\n\tsize_t path_len;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tpath_len = strlen(path);\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tif (git_buf_printf(&buf, \"%.*s.pack\", (int)(path_len - strlen(\".idx\")), path) < 0)\n\t\treturn -1;\n\n\t*out = git_buf_detach(&buf);\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nint git_packfile__name(char **out, const char *path)\n{\n\tsize_t path_len;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tpath_len = strlen(path);\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tif (git_buf_printf(&buf, \"%.*s.pack\", (int)(path_len - strlen(\".idx\")), path) < 0)\n\t\treturn -1;\n\n\t*out = git_buf_detach(&buf);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\ngit_strmap *git__pack_cache = NULL;\n\nint git_mwindow_get_pack(struct git_pack_file **out, const char *path)\n{\n\tint error;\n\tchar *packname;\n\tgit_strmap_iter pos;\n\tstruct git_pack_file *pack;\n\n\tif ((error = git_packfile__name(&packname, path)) < 0)\n\t\treturn error;\n\n\tif (git_mutex_lock(&git__mwindow_mutex) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tpos = git_strmap_lookup_index(git__pack_cache, packname);\n\tgit__free(packname);\n\n\tif (git_strmap_valid_index(git__pack_cache, pos)) {\n\t\tpack = git_strmap_value_at(git__pack_cache, pos);\n\t\tgit_atomic_inc(&pack->refcount);\n\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*out = pack;\n\t\treturn 0;\n\t}\n\n\t/* If we didn't find it, we need to create it */\n\tif ((error = git_packfile_alloc(&pack, path)) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn error;\n\t}\n\n\tgit_atomic_inc(&pack->refcount);\n\n\tgit_strmap_insert(git__pack_cache, pack->pack_name, pack, error);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\tif (error < 0) {\n\t\tgit_packfile_free(pack);\n\t\treturn -1;\n\t}\n\n\t*out = pack;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_mwindow_global_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "44-50",
    "snippet": "int git_mwindow_global_init(void)\n{\n\tassert(!git__pack_cache);\n\n\tgit__on_shutdown(git_mwindow_files_free);\n\treturn git_strmap_alloc(&git__pack_cache);\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "git_strmap *git__pack_cache = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_alloc",
          "args": [
            "&git__pack_cache"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__on_shutdown",
          "args": [
            "git_mwindow_files_free"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "git__on_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/global.c",
          "lines": "32-37",
          "snippet": "void git__on_shutdown(git_global_shutdown_fn callback)\n{\n\tint count = git_atomic_inc(&git__n_shutdown_callbacks);\n\tassert(count <= MAX_SHUTDOWN_CB && count > 0);\n\tgit__shutdown_callbacks[count - 1] = callback;\n}",
          "includes": [
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include \"win32/w32_stack.h\"",
            "#include \"transports/ssh.h\"",
            "#include \"git2/global.h\"",
            "#include \"thread-utils.h\"",
            "#include \"openssl_stream.h\"",
            "#include \"filter.h\"",
            "#include \"sysdir.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MAX_SHUTDOWN_CB 8"
          ],
          "globals_used": [
            "static git_global_shutdown_fn git__shutdown_callbacks[MAX_SHUTDOWN_CB];",
            "static git_atomic git__n_shutdown_callbacks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/w32_crtdbg_stacktrace.h\"\n#include \"win32/w32_stack.h\"\n#include \"transports/ssh.h\"\n#include \"git2/global.h\"\n#include \"thread-utils.h\"\n#include \"openssl_stream.h\"\n#include \"filter.h\"\n#include \"sysdir.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\n#define MAX_SHUTDOWN_CB 8\n\nstatic git_global_shutdown_fn git__shutdown_callbacks[MAX_SHUTDOWN_CB];\nstatic git_atomic git__n_shutdown_callbacks;\n\nvoid git__on_shutdown(git_global_shutdown_fn callback)\n{\n\tint count = git_atomic_inc(&git__n_shutdown_callbacks);\n\tassert(count <= MAX_SHUTDOWN_CB && count > 0);\n\tgit__shutdown_callbacks[count - 1] = callback;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!git__pack_cache"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\ngit_strmap *git__pack_cache = NULL;\n\nint git_mwindow_global_init(void)\n{\n\tassert(!git__pack_cache);\n\n\tgit__on_shutdown(git_mwindow_files_free);\n\treturn git_strmap_alloc(&git__pack_cache);\n}"
  },
  {
    "function_name": "git_mwindow_files_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
    "lines": "36-42",
    "snippet": "static void git_mwindow_files_free(void)\n{\n\tgit_strmap *tmp = git__pack_cache;\n\n\tgit__pack_cache = NULL;\n\tgit_strmap_free(tmp);\n}",
    "includes": [
      "#include \"pack.h\"",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"map.h\"",
      "#include \"fileops.h\"",
      "#include \"vector.h\"",
      "#include \"mwindow.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "git_strmap *git__pack_cache = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_free",
          "args": [
            "tmp"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\ngit_strmap *git__pack_cache = NULL;\n\nstatic void git_mwindow_files_free(void)\n{\n\tgit_strmap *tmp = git__pack_cache;\n\n\tgit__pack_cache = NULL;\n\tgit_strmap_free(tmp);\n}"
  }
]