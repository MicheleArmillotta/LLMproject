[
  {
    "function_name": "git_reset_from_annotated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reset.c",
    "lines": "192-199",
    "snippet": "int git_reset_from_annotated(\n\tgit_repository *repo,\n\tgit_annotated_commit *commit,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\treturn reset(repo, (git_object *) commit->commit, commit->ref_name, reset_type, checkout_opts);\n}",
    "includes": [
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset",
          "args": [
            "repo",
            "(git_object *) commit->commit",
            "commit->ref_name",
            "reset_type",
            "checkout_opts"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reset.c",
          "lines": "101-181",
          "snippet": "static int reset(\n\tgit_repository *repo,\n\tgit_object *target,\n\tconst char *to,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\tgit_object *commit = NULL;\n\tgit_index *index = NULL;\n\tgit_tree *tree = NULL;\n\tint error = 0;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\n\tassert(repo && target);\n\n\tif (checkout_opts)\n\t\topts = *checkout_opts;\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\"%s - The given target does not belong to this repository.\", ERROR_MSG);\n\t\treturn -1;\n\t}\n\n\tif (reset_type != GIT_RESET_SOFT &&\n\t\t(error = git_repository__ensure_not_bare(repo,\n\t\t\treset_type == GIT_RESET_MIXED ? \"reset mixed\" : \"reset hard\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_object_peel(&commit, target, GIT_OBJ_COMMIT)) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0 ||\n\t\t(error = git_commit_tree(&tree, (git_commit *)commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type == GIT_RESET_SOFT &&\n\t\t(git_repository_state(repo) == GIT_REPOSITORY_STATE_MERGE ||\n\t\t git_index_has_conflicts(index)))\n\t{\n\t\tgiterr_set(GITERR_OBJECT, \"%s (soft) in the middle of a merge.\", ERROR_MSG);\n\t\terror = GIT_EUNMERGED;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&log_message, \"reset: moving to %s\", to)) < 0)\n\t\treturn error;\n\n\tif (reset_type == GIT_RESET_HARD) {\n\t\t/* overwrite working directory with the new tree */\n\t\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\t\tif ((error = git_checkout_tree(repo, (git_object *)tree, &opts)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* move HEAD to the new target */\n\tif ((error = git_reference__update_terminal(repo, GIT_HEAD_FILE,\n\t\tgit_object_id(commit), NULL, git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type > GIT_RESET_SOFT) {\n\t\t/* reset index to the target content */\n\n\t\tif ((error = git_index_read_tree(index, tree)) < 0 ||\n\t\t\t(error = git_index_write(index)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_repository_state_cleanup(repo)) < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"%s - failed to clean up merge data\", ERROR_MSG);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tgit_object_free(commit);\n\tgit_index_free(index);\n\tgit_tree_free(tree);\n\tgit_buf_free(&log_message);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define ERROR_MSG \"Cannot perform reset\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"annotated_commit.h\"\n#include \"diff.h\"\n#include \"merge.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\n#define ERROR_MSG \"Cannot perform reset\"\n\nstatic int reset(\n\tgit_repository *repo,\n\tgit_object *target,\n\tconst char *to,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\tgit_object *commit = NULL;\n\tgit_index *index = NULL;\n\tgit_tree *tree = NULL;\n\tint error = 0;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\n\tassert(repo && target);\n\n\tif (checkout_opts)\n\t\topts = *checkout_opts;\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\"%s - The given target does not belong to this repository.\", ERROR_MSG);\n\t\treturn -1;\n\t}\n\n\tif (reset_type != GIT_RESET_SOFT &&\n\t\t(error = git_repository__ensure_not_bare(repo,\n\t\t\treset_type == GIT_RESET_MIXED ? \"reset mixed\" : \"reset hard\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_object_peel(&commit, target, GIT_OBJ_COMMIT)) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0 ||\n\t\t(error = git_commit_tree(&tree, (git_commit *)commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type == GIT_RESET_SOFT &&\n\t\t(git_repository_state(repo) == GIT_REPOSITORY_STATE_MERGE ||\n\t\t git_index_has_conflicts(index)))\n\t{\n\t\tgiterr_set(GITERR_OBJECT, \"%s (soft) in the middle of a merge.\", ERROR_MSG);\n\t\terror = GIT_EUNMERGED;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&log_message, \"reset: moving to %s\", to)) < 0)\n\t\treturn error;\n\n\tif (reset_type == GIT_RESET_HARD) {\n\t\t/* overwrite working directory with the new tree */\n\t\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\t\tif ((error = git_checkout_tree(repo, (git_object *)tree, &opts)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* move HEAD to the new target */\n\tif ((error = git_reference__update_terminal(repo, GIT_HEAD_FILE,\n\t\tgit_object_id(commit), NULL, git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type > GIT_RESET_SOFT) {\n\t\t/* reset index to the target content */\n\n\t\tif ((error = git_index_read_tree(index, tree)) < 0 ||\n\t\t\t(error = git_index_write(index)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_repository_state_cleanup(repo)) < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"%s - failed to clean up merge data\", ERROR_MSG);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tgit_object_free(commit);\n\tgit_index_free(index);\n\tgit_tree_free(tree);\n\tgit_buf_free(&log_message);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"annotated_commit.h\"\n#include \"diff.h\"\n#include \"merge.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_reset_from_annotated(\n\tgit_repository *repo,\n\tgit_annotated_commit *commit,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\treturn reset(repo, (git_object *) commit->commit, commit->ref_name, reset_type, checkout_opts);\n}"
  },
  {
    "function_name": "git_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reset.c",
    "lines": "183-190",
    "snippet": "int git_reset(\n\tgit_repository *repo,\n\tgit_object *target,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\treturn reset(repo, target, git_oid_tostr_s(git_object_id(target)), reset_type, checkout_opts);\n}",
    "includes": [
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset",
          "args": [
            "repo",
            "target",
            "git_oid_tostr_s(git_object_id(target))",
            "reset_type",
            "checkout_opts"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reset.c",
          "lines": "101-181",
          "snippet": "static int reset(\n\tgit_repository *repo,\n\tgit_object *target,\n\tconst char *to,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\tgit_object *commit = NULL;\n\tgit_index *index = NULL;\n\tgit_tree *tree = NULL;\n\tint error = 0;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\n\tassert(repo && target);\n\n\tif (checkout_opts)\n\t\topts = *checkout_opts;\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\"%s - The given target does not belong to this repository.\", ERROR_MSG);\n\t\treturn -1;\n\t}\n\n\tif (reset_type != GIT_RESET_SOFT &&\n\t\t(error = git_repository__ensure_not_bare(repo,\n\t\t\treset_type == GIT_RESET_MIXED ? \"reset mixed\" : \"reset hard\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_object_peel(&commit, target, GIT_OBJ_COMMIT)) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0 ||\n\t\t(error = git_commit_tree(&tree, (git_commit *)commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type == GIT_RESET_SOFT &&\n\t\t(git_repository_state(repo) == GIT_REPOSITORY_STATE_MERGE ||\n\t\t git_index_has_conflicts(index)))\n\t{\n\t\tgiterr_set(GITERR_OBJECT, \"%s (soft) in the middle of a merge.\", ERROR_MSG);\n\t\terror = GIT_EUNMERGED;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&log_message, \"reset: moving to %s\", to)) < 0)\n\t\treturn error;\n\n\tif (reset_type == GIT_RESET_HARD) {\n\t\t/* overwrite working directory with the new tree */\n\t\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\t\tif ((error = git_checkout_tree(repo, (git_object *)tree, &opts)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* move HEAD to the new target */\n\tif ((error = git_reference__update_terminal(repo, GIT_HEAD_FILE,\n\t\tgit_object_id(commit), NULL, git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type > GIT_RESET_SOFT) {\n\t\t/* reset index to the target content */\n\n\t\tif ((error = git_index_read_tree(index, tree)) < 0 ||\n\t\t\t(error = git_index_write(index)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_repository_state_cleanup(repo)) < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"%s - failed to clean up merge data\", ERROR_MSG);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tgit_object_free(commit);\n\tgit_index_free(index);\n\tgit_tree_free(tree);\n\tgit_buf_free(&log_message);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define ERROR_MSG \"Cannot perform reset\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"annotated_commit.h\"\n#include \"diff.h\"\n#include \"merge.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\n#define ERROR_MSG \"Cannot perform reset\"\n\nstatic int reset(\n\tgit_repository *repo,\n\tgit_object *target,\n\tconst char *to,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\tgit_object *commit = NULL;\n\tgit_index *index = NULL;\n\tgit_tree *tree = NULL;\n\tint error = 0;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\n\tassert(repo && target);\n\n\tif (checkout_opts)\n\t\topts = *checkout_opts;\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\"%s - The given target does not belong to this repository.\", ERROR_MSG);\n\t\treturn -1;\n\t}\n\n\tif (reset_type != GIT_RESET_SOFT &&\n\t\t(error = git_repository__ensure_not_bare(repo,\n\t\t\treset_type == GIT_RESET_MIXED ? \"reset mixed\" : \"reset hard\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_object_peel(&commit, target, GIT_OBJ_COMMIT)) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0 ||\n\t\t(error = git_commit_tree(&tree, (git_commit *)commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type == GIT_RESET_SOFT &&\n\t\t(git_repository_state(repo) == GIT_REPOSITORY_STATE_MERGE ||\n\t\t git_index_has_conflicts(index)))\n\t{\n\t\tgiterr_set(GITERR_OBJECT, \"%s (soft) in the middle of a merge.\", ERROR_MSG);\n\t\terror = GIT_EUNMERGED;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&log_message, \"reset: moving to %s\", to)) < 0)\n\t\treturn error;\n\n\tif (reset_type == GIT_RESET_HARD) {\n\t\t/* overwrite working directory with the new tree */\n\t\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\t\tif ((error = git_checkout_tree(repo, (git_object *)tree, &opts)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* move HEAD to the new target */\n\tif ((error = git_reference__update_terminal(repo, GIT_HEAD_FILE,\n\t\tgit_object_id(commit), NULL, git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type > GIT_RESET_SOFT) {\n\t\t/* reset index to the target content */\n\n\t\tif ((error = git_index_read_tree(index, tree)) < 0 ||\n\t\t\t(error = git_index_write(index)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_repository_state_cleanup(repo)) < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"%s - failed to clean up merge data\", ERROR_MSG);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tgit_object_free(commit);\n\tgit_index_free(index);\n\tgit_tree_free(tree);\n\tgit_buf_free(&log_message);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_tostr_s",
          "args": [
            "git_object_id(target)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_tostr_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "103-108",
          "snippet": "char *git_oid_tostr_s(const git_oid *oid)\n{\n\tchar *str = GIT_GLOBAL->oid_fmt;\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ + 1, oid);\n\treturn str;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nchar *git_oid_tostr_s(const git_oid *oid)\n{\n\tchar *str = GIT_GLOBAL->oid_fmt;\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ + 1, oid);\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "target"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"annotated_commit.h\"\n#include \"diff.h\"\n#include \"merge.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_reset(\n\tgit_repository *repo,\n\tgit_object *target,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\treturn reset(repo, target, git_oid_tostr_s(git_object_id(target)), reset_type, checkout_opts);\n}"
  },
  {
    "function_name": "reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reset.c",
    "lines": "101-181",
    "snippet": "static int reset(\n\tgit_repository *repo,\n\tgit_object *target,\n\tconst char *to,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\tgit_object *commit = NULL;\n\tgit_index *index = NULL;\n\tgit_tree *tree = NULL;\n\tint error = 0;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\n\tassert(repo && target);\n\n\tif (checkout_opts)\n\t\topts = *checkout_opts;\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\"%s - The given target does not belong to this repository.\", ERROR_MSG);\n\t\treturn -1;\n\t}\n\n\tif (reset_type != GIT_RESET_SOFT &&\n\t\t(error = git_repository__ensure_not_bare(repo,\n\t\t\treset_type == GIT_RESET_MIXED ? \"reset mixed\" : \"reset hard\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_object_peel(&commit, target, GIT_OBJ_COMMIT)) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0 ||\n\t\t(error = git_commit_tree(&tree, (git_commit *)commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type == GIT_RESET_SOFT &&\n\t\t(git_repository_state(repo) == GIT_REPOSITORY_STATE_MERGE ||\n\t\t git_index_has_conflicts(index)))\n\t{\n\t\tgiterr_set(GITERR_OBJECT, \"%s (soft) in the middle of a merge.\", ERROR_MSG);\n\t\terror = GIT_EUNMERGED;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&log_message, \"reset: moving to %s\", to)) < 0)\n\t\treturn error;\n\n\tif (reset_type == GIT_RESET_HARD) {\n\t\t/* overwrite working directory with the new tree */\n\t\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\t\tif ((error = git_checkout_tree(repo, (git_object *)tree, &opts)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* move HEAD to the new target */\n\tif ((error = git_reference__update_terminal(repo, GIT_HEAD_FILE,\n\t\tgit_object_id(commit), NULL, git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type > GIT_RESET_SOFT) {\n\t\t/* reset index to the target content */\n\n\t\tif ((error = git_index_read_tree(index, tree)) < 0 ||\n\t\t\t(error = git_index_write(index)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_repository_state_cleanup(repo)) < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"%s - failed to clean up merge data\", ERROR_MSG);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tgit_object_free(commit);\n\tgit_index_free(index);\n\tgit_tree_free(tree);\n\tgit_buf_free(&log_message);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define ERROR_MSG \"Cannot perform reset\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&log_message"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "tree"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "commit"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"%s - failed to clean up merge data\"",
            "ERROR_MSG"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_state_cleanup",
          "args": [
            "repo"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_state_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "2293-2298",
          "snippet": "int git_repository_state_cleanup(git_repository *repo)\n{\n\tassert(repo);\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *state_files[] = {\n\tGIT_MERGE_HEAD_FILE,\n\tGIT_MERGE_MODE_FILE,\n\tGIT_MERGE_MSG_FILE,\n\tGIT_REVERT_HEAD_FILE,\n\tGIT_CHERRYPICK_HEAD_FILE,\n\tGIT_BISECT_LOG_FILE,\n\tGIT_REBASE_MERGE_DIR,\n\tGIT_REBASE_APPLY_DIR,\n\tGIT_SEQUENCER_DIR,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic const char *state_files[] = {\n\tGIT_MERGE_HEAD_FILE,\n\tGIT_MERGE_MODE_FILE,\n\tGIT_MERGE_MSG_FILE,\n\tGIT_REVERT_HEAD_FILE,\n\tGIT_CHERRYPICK_HEAD_FILE,\n\tGIT_BISECT_LOG_FILE,\n\tGIT_REBASE_MERGE_DIR,\n\tGIT_REBASE_APPLY_DIR,\n\tGIT_SEQUENCER_DIR,\n};\n\nint git_repository_state_cleanup(git_repository *repo)\n{\n\tassert(repo);\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_write",
          "args": [
            "index"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "750-763",
          "snippet": "int git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_read_tree",
          "args": [
            "index",
            "tree"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_read_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2865-2926",
          "snippet": "int git_index_read_tree(git_index *index, const git_tree *tree)\n{\n\tint error = 0;\n\tgit_vector entries = GIT_VECTOR_INIT;\n\tgit_idxmap *entries_map;\n\tread_tree_data data;\n\tsize_t i;\n\tgit_index_entry *e;\n\n\tif (git_idxmap_alloc(&entries_map) < 0)\n\t\treturn -1;\n\n\tgit_vector_set_cmp(&entries, index->entries._cmp); /* match sort */\n\n\tdata.index = index;\n\tdata.old_entries = &index->entries;\n\tdata.new_entries = &entries;\n\tdata.entry_cmp   = index->entries_search;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_vector_sort(&index->entries);\n\n\tif ((error = git_tree_walk(tree, GIT_TREEWALK_POST, read_tree_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) entries_map, entries.length);\n\telse\n\t\tkh_resize(idx, entries_map, entries.length);\n\n\tgit_vector_foreach(&entries, i, e) {\n\t\tINSERT_IN_MAP_EX(index, entries_map, e, error);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry into map\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = 0;\n\n\tgit_vector_sort(&entries);\n\n\tif ((error = git_index_clear(index)) < 0) {\n\t\t/* well, this isn't good */;\n\t} else {\n\t\tgit_vector_swap(&entries, &index->entries);\n\t\tentries_map = git__swap(index->entries_map, entries_map);\n\t}\n\ncleanup:\n\tgit_vector_free(&entries);\n\tgit_idxmap_free(entries_map);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_read_tree(git_index *index, const git_tree *tree)\n{\n\tint error = 0;\n\tgit_vector entries = GIT_VECTOR_INIT;\n\tgit_idxmap *entries_map;\n\tread_tree_data data;\n\tsize_t i;\n\tgit_index_entry *e;\n\n\tif (git_idxmap_alloc(&entries_map) < 0)\n\t\treturn -1;\n\n\tgit_vector_set_cmp(&entries, index->entries._cmp); /* match sort */\n\n\tdata.index = index;\n\tdata.old_entries = &index->entries;\n\tdata.new_entries = &entries;\n\tdata.entry_cmp   = index->entries_search;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_vector_sort(&index->entries);\n\n\tif ((error = git_tree_walk(tree, GIT_TREEWALK_POST, read_tree_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) entries_map, entries.length);\n\telse\n\t\tkh_resize(idx, entries_map, entries.length);\n\n\tgit_vector_foreach(&entries, i, e) {\n\t\tINSERT_IN_MAP_EX(index, entries_map, e, error);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry into map\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = 0;\n\n\tgit_vector_sort(&entries);\n\n\tif ((error = git_index_clear(index)) < 0) {\n\t\t/* well, this isn't good */;\n\t} else {\n\t\tgit_vector_swap(&entries, &index->entries);\n\t\tentries_map = git__swap(index->entries_map, entries_map);\n\t}\n\ncleanup:\n\tgit_vector_free(&entries);\n\tgit_idxmap_free(entries_map);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__update_terminal",
          "args": [
            "repo",
            "GIT_HEAD_FILE",
            "git_object_id(commit)",
            "NULL",
            "git_buf_cstr(&log_message)"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__update_terminal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1066-1104",
          "snippet": "int git_reference__update_terminal(\n\tgit_repository *repo,\n\tconst char *ref_name,\n\tconst git_oid *oid,\n\tconst git_signature *sig,\n\tconst char *log_message)\n{\n\tgit_reference *ref = NULL, *ref2 = NULL;\n\tgit_signature *who = NULL;\n\tconst git_signature *to_use;\n\tint error = 0;\n\n\tif (!sig && (error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\tto_use = sig ? sig : who;\n\terror = get_terminal(&ref, repo, ref_name, 0);\n\n\t/* found a dangling symref */\n\tif (error == GIT_ENOTFOUND && ref) {\n\t\tassert(git_reference_type(ref) == GIT_REF_SYMBOLIC);\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref->target.symbolic, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t} else if (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref_name, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t}  else if (error == 0) {\n\t\tassert(git_reference_type(ref) == GIT_REF_OID);\n\t\terror = reference__create(&ref2, repo, ref->name, oid, NULL, 1, to_use,\n\t\t\t\t\t  log_message, &ref->target.oid, NULL);\n\t}\n\n\tgit_reference_free(ref2);\n\tgit_reference_free(ref);\n\tgit_signature_free(who);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__update_terminal(\n\tgit_repository *repo,\n\tconst char *ref_name,\n\tconst git_oid *oid,\n\tconst git_signature *sig,\n\tconst char *log_message)\n{\n\tgit_reference *ref = NULL, *ref2 = NULL;\n\tgit_signature *who = NULL;\n\tconst git_signature *to_use;\n\tint error = 0;\n\n\tif (!sig && (error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\tto_use = sig ? sig : who;\n\terror = get_terminal(&ref, repo, ref_name, 0);\n\n\t/* found a dangling symref */\n\tif (error == GIT_ENOTFOUND && ref) {\n\t\tassert(git_reference_type(ref) == GIT_REF_SYMBOLIC);\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref->target.symbolic, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t} else if (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = reference__create(&ref2, repo, ref_name, oid, NULL, 0, to_use,\n\t\t\t\t\t  log_message, NULL, NULL);\n\t}  else if (error == 0) {\n\t\tassert(git_reference_type(ref) == GIT_REF_OID);\n\t\terror = reference__create(&ref2, repo, ref->name, oid, NULL, 1, to_use,\n\t\t\t\t\t  log_message, &ref->target.oid, NULL);\n\t}\n\n\tgit_reference_free(ref2);\n\tgit_reference_free(ref);\n\tgit_signature_free(who);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&log_message"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "commit"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_checkout_tree",
          "args": [
            "repo",
            "(git_object *)tree",
            "&opts"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&log_message",
            "\"reset: moving to %s\"",
            "to"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_has_conflicts",
          "args": [
            "index"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_has_conflicts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1887-1900",
          "snippet": "int git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&tree",
            "(git_commit *)commit"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index",
          "args": [
            "&index",
            "repo"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "852-859",
          "snippet": "int git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_peel",
          "args": [
            "&commit",
            "target",
            "GIT_OBJ_COMMIT"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "327-381",
          "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "reset_type == GIT_RESET_MIXED ? \"reset mixed\" : \"reset hard\""
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "target"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && target"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"annotated_commit.h\"\n#include \"diff.h\"\n#include \"merge.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\n#define ERROR_MSG \"Cannot perform reset\"\n\nstatic int reset(\n\tgit_repository *repo,\n\tgit_object *target,\n\tconst char *to,\n\tgit_reset_t reset_type,\n\tconst git_checkout_options *checkout_opts)\n{\n\tgit_object *commit = NULL;\n\tgit_index *index = NULL;\n\tgit_tree *tree = NULL;\n\tint error = 0;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\n\tassert(repo && target);\n\n\tif (checkout_opts)\n\t\topts = *checkout_opts;\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\"%s - The given target does not belong to this repository.\", ERROR_MSG);\n\t\treturn -1;\n\t}\n\n\tif (reset_type != GIT_RESET_SOFT &&\n\t\t(error = git_repository__ensure_not_bare(repo,\n\t\t\treset_type == GIT_RESET_MIXED ? \"reset mixed\" : \"reset hard\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_object_peel(&commit, target, GIT_OBJ_COMMIT)) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0 ||\n\t\t(error = git_commit_tree(&tree, (git_commit *)commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type == GIT_RESET_SOFT &&\n\t\t(git_repository_state(repo) == GIT_REPOSITORY_STATE_MERGE ||\n\t\t git_index_has_conflicts(index)))\n\t{\n\t\tgiterr_set(GITERR_OBJECT, \"%s (soft) in the middle of a merge.\", ERROR_MSG);\n\t\terror = GIT_EUNMERGED;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&log_message, \"reset: moving to %s\", to)) < 0)\n\t\treturn error;\n\n\tif (reset_type == GIT_RESET_HARD) {\n\t\t/* overwrite working directory with the new tree */\n\t\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\t\tif ((error = git_checkout_tree(repo, (git_object *)tree, &opts)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* move HEAD to the new target */\n\tif ((error = git_reference__update_terminal(repo, GIT_HEAD_FILE,\n\t\tgit_object_id(commit), NULL, git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (reset_type > GIT_RESET_SOFT) {\n\t\t/* reset index to the target content */\n\n\t\tif ((error = git_index_read_tree(index, tree)) < 0 ||\n\t\t\t(error = git_index_write(index)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_repository_state_cleanup(repo)) < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"%s - failed to clean up merge data\", ERROR_MSG);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tgit_object_free(commit);\n\tgit_index_free(index);\n\tgit_tree_free(tree);\n\tgit_buf_free(&log_message);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_reset_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reset.c",
    "lines": "21-99",
    "snippet": "int git_reset_default(\n\tgit_repository *repo,\n\tgit_object *target,\n\tgit_strarray* pathspecs)\n{\n\tgit_object *commit = NULL;\n\tgit_tree *tree = NULL;\n\tgit_diff *diff = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tsize_t i, max_i;\n\tgit_index_entry entry;\n\tint error;\n\tgit_index *index = NULL;\n\n\tassert(pathspecs != NULL && pathspecs->count > 0);\n\n\tmemset(&entry, 0, sizeof(git_index_entry));\n\n\tif ((error = git_repository_index(&index, repo)) < 0)\n\t\tgoto cleanup;\n\n\tif (target) {\n\t\tif (git_object_owner(target) != repo) {\n\t\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"%s_default - The given target does not belong to this repository.\", ERROR_MSG);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((error = git_object_peel(&commit, target, GIT_OBJ_COMMIT)) < 0 ||\n\t\t\t(error = git_commit_tree(&tree, (git_commit *)commit)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\topts.pathspec = *pathspecs;\n\topts.flags = GIT_DIFF_REVERSE;\n\n\tif ((error = git_diff_tree_to_index(\n\t\t&diff, repo, tree, index, &opts)) < 0)\n\t\t\tgoto cleanup;\n\n\tfor (i = 0, max_i = git_diff_num_deltas(diff); i < max_i; ++i) {\n\t\tconst git_diff_delta *delta = git_diff_get_delta(diff, i);\n\n\t\tassert(delta->status == GIT_DELTA_ADDED ||\n\t\t\tdelta->status == GIT_DELTA_MODIFIED ||\n\t\t\tdelta->status == GIT_DELTA_CONFLICTED ||\n\t\t\tdelta->status == GIT_DELTA_DELETED);\n\n\t\terror = git_index_conflict_remove(index, delta->old_file.path);\n\t\tif (error < 0) {\n\t\t\tif (delta->status == GIT_DELTA_ADDED && error == GIT_ENOTFOUND)\n\t\t\t\tgiterr_clear();\n\t\t\telse\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (delta->status == GIT_DELTA_DELETED) {\n\t\t\tif ((error = git_index_remove(index, delta->old_file.path, 0)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tentry.mode = delta->new_file.mode;\n\t\t\tgit_oid_cpy(&entry.id, &delta->new_file.id);\n\t\t\tentry.path = (char *)delta->new_file.path;\n\n\t\t\tif ((error = git_index_add(index, &entry)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\terror = git_index_write(index);\n\ncleanup:\n\tgit_object_free(commit);\n\tgit_tree_free(tree);\n\tgit_index_free(index);\n\tgit_diff_free(diff);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define ERROR_MSG \"Cannot perform reset\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "diff"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "tree"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "commit"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_write",
          "args": [
            "index"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "750-763",
          "snippet": "int git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_add",
          "args": [
            "index",
            "&entry"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1580-1598",
          "snippet": "int git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&entry.id",
            "&delta->new_file.id"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_remove",
          "args": [
            "index",
            "delta->old_file.path",
            "0"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_remove_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1622-1651",
          "snippet": "int git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_conflict_remove",
          "args": [
            "index",
            "delta->old_file.path"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_conflict_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1875-1879",
          "snippet": "int git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "delta->status == GIT_DELTA_ADDED ||\n\t\t\tdelta->status == GIT_DELTA_MODIFIED ||\n\t\t\tdelta->status == GIT_DELTA_CONFLICTED ||\n\t\t\tdelta->status == GIT_DELTA_DELETED"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_diff_get_delta",
          "args": [
            "diff",
            "i"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_get_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1506-1510",
          "snippet": "const git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)\n{\n\tassert(diff);\n\treturn git_vector_get(&diff->deltas, idx);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nconst git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)\n{\n\tassert(diff);\n\treturn git_vector_get(&diff->deltas, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_num_deltas",
          "args": [
            "diff"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_num_deltas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1486-1490",
          "snippet": "size_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nsize_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_index",
          "args": [
            "&diff",
            "repo",
            "tree",
            "index",
            "&opts"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1353-1382",
          "snippet": "int git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&tree",
            "(git_commit *)commit"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_peel",
          "args": [
            "&commit",
            "target",
            "GIT_OBJ_COMMIT"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "327-381",
          "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"%s_default - The given target does not belong to this repository.\"",
            "ERROR_MSG"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "target"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index",
          "args": [
            "&index",
            "repo"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "852-859",
          "snippet": "int git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&entry",
            "0",
            "sizeof(git_index_entry)"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pathspecs != NULL && pathspecs->count > 0"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"annotated_commit.h\"\n#include \"diff.h\"\n#include \"merge.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\n#define ERROR_MSG \"Cannot perform reset\"\n\nint git_reset_default(\n\tgit_repository *repo,\n\tgit_object *target,\n\tgit_strarray* pathspecs)\n{\n\tgit_object *commit = NULL;\n\tgit_tree *tree = NULL;\n\tgit_diff *diff = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tsize_t i, max_i;\n\tgit_index_entry entry;\n\tint error;\n\tgit_index *index = NULL;\n\n\tassert(pathspecs != NULL && pathspecs->count > 0);\n\n\tmemset(&entry, 0, sizeof(git_index_entry));\n\n\tif ((error = git_repository_index(&index, repo)) < 0)\n\t\tgoto cleanup;\n\n\tif (target) {\n\t\tif (git_object_owner(target) != repo) {\n\t\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"%s_default - The given target does not belong to this repository.\", ERROR_MSG);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((error = git_object_peel(&commit, target, GIT_OBJ_COMMIT)) < 0 ||\n\t\t\t(error = git_commit_tree(&tree, (git_commit *)commit)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\topts.pathspec = *pathspecs;\n\topts.flags = GIT_DIFF_REVERSE;\n\n\tif ((error = git_diff_tree_to_index(\n\t\t&diff, repo, tree, index, &opts)) < 0)\n\t\t\tgoto cleanup;\n\n\tfor (i = 0, max_i = git_diff_num_deltas(diff); i < max_i; ++i) {\n\t\tconst git_diff_delta *delta = git_diff_get_delta(diff, i);\n\n\t\tassert(delta->status == GIT_DELTA_ADDED ||\n\t\t\tdelta->status == GIT_DELTA_MODIFIED ||\n\t\t\tdelta->status == GIT_DELTA_CONFLICTED ||\n\t\t\tdelta->status == GIT_DELTA_DELETED);\n\n\t\terror = git_index_conflict_remove(index, delta->old_file.path);\n\t\tif (error < 0) {\n\t\t\tif (delta->status == GIT_DELTA_ADDED && error == GIT_ENOTFOUND)\n\t\t\t\tgiterr_clear();\n\t\t\telse\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (delta->status == GIT_DELTA_DELETED) {\n\t\t\tif ((error = git_index_remove(index, delta->old_file.path, 0)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tentry.mode = delta->new_file.mode;\n\t\t\tgit_oid_cpy(&entry.id, &delta->new_file.id);\n\t\t\tentry.path = (char *)delta->new_file.path;\n\n\t\t\tif ((error = git_index_add(index, &entry)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\terror = git_index_write(index);\n\ncleanup:\n\tgit_object_free(commit);\n\tgit_tree_free(tree);\n\tgit_index_free(index);\n\tgit_diff_free(diff);\n\n\treturn error;\n}"
  }
]