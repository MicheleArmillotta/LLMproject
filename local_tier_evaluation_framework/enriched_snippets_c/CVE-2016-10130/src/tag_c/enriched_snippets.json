[
  {
    "function_name": "git_tag_peel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "514-517",
    "snippet": "int git_tag_peel(git_object **tag_target, const git_tag *tag)\n{\n\treturn git_object_peel(tag_target, (const git_object *)tag, GIT_OBJ_ANY);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_peel",
          "args": [
            "tag_target",
            "(const git_object *)tag",
            "GIT_OBJ_ANY"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "327-381",
          "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_peel(git_object **tag_target, const git_tag *tag)\n{\n\treturn git_object_peel(tag_target, (const git_object *)tag, GIT_OBJ_ANY);\n}"
  },
  {
    "function_name": "git_tag_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "509-512",
    "snippet": "int git_tag_list(git_strarray *tag_names, git_repository *repo)\n{\n\treturn git_tag_list_match(tag_names, \"\", repo);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tag_list_match",
          "args": [
            "tag_names",
            "\"\"",
            "repo"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "git_tag_list_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "484-507",
          "snippet": "int git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo)\n{\n\tint error;\n\ttag_filter_data filter;\n\tgit_vector taglist;\n\n\tassert(tag_names && repo && pattern);\n\n\tif ((error = git_vector_init(&taglist, 8, NULL)) < 0)\n\t\treturn error;\n\n\tfilter.taglist = &taglist;\n\tfilter.pattern = pattern;\n\n\terror = git_tag_foreach(repo, &tag_list_cb, (void *)&filter);\n\n\tif (error < 0)\n\t\tgit_vector_free(&taglist);\n\n\ttag_names->strings =\n\t\t(char **)git_vector_detach(&tag_names->count, NULL, &taglist);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo)\n{\n\tint error;\n\ttag_filter_data filter;\n\tgit_vector taglist;\n\n\tassert(tag_names && repo && pattern);\n\n\tif ((error = git_vector_init(&taglist, 8, NULL)) < 0)\n\t\treturn error;\n\n\tfilter.taglist = &taglist;\n\tfilter.pattern = pattern;\n\n\terror = git_tag_foreach(repo, &tag_list_cb, (void *)&filter);\n\n\tif (error < 0)\n\t\tgit_vector_free(&taglist);\n\n\ttag_names->strings =\n\t\t(char **)git_vector_detach(&tag_names->count, NULL, &taglist);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_list(git_strarray *tag_names, git_repository *repo)\n{\n\treturn git_tag_list_match(tag_names, \"\", repo);\n}"
  },
  {
    "function_name": "git_tag_list_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "484-507",
    "snippet": "int git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo)\n{\n\tint error;\n\ttag_filter_data filter;\n\tgit_vector taglist;\n\n\tassert(tag_names && repo && pattern);\n\n\tif ((error = git_vector_init(&taglist, 8, NULL)) < 0)\n\t\treturn error;\n\n\tfilter.taglist = &taglist;\n\tfilter.pattern = pattern;\n\n\terror = git_tag_foreach(repo, &tag_list_cb, (void *)&filter);\n\n\tif (error < 0)\n\t\tgit_vector_free(&taglist);\n\n\ttag_names->strings =\n\t\t(char **)git_vector_detach(&tag_names->count, NULL, &taglist);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_detach",
          "args": [
            "&tag_names->count",
            "NULL",
            "&taglist"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "110-124",
          "snippet": "void **git_vector_detach(size_t *size, size_t *asize, git_vector *v)\n{\n\tvoid **data = v->contents;\n\n\tif (size)\n\t\t*size = v->length;\n\tif (asize)\n\t\t*asize = v->_alloc_size;\n\n\tv->_alloc_size = 0;\n\tv->length   = 0;\n\tv->contents = NULL;\n\n\treturn data;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid **git_vector_detach(size_t *size, size_t *asize, git_vector *v)\n{\n\tvoid **data = v->contents;\n\n\tif (size)\n\t\t*size = v->length;\n\tif (asize)\n\t\t*asize = v->_alloc_size;\n\n\tv->_alloc_size = 0;\n\tv->length   = 0;\n\tv->contents = NULL;\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&taglist"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tag_foreach",
          "args": [
            "repo",
            "&tag_list_cb",
            "(void *)&filter"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "git_tag_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "447-458",
          "snippet": "int git_tag_foreach(git_repository *repo, git_tag_foreach_cb cb, void *cb_data)\n{\n\ttag_cb_data data;\n\n\tassert(repo && cb);\n\n\tdata.cb = cb;\n\tdata.cb_data = cb_data;\n\tdata.repo = repo;\n\n\treturn git_reference_foreach_name(repo, &tags_cb, &data);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_foreach(git_repository *repo, git_tag_foreach_cb cb, void *cb_data)\n{\n\ttag_cb_data data;\n\n\tassert(repo && cb);\n\n\tdata.cb = cb;\n\tdata.cb_data = cb_data;\n\tdata.repo = repo;\n\n\treturn git_reference_foreach_name(repo, &tags_cb, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&taglist",
            "8",
            "NULL"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tag_names && repo && pattern"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo)\n{\n\tint error;\n\ttag_filter_data filter;\n\tgit_vector taglist;\n\n\tassert(tag_names && repo && pattern);\n\n\tif ((error = git_vector_init(&taglist, 8, NULL)) < 0)\n\t\treturn error;\n\n\tfilter.taglist = &taglist;\n\tfilter.pattern = pattern;\n\n\terror = git_tag_foreach(repo, &tag_list_cb, (void *)&filter);\n\n\tif (error < 0)\n\t\tgit_vector_free(&taglist);\n\n\ttag_names->strings =\n\t\t(char **)git_vector_detach(&tag_names->count, NULL, &taglist);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tag_list_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "467-482",
    "snippet": "static int tag_list_cb(const char *tag_name, git_oid *oid, void *data)\n{\n\ttag_filter_data *filter = (tag_filter_data *)data;\n\tGIT_UNUSED(oid);\n\n\tif (!*filter->pattern ||\n\t\tp_fnmatch(filter->pattern, tag_name + GIT_REFS_TAGS_DIR_LEN, 0) == 0)\n\t{\n\t\tchar *matched = git__strdup(tag_name + GIT_REFS_TAGS_DIR_LEN);\n\t\tGITERR_CHECK_ALLOC(matched);\n\n\t\treturn git_vector_insert(filter->taglist, matched);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define GIT_REFS_TAGS_DIR_LEN strlen(GIT_REFS_TAGS_DIR)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "filter->taglist",
            "matched"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "matched"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "tag_name + GIT_REFS_TAGS_DIR_LEN"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_fnmatch",
          "args": [
            "filter->pattern",
            "tag_name + GIT_REFS_TAGS_DIR_LEN",
            "0"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "230-234",
          "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "oid"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\n#define GIT_REFS_TAGS_DIR_LEN strlen(GIT_REFS_TAGS_DIR)\n\nstatic int tag_list_cb(const char *tag_name, git_oid *oid, void *data)\n{\n\ttag_filter_data *filter = (tag_filter_data *)data;\n\tGIT_UNUSED(oid);\n\n\tif (!*filter->pattern ||\n\t\tp_fnmatch(filter->pattern, tag_name + GIT_REFS_TAGS_DIR_LEN, 0) == 0)\n\t{\n\t\tchar *matched = git__strdup(tag_name + GIT_REFS_TAGS_DIR_LEN);\n\t\tGITERR_CHECK_ALLOC(matched);\n\n\t\treturn git_vector_insert(filter->taglist, matched);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_tag_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "447-458",
    "snippet": "int git_tag_foreach(git_repository *repo, git_tag_foreach_cb cb, void *cb_data)\n{\n\ttag_cb_data data;\n\n\tassert(repo && cb);\n\n\tdata.cb = cb;\n\tdata.cb_data = cb_data;\n\tdata.repo = repo;\n\n\treturn git_reference_foreach_name(repo, &tags_cb, &data);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_foreach_name",
          "args": [
            "repo",
            "&tags_cb",
            "&data"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_foreach_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "658-682",
          "snippet": "int git_reference_foreach_name(\n\tgit_repository *repo,\n\tgit_reference_foreach_name_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tconst char *refname;\n\tint error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next_name(&refname, iter))) {\n\t\tif ((error = callback(refname, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_foreach_name(\n\tgit_repository *repo,\n\tgit_reference_foreach_name_cb callback,\n\tvoid *payload)\n{\n\tgit_reference_iterator *iter;\n\tconst char *refname;\n\tint error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_reference_next_name(&refname, iter))) {\n\t\tif ((error = callback(refname, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_reference_iterator_free(iter);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && cb"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_foreach(git_repository *repo, git_tag_foreach_cb cb, void *cb_data)\n{\n\ttag_cb_data data;\n\n\tassert(repo && cb);\n\n\tdata.cb = cb;\n\tdata.cb_data = cb_data;\n\tdata.repo = repo;\n\n\treturn git_reference_foreach_name(repo, &tags_cb, &data);\n}"
  },
  {
    "function_name": "tags_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "430-445",
    "snippet": "static int tags_cb(const char *ref, void *data)\n{\n\tint error;\n\tgit_oid oid;\n\ttag_cb_data *d = (tag_cb_data *)data;\n\n\tif (git__prefixcmp(ref, GIT_REFS_TAGS_DIR) != 0)\n\t\treturn 0; /* no tag */\n\n\tif (!(error = git_reference_name_to_id(&oid, d->repo, ref))) {\n\t\tif ((error = d->cb(ref, &oid, d->cb_data)) != 0)\n\t\t\tgiterr_set_after_callback_function(error, \"git_tag_foreach\");\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set_after_callback_function",
          "args": [
            "error",
            "\"git_tag_foreach\""
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->cb",
          "args": [
            "ref",
            "&oid",
            "d->cb_data"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_name_to_id",
          "args": [
            "&oid",
            "d->repo",
            "ref"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name_to_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "152-164",
          "snippet": "int git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ref",
            "GIT_REFS_TAGS_DIR"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int tags_cb(const char *ref, void *data)\n{\n\tint error;\n\tgit_oid oid;\n\ttag_cb_data *d = (tag_cb_data *)data;\n\n\tif (git__prefixcmp(ref, GIT_REFS_TAGS_DIR) != 0)\n\t\treturn 0; /* no tag */\n\n\tif (!(error = git_reference_name_to_id(&oid, d->repo, ref))) {\n\t\tif ((error = d->cb(ref, &oid, d->cb_data)) != 0)\n\t\t\tgiterr_set_after_callback_function(error, \"git_tag_foreach\");\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_tag_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "404-422",
    "snippet": "int git_tag_delete(git_repository *repo, const char *tag_name)\n{\n\tgit_reference *tag_ref;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\tint error;\n\n\terror = retrieve_tag_reference(&tag_ref, &ref_name, repo, tag_name);\n\n\tgit_buf_free(&ref_name);\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_reference_delete(tag_ref);\n\n\tgit_reference_free(tag_ref);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "tag_ref"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_delete",
          "args": [
            "tag_ref"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "122-133",
          "snippet": "int git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ref_name"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_tag_reference",
          "args": [
            "&tag_ref",
            "&ref_name",
            "repo",
            "tag_name"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_tag_reference_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "194-204",
          "snippet": "static int retrieve_tag_reference_oid(\n\tgit_oid *oid,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\treturn git_reference_name_to_id(oid, repo, ref_name_out->ptr);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_tag_reference_oid(\n\tgit_oid *oid,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\treturn git_reference_name_to_id(oid, repo, ref_name_out->ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_delete(git_repository *repo, const char *tag_name)\n{\n\tgit_reference *tag_ref;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\tint error;\n\n\terror = retrieve_tag_reference(&tag_ref, &ref_name, repo, tag_name);\n\n\tgit_buf_free(&ref_name);\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_reference_delete(tag_ref);\n\n\tgit_reference_free(tag_ref);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_tag_create_frombuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "325-402",
    "snippet": "int git_tag_create_frombuffer(git_oid *oid, git_repository *repo, const char *buffer, int allow_ref_overwrite)\n{\n\tgit_tag tag;\n\tint error;\n\tgit_odb *odb;\n\tgit_odb_stream *stream;\n\tgit_odb_object *target_obj;\n\n\tgit_reference *new_ref = NULL;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tassert(oid && buffer);\n\n\tmemset(&tag, 0, sizeof(tag));\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\treturn -1;\n\n\t/* validate the buffer */\n\tif (tag_parse(&tag, buffer, buffer + strlen(buffer)) < 0)\n\t\treturn -1;\n\n\t/* validate the target */\n\tif (git_odb_read(&target_obj, odb, &tag.target) < 0)\n\t\tgoto on_error;\n\n\tif (tag.type != target_obj->cached.type) {\n\t\tgiterr_set(GITERR_TAG, \"The type for the given target is invalid\");\n\t\tgoto on_error;\n\t}\n\n\terror = retrieve_tag_reference_oid(oid, &ref_name, repo, tag.tag_name);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto on_error;\n\n\t/* We don't need these objects after this */\n\tgit_signature_free(tag.tagger);\n\tgit__free(tag.tag_name);\n\tgit__free(tag.message);\n\tgit_odb_object_free(target_obj);\n\n\t/** Ensure the tag name doesn't conflict with an already existing\n\t *\treference unless overwriting has explicitly been requested **/\n\tif (error == 0 && !allow_ref_overwrite) {\n\t\tgiterr_set(GITERR_TAG, \"Tag already exists\");\n\t\treturn GIT_EEXISTS;\n\t}\n\n\t/* write the buffer */\n\tif ((error = git_odb_open_wstream(\n\t\t\t&stream, odb, strlen(buffer), GIT_OBJ_TAG)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_odb_stream_write(stream, buffer, strlen(buffer))))\n\t\terror = git_odb_stream_finalize_write(oid, stream);\n\n\tgit_odb_stream_free(stream);\n\n\tif (error < 0) {\n\t\tgit_buf_free(&ref_name);\n\t\treturn error;\n\t}\n\n\terror = git_reference_create(\n\t\t&new_ref, repo, ref_name.ptr, oid, allow_ref_overwrite, NULL);\n\n\tgit_reference_free(new_ref);\n\tgit_buf_free(&ref_name);\n\n\treturn error;\n\non_error:\n\tgit_signature_free(tag.tagger);\n\tgit__free(tag.tag_name);\n\tgit__free(tag.message);\n\tgit_odb_object_free(target_obj);\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb_object_free",
          "args": [
            "target_obj"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "137-143",
          "snippet": "void git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "tag.message"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature_free",
          "args": [
            "tag.tagger"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "14-24",
          "snippet": "void git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ref_name"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "new_ref"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_create",
          "args": [
            "&new_ref",
            "repo",
            "ref_name.ptr",
            "oid",
            "allow_ref_overwrite",
            "NULL"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "464-473",
          "snippet": "int git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_stream_free",
          "args": [
            "stream"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_stream_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1131-1139",
          "snippet": "void git_odb_stream_free(git_odb_stream *stream)\n{\n\tif (stream == NULL)\n\t\treturn;\n\n\tgit_hash_ctx_cleanup(stream->hash_ctx);\n\tgit__free(stream->hash_ctx);\n\tstream->free(stream);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_stream_free(git_odb_stream *stream)\n{\n\tif (stream == NULL)\n\t\treturn;\n\n\tgit_hash_ctx_cleanup(stream->hash_ctx);\n\tgit__free(stream->hash_ctx);\n\tstream->free(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_stream_finalize_write",
          "args": [
            "oid",
            "stream"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_stream_finalize_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1112-1124",
          "snippet": "int git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)\n{\n\tif (stream->received_bytes != stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_finalize_write()\");\n\n\tgit_hash_final(out, stream->hash_ctx);\n\n\tif (git_odb_exists(stream->backend->odb, out))\n\t\treturn 0;\n\n\treturn stream->finalize_write(stream, out);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)\n{\n\tif (stream->received_bytes != stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_finalize_write()\");\n\n\tgit_hash_final(out, stream->hash_ctx);\n\n\tif (git_odb_exists(stream->backend->odb, out))\n\t\treturn 0;\n\n\treturn stream->finalize_write(stream, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_stream_write",
          "args": [
            "stream",
            "buffer",
            "strlen(buffer)"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_stream_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1099-1110",
          "snippet": "int git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)\n{\n\tgit_hash_update(stream->hash_ctx, buffer, len);\n\n\tstream->received_bytes += len;\n\n\tif (stream->received_bytes > stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_write()\");\n\n\treturn stream->write(stream, buffer, len);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)\n{\n\tgit_hash_update(stream->hash_ctx, buffer, len);\n\n\tstream->received_bytes += len;\n\n\tif (stream->received_bytes > stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_write()\");\n\n\treturn stream->write(stream, buffer, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_odb_open_wstream",
          "args": [
            "&stream",
            "odb",
            "strlen(buffer)",
            "GIT_OBJ_TAG"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_open_wstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1035-1084",
          "snippet": "int git_odb_open_wstream(\n\tgit_odb_stream **stream, git_odb *db, git_off_t size, git_otype type)\n{\n\tsize_t i, writes = 0;\n\tint error = GIT_ERROR;\n\tgit_hash_ctx *ctx = NULL;\n\n\tassert(stream && db);\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->writestream != NULL) {\n\t\t\t++writes;\n\t\t\terror = b->writestream(stream, b, size, type);\n\t\t} else if (b->write != NULL) {\n\t\t\t++writes;\n\t\t\terror = init_fake_wstream(stream, b, size, type);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\terror = 0;\n\t\telse if (!writes)\n\t\t\terror = git_odb__error_unsupported_in_backend(\"write object\");\n\n\t\tgoto done;\n\t}\n\n\tctx = git__malloc(sizeof(git_hash_ctx));\n\tGITERR_CHECK_ALLOC(ctx);\n\n\tif ((error = git_hash_ctx_init(ctx)) < 0)\n\t\tgoto done;\n\n\thash_header(ctx, size, type);\n\t(*stream)->hash_ctx = ctx;\n\n\t(*stream)->declared_size = size;\n\t(*stream)->received_bytes = 0;\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_open_wstream(\n\tgit_odb_stream **stream, git_odb *db, git_off_t size, git_otype type)\n{\n\tsize_t i, writes = 0;\n\tint error = GIT_ERROR;\n\tgit_hash_ctx *ctx = NULL;\n\n\tassert(stream && db);\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->writestream != NULL) {\n\t\t\t++writes;\n\t\t\terror = b->writestream(stream, b, size, type);\n\t\t} else if (b->write != NULL) {\n\t\t\t++writes;\n\t\t\terror = init_fake_wstream(stream, b, size, type);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\terror = 0;\n\t\telse if (!writes)\n\t\t\terror = git_odb__error_unsupported_in_backend(\"write object\");\n\n\t\tgoto done;\n\t}\n\n\tctx = git__malloc(sizeof(git_hash_ctx));\n\tGITERR_CHECK_ALLOC(ctx);\n\n\tif ((error = git_hash_ctx_init(ctx)) < 0)\n\t\tgoto done;\n\n\thash_header(ctx, size, type);\n\t(*stream)->hash_ctx = ctx;\n\n\t(*stream)->declared_size = size;\n\t(*stream)->received_bytes = 0;\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_TAG",
            "\"Tag already exists\""
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_tag_reference_oid",
          "args": [
            "oid",
            "&ref_name",
            "repo",
            "tag.tag_name"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_tag_reference_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "194-204",
          "snippet": "static int retrieve_tag_reference_oid(\n\tgit_oid *oid,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\treturn git_reference_name_to_id(oid, repo, ref_name_out->ptr);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_tag_reference_oid(\n\tgit_oid *oid,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\treturn git_reference_name_to_id(oid, repo, ref_name_out->ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_read",
          "args": [
            "&target_obj",
            "odb",
            "&tag.target"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "862-881",
          "snippet": "int git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id)\n{\n\tint error;\n\n\tassert(out && db && id);\n\n\t*out = git_cache_get_raw(odb_cache(db), id);\n\tif (*out != NULL)\n\t\treturn 0;\n\n\terror = odb_read_1(out, db, id, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_read_1(out, db, id, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id\", id, GIT_OID_HEXSZ);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id)\n{\n\tint error;\n\n\tassert(out && db && id);\n\n\t*out = git_cache_get_raw(odb_cache(db), id);\n\tif (*out != NULL)\n\t\treturn 0;\n\n\terror = odb_read_1(out, db, id, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_read_1(out, db, id, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id\", id, GIT_OID_HEXSZ);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag_parse",
          "args": [
            "&tag",
            "buffer",
            "buffer + strlen(buffer)"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "tag_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "68-160",
          "snippet": "static int tag_parse(git_tag *tag, const char *buffer, const char *buffer_end)\n{\n\tstatic const char *tag_types[] = {\n\t\tNULL, \"commit\\n\", \"tree\\n\", \"blob\\n\", \"tag\\n\"\n\t};\n\n\tunsigned int i;\n\tsize_t text_len, alloc_len;\n\tchar *search;\n\n\tif (git_oid__parse(&tag->target, &buffer, buffer_end, \"object \") < 0)\n\t\treturn tag_error(\"Object field invalid\");\n\n\tif (buffer + 5 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"type \", 5) != 0)\n\t\treturn tag_error(\"Type field not found\");\n\tbuffer += 5;\n\n\ttag->type = GIT_OBJ_BAD;\n\n\tfor (i = 1; i < ARRAY_SIZE(tag_types); ++i) {\n\t\tsize_t type_length = strlen(tag_types[i]);\n\n\t\tif (buffer + type_length >= buffer_end)\n\t\t\treturn tag_error(\"Object too short\");\n\n\t\tif (memcmp(buffer, tag_types[i], type_length) == 0) {\n\t\t\ttag->type = i;\n\t\t\tbuffer += type_length;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tag->type == GIT_OBJ_BAD)\n\t\treturn tag_error(\"Invalid object type\");\n\n\tif (buffer + 4 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"tag \", 4) != 0)\n\t\treturn tag_error(\"Tag field not found\");\n\n\tbuffer += 4;\n\n\tsearch = memchr(buffer, '\\n', buffer_end - buffer);\n\tif (search == NULL)\n\t\treturn tag_error(\"Object too short\");\n\n\ttext_len = search - buffer;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\ttag->tag_name = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(tag->tag_name);\n\n\tmemcpy(tag->tag_name, buffer, text_len);\n\ttag->tag_name[text_len] = '\\0';\n\n\tbuffer = search + 1;\n\n\ttag->tagger = NULL;\n\tif (buffer < buffer_end && *buffer != '\\n') {\n\t\ttag->tagger = git__malloc(sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(tag->tagger);\n\n\t\tif (git_signature__parse(tag->tagger, &buffer, buffer_end, \"tagger \", '\\n') < 0)\n\t\t\treturn -1;\n\t}\n\n\ttag->message = NULL;\n\tif (buffer < buffer_end) {\n\t\t/* If we're not at the end of the header, search for it */\n\t\tif( *buffer != '\\n' ) {\n\t\t\tsearch = strstr(buffer, \"\\n\\n\");\n\t\t\tif (search)\n\t\t\t\tbuffer = search + 1;\n\t\t\telse\n\t\t\t\treturn tag_error(\"tag contains no message\");\n\t\t}\n\n\t\ttext_len = buffer_end - ++buffer;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\t\ttag->message = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(tag->message);\n\n\t\tmemcpy(tag->message, buffer, text_len);\n\t\ttag->message[text_len] = '\\0';\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int tag_parse(git_tag *tag, const char *buffer, const char *buffer_end)\n{\n\tstatic const char *tag_types[] = {\n\t\tNULL, \"commit\\n\", \"tree\\n\", \"blob\\n\", \"tag\\n\"\n\t};\n\n\tunsigned int i;\n\tsize_t text_len, alloc_len;\n\tchar *search;\n\n\tif (git_oid__parse(&tag->target, &buffer, buffer_end, \"object \") < 0)\n\t\treturn tag_error(\"Object field invalid\");\n\n\tif (buffer + 5 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"type \", 5) != 0)\n\t\treturn tag_error(\"Type field not found\");\n\tbuffer += 5;\n\n\ttag->type = GIT_OBJ_BAD;\n\n\tfor (i = 1; i < ARRAY_SIZE(tag_types); ++i) {\n\t\tsize_t type_length = strlen(tag_types[i]);\n\n\t\tif (buffer + type_length >= buffer_end)\n\t\t\treturn tag_error(\"Object too short\");\n\n\t\tif (memcmp(buffer, tag_types[i], type_length) == 0) {\n\t\t\ttag->type = i;\n\t\t\tbuffer += type_length;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tag->type == GIT_OBJ_BAD)\n\t\treturn tag_error(\"Invalid object type\");\n\n\tif (buffer + 4 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"tag \", 4) != 0)\n\t\treturn tag_error(\"Tag field not found\");\n\n\tbuffer += 4;\n\n\tsearch = memchr(buffer, '\\n', buffer_end - buffer);\n\tif (search == NULL)\n\t\treturn tag_error(\"Object too short\");\n\n\ttext_len = search - buffer;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\ttag->tag_name = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(tag->tag_name);\n\n\tmemcpy(tag->tag_name, buffer, text_len);\n\ttag->tag_name[text_len] = '\\0';\n\n\tbuffer = search + 1;\n\n\ttag->tagger = NULL;\n\tif (buffer < buffer_end && *buffer != '\\n') {\n\t\ttag->tagger = git__malloc(sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(tag->tagger);\n\n\t\tif (git_signature__parse(tag->tagger, &buffer, buffer_end, \"tagger \", '\\n') < 0)\n\t\t\treturn -1;\n\t}\n\n\ttag->message = NULL;\n\tif (buffer < buffer_end) {\n\t\t/* If we're not at the end of the header, search for it */\n\t\tif( *buffer != '\\n' ) {\n\t\t\tsearch = strstr(buffer, \"\\n\\n\");\n\t\t\tif (search)\n\t\t\t\tbuffer = search + 1;\n\t\t\telse\n\t\t\t\treturn tag_error(\"tag contains no message\");\n\t\t}\n\n\t\ttext_len = buffer_end - ++buffer;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\t\ttag->message = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(tag->message);\n\n\t\tmemcpy(tag->message, buffer, text_len);\n\t\ttag->message[text_len] = '\\0';\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tag",
            "0",
            "sizeof(tag)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "oid && buffer"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_create_frombuffer(git_oid *oid, git_repository *repo, const char *buffer, int allow_ref_overwrite)\n{\n\tgit_tag tag;\n\tint error;\n\tgit_odb *odb;\n\tgit_odb_stream *stream;\n\tgit_odb_object *target_obj;\n\n\tgit_reference *new_ref = NULL;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tassert(oid && buffer);\n\n\tmemset(&tag, 0, sizeof(tag));\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\treturn -1;\n\n\t/* validate the buffer */\n\tif (tag_parse(&tag, buffer, buffer + strlen(buffer)) < 0)\n\t\treturn -1;\n\n\t/* validate the target */\n\tif (git_odb_read(&target_obj, odb, &tag.target) < 0)\n\t\tgoto on_error;\n\n\tif (tag.type != target_obj->cached.type) {\n\t\tgiterr_set(GITERR_TAG, \"The type for the given target is invalid\");\n\t\tgoto on_error;\n\t}\n\n\terror = retrieve_tag_reference_oid(oid, &ref_name, repo, tag.tag_name);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto on_error;\n\n\t/* We don't need these objects after this */\n\tgit_signature_free(tag.tagger);\n\tgit__free(tag.tag_name);\n\tgit__free(tag.message);\n\tgit_odb_object_free(target_obj);\n\n\t/** Ensure the tag name doesn't conflict with an already existing\n\t *\treference unless overwriting has explicitly been requested **/\n\tif (error == 0 && !allow_ref_overwrite) {\n\t\tgiterr_set(GITERR_TAG, \"Tag already exists\");\n\t\treturn GIT_EEXISTS;\n\t}\n\n\t/* write the buffer */\n\tif ((error = git_odb_open_wstream(\n\t\t\t&stream, odb, strlen(buffer), GIT_OBJ_TAG)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_odb_stream_write(stream, buffer, strlen(buffer))))\n\t\terror = git_odb_stream_finalize_write(oid, stream);\n\n\tgit_odb_stream_free(stream);\n\n\tif (error < 0) {\n\t\tgit_buf_free(&ref_name);\n\t\treturn error;\n\t}\n\n\terror = git_reference_create(\n\t\t&new_ref, repo, ref_name.ptr, oid, allow_ref_overwrite, NULL);\n\n\tgit_reference_free(new_ref);\n\tgit_buf_free(&ref_name);\n\n\treturn error;\n\non_error:\n\tgit_signature_free(tag.tagger);\n\tgit__free(tag.tag_name);\n\tgit__free(tag.message);\n\tgit_odb_object_free(target_obj);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_tag_create_lightweight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "315-323",
    "snippet": "int git_tag_create_lightweight(\n\tgit_oid *oid,\n\tgit_repository *repo,\n\tconst char *tag_name,\n\tconst git_object *target,\n\tint allow_ref_overwrite)\n{\n\treturn git_tag_create__internal(oid, repo, tag_name, target, NULL, NULL, allow_ref_overwrite, 0);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tag_create__internal",
          "args": [
            "oid",
            "repo",
            "tag_name",
            "target",
            "NULL",
            "NULL",
            "allow_ref_overwrite",
            "0"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "git_tag_create__internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "241-288",
          "snippet": "static int git_tag_create__internal(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message,\n\t\tint allow_ref_overwrite,\n\t\tint create_tag_annotation)\n{\n\tgit_reference *new_ref = NULL;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tint error;\n\n\tassert(repo && tag_name && target);\n\tassert(!create_tag_annotation || (tagger && message));\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_INVALID, \"The given target does not belong to this repository\");\n\t\treturn -1;\n\t}\n\n\terror = retrieve_tag_reference_oid(oid, &ref_name, repo, tag_name);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\t/** Ensure the tag name doesn't conflict with an already existing\n\t *\treference unless overwriting has explicitly been requested **/\n\tif (error == 0 && !allow_ref_overwrite) {\n\t\tgit_buf_free(&ref_name);\n\t\tgiterr_set(GITERR_TAG, \"Tag already exists\");\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif (create_tag_annotation) {\n\t\tif (write_tag_annotation(oid, repo, tag_name, target, tagger, message) < 0)\n\t\t\treturn -1;\n\t} else\n\t\tgit_oid_cpy(oid, git_object_id(target));\n\n\terror = git_reference_create(&new_ref, repo, ref_name.ptr, oid, allow_ref_overwrite, NULL);\n\ncleanup:\n\tgit_reference_free(new_ref);\n\tgit_buf_free(&ref_name);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int git_tag_create__internal(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message,\n\t\tint allow_ref_overwrite,\n\t\tint create_tag_annotation)\n{\n\tgit_reference *new_ref = NULL;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tint error;\n\n\tassert(repo && tag_name && target);\n\tassert(!create_tag_annotation || (tagger && message));\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_INVALID, \"The given target does not belong to this repository\");\n\t\treturn -1;\n\t}\n\n\terror = retrieve_tag_reference_oid(oid, &ref_name, repo, tag_name);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\t/** Ensure the tag name doesn't conflict with an already existing\n\t *\treference unless overwriting has explicitly been requested **/\n\tif (error == 0 && !allow_ref_overwrite) {\n\t\tgit_buf_free(&ref_name);\n\t\tgiterr_set(GITERR_TAG, \"Tag already exists\");\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif (create_tag_annotation) {\n\t\tif (write_tag_annotation(oid, repo, tag_name, target, tagger, message) < 0)\n\t\t\treturn -1;\n\t} else\n\t\tgit_oid_cpy(oid, git_object_id(target));\n\n\terror = git_reference_create(&new_ref, repo, ref_name.ptr, oid, allow_ref_overwrite, NULL);\n\ncleanup:\n\tgit_reference_free(new_ref);\n\tgit_buf_free(&ref_name);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_create_lightweight(\n\tgit_oid *oid,\n\tgit_repository *repo,\n\tconst char *tag_name,\n\tconst git_object *target,\n\tint allow_ref_overwrite)\n{\n\treturn git_tag_create__internal(oid, repo, tag_name, target, NULL, NULL, allow_ref_overwrite, 0);\n}"
  },
  {
    "function_name": "git_tag_annotation_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "302-313",
    "snippet": "int git_tag_annotation_create(\n\tgit_oid *oid,\n\tgit_repository *repo,\n\tconst char *tag_name,\n\tconst git_object *target,\n\tconst git_signature *tagger,\n\tconst char *message)\n{\n\tassert(oid && repo && tag_name && target && tagger && message);\n\n\treturn write_tag_annotation(oid, repo, tag_name, target, tagger, message);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_tag_annotation",
          "args": [
            "oid",
            "repo",
            "tag_name",
            "target",
            "tagger",
            "message"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "write_tag_annotation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "206-239",
          "snippet": "static int write_tag_annotation(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message)\n{\n\tgit_buf tag = GIT_BUF_INIT;\n\tgit_odb *odb;\n\n\tgit_oid__writebuf(&tag, \"object \", git_object_id(target));\n\tgit_buf_printf(&tag, \"type %s\\n\", git_object_type2string(git_object_type(target)));\n\tgit_buf_printf(&tag, \"tag %s\\n\", tag_name);\n\tgit_signature__writebuf(&tag, \"tagger \", tagger);\n\tgit_buf_putc(&tag, '\\n');\n\n\tif (git_buf_puts(&tag, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(oid, odb, tag.ptr, tag.size, GIT_OBJ_TAG) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&tag);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&tag);\n\tgiterr_set(GITERR_OBJECT, \"Failed to create tag annotation.\");\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int write_tag_annotation(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message)\n{\n\tgit_buf tag = GIT_BUF_INIT;\n\tgit_odb *odb;\n\n\tgit_oid__writebuf(&tag, \"object \", git_object_id(target));\n\tgit_buf_printf(&tag, \"type %s\\n\", git_object_type2string(git_object_type(target)));\n\tgit_buf_printf(&tag, \"tag %s\\n\", tag_name);\n\tgit_signature__writebuf(&tag, \"tagger \", tagger);\n\tgit_buf_putc(&tag, '\\n');\n\n\tif (git_buf_puts(&tag, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(oid, odb, tag.ptr, tag.size, GIT_OBJ_TAG) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&tag);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&tag);\n\tgiterr_set(GITERR_OBJECT, \"Failed to create tag annotation.\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "oid && repo && tag_name && target && tagger && message"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_annotation_create(\n\tgit_oid *oid,\n\tgit_repository *repo,\n\tconst char *tag_name,\n\tconst git_object *target,\n\tconst git_signature *tagger,\n\tconst char *message)\n{\n\tassert(oid && repo && tag_name && target && tagger && message);\n\n\treturn write_tag_annotation(oid, repo, tag_name, target, tagger, message);\n}"
  },
  {
    "function_name": "git_tag_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "290-300",
    "snippet": "int git_tag_create(\n\tgit_oid *oid,\n\tgit_repository *repo,\n\tconst char *tag_name,\n\tconst git_object *target,\n\tconst git_signature *tagger,\n\tconst char *message,\n\tint allow_ref_overwrite)\n{\n\treturn git_tag_create__internal(oid, repo, tag_name, target, tagger, message, allow_ref_overwrite, 1);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tag_create__internal",
          "args": [
            "oid",
            "repo",
            "tag_name",
            "target",
            "tagger",
            "message",
            "allow_ref_overwrite",
            "1"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "git_tag_create__internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "241-288",
          "snippet": "static int git_tag_create__internal(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message,\n\t\tint allow_ref_overwrite,\n\t\tint create_tag_annotation)\n{\n\tgit_reference *new_ref = NULL;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tint error;\n\n\tassert(repo && tag_name && target);\n\tassert(!create_tag_annotation || (tagger && message));\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_INVALID, \"The given target does not belong to this repository\");\n\t\treturn -1;\n\t}\n\n\terror = retrieve_tag_reference_oid(oid, &ref_name, repo, tag_name);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\t/** Ensure the tag name doesn't conflict with an already existing\n\t *\treference unless overwriting has explicitly been requested **/\n\tif (error == 0 && !allow_ref_overwrite) {\n\t\tgit_buf_free(&ref_name);\n\t\tgiterr_set(GITERR_TAG, \"Tag already exists\");\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif (create_tag_annotation) {\n\t\tif (write_tag_annotation(oid, repo, tag_name, target, tagger, message) < 0)\n\t\t\treturn -1;\n\t} else\n\t\tgit_oid_cpy(oid, git_object_id(target));\n\n\terror = git_reference_create(&new_ref, repo, ref_name.ptr, oid, allow_ref_overwrite, NULL);\n\ncleanup:\n\tgit_reference_free(new_ref);\n\tgit_buf_free(&ref_name);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int git_tag_create__internal(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message,\n\t\tint allow_ref_overwrite,\n\t\tint create_tag_annotation)\n{\n\tgit_reference *new_ref = NULL;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tint error;\n\n\tassert(repo && tag_name && target);\n\tassert(!create_tag_annotation || (tagger && message));\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_INVALID, \"The given target does not belong to this repository\");\n\t\treturn -1;\n\t}\n\n\terror = retrieve_tag_reference_oid(oid, &ref_name, repo, tag_name);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\t/** Ensure the tag name doesn't conflict with an already existing\n\t *\treference unless overwriting has explicitly been requested **/\n\tif (error == 0 && !allow_ref_overwrite) {\n\t\tgit_buf_free(&ref_name);\n\t\tgiterr_set(GITERR_TAG, \"Tag already exists\");\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif (create_tag_annotation) {\n\t\tif (write_tag_annotation(oid, repo, tag_name, target, tagger, message) < 0)\n\t\t\treturn -1;\n\t} else\n\t\tgit_oid_cpy(oid, git_object_id(target));\n\n\terror = git_reference_create(&new_ref, repo, ref_name.ptr, oid, allow_ref_overwrite, NULL);\n\ncleanup:\n\tgit_reference_free(new_ref);\n\tgit_buf_free(&ref_name);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_create(\n\tgit_oid *oid,\n\tgit_repository *repo,\n\tconst char *tag_name,\n\tconst git_object *target,\n\tconst git_signature *tagger,\n\tconst char *message,\n\tint allow_ref_overwrite)\n{\n\treturn git_tag_create__internal(oid, repo, tag_name, target, tagger, message, allow_ref_overwrite, 1);\n}"
  },
  {
    "function_name": "git_tag_create__internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "241-288",
    "snippet": "static int git_tag_create__internal(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message,\n\t\tint allow_ref_overwrite,\n\t\tint create_tag_annotation)\n{\n\tgit_reference *new_ref = NULL;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tint error;\n\n\tassert(repo && tag_name && target);\n\tassert(!create_tag_annotation || (tagger && message));\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_INVALID, \"The given target does not belong to this repository\");\n\t\treturn -1;\n\t}\n\n\terror = retrieve_tag_reference_oid(oid, &ref_name, repo, tag_name);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\t/** Ensure the tag name doesn't conflict with an already existing\n\t *\treference unless overwriting has explicitly been requested **/\n\tif (error == 0 && !allow_ref_overwrite) {\n\t\tgit_buf_free(&ref_name);\n\t\tgiterr_set(GITERR_TAG, \"Tag already exists\");\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif (create_tag_annotation) {\n\t\tif (write_tag_annotation(oid, repo, tag_name, target, tagger, message) < 0)\n\t\t\treturn -1;\n\t} else\n\t\tgit_oid_cpy(oid, git_object_id(target));\n\n\terror = git_reference_create(&new_ref, repo, ref_name.ptr, oid, allow_ref_overwrite, NULL);\n\ncleanup:\n\tgit_reference_free(new_ref);\n\tgit_buf_free(&ref_name);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ref_name"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "new_ref"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_create",
          "args": [
            "&new_ref",
            "repo",
            "ref_name.ptr",
            "oid",
            "allow_ref_overwrite",
            "NULL"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "464-473",
          "snippet": "int git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "oid",
            "git_object_id(target)"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "target"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_tag_annotation",
          "args": [
            "oid",
            "repo",
            "tag_name",
            "target",
            "tagger",
            "message"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "write_tag_annotation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "206-239",
          "snippet": "static int write_tag_annotation(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message)\n{\n\tgit_buf tag = GIT_BUF_INIT;\n\tgit_odb *odb;\n\n\tgit_oid__writebuf(&tag, \"object \", git_object_id(target));\n\tgit_buf_printf(&tag, \"type %s\\n\", git_object_type2string(git_object_type(target)));\n\tgit_buf_printf(&tag, \"tag %s\\n\", tag_name);\n\tgit_signature__writebuf(&tag, \"tagger \", tagger);\n\tgit_buf_putc(&tag, '\\n');\n\n\tif (git_buf_puts(&tag, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(oid, odb, tag.ptr, tag.size, GIT_OBJ_TAG) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&tag);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&tag);\n\tgiterr_set(GITERR_OBJECT, \"Failed to create tag annotation.\");\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int write_tag_annotation(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message)\n{\n\tgit_buf tag = GIT_BUF_INIT;\n\tgit_odb *odb;\n\n\tgit_oid__writebuf(&tag, \"object \", git_object_id(target));\n\tgit_buf_printf(&tag, \"type %s\\n\", git_object_type2string(git_object_type(target)));\n\tgit_buf_printf(&tag, \"tag %s\\n\", tag_name);\n\tgit_signature__writebuf(&tag, \"tagger \", tagger);\n\tgit_buf_putc(&tag, '\\n');\n\n\tif (git_buf_puts(&tag, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(oid, odb, tag.ptr, tag.size, GIT_OBJ_TAG) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&tag);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&tag);\n\tgiterr_set(GITERR_OBJECT, \"Failed to create tag annotation.\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_TAG",
            "\"Tag already exists\""
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_tag_reference_oid",
          "args": [
            "oid",
            "&ref_name",
            "repo",
            "tag_name"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_tag_reference_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "194-204",
          "snippet": "static int retrieve_tag_reference_oid(\n\tgit_oid *oid,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\treturn git_reference_name_to_id(oid, repo, ref_name_out->ptr);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_tag_reference_oid(\n\tgit_oid *oid,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\treturn git_reference_name_to_id(oid, repo, ref_name_out->ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "target"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!create_tag_annotation || (tagger && message)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && tag_name && target"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int git_tag_create__internal(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message,\n\t\tint allow_ref_overwrite,\n\t\tint create_tag_annotation)\n{\n\tgit_reference *new_ref = NULL;\n\tgit_buf ref_name = GIT_BUF_INIT;\n\n\tint error;\n\n\tassert(repo && tag_name && target);\n\tassert(!create_tag_annotation || (tagger && message));\n\n\tif (git_object_owner(target) != repo) {\n\t\tgiterr_set(GITERR_INVALID, \"The given target does not belong to this repository\");\n\t\treturn -1;\n\t}\n\n\terror = retrieve_tag_reference_oid(oid, &ref_name, repo, tag_name);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\t/** Ensure the tag name doesn't conflict with an already existing\n\t *\treference unless overwriting has explicitly been requested **/\n\tif (error == 0 && !allow_ref_overwrite) {\n\t\tgit_buf_free(&ref_name);\n\t\tgiterr_set(GITERR_TAG, \"Tag already exists\");\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif (create_tag_annotation) {\n\t\tif (write_tag_annotation(oid, repo, tag_name, target, tagger, message) < 0)\n\t\t\treturn -1;\n\t} else\n\t\tgit_oid_cpy(oid, git_object_id(target));\n\n\terror = git_reference_create(&new_ref, repo, ref_name.ptr, oid, allow_ref_overwrite, NULL);\n\ncleanup:\n\tgit_reference_free(new_ref);\n\tgit_buf_free(&ref_name);\n\treturn error;\n}"
  },
  {
    "function_name": "write_tag_annotation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "206-239",
    "snippet": "static int write_tag_annotation(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message)\n{\n\tgit_buf tag = GIT_BUF_INIT;\n\tgit_odb *odb;\n\n\tgit_oid__writebuf(&tag, \"object \", git_object_id(target));\n\tgit_buf_printf(&tag, \"type %s\\n\", git_object_type2string(git_object_type(target)));\n\tgit_buf_printf(&tag, \"tag %s\\n\", tag_name);\n\tgit_signature__writebuf(&tag, \"tagger \", tagger);\n\tgit_buf_putc(&tag, '\\n');\n\n\tif (git_buf_puts(&tag, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(oid, odb, tag.ptr, tag.size, GIT_OBJ_TAG) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&tag);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&tag);\n\tgiterr_set(GITERR_OBJECT, \"Failed to create tag annotation.\");\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"Failed to create tag annotation.\""
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&tag"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_write",
          "args": [
            "oid",
            "odb",
            "tag.ptr",
            "tag.size",
            "GIT_OBJ_TAG"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "984-1024",
          "snippet": "int git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&tag",
            "message"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "&tag",
            "'\\n'"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature__writebuf",
          "args": [
            "&tag",
            "\"tagger \"",
            "tagger"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature__writebuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "265-284",
          "snippet": "void git_signature__writebuf(git_buf *buf, const char *header, const git_signature *sig)\n{\n\tint offset, hours, mins;\n\tchar sign;\n\n\tassert(buf && sig);\n\n\toffset = sig->when.offset;\n\tsign = (sig->when.offset < 0) ? '-' : '+';\n\n\tif (offset < 0)\n\t\toffset = -offset;\n\n\thours = offset / 60;\n\tmins = offset % 60;\n\n\tgit_buf_printf(buf, \"%s%s <%s> %u %c%02d%02d\\n\",\n\t\t\theader ? header : \"\", sig->name, sig->email,\n\t\t\t(unsigned)sig->when.time, sign, hours, mins);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature__writebuf(git_buf *buf, const char *header, const git_signature *sig)\n{\n\tint offset, hours, mins;\n\tchar sign;\n\n\tassert(buf && sig);\n\n\toffset = sig->when.offset;\n\tsign = (sig->when.offset < 0) ? '-' : '+';\n\n\tif (offset < 0)\n\t\toffset = -offset;\n\n\thours = offset / 60;\n\tmins = offset % 60;\n\n\tgit_buf_printf(buf, \"%s%s <%s> %u %c%02d%02d\\n\",\n\t\t\theader ? header : \"\", sig->name, sig->email,\n\t\t\t(unsigned)sig->when.time, sign, hours, mins);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&tag",
            "\"tag %s\\n\"",
            "tag_name"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type2string",
          "args": [
            "git_object_type(target)"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_type2string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "227-233",
          "snippet": "const char *git_object_type2string(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn \"\";\n\n\treturn git_objects_table[type].str;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nconst char *git_object_type2string(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn \"\";\n\n\treturn git_objects_table[type].str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type",
          "args": [
            "target"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__writebuf",
          "args": [
            "&tag",
            "\"object \"",
            "git_object_id(target)"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__writebuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "159-167",
          "snippet": "void git_oid__writebuf(git_buf *buf, const char *header, const git_oid *oid)\n{\n\tchar hex_oid[GIT_OID_HEXSZ];\n\n\tgit_oid_fmt(hex_oid, oid);\n\tgit_buf_puts(buf, header);\n\tgit_buf_put(buf, hex_oid, GIT_OID_HEXSZ);\n\tgit_buf_putc(buf, '\\n');\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid__writebuf(git_buf *buf, const char *header, const git_oid *oid)\n{\n\tchar hex_oid[GIT_OID_HEXSZ];\n\n\tgit_oid_fmt(hex_oid, oid);\n\tgit_buf_puts(buf, header);\n\tgit_buf_put(buf, hex_oid, GIT_OID_HEXSZ);\n\tgit_buf_putc(buf, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "target"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int write_tag_annotation(\n\t\tgit_oid *oid,\n\t\tgit_repository *repo,\n\t\tconst char *tag_name,\n\t\tconst git_object *target,\n\t\tconst git_signature *tagger,\n\t\tconst char *message)\n{\n\tgit_buf tag = GIT_BUF_INIT;\n\tgit_odb *odb;\n\n\tgit_oid__writebuf(&tag, \"object \", git_object_id(target));\n\tgit_buf_printf(&tag, \"type %s\\n\", git_object_type2string(git_object_type(target)));\n\tgit_buf_printf(&tag, \"tag %s\\n\", tag_name);\n\tgit_signature__writebuf(&tag, \"tagger \", tagger);\n\tgit_buf_putc(&tag, '\\n');\n\n\tif (git_buf_puts(&tag, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(oid, odb, tag.ptr, tag.size, GIT_OBJ_TAG) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&tag);\n\treturn 0;\n\non_error:\n\tgit_buf_free(&tag);\n\tgiterr_set(GITERR_OBJECT, \"Failed to create tag annotation.\");\n\treturn -1;\n}"
  },
  {
    "function_name": "retrieve_tag_reference_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "194-204",
    "snippet": "static int retrieve_tag_reference_oid(\n\tgit_oid *oid,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\treturn git_reference_name_to_id(oid, repo, ref_name_out->ptr);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_name_to_id",
          "args": [
            "oid",
            "repo",
            "ref_name_out->ptr"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name_to_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "152-164",
          "snippet": "int git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "ref_name_out",
            "GIT_REFS_TAGS_DIR",
            "tag_name"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_tag_reference_oid(\n\tgit_oid *oid,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\treturn git_reference_name_to_id(oid, repo, ref_name_out->ptr);\n}"
  },
  {
    "function_name": "retrieve_tag_reference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "171-192",
    "snippet": "static int retrieve_tag_reference(\n\tgit_reference **tag_reference_out,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tgit_reference *tag_ref;\n\tint error;\n\n\t*tag_reference_out = NULL;\n\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\terror = git_reference_lookup(&tag_ref, repo, ref_name_out->ptr);\n\tif (error < 0)\n\t\treturn error; /* Be it not foundo or corrupted */\n\n\t*tag_reference_out = tag_ref;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&tag_ref",
            "repo",
            "ref_name_out->ptr"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "ref_name_out",
            "GIT_REFS_TAGS_DIR",
            "tag_name"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int retrieve_tag_reference(\n\tgit_reference **tag_reference_out,\n\tgit_buf *ref_name_out,\n\tgit_repository *repo,\n\tconst char *tag_name)\n{\n\tgit_reference *tag_ref;\n\tint error;\n\n\t*tag_reference_out = NULL;\n\n\tif (git_buf_joinpath(ref_name_out, GIT_REFS_TAGS_DIR, tag_name) < 0)\n\t\treturn -1;\n\n\terror = git_reference_lookup(&tag_ref, repo, ref_name_out->ptr);\n\tif (error < 0)\n\t\treturn error; /* Be it not foundo or corrupted */\n\n\t*tag_reference_out = tag_ref;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_tag__parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "162-169",
    "snippet": "int git_tag__parse(void *_tag, git_odb_object *odb_obj)\n{\n\tgit_tag *tag = _tag;\n\tconst char *buffer = git_odb_object_data(odb_obj);\n\tconst char *buffer_end = buffer + git_odb_object_size(odb_obj);\n\n\treturn tag_parse(tag, buffer, buffer_end);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tag_parse",
          "args": [
            "tag",
            "buffer",
            "buffer_end"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "tag_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "68-160",
          "snippet": "static int tag_parse(git_tag *tag, const char *buffer, const char *buffer_end)\n{\n\tstatic const char *tag_types[] = {\n\t\tNULL, \"commit\\n\", \"tree\\n\", \"blob\\n\", \"tag\\n\"\n\t};\n\n\tunsigned int i;\n\tsize_t text_len, alloc_len;\n\tchar *search;\n\n\tif (git_oid__parse(&tag->target, &buffer, buffer_end, \"object \") < 0)\n\t\treturn tag_error(\"Object field invalid\");\n\n\tif (buffer + 5 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"type \", 5) != 0)\n\t\treturn tag_error(\"Type field not found\");\n\tbuffer += 5;\n\n\ttag->type = GIT_OBJ_BAD;\n\n\tfor (i = 1; i < ARRAY_SIZE(tag_types); ++i) {\n\t\tsize_t type_length = strlen(tag_types[i]);\n\n\t\tif (buffer + type_length >= buffer_end)\n\t\t\treturn tag_error(\"Object too short\");\n\n\t\tif (memcmp(buffer, tag_types[i], type_length) == 0) {\n\t\t\ttag->type = i;\n\t\t\tbuffer += type_length;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tag->type == GIT_OBJ_BAD)\n\t\treturn tag_error(\"Invalid object type\");\n\n\tif (buffer + 4 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"tag \", 4) != 0)\n\t\treturn tag_error(\"Tag field not found\");\n\n\tbuffer += 4;\n\n\tsearch = memchr(buffer, '\\n', buffer_end - buffer);\n\tif (search == NULL)\n\t\treturn tag_error(\"Object too short\");\n\n\ttext_len = search - buffer;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\ttag->tag_name = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(tag->tag_name);\n\n\tmemcpy(tag->tag_name, buffer, text_len);\n\ttag->tag_name[text_len] = '\\0';\n\n\tbuffer = search + 1;\n\n\ttag->tagger = NULL;\n\tif (buffer < buffer_end && *buffer != '\\n') {\n\t\ttag->tagger = git__malloc(sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(tag->tagger);\n\n\t\tif (git_signature__parse(tag->tagger, &buffer, buffer_end, \"tagger \", '\\n') < 0)\n\t\t\treturn -1;\n\t}\n\n\ttag->message = NULL;\n\tif (buffer < buffer_end) {\n\t\t/* If we're not at the end of the header, search for it */\n\t\tif( *buffer != '\\n' ) {\n\t\t\tsearch = strstr(buffer, \"\\n\\n\");\n\t\t\tif (search)\n\t\t\t\tbuffer = search + 1;\n\t\t\telse\n\t\t\t\treturn tag_error(\"tag contains no message\");\n\t\t}\n\n\t\ttext_len = buffer_end - ++buffer;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\t\ttag->message = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(tag->message);\n\n\t\tmemcpy(tag->message, buffer, text_len);\n\t\ttag->message[text_len] = '\\0';\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int tag_parse(git_tag *tag, const char *buffer, const char *buffer_end)\n{\n\tstatic const char *tag_types[] = {\n\t\tNULL, \"commit\\n\", \"tree\\n\", \"blob\\n\", \"tag\\n\"\n\t};\n\n\tunsigned int i;\n\tsize_t text_len, alloc_len;\n\tchar *search;\n\n\tif (git_oid__parse(&tag->target, &buffer, buffer_end, \"object \") < 0)\n\t\treturn tag_error(\"Object field invalid\");\n\n\tif (buffer + 5 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"type \", 5) != 0)\n\t\treturn tag_error(\"Type field not found\");\n\tbuffer += 5;\n\n\ttag->type = GIT_OBJ_BAD;\n\n\tfor (i = 1; i < ARRAY_SIZE(tag_types); ++i) {\n\t\tsize_t type_length = strlen(tag_types[i]);\n\n\t\tif (buffer + type_length >= buffer_end)\n\t\t\treturn tag_error(\"Object too short\");\n\n\t\tif (memcmp(buffer, tag_types[i], type_length) == 0) {\n\t\t\ttag->type = i;\n\t\t\tbuffer += type_length;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tag->type == GIT_OBJ_BAD)\n\t\treturn tag_error(\"Invalid object type\");\n\n\tif (buffer + 4 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"tag \", 4) != 0)\n\t\treturn tag_error(\"Tag field not found\");\n\n\tbuffer += 4;\n\n\tsearch = memchr(buffer, '\\n', buffer_end - buffer);\n\tif (search == NULL)\n\t\treturn tag_error(\"Object too short\");\n\n\ttext_len = search - buffer;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\ttag->tag_name = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(tag->tag_name);\n\n\tmemcpy(tag->tag_name, buffer, text_len);\n\ttag->tag_name[text_len] = '\\0';\n\n\tbuffer = search + 1;\n\n\ttag->tagger = NULL;\n\tif (buffer < buffer_end && *buffer != '\\n') {\n\t\ttag->tagger = git__malloc(sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(tag->tagger);\n\n\t\tif (git_signature__parse(tag->tagger, &buffer, buffer_end, \"tagger \", '\\n') < 0)\n\t\t\treturn -1;\n\t}\n\n\ttag->message = NULL;\n\tif (buffer < buffer_end) {\n\t\t/* If we're not at the end of the header, search for it */\n\t\tif( *buffer != '\\n' ) {\n\t\t\tsearch = strstr(buffer, \"\\n\\n\");\n\t\t\tif (search)\n\t\t\t\tbuffer = search + 1;\n\t\t\telse\n\t\t\t\treturn tag_error(\"tag contains no message\");\n\t\t}\n\n\t\ttext_len = buffer_end - ++buffer;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\t\ttag->message = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(tag->message);\n\n\t\tmemcpy(tag->message, buffer, text_len);\n\t\ttag->message[text_len] = '\\0';\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_size",
          "args": [
            "odb_obj"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "120-123",
          "snippet": "size_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nsize_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_data",
          "args": [
            "odb_obj"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "115-118",
          "snippet": "const void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nconst void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag__parse(void *_tag, git_odb_object *odb_obj)\n{\n\tgit_tag *tag = _tag;\n\tconst char *buffer = git_odb_object_data(odb_obj);\n\tconst char *buffer_end = buffer + git_odb_object_size(odb_obj);\n\n\treturn tag_parse(tag, buffer, buffer_end);\n}"
  },
  {
    "function_name": "tag_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "68-160",
    "snippet": "static int tag_parse(git_tag *tag, const char *buffer, const char *buffer_end)\n{\n\tstatic const char *tag_types[] = {\n\t\tNULL, \"commit\\n\", \"tree\\n\", \"blob\\n\", \"tag\\n\"\n\t};\n\n\tunsigned int i;\n\tsize_t text_len, alloc_len;\n\tchar *search;\n\n\tif (git_oid__parse(&tag->target, &buffer, buffer_end, \"object \") < 0)\n\t\treturn tag_error(\"Object field invalid\");\n\n\tif (buffer + 5 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"type \", 5) != 0)\n\t\treturn tag_error(\"Type field not found\");\n\tbuffer += 5;\n\n\ttag->type = GIT_OBJ_BAD;\n\n\tfor (i = 1; i < ARRAY_SIZE(tag_types); ++i) {\n\t\tsize_t type_length = strlen(tag_types[i]);\n\n\t\tif (buffer + type_length >= buffer_end)\n\t\t\treturn tag_error(\"Object too short\");\n\n\t\tif (memcmp(buffer, tag_types[i], type_length) == 0) {\n\t\t\ttag->type = i;\n\t\t\tbuffer += type_length;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tag->type == GIT_OBJ_BAD)\n\t\treturn tag_error(\"Invalid object type\");\n\n\tif (buffer + 4 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"tag \", 4) != 0)\n\t\treturn tag_error(\"Tag field not found\");\n\n\tbuffer += 4;\n\n\tsearch = memchr(buffer, '\\n', buffer_end - buffer);\n\tif (search == NULL)\n\t\treturn tag_error(\"Object too short\");\n\n\ttext_len = search - buffer;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\ttag->tag_name = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(tag->tag_name);\n\n\tmemcpy(tag->tag_name, buffer, text_len);\n\ttag->tag_name[text_len] = '\\0';\n\n\tbuffer = search + 1;\n\n\ttag->tagger = NULL;\n\tif (buffer < buffer_end && *buffer != '\\n') {\n\t\ttag->tagger = git__malloc(sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(tag->tagger);\n\n\t\tif (git_signature__parse(tag->tagger, &buffer, buffer_end, \"tagger \", '\\n') < 0)\n\t\t\treturn -1;\n\t}\n\n\ttag->message = NULL;\n\tif (buffer < buffer_end) {\n\t\t/* If we're not at the end of the header, search for it */\n\t\tif( *buffer != '\\n' ) {\n\t\t\tsearch = strstr(buffer, \"\\n\\n\");\n\t\t\tif (search)\n\t\t\t\tbuffer = search + 1;\n\t\t\telse\n\t\t\t\treturn tag_error(\"tag contains no message\");\n\t\t}\n\n\t\ttext_len = buffer_end - ++buffer;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\t\ttag->message = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(tag->message);\n\n\t\tmemcpy(tag->message, buffer, text_len);\n\t\ttag->message[text_len] = '\\0';\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tag->message",
            "buffer",
            "text_len"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tag->message"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloc_len"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "text_len",
            "1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag_error",
          "args": [
            "\"tag contains no message\""
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "tag_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "62-66",
          "snippet": "static int tag_error(const char *str)\n{\n\tgiterr_set(GITERR_TAG, \"Failed to parse tag. %s\", str);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int tag_error(const char *str)\n{\n\tgiterr_set(GITERR_TAG, \"Failed to parse tag. %s\", str);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buffer",
            "\"\\n\\n\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_signature__parse",
          "args": [
            "tag->tagger",
            "&buffer",
            "buffer_end",
            "\"tagger \"",
            "'\\n'"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "195-263",
          "snippet": "int git_signature__parse(git_signature *sig, const char **buffer_out,\n\t\tconst char *buffer_end, const char *header, char ender)\n{\n\tconst char *buffer = *buffer_out;\n\tconst char *email_start, *email_end;\n\n\tmemset(sig, 0, sizeof(git_signature));\n\n\tif ((buffer_end = memchr(buffer, ender, buffer_end - buffer)) == NULL)\n\t\treturn signature_error(\"no newline given\");\n\n\tif (header) {\n\t\tconst size_t header_len = strlen(header);\n\n\t\tif (buffer + header_len >= buffer_end || memcmp(buffer, header, header_len) != 0)\n\t\t\treturn signature_error(\"expected prefix doesn't match actual\");\n\n\t\tbuffer += header_len;\n\t}\n\n\temail_start = git__memrchr(buffer, '<', buffer_end - buffer);\n\temail_end = git__memrchr(buffer, '>', buffer_end - buffer);\n\n\tif (!email_start || !email_end || email_end <= email_start)\n\t\treturn signature_error(\"malformed e-mail\");\n\n\temail_start += 1;\n\tsig->name = extract_trimmed(buffer, email_start - buffer - 1);\n\tsig->email = extract_trimmed(email_start, email_end - email_start);\n\n\t/* Do we even have a time at the end of the signature? */\n\tif (email_end + 2 < buffer_end) {\n\t\tconst char *time_start = email_end + 2;\n\t\tconst char *time_end;\n\n\t\tif (git__strtol64(&sig->when.time, time_start, &time_end, 10) < 0)\n\t\t\treturn signature_error(\"invalid Unix timestamp\");\n\n\t\t/* do we have a timezone? */\n\t\tif (time_end + 1 < buffer_end) {\n\t\t\tint offset, hours, mins;\n\t\t\tconst char *tz_start, *tz_end;\n\n\t\t\ttz_start = time_end + 1;\n\n\t\t\tif ((tz_start[0] != '-' && tz_start[0] != '+') ||\n\t\t\t\tgit__strtol32(&offset, tz_start + 1, &tz_end, 10) < 0) {\n\t\t\t\t//malformed timezone, just assume it's zero\n\t\t\t\toffset = 0;\n\t\t\t}\n\n\t\t\thours = offset / 100;\n\t\t\tmins = offset % 100;\n\n\t\t\t/*\n\t\t\t * only store timezone if it's not overflowing;\n\t\t\t * see http://www.worldtimezone.com/faq.html\n\t\t\t */\n\t\t\tif (hours < 14 && mins < 59) {\n\t\t\t\tsig->when.offset = (hours * 60) + mins;\n\t\t\t\tif (tz_start[0] == '-')\n\t\t\t\t\tsig->when.offset = -sig->when.offset;\n\t\t\t}\n\t\t}\n\t}\n\n\t*buffer_out = buffer_end + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nint git_signature__parse(git_signature *sig, const char **buffer_out,\n\t\tconst char *buffer_end, const char *header, char ender)\n{\n\tconst char *buffer = *buffer_out;\n\tconst char *email_start, *email_end;\n\n\tmemset(sig, 0, sizeof(git_signature));\n\n\tif ((buffer_end = memchr(buffer, ender, buffer_end - buffer)) == NULL)\n\t\treturn signature_error(\"no newline given\");\n\n\tif (header) {\n\t\tconst size_t header_len = strlen(header);\n\n\t\tif (buffer + header_len >= buffer_end || memcmp(buffer, header, header_len) != 0)\n\t\t\treturn signature_error(\"expected prefix doesn't match actual\");\n\n\t\tbuffer += header_len;\n\t}\n\n\temail_start = git__memrchr(buffer, '<', buffer_end - buffer);\n\temail_end = git__memrchr(buffer, '>', buffer_end - buffer);\n\n\tif (!email_start || !email_end || email_end <= email_start)\n\t\treturn signature_error(\"malformed e-mail\");\n\n\temail_start += 1;\n\tsig->name = extract_trimmed(buffer, email_start - buffer - 1);\n\tsig->email = extract_trimmed(email_start, email_end - email_start);\n\n\t/* Do we even have a time at the end of the signature? */\n\tif (email_end + 2 < buffer_end) {\n\t\tconst char *time_start = email_end + 2;\n\t\tconst char *time_end;\n\n\t\tif (git__strtol64(&sig->when.time, time_start, &time_end, 10) < 0)\n\t\t\treturn signature_error(\"invalid Unix timestamp\");\n\n\t\t/* do we have a timezone? */\n\t\tif (time_end + 1 < buffer_end) {\n\t\t\tint offset, hours, mins;\n\t\t\tconst char *tz_start, *tz_end;\n\n\t\t\ttz_start = time_end + 1;\n\n\t\t\tif ((tz_start[0] != '-' && tz_start[0] != '+') ||\n\t\t\t\tgit__strtol32(&offset, tz_start + 1, &tz_end, 10) < 0) {\n\t\t\t\t//malformed timezone, just assume it's zero\n\t\t\t\toffset = 0;\n\t\t\t}\n\n\t\t\thours = offset / 100;\n\t\t\tmins = offset % 100;\n\n\t\t\t/*\n\t\t\t * only store timezone if it's not overflowing;\n\t\t\t * see http://www.worldtimezone.com/faq.html\n\t\t\t */\n\t\t\tif (hours < 14 && mins < 59) {\n\t\t\t\tsig->when.offset = (hours * 60) + mins;\n\t\t\t\tif (tz_start[0] == '-')\n\t\t\t\t\tsig->when.offset = -sig->when.offset;\n\t\t\t}\n\t\t}\n\t}\n\n\t*buffer_out = buffer_end + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tag->tagger"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tag->tag_name",
            "buffer",
            "text_len"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tag->tag_name"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "text_len",
            "1"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buffer",
            "'\\n'",
            "buffer_end - buffer"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"tag \"",
            "4"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "tag_types[i]",
            "type_length"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tag_types[i]"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tag_types"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"type \"",
            "5"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid__parse",
          "args": [
            "&tag->target",
            "&buffer",
            "buffer_end",
            "\"object \""
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "133-157",
          "snippet": "int git_oid__parse(\n\tgit_oid *oid, const char **buffer_out,\n\tconst char *buffer_end, const char *header)\n{\n\tconst size_t sha_len = GIT_OID_HEXSZ;\n\tconst size_t header_len = strlen(header);\n\n\tconst char *buffer = *buffer_out;\n\n\tif (buffer + (header_len + sha_len + 1) > buffer_end)\n\t\treturn -1;\n\n\tif (memcmp(buffer, header, header_len) != 0)\n\t\treturn -1;\n\n\tif (buffer[header_len + sha_len] != '\\n')\n\t\treturn -1;\n\n\tif (git_oid_fromstr(oid, buffer + header_len) < 0)\n\t\treturn -1;\n\n\t*buffer_out = buffer + (header_len + sha_len + 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid__parse(\n\tgit_oid *oid, const char **buffer_out,\n\tconst char *buffer_end, const char *header)\n{\n\tconst size_t sha_len = GIT_OID_HEXSZ;\n\tconst size_t header_len = strlen(header);\n\n\tconst char *buffer = *buffer_out;\n\n\tif (buffer + (header_len + sha_len + 1) > buffer_end)\n\t\treturn -1;\n\n\tif (memcmp(buffer, header, header_len) != 0)\n\t\treturn -1;\n\n\tif (buffer[header_len + sha_len] != '\\n')\n\t\treturn -1;\n\n\tif (git_oid_fromstr(oid, buffer + header_len) < 0)\n\t\treturn -1;\n\n\t*buffer_out = buffer + (header_len + sha_len + 1);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int tag_parse(git_tag *tag, const char *buffer, const char *buffer_end)\n{\n\tstatic const char *tag_types[] = {\n\t\tNULL, \"commit\\n\", \"tree\\n\", \"blob\\n\", \"tag\\n\"\n\t};\n\n\tunsigned int i;\n\tsize_t text_len, alloc_len;\n\tchar *search;\n\n\tif (git_oid__parse(&tag->target, &buffer, buffer_end, \"object \") < 0)\n\t\treturn tag_error(\"Object field invalid\");\n\n\tif (buffer + 5 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"type \", 5) != 0)\n\t\treturn tag_error(\"Type field not found\");\n\tbuffer += 5;\n\n\ttag->type = GIT_OBJ_BAD;\n\n\tfor (i = 1; i < ARRAY_SIZE(tag_types); ++i) {\n\t\tsize_t type_length = strlen(tag_types[i]);\n\n\t\tif (buffer + type_length >= buffer_end)\n\t\t\treturn tag_error(\"Object too short\");\n\n\t\tif (memcmp(buffer, tag_types[i], type_length) == 0) {\n\t\t\ttag->type = i;\n\t\t\tbuffer += type_length;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tag->type == GIT_OBJ_BAD)\n\t\treturn tag_error(\"Invalid object type\");\n\n\tif (buffer + 4 >= buffer_end)\n\t\treturn tag_error(\"Object too short\");\n\n\tif (memcmp(buffer, \"tag \", 4) != 0)\n\t\treturn tag_error(\"Tag field not found\");\n\n\tbuffer += 4;\n\n\tsearch = memchr(buffer, '\\n', buffer_end - buffer);\n\tif (search == NULL)\n\t\treturn tag_error(\"Object too short\");\n\n\ttext_len = search - buffer;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\ttag->tag_name = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(tag->tag_name);\n\n\tmemcpy(tag->tag_name, buffer, text_len);\n\ttag->tag_name[text_len] = '\\0';\n\n\tbuffer = search + 1;\n\n\ttag->tagger = NULL;\n\tif (buffer < buffer_end && *buffer != '\\n') {\n\t\ttag->tagger = git__malloc(sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(tag->tagger);\n\n\t\tif (git_signature__parse(tag->tagger, &buffer, buffer_end, \"tagger \", '\\n') < 0)\n\t\t\treturn -1;\n\t}\n\n\ttag->message = NULL;\n\tif (buffer < buffer_end) {\n\t\t/* If we're not at the end of the header, search for it */\n\t\tif( *buffer != '\\n' ) {\n\t\t\tsearch = strstr(buffer, \"\\n\\n\");\n\t\t\tif (search)\n\t\t\t\tbuffer = search + 1;\n\t\t\telse\n\t\t\t\treturn tag_error(\"tag contains no message\");\n\t\t}\n\n\t\ttext_len = buffer_end - ++buffer;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, text_len, 1);\n\t\ttag->message = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(tag->message);\n\n\t\tmemcpy(tag->message, buffer, text_len);\n\t\ttag->message[text_len] = '\\0';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tag_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "62-66",
    "snippet": "static int tag_error(const char *str)\n{\n\tgiterr_set(GITERR_TAG, \"Failed to parse tag. %s\", str);\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_TAG",
            "\"Failed to parse tag. %s\"",
            "str"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int tag_error(const char *str)\n{\n\tgiterr_set(GITERR_TAG, \"Failed to parse tag. %s\", str);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_tag_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "56-60",
    "snippet": "const char *git_tag_message(const git_tag *t)\n{\n\tassert(t);\n\treturn t->message;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst char *git_tag_message(const git_tag *t)\n{\n\tassert(t);\n\treturn t->message;\n}"
  },
  {
    "function_name": "git_tag_tagger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "51-54",
    "snippet": "const git_signature *git_tag_tagger(const git_tag *t)\n{\n\treturn t->tagger;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst git_signature *git_tag_tagger(const git_tag *t)\n{\n\treturn t->tagger;\n}"
  },
  {
    "function_name": "git_tag_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "45-49",
    "snippet": "const char *git_tag_name(const git_tag *t)\n{\n\tassert(t);\n\treturn t->tag_name;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst char *git_tag_name(const git_tag *t)\n{\n\tassert(t);\n\treturn t->tag_name;\n}"
  },
  {
    "function_name": "git_tag_target_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "39-43",
    "snippet": "git_otype git_tag_target_type(const git_tag *t)\n{\n\tassert(t);\n\treturn t->type;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\ngit_otype git_tag_target_type(const git_tag *t)\n{\n\tassert(t);\n\treturn t->type;\n}"
  },
  {
    "function_name": "git_tag_target_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "33-37",
    "snippet": "const git_oid *git_tag_target_id(const git_tag *t)\n{\n\tassert(t);\n\treturn &t->target;\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst git_oid *git_tag_target_id(const git_tag *t)\n{\n\tassert(t);\n\treturn &t->target;\n}"
  },
  {
    "function_name": "git_tag_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "27-31",
    "snippet": "int git_tag_target(git_object **target, const git_tag *t)\n{\n\tassert(t);\n\treturn git_object_lookup(target, t->object.repo, &t->target, t->type);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "target",
            "t->object.repo",
            "&t->target",
            "t->type"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_target(git_object **target, const git_tag *t)\n{\n\tassert(t);\n\treturn git_object_lookup(target, t->object.repo, &t->target, t->type);\n}"
  },
  {
    "function_name": "git_tag__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
    "lines": "18-25",
    "snippet": "void git_tag__free(void *_tag)\n{\n\tgit_tag *tag = _tag;\n\tgit_signature_free(tag->tagger);\n\tgit__free(tag->message);\n\tgit__free(tag->tag_name);\n\tgit__free(tag);\n}",
    "includes": [
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"tag.h\"",
      "#include \"commit.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "tag"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature_free",
          "args": [
            "tag->tagger"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "14-24",
          "snippet": "void git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_tag__free(void *_tag)\n{\n\tgit_tag *tag = _tag;\n\tgit_signature_free(tag->tagger);\n\tgit__free(tag->message);\n\tgit__free(tag->tag_name);\n\tgit__free(tag);\n}"
  }
]