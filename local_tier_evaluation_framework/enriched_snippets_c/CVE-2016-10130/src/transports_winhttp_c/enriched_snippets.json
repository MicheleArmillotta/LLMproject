[
  {
    "function_name": "git_smart_subtransport_http",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1388-1407",
    "snippet": "int git_smart_subtransport_http(git_smart_subtransport **out, git_transport *owner, void *param)\n{\n\twinhttp_subtransport *t;\n\n\tGIT_UNUSED(param);\n\n\tif (!out)\n\t\treturn -1;\n\n\tt = git__calloc(1, sizeof(winhttp_subtransport));\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->owner = (transport_smart *)owner;\n\tt->parent.action = winhttp_action;\n\tt->parent.close = winhttp_close;\n\tt->parent.free = winhttp_free;\n\n\t*out = (git_smart_subtransport *) t;\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "t"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(winhttp_subtransport)"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "param"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nint git_smart_subtransport_http(git_smart_subtransport **out, git_transport *owner, void *param)\n{\n\twinhttp_subtransport *t;\n\n\tGIT_UNUSED(param);\n\n\tif (!out)\n\t\treturn -1;\n\n\tt = git__calloc(1, sizeof(winhttp_subtransport));\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->owner = (transport_smart *)owner;\n\tt->parent.action = winhttp_action;\n\tt->parent.close = winhttp_close;\n\tt->parent.free = winhttp_free;\n\n\t*out = (git_smart_subtransport *) t;\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1379-1386",
    "snippet": "static void winhttp_free(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\twinhttp_close(subtransport);\n\n\tgit__free(t);\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "t"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_close",
          "args": [
            "subtransport"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic void winhttp_free(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\twinhttp_close(subtransport);\n\n\tgit__free(t);\n}"
  },
  {
    "function_name": "winhttp_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1359-1377",
    "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "winhttp_close_connection",
          "args": [
            "t"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "551-574",
          "snippet": "static int winhttp_close_connection(winhttp_subtransport *t)\n{\n\tint ret = 0;\n\n\tif (t->connection) {\n\t\tif (!WinHttpCloseHandle(t->connection)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close connection\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->connection = NULL;\n\t}\n\n\tif (t->session) {\n\t\tif (!WinHttpCloseHandle(t->session)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close session\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->session = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close_connection(winhttp_subtransport *t)\n{\n\tint ret = 0;\n\n\tif (t->connection) {\n\t\tif (!WinHttpCloseHandle(t->connection)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close connection\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->connection = NULL;\n\t}\n\n\tif (t->session) {\n\t\tif (!WinHttpCloseHandle(t->session)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close session\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->session = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->url_cred->free",
          "args": [
            "t->url_cred"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->cred->free",
          "args": [
            "t->cred"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&t->connection_data",
            "0x0",
            "sizeof(gitno_connection_data)"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gitno_connection_data_free_ptrs",
          "args": [
            "&t->connection_data"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_connection_data_free_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "200-207",
          "snippet": "void gitno_connection_data_free_ptrs(gitno_connection_data *d)\n{\n\tgit__free(d->host); d->host = NULL;\n\tgit__free(d->port); d->port = NULL;\n\tgit__free(d->path); d->path = NULL;\n\tgit__free(d->user); d->user = NULL;\n\tgit__free(d->pass); d->pass = NULL;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_connection_data_free_ptrs(gitno_connection_data *d)\n{\n\tgit__free(d->host); d->host = NULL;\n\tgit__free(d->port); d->port = NULL;\n\tgit__free(d->path); d->path = NULL;\n\tgit__free(d->user); d->user = NULL;\n\tgit__free(d->pass); d->pass = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
  },
  {
    "function_name": "winhttp_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1310-1357",
    "snippet": "static int winhttp_action(\n\tgit_smart_subtransport_stream **stream,\n\tgit_smart_subtransport *subtransport,\n\tconst char *url,\n\tgit_smart_service_t action)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\twinhttp_stream *s;\n\tint ret = -1;\n\n\tif (!t->connection)\n\t\tif ((ret = gitno_connection_data_from_url(&t->connection_data, url, NULL)) < 0 ||\n\t\t\t (ret = winhttp_connect(t)) < 0)\n\t\t\treturn ret;\n\n\tif (winhttp_stream_alloc(t, &s) < 0)\n\t\treturn -1;\n\n\tif (!stream)\n\t\treturn -1;\n\n\tswitch (action)\n\t{\n\t\tcase GIT_SERVICE_UPLOADPACK_LS:\n\t\t\tret = winhttp_uploadpack_ls(t, s);\n\t\t\tbreak;\n\n\t\tcase GIT_SERVICE_UPLOADPACK:\n\t\t\tret = winhttp_uploadpack(t, s);\n\t\t\tbreak;\n\n\t\tcase GIT_SERVICE_RECEIVEPACK_LS:\n\t\t\tret = winhttp_receivepack_ls(t, s);\n\t\t\tbreak;\n\n\t\tcase GIT_SERVICE_RECEIVEPACK:\n\t\t\tret = winhttp_receivepack(t, s);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tassert(0);\n\t}\n\n\tif (!ret)\n\t\t*stream = &s->parent;\n\n\treturn ret;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "winhttp_receivepack",
          "args": [
            "t",
            "s"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_receivepack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1288-1308",
          "snippet": "static int winhttp_receivepack(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\t/* WinHTTP only supports Transfer-Encoding: chunked\n\t * on Windows Vista (NT 6.0) and higher. */\n\ts->chunked = git_has_win32_version(6, 0, 0);\n\n\tif (s->chunked)\n\t\ts->parent.write = winhttp_stream_write_chunked;\n\telse\n\t\ts->parent.write = winhttp_stream_write_buffered;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_receivepack(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\t/* WinHTTP only supports Transfer-Encoding: chunked\n\t * on Windows Vista (NT 6.0) and higher. */\n\ts->chunked = git_has_win32_version(6, 0, 0);\n\n\tif (s->chunked)\n\t\ts->parent.write = winhttp_stream_write_chunked;\n\telse\n\t\ts->parent.write = winhttp_stream_write_buffered;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_receivepack_ls",
          "args": [
            "t",
            "s"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_receivepack_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1275-1286",
          "snippet": "static int winhttp_receivepack_ls(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_receivepack_ls(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_uploadpack",
          "args": [
            "t",
            "s"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_uploadpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1262-1273",
          "snippet": "static int winhttp_uploadpack(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_uploadpack(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_uploadpack_ls",
          "args": [
            "t",
            "s"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_uploadpack_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1249-1260",
          "snippet": "static int winhttp_uploadpack_ls(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_uploadpack_ls(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_stream_alloc",
          "args": [
            "t",
            "&s"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1229-1247",
          "snippet": "static int winhttp_stream_alloc(winhttp_subtransport *t, winhttp_stream **stream)\n{\n\twinhttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(1, sizeof(winhttp_stream));\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = winhttp_stream_read;\n\ts->parent.write = winhttp_stream_write_single;\n\ts->parent.free = winhttp_stream_free;\n\n\t*stream = s;\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_stream_alloc(winhttp_subtransport *t, winhttp_stream **stream)\n{\n\twinhttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(1, sizeof(winhttp_stream));\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = winhttp_stream_read;\n\ts->parent.write = winhttp_stream_write_single;\n\ts->parent.free = winhttp_stream_free;\n\n\t*stream = s;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_connect",
          "args": [
            "t"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "591-670",
          "snippet": "static int winhttp_connect(\n\twinhttp_subtransport *t)\n{\n\twchar_t *wide_host;\n\tint32_t port;\n\twchar_t *wide_ua;\n\tgit_buf ua = GIT_BUF_INIT;\n\tint error = -1;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\n\tt->session = NULL;\n\tt->connection = NULL;\n\n\t/* Prepare port */\n\tif (git__strtol32(&port, t->connection_data.port, NULL, 10) < 0)\n\t\treturn -1;\n\n\t/* Prepare host */\n\tif (git__utf8_to_16_alloc(&wide_host, t->connection_data.host) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\treturn -1;\n\t}\n\n\tif ((error = user_agent(&ua)) < 0) {\n\t\tgit__free(wide_host);\n\t\treturn error;\n\t}\n\n\tif (git__utf8_to_16_alloc(&wide_ua, git_buf_cstr(&ua)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\tgit__free(wide_host);\n\t\tgit_buf_free(&ua);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&ua);\n\n\t/* Establish session */\n\tt->session = WinHttpOpen(\n\t\twide_ua,\n\t\tWINHTTP_ACCESS_TYPE_DEFAULT_PROXY,\n\t\tWINHTTP_NO_PROXY_NAME,\n\t\tWINHTTP_NO_PROXY_BYPASS,\n\t\t0);\n\n\tif (!t->session) {\n\t\tgiterr_set(GITERR_OS, \"Failed to init WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(t->session, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t\n\t/* Establish connection */\n\tt->connection = WinHttpConnect(\n\t\tt->session,\n\t\twide_host,\n\t\t(INTERNET_PORT) port,\n\t\t0);\n\n\tif (!t->connection) {\n\t\tgiterr_set(GITERR_OS, \"Failed to connect to host\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_close_connection(t);\n\n\tgit__free(wide_host);\n\tgit__free(wide_ua);\n\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CONNECT_TIMEOUT 60000",
            "#define TIMEOUT_INFINITE -1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define DEFAULT_CONNECT_TIMEOUT 60000\n#define TIMEOUT_INFINITE -1\n\nstatic int winhttp_connect(\n\twinhttp_subtransport *t)\n{\n\twchar_t *wide_host;\n\tint32_t port;\n\twchar_t *wide_ua;\n\tgit_buf ua = GIT_BUF_INIT;\n\tint error = -1;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\n\tt->session = NULL;\n\tt->connection = NULL;\n\n\t/* Prepare port */\n\tif (git__strtol32(&port, t->connection_data.port, NULL, 10) < 0)\n\t\treturn -1;\n\n\t/* Prepare host */\n\tif (git__utf8_to_16_alloc(&wide_host, t->connection_data.host) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\treturn -1;\n\t}\n\n\tif ((error = user_agent(&ua)) < 0) {\n\t\tgit__free(wide_host);\n\t\treturn error;\n\t}\n\n\tif (git__utf8_to_16_alloc(&wide_ua, git_buf_cstr(&ua)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\tgit__free(wide_host);\n\t\tgit_buf_free(&ua);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&ua);\n\n\t/* Establish session */\n\tt->session = WinHttpOpen(\n\t\twide_ua,\n\t\tWINHTTP_ACCESS_TYPE_DEFAULT_PROXY,\n\t\tWINHTTP_NO_PROXY_NAME,\n\t\tWINHTTP_NO_PROXY_BYPASS,\n\t\t0);\n\n\tif (!t->session) {\n\t\tgiterr_set(GITERR_OS, \"Failed to init WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(t->session, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t\n\t/* Establish connection */\n\tt->connection = WinHttpConnect(\n\t\tt->session,\n\t\twide_host,\n\t\t(INTERNET_PORT) port,\n\t\t0);\n\n\tif (!t->connection) {\n\t\tgiterr_set(GITERR_OS, \"Failed to connect to host\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_close_connection(t);\n\n\tgit__free(wide_host);\n\tgit__free(wide_ua);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_connection_data_from_url",
          "args": [
            "&t->connection_data",
            "url",
            "NULL"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_connection_data_from_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "125-198",
          "snippet": "int gitno_connection_data_from_url(\n\t\tgitno_connection_data *data,\n\t\tconst char *url,\n\t\tconst char *service_suffix)\n{\n\tint error = -1;\n\tconst char *default_port = NULL, *path_search_start = NULL;\n\tchar *original_host = NULL;\n\n\t/* service_suffix is optional */\n\tassert(data && url);\n\n\t/* Save these for comparison later */\n\toriginal_host = data->host;\n\tdata->host = NULL;\n\tgitno_connection_data_free_ptrs(data);\n\n\tif (!git__prefixcmp(url, prefix_http)) {\n\t\tpath_search_start = url + strlen(prefix_http);\n\t\tdefault_port = \"80\";\n\n\t\tif (data->use_ssl) {\n\t\t\tgiterr_set(GITERR_NET, \"Redirect from HTTPS to HTTP is not allowed\");\n\t\t\tgoto cleanup;\n\t\t}\n\t} else if (!git__prefixcmp(url, prefix_https)) {\n\t\tpath_search_start = url + strlen(prefix_https);\n\t\tdefault_port = \"443\";\n\t\tdata->use_ssl = true;\n\t} else if (url[0] == '/')\n\t\tdefault_port = data->use_ssl ? \"443\" : \"80\";\n\n\tif (!default_port) {\n\t\tgiterr_set(GITERR_NET, \"Unrecognized URL prefix\");\n\t\tgoto cleanup;\n\t}\n\n\terror = gitno_extract_url_parts(\n\t\t&data->host, &data->port, &data->path, &data->user, &data->pass,\n\t\turl, default_port);\n\n\tif (url[0] == '/') {\n\t\t/* Relative redirect; reuse original host name and port */\n\t\tpath_search_start = url;\n\t\tgit__free(data->host);\n\t\tdata->host = original_host;\n\t\toriginal_host = NULL;\n\t}\n\n\tif (!error) {\n\t\tconst char *path = strchr(path_search_start, '/');\n\t\tsize_t pathlen = strlen(path);\n\t\tsize_t suffixlen = service_suffix ? strlen(service_suffix) : 0;\n\n\t\tif (suffixlen &&\n\t\t    !memcmp(path + pathlen - suffixlen, service_suffix, suffixlen)) {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strndup(path, pathlen - suffixlen);\n\t\t} else {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strdup(path);\n\t\t}\n\n\t\t/* Check for errors in the resulting data */\n\t\tif (original_host && url[0] != '/' && strcmp(original_host, data->host)) {\n\t\t\tgiterr_set(GITERR_NET, \"Cross host redirect not allowed\");\n\t\t\terror = -1;\n\t\t}\n\t}\n\ncleanup:\n\tif (original_host) git__free(original_host);\n\treturn error;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prefix_http = \"http://\";",
            "static const char *prefix_https = \"https://\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nstatic const char *prefix_http = \"http://\";\nstatic const char *prefix_https = \"https://\";\n\nint gitno_connection_data_from_url(\n\t\tgitno_connection_data *data,\n\t\tconst char *url,\n\t\tconst char *service_suffix)\n{\n\tint error = -1;\n\tconst char *default_port = NULL, *path_search_start = NULL;\n\tchar *original_host = NULL;\n\n\t/* service_suffix is optional */\n\tassert(data && url);\n\n\t/* Save these for comparison later */\n\toriginal_host = data->host;\n\tdata->host = NULL;\n\tgitno_connection_data_free_ptrs(data);\n\n\tif (!git__prefixcmp(url, prefix_http)) {\n\t\tpath_search_start = url + strlen(prefix_http);\n\t\tdefault_port = \"80\";\n\n\t\tif (data->use_ssl) {\n\t\t\tgiterr_set(GITERR_NET, \"Redirect from HTTPS to HTTP is not allowed\");\n\t\t\tgoto cleanup;\n\t\t}\n\t} else if (!git__prefixcmp(url, prefix_https)) {\n\t\tpath_search_start = url + strlen(prefix_https);\n\t\tdefault_port = \"443\";\n\t\tdata->use_ssl = true;\n\t} else if (url[0] == '/')\n\t\tdefault_port = data->use_ssl ? \"443\" : \"80\";\n\n\tif (!default_port) {\n\t\tgiterr_set(GITERR_NET, \"Unrecognized URL prefix\");\n\t\tgoto cleanup;\n\t}\n\n\terror = gitno_extract_url_parts(\n\t\t&data->host, &data->port, &data->path, &data->user, &data->pass,\n\t\turl, default_port);\n\n\tif (url[0] == '/') {\n\t\t/* Relative redirect; reuse original host name and port */\n\t\tpath_search_start = url;\n\t\tgit__free(data->host);\n\t\tdata->host = original_host;\n\t\toriginal_host = NULL;\n\t}\n\n\tif (!error) {\n\t\tconst char *path = strchr(path_search_start, '/');\n\t\tsize_t pathlen = strlen(path);\n\t\tsize_t suffixlen = service_suffix ? strlen(service_suffix) : 0;\n\n\t\tif (suffixlen &&\n\t\t    !memcmp(path + pathlen - suffixlen, service_suffix, suffixlen)) {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strndup(path, pathlen - suffixlen);\n\t\t} else {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strdup(path);\n\t\t}\n\n\t\t/* Check for errors in the resulting data */\n\t\tif (original_host && url[0] != '/' && strcmp(original_host, data->host)) {\n\t\t\tgiterr_set(GITERR_NET, \"Cross host redirect not allowed\");\n\t\t\terror = -1;\n\t\t}\n\t}\n\ncleanup:\n\tif (original_host) git__free(original_host);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_action(\n\tgit_smart_subtransport_stream **stream,\n\tgit_smart_subtransport *subtransport,\n\tconst char *url,\n\tgit_smart_service_t action)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\twinhttp_stream *s;\n\tint ret = -1;\n\n\tif (!t->connection)\n\t\tif ((ret = gitno_connection_data_from_url(&t->connection_data, url, NULL)) < 0 ||\n\t\t\t (ret = winhttp_connect(t)) < 0)\n\t\t\treturn ret;\n\n\tif (winhttp_stream_alloc(t, &s) < 0)\n\t\treturn -1;\n\n\tif (!stream)\n\t\treturn -1;\n\n\tswitch (action)\n\t{\n\t\tcase GIT_SERVICE_UPLOADPACK_LS:\n\t\t\tret = winhttp_uploadpack_ls(t, s);\n\t\t\tbreak;\n\n\t\tcase GIT_SERVICE_UPLOADPACK:\n\t\t\tret = winhttp_uploadpack(t, s);\n\t\t\tbreak;\n\n\t\tcase GIT_SERVICE_RECEIVEPACK_LS:\n\t\t\tret = winhttp_receivepack_ls(t, s);\n\t\t\tbreak;\n\n\t\tcase GIT_SERVICE_RECEIVEPACK:\n\t\t\tret = winhttp_receivepack(t, s);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tassert(0);\n\t}\n\n\tif (!ret)\n\t\t*stream = &s->parent;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "winhttp_receivepack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1288-1308",
    "snippet": "static int winhttp_receivepack(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\t/* WinHTTP only supports Transfer-Encoding: chunked\n\t * on Windows Vista (NT 6.0) and higher. */\n\ts->chunked = git_has_win32_version(6, 0, 0);\n\n\tif (s->chunked)\n\t\ts->parent.write = winhttp_stream_write_chunked;\n\telse\n\t\ts->parent.write = winhttp_stream_write_buffered;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_has_win32_version",
          "args": [
            "6",
            "0",
            "0"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "git_has_win32_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/version.h",
          "lines": "12-35",
          "snippet": "GIT_INLINE(int) git_has_win32_version(int major, int minor, int service_pack)\n{\n\tOSVERSIONINFOEX version_test = {0};\n\tDWORD version_test_mask;\n\tDWORDLONG version_condition_mask = 0;\n\t\n\tversion_test.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\n\tversion_test.dwMajorVersion = major;\n\tversion_test.dwMinorVersion = minor;\n\tversion_test.wServicePackMajor = (WORD)service_pack;\n\tversion_test.wServicePackMinor = 0;\n\n\tversion_test_mask = (VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR);\n\n\tVER_SET_CONDITION(version_condition_mask, VER_MAJORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_MINORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_SERVICEPACKMINOR, VER_GREATER_EQUAL);\n\n\tif (!VerifyVersionInfo(&version_test, version_test_mask, version_condition_mask))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <windows.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n\nGIT_INLINE(int) git_has_win32_version(int major, int minor, int service_pack)\n{\n\tOSVERSIONINFOEX version_test = {0};\n\tDWORD version_test_mask;\n\tDWORDLONG version_condition_mask = 0;\n\t\n\tversion_test.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\n\tversion_test.dwMajorVersion = major;\n\tversion_test.dwMinorVersion = minor;\n\tversion_test.wServicePackMajor = (WORD)service_pack;\n\tversion_test.wServicePackMinor = 0;\n\n\tversion_test_mask = (VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR);\n\n\tVER_SET_CONDITION(version_condition_mask, VER_MAJORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_MINORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(version_condition_mask, VER_SERVICEPACKMINOR, VER_GREATER_EQUAL);\n\n\tif (!VerifyVersionInfo(&version_test, version_test_mask, version_condition_mask))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "t"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_receivepack(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\t/* WinHTTP only supports Transfer-Encoding: chunked\n\t * on Windows Vista (NT 6.0) and higher. */\n\ts->chunked = git_has_win32_version(6, 0, 0);\n\n\tif (s->chunked)\n\t\ts->parent.write = winhttp_stream_write_chunked;\n\telse\n\t\ts->parent.write = winhttp_stream_write_buffered;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_receivepack_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1275-1286",
    "snippet": "static int winhttp_receivepack_ls(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "t"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_receivepack_ls(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_uploadpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1262-1273",
    "snippet": "static int winhttp_uploadpack(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "t"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_uploadpack(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_uploadpack_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1249-1260",
    "snippet": "static int winhttp_uploadpack_ls(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "t"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_uploadpack_ls(\n\twinhttp_subtransport *t,\n\twinhttp_stream *s)\n{\n\tGIT_UNUSED(t);\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_stream_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1229-1247",
    "snippet": "static int winhttp_stream_alloc(winhttp_subtransport *t, winhttp_stream **stream)\n{\n\twinhttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(1, sizeof(winhttp_stream));\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = winhttp_stream_read;\n\ts->parent.write = winhttp_stream_write_single;\n\ts->parent.free = winhttp_stream_free;\n\n\t*stream = s;\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "s"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(winhttp_stream)"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_stream_alloc(winhttp_subtransport *t, winhttp_stream **stream)\n{\n\twinhttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(1, sizeof(winhttp_stream));\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = winhttp_stream_read;\n\ts->parent.write = winhttp_stream_write_single;\n\ts->parent.free = winhttp_stream_free;\n\n\t*stream = s;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_stream_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1221-1227",
    "snippet": "static void winhttp_stream_free(git_smart_subtransport_stream *stream)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\n\twinhttp_stream_close(s);\n\tgit__free(s);\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "s"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_stream_close",
          "args": [
            "s"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "249-272",
          "snippet": "static void winhttp_stream_close(winhttp_stream *s)\n{\n\tif (s->chunk_buffer) {\n\t\tgit__free(s->chunk_buffer);\n\t\ts->chunk_buffer = NULL;\n\t}\n\n\tif (s->post_body) {\n\t\tCloseHandle(s->post_body);\n\t\ts->post_body = NULL;\n\t}\n\n\tif (s->request_uri) {\n\t\tgit__free(s->request_uri);\n\t\ts->request_uri = NULL;\n\t}\n\n\tif (s->request) {\n\t\tWinHttpCloseHandle(s->request);\n\t\ts->request = NULL;\n\t}\n\n\ts->sent_request = 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic void winhttp_stream_close(winhttp_stream *s)\n{\n\tif (s->chunk_buffer) {\n\t\tgit__free(s->chunk_buffer);\n\t\ts->chunk_buffer = NULL;\n\t}\n\n\tif (s->post_body) {\n\t\tCloseHandle(s->post_body);\n\t\ts->post_body = NULL;\n\t}\n\n\tif (s->request_uri) {\n\t\tgit__free(s->request_uri);\n\t\ts->request_uri = NULL;\n\t}\n\n\tif (s->request) {\n\t\tWinHttpCloseHandle(s->request);\n\t\ts->request = NULL;\n\t}\n\n\ts->sent_request = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic void winhttp_stream_free(git_smart_subtransport_stream *stream)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\n\twinhttp_stream_close(s);\n\tgit__free(s);\n}"
  },
  {
    "function_name": "winhttp_stream_write_chunked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1152-1219",
    "snippet": "static int winhttp_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\tint error;\n\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\tif (!s->sent_request) {\n\t\t/* Send Transfer-Encoding: chunked header */\n\t\tif (!WinHttpAddRequestHeaders(s->request,\n\t\t\ttransfer_encoding, (ULONG) -1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((error = send_request(s, 0, 1)) < 0)\n\t\t\treturn error;\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CACHED_POST_BODY_BUF_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(s->request, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = (int)min(CACHED_POST_BODY_BUF_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CACHED_POST_BODY_BUF_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CACHED_POST_BODY_BUF_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Is there any remaining data from the source? */\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = (unsigned int)len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define CACHED_POST_BODY_BUF_SIZE\t4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->chunk_buffer",
            "buffer",
            "len"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_chunk",
          "args": [
            "s->request",
            "s->chunk_buffer",
            "s->chunk_buffer_len"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_write_chunked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1152-1219",
          "snippet": "static int winhttp_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\tint error;\n\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\tif (!s->sent_request) {\n\t\t/* Send Transfer-Encoding: chunked header */\n\t\tif (!WinHttpAddRequestHeaders(s->request,\n\t\t\ttransfer_encoding, (ULONG) -1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((error = send_request(s, 0, 1)) < 0)\n\t\t\treturn error;\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CACHED_POST_BODY_BUF_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(s->request, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = (int)min(CACHED_POST_BODY_BUF_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CACHED_POST_BODY_BUF_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CACHED_POST_BODY_BUF_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Is there any remaining data from the source? */\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = (unsigned int)len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->chunk_buffer + s->chunk_buffer_len",
            "buffer",
            "count"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "CACHED_POST_BODY_BUF_SIZE"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "CACHED_POST_BODY_BUF_SIZE - s->chunk_buffer_len",
            "len"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "homing_search_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "130-143",
          "snippet": "static int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_request",
          "args": [
            "s",
            "0",
            "1"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "send_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "693-733",
          "snippet": "static int send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tint request_failed = 0, cert_valid = 1, error = 0;\n\tDWORD ignore_flags;\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\trequest_failed = 1;\n\n\tif (request_failed) {\n\t\tif (GetLastError() != ERROR_WINHTTP_SECURE_FAILURE) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tcert_valid = 0;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\tif ((error = certificate_check(s, cert_valid)) < 0) {\n\t\tif (!giterr_last())\n\t\t\tgiterr_set(GITERR_OS, \"user cancelled certificate check\");\n\n\t\treturn error;\n\t}\n\n\t/* if neither the request nor the certificate check returned errors, we're done */\n\tif (!request_failed)\n\t\treturn 0;\n\n\tignore_flags = no_check_cert_flags;\n\t\n\tif (!WinHttpSetOption(s->request, WINHTTP_OPTION_SECURITY_FLAGS, &ignore_flags, sizeof(ignore_flags))) {\n\t\tgiterr_set(GITERR_OS, \"failed to set security options\");\n\t\treturn -1;\n\t}\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tint request_failed = 0, cert_valid = 1, error = 0;\n\tDWORD ignore_flags;\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\trequest_failed = 1;\n\n\tif (request_failed) {\n\t\tif (GetLastError() != ERROR_WINHTTP_SECURE_FAILURE) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tcert_valid = 0;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\tif ((error = certificate_check(s, cert_valid)) < 0) {\n\t\tif (!giterr_last())\n\t\t\tgiterr_set(GITERR_OS, \"user cancelled certificate check\");\n\n\t\treturn error;\n\t}\n\n\t/* if neither the request nor the certificate check returned errors, we're done */\n\tif (!request_failed)\n\t\treturn 0;\n\n\tignore_flags = no_check_cert_flags;\n\t\n\tif (!WinHttpSetOption(s->request, WINHTTP_OPTION_SECURITY_FLAGS, &ignore_flags, sizeof(ignore_flags))) {\n\t\tgiterr_set(GITERR_OS, \"failed to set security options\");\n\t\treturn -1;\n\t}\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to add a header to the request\""
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpAddRequestHeaders",
          "args": [
            "s->request",
            "transfer_encoding",
            "(ULONG) -1L",
            "WINHTTP_ADDREQ_FLAG_ADD"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "winhttp_stream_connect",
          "args": [
            "s"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "274-477",
          "snippet": "static int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CONNECT_TIMEOUT 60000",
            "#define TIMEOUT_INFINITE -1",
            "#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109",
            "#define MAX_CONTENT_TYPE_LEN\t100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define DEFAULT_CONNECT_TIMEOUT 60000\n#define TIMEOUT_INFINITE -1\n#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109\n#define MAX_CONTENT_TYPE_LEN\t100\n\nstatic int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define CACHED_POST_BODY_BUF_SIZE\t4096\n\nstatic int winhttp_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\tint error;\n\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\tif (!s->sent_request) {\n\t\t/* Send Transfer-Encoding: chunked header */\n\t\tif (!WinHttpAddRequestHeaders(s->request,\n\t\t\ttransfer_encoding, (ULONG) -1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((error = send_request(s, 0, 1)) < 0)\n\t\t\treturn error;\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CACHED_POST_BODY_BUF_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(s->request, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = (int)min(CACHED_POST_BODY_BUF_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CACHED_POST_BODY_BUF_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CACHED_POST_BODY_BUF_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Is there any remaining data from the source? */\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = (unsigned int)len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_stream_write_buffered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1107-1150",
    "snippet": "static int winhttp_stream_write_buffered(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\tDWORD bytes_written;\n\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\t/* Buffer the payload, using a temporary file so we delegate\n\t * memory management of the data to the operating system. */\n\tif (!s->post_body) {\n\t\twchar_t temp_path[MAX_PATH + 1];\n\n\t\tif (get_temp_file(temp_path, MAX_PATH + 1) < 0)\n\t\t\treturn -1;\n\n\t\ts->post_body = CreateFileW(temp_path,\n\t\t\tGENERIC_READ | GENERIC_WRITE,\n\t\t\tFILE_SHARE_DELETE, NULL,\n\t\t\tCREATE_NEW,\n\t\t\tFILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_SEQUENTIAL_SCAN,\n\t\t\tNULL);\n\n\t\tif (INVALID_HANDLE_VALUE == s->post_body) {\n\t\t\ts->post_body = NULL;\n\t\t\tgiterr_set(GITERR_OS, \"Failed to create temporary file\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!WriteFile(s->post_body, buffer, (DWORD)len, &bytes_written, NULL)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to write to temporary file\");\n\t\treturn -1;\n\t}\n\n\tassert((DWORD)len == bytes_written);\n\n\ts->post_body_len += bytes_written;\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(DWORD)len == bytes_written"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to write to temporary file\""
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteFile",
          "args": [
            "s->post_body",
            "buffer",
            "(DWORD)len",
            "&bytes_written",
            "NULL"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateFileW",
          "args": [
            "temp_path",
            "GENERIC_READ | GENERIC_WRITE",
            "FILE_SHARE_DELETE",
            "NULL",
            "CREATE_NEW",
            "FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_SEQUENTIAL_SCAN",
            "NULL"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_temp_file",
          "args": [
            "temp_path",
            "MAX_PATH + 1"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "get_temp_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1087-1105",
          "snippet": "static int get_temp_file(LPWSTR buffer, DWORD buffer_len_cch)\n{\n\tsize_t len;\n\n\tif (!GetTempPathW(buffer_len_cch, buffer)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to get temp path\");\n\t\treturn -1;\n\t}\n\n\tlen = wcslen(buffer);\n\n\tif (buffer[len - 1] != '\\\\' && len < buffer_len_cch)\n\t\tbuffer[len++] = '\\\\';\n\n\tif (put_uuid_string(&buffer[len], (size_t)buffer_len_cch - len) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int get_temp_file(LPWSTR buffer, DWORD buffer_len_cch)\n{\n\tsize_t len;\n\n\tif (!GetTempPathW(buffer_len_cch, buffer)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to get temp path\");\n\t\treturn -1;\n\t}\n\n\tlen = wcslen(buffer);\n\n\tif (buffer[len - 1] != '\\\\' && len < buffer_len_cch)\n\t\tbuffer[len++] = '\\\\';\n\n\tif (put_uuid_string(&buffer[len], (size_t)buffer_len_cch - len) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_stream_connect",
          "args": [
            "s"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "274-477",
          "snippet": "static int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CONNECT_TIMEOUT 60000",
            "#define TIMEOUT_INFINITE -1",
            "#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109",
            "#define MAX_CONTENT_TYPE_LEN\t100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define DEFAULT_CONNECT_TIMEOUT 60000\n#define TIMEOUT_INFINITE -1\n#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109\n#define MAX_CONTENT_TYPE_LEN\t100\n\nstatic int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_stream_write_buffered(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\tDWORD bytes_written;\n\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\t/* Buffer the payload, using a temporary file so we delegate\n\t * memory management of the data to the operating system. */\n\tif (!s->post_body) {\n\t\twchar_t temp_path[MAX_PATH + 1];\n\n\t\tif (get_temp_file(temp_path, MAX_PATH + 1) < 0)\n\t\t\treturn -1;\n\n\t\ts->post_body = CreateFileW(temp_path,\n\t\t\tGENERIC_READ | GENERIC_WRITE,\n\t\t\tFILE_SHARE_DELETE, NULL,\n\t\t\tCREATE_NEW,\n\t\t\tFILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_SEQUENTIAL_SCAN,\n\t\t\tNULL);\n\n\t\tif (INVALID_HANDLE_VALUE == s->post_body) {\n\t\t\ts->post_body = NULL;\n\t\t\tgiterr_set(GITERR_OS, \"Failed to create temporary file\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!WriteFile(s->post_body, buffer, (DWORD)len, &bytes_written, NULL)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to write to temporary file\");\n\t\treturn -1;\n\t}\n\n\tassert((DWORD)len == bytes_written);\n\n\ts->post_body_len += bytes_written;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_temp_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1087-1105",
    "snippet": "static int get_temp_file(LPWSTR buffer, DWORD buffer_len_cch)\n{\n\tsize_t len;\n\n\tif (!GetTempPathW(buffer_len_cch, buffer)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to get temp path\");\n\t\treturn -1;\n\t}\n\n\tlen = wcslen(buffer);\n\n\tif (buffer[len - 1] != '\\\\' && len < buffer_len_cch)\n\t\tbuffer[len++] = '\\\\';\n\n\tif (put_uuid_string(&buffer[len], (size_t)buffer_len_cch - len) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uuid_string",
          "args": [
            "&buffer[len]",
            "(size_t)buffer_len_cch - len"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcslen",
          "args": [
            "buffer"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to get temp path\""
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTempPathW",
          "args": [
            "buffer_len_cch",
            "buffer"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int get_temp_file(LPWSTR buffer, DWORD buffer_len_cch)\n{\n\tsize_t len;\n\n\tif (!GetTempPathW(buffer_len_cch, buffer)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to get temp path\");\n\t\treturn -1;\n\t}\n\n\tlen = wcslen(buffer);\n\n\tif (buffer[len - 1] != '\\\\' && len < buffer_len_cch)\n\t\tbuffer[len++] = '\\\\';\n\n\tif (put_uuid_string(&buffer[len], (size_t)buffer_len_cch - len) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_stream_write_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "1015-1049",
    "snippet": "static int winhttp_stream_write_single(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\tDWORD bytes_written;\n\tint error;\n\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\t/* This implementation of write permits only a single call. */\n\tif (s->sent_request) {\n\t\tgiterr_set(GITERR_NET, \"Subtransport configured for only one write\");\n\t\treturn -1;\n\t}\n\n\tif ((error = send_request(s, len, 0)) < 0)\n\t\treturn error;\n\n\ts->sent_request = 1;\n\n\tif (!WinHttpWriteData(s->request,\n\t\t\t(LPCVOID)buffer,\n\t\t\t(DWORD)len,\n\t\t\t&bytes_written)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to write data\");\n\t\treturn -1;\n\t}\n\n\tassert((DWORD)len == bytes_written);\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(DWORD)len == bytes_written"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to write data\""
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpWriteData",
          "args": [
            "s->request",
            "(LPCVOID)buffer",
            "(DWORD)len",
            "&bytes_written"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_request",
          "args": [
            "s",
            "len",
            "0"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "send_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "693-733",
          "snippet": "static int send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tint request_failed = 0, cert_valid = 1, error = 0;\n\tDWORD ignore_flags;\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\trequest_failed = 1;\n\n\tif (request_failed) {\n\t\tif (GetLastError() != ERROR_WINHTTP_SECURE_FAILURE) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tcert_valid = 0;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\tif ((error = certificate_check(s, cert_valid)) < 0) {\n\t\tif (!giterr_last())\n\t\t\tgiterr_set(GITERR_OS, \"user cancelled certificate check\");\n\n\t\treturn error;\n\t}\n\n\t/* if neither the request nor the certificate check returned errors, we're done */\n\tif (!request_failed)\n\t\treturn 0;\n\n\tignore_flags = no_check_cert_flags;\n\t\n\tif (!WinHttpSetOption(s->request, WINHTTP_OPTION_SECURITY_FLAGS, &ignore_flags, sizeof(ignore_flags))) {\n\t\tgiterr_set(GITERR_OS, \"failed to set security options\");\n\t\treturn -1;\n\t}\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tint request_failed = 0, cert_valid = 1, error = 0;\n\tDWORD ignore_flags;\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\trequest_failed = 1;\n\n\tif (request_failed) {\n\t\tif (GetLastError() != ERROR_WINHTTP_SECURE_FAILURE) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tcert_valid = 0;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\tif ((error = certificate_check(s, cert_valid)) < 0) {\n\t\tif (!giterr_last())\n\t\t\tgiterr_set(GITERR_OS, \"user cancelled certificate check\");\n\n\t\treturn error;\n\t}\n\n\t/* if neither the request nor the certificate check returned errors, we're done */\n\tif (!request_failed)\n\t\treturn 0;\n\n\tignore_flags = no_check_cert_flags;\n\t\n\tif (!WinHttpSetOption(s->request, WINHTTP_OPTION_SECURITY_FLAGS, &ignore_flags, sizeof(ignore_flags))) {\n\t\tgiterr_set(GITERR_OS, \"failed to set security options\");\n\t\treturn -1;\n\t}\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_stream_connect",
          "args": [
            "s"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "274-477",
          "snippet": "static int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CONNECT_TIMEOUT 60000",
            "#define TIMEOUT_INFINITE -1",
            "#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109",
            "#define MAX_CONTENT_TYPE_LEN\t100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define DEFAULT_CONNECT_TIMEOUT 60000\n#define TIMEOUT_INFINITE -1\n#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109\n#define MAX_CONTENT_TYPE_LEN\t100\n\nstatic int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_stream_write_single(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\tDWORD bytes_written;\n\tint error;\n\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\t/* This implementation of write permits only a single call. */\n\tif (s->sent_request) {\n\t\tgiterr_set(GITERR_NET, \"Subtransport configured for only one write\");\n\t\treturn -1;\n\t}\n\n\tif ((error = send_request(s, len, 0)) < 0)\n\t\treturn error;\n\n\ts->sent_request = 1;\n\n\tif (!WinHttpWriteData(s->request,\n\t\t\t(LPCVOID)buffer,\n\t\t\t(DWORD)len,\n\t\t\t&bytes_written)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to write data\");\n\t\treturn -1;\n\t}\n\n\tassert((DWORD)len == bytes_written);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_stream_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "735-1013",
    "snippet": "static int winhttp_stream_read(\n\tgit_smart_subtransport_stream *stream,\n\tchar *buffer,\n\tsize_t buf_size,\n\tsize_t *bytes_read)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tDWORD dw_bytes_read;\n\tchar replay_count = 0;\n\tint error;\n\nreplay:\n\t/* Enforce a reasonable cap on the number of replays */\n\tif (++replay_count >= 7) {\n\t\tgiterr_set(GITERR_NET, \"Too many redirects or authentication replays\");\n\t\treturn -1;\n\t}\n\n\t/* Connect if necessary */\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\tif (!s->received_response) {\n\t\tDWORD status_code, status_code_length, content_type_length, bytes_written;\n\t\tchar expected_content_type_8[MAX_CONTENT_TYPE_LEN];\n\t\twchar_t expected_content_type[MAX_CONTENT_TYPE_LEN], content_type[MAX_CONTENT_TYPE_LEN];\n\n\t\tif (!s->sent_request) {\n\n\t\t\tif ((error = send_request(s, s->post_body_len, 0)) < 0)\n\t\t\t\treturn error;\n\n\t\t\ts->sent_request = 1;\n\t\t}\n\n\t\tif (s->chunked) {\n\t\t\tassert(s->verb == post_verb);\n\n\t\t\t/* Flush, if necessary */\n\t\t\tif (s->chunk_buffer_len > 0 &&\n\t\t\t\twrite_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Write the final chunk. */\n\t\t\tif (!WinHttpWriteData(s->request,\n\t\t\t\t\"0\\r\\n\\r\\n\", 5,\n\t\t\t\t&bytes_written)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to write final chunk\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse if (s->post_body) {\n\t\t\tchar *buffer;\n\t\t\tDWORD len = s->post_body_len, bytes_read;\n\n\t\t\tif (INVALID_SET_FILE_POINTER == SetFilePointer(s->post_body,\n\t\t\t\t\t0, 0, FILE_BEGIN) &&\n\t\t\t\tNO_ERROR != GetLastError()) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to reset file pointer\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbuffer = git__malloc(CACHED_POST_BODY_BUF_SIZE);\n\n\t\t\twhile (len > 0) {\n\t\t\t\tDWORD bytes_written;\n\n\t\t\t\tif (!ReadFile(s->post_body, buffer,\n\t\t\t\t\tmin(CACHED_POST_BODY_BUF_SIZE, len),\n\t\t\t\t\t&bytes_read, NULL) ||\n\t\t\t\t\t!bytes_read) {\n\t\t\t\t\tgit__free(buffer);\n\t\t\t\t\tgiterr_set(GITERR_OS, \"Failed to read from temp file\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (!WinHttpWriteData(s->request, buffer,\n\t\t\t\t\tbytes_read, &bytes_written)) {\n\t\t\t\t\tgit__free(buffer);\n\t\t\t\t\tgiterr_set(GITERR_OS, \"Failed to write data\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tlen -= bytes_read;\n\t\t\t\tassert(bytes_read == bytes_written);\n\t\t\t}\n\n\t\t\tgit__free(buffer);\n\n\t\t\t/* Eagerly close the temp file */\n\t\t\tCloseHandle(s->post_body);\n\t\t\ts->post_body = NULL;\n\t\t}\n\n\t\tif (!WinHttpReceiveResponse(s->request, 0)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to receive response\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Verify that we got a 200 back */\n\t\tstatus_code_length = sizeof(status_code);\n\n\t\tif (!WinHttpQueryHeaders(s->request,\n\t\t\tWINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,\n\t\t\tWINHTTP_HEADER_NAME_BY_INDEX,\n\t\t\t&status_code, &status_code_length,\n\t\t\tWINHTTP_NO_HEADER_INDEX)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to retrieve status code\");\n\t\t\t\treturn -1;\n\t\t}\n\n\t\t/* The implementation of WinHTTP prior to Windows 7 will not\n\t\t * redirect to an identical URI. Some Git hosters use self-redirects\n\t\t * as part of their DoS mitigation strategy. Check first to see if we\n\t\t * have a redirect status code, and that we haven't already streamed\n\t\t * a post body. (We can't replay a streamed POST.) */\n\t\tif (!s->chunked &&\n\t\t\t(HTTP_STATUS_MOVED == status_code ||\n\t\t\t HTTP_STATUS_REDIRECT == status_code ||\n\t\t\t (HTTP_STATUS_REDIRECT_METHOD == status_code &&\n\t\t\t  get_verb == s->verb) ||\n\t\t\t HTTP_STATUS_REDIRECT_KEEP_VERB == status_code)) {\n\n\t\t\t/* Check for Windows 7. This workaround is only necessary on\n\t\t\t * Windows Vista and earlier. Windows 7 is version 6.1. */\n\t\t\twchar_t *location;\n\t\t\tDWORD location_length;\n\t\t\tchar *location8;\n\n\t\t\t/* OK, fetch the Location header from the redirect. */\n\t\t\tif (WinHttpQueryHeaders(s->request,\n\t\t\t\tWINHTTP_QUERY_LOCATION,\n\t\t\t\tWINHTTP_HEADER_NAME_BY_INDEX,\n\t\t\t\tWINHTTP_NO_OUTPUT_BUFFER,\n\t\t\t\t&location_length,\n\t\t\t\tWINHTTP_NO_HEADER_INDEX) ||\n\t\t\t\tGetLastError() != ERROR_INSUFFICIENT_BUFFER) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to read Location header\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tlocation = git__malloc(location_length);\n\t\t\tGITERR_CHECK_ALLOC(location);\n\n\t\t\tif (!WinHttpQueryHeaders(s->request,\n\t\t\t\tWINHTTP_QUERY_LOCATION,\n\t\t\t\tWINHTTP_HEADER_NAME_BY_INDEX,\n\t\t\t\tlocation,\n\t\t\t\t&location_length,\n\t\t\t\tWINHTTP_NO_HEADER_INDEX)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to read Location header\");\n\t\t\t\tgit__free(location);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* Convert the Location header to UTF-8 */\n\t\t\tif (git__utf16_to_8_alloc(&location8, location) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert Location header to UTF-8\");\n\t\t\t\tgit__free(location);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tgit__free(location);\n\n\t\t\t/* Replay the request */\n\t\t\twinhttp_stream_close(s);\n\n\t\t\tif (!git__prefixcmp_icase(location8, prefix_https)) {\n\t\t\t\t/* Upgrade to secure connection; disconnect and start over */\n\t\t\t\tif (gitno_connection_data_from_url(&t->connection_data, location8, s->service_url) < 0) {\n\t\t\t\t\tgit__free(location8);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\twinhttp_close_connection(t);\n\n\t\t\t\tif (winhttp_connect(t) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tgit__free(location8);\n\t\t\tgoto replay;\n\t\t}\n\n\t\t/* Handle authentication failures */\n\t\tif (HTTP_STATUS_DENIED == status_code && get_verb == s->verb) {\n\t\t\tint allowed_types;\n\n\t\t\tif (parse_unauthorized_response(s->request, &allowed_types, &t->auth_mechanism) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (allowed_types) {\n\t\t\t\tint cred_error = 1;\n\n\t\t\t\tgit_cred_free(t->cred);\n\t\t\t\tt->cred = NULL;\n\t\t\t\t/* Start with the user-supplied credential callback, if present */\n\t\t\t\tif (t->owner->cred_acquire_cb) {\n\t\t\t\t\tcred_error = t->owner->cred_acquire_cb(&t->cred, t->owner->url,\n\t\t\t\t\t\tt->connection_data.user, allowed_types,\tt->owner->cred_acquire_payload);\n\n\t\t\t\t\t/* Treat GIT_PASSTHROUGH as though git_cred_acquire_cb isn't set */\n\t\t\t\t\tif (cred_error == GIT_PASSTHROUGH)\n\t\t\t\t\t\tcred_error = 1;\n\t\t\t\t\telse if (cred_error < 0)\n\t\t\t\t\t\treturn cred_error;\n\t\t\t\t}\n\n\t\t\t\t/* Invoke the fallback credentials acquisition callback if necessary */\n\t\t\t\tif (cred_error > 0) {\n\t\t\t\t\tcred_error = fallback_cred_acquire_cb(&t->cred, t->owner->url,\n\t\t\t\t\t\tt->connection_data.user, allowed_types, NULL);\n\n\t\t\t\t\tif (cred_error < 0)\n\t\t\t\t\t\treturn cred_error;\n\t\t\t\t}\n\n\t\t\t\tif (!cred_error) {\n\t\t\t\t\tassert(t->cred);\n\n\t\t\t\t\twinhttp_stream_close(s);\n\n\t\t\t\t\t/* Successfully acquired a credential */\n\t\t\t\t\tgoto replay;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (HTTP_STATUS_OK != status_code) {\n\t\t\tgiterr_set(GITERR_NET, \"Request failed with status code: %d\", status_code);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Verify that we got the correct content-type back */\n\t\tif (post_verb == s->verb)\n\t\t\tp_snprintf(expected_content_type_8, MAX_CONTENT_TYPE_LEN, \"application/x-git-%s-result\", s->service);\n\t\telse\n\t\t\tp_snprintf(expected_content_type_8, MAX_CONTENT_TYPE_LEN, \"application/x-git-%s-advertisement\", s->service);\n\n\t\tif (git__utf8_to_16(expected_content_type, MAX_CONTENT_TYPE_LEN, expected_content_type_8) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert expected content-type to wide characters\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tcontent_type_length = sizeof(content_type);\n\n\t\tif (!WinHttpQueryHeaders(s->request,\n\t\t\tWINHTTP_QUERY_CONTENT_TYPE,\n\t\t\tWINHTTP_HEADER_NAME_BY_INDEX,\n\t\t\t&content_type, &content_type_length,\n\t\t\tWINHTTP_NO_HEADER_INDEX)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to retrieve response content-type\");\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (wcscmp(expected_content_type, content_type)) {\n\t\t\tgiterr_set(GITERR_NET, \"Received unexpected content-type\");\n\t\t\treturn -1;\n\t\t}\n\n\t\ts->received_response = 1;\n\t}\n\n\tif (!WinHttpReadData(s->request,\n\t\t(LPVOID)buffer,\n\t\t(DWORD)buf_size,\n\t\t&dw_bytes_read))\n\t{\n\t\tgiterr_set(GITERR_OS, \"Failed to read data\");\n\t\treturn -1;\n\t}\n\n\t*bytes_read = dw_bytes_read;\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define CACHED_POST_BODY_BUF_SIZE\t4096",
      "#define MAX_CONTENT_TYPE_LEN\t100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to read data\""
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpReadData",
          "args": [
            "s->request",
            "(LPVOID)buffer",
            "(DWORD)buf_size",
            "&dw_bytes_read"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcscmp",
          "args": [
            "expected_content_type",
            "content_type"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpQueryHeaders",
          "args": [
            "s->request",
            "WINHTTP_QUERY_CONTENT_TYPE",
            "WINHTTP_HEADER_NAME_BY_INDEX",
            "&content_type",
            "&content_type_length",
            "WINHTTP_NO_HEADER_INDEX"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__utf8_to_16",
          "args": [
            "expected_content_type",
            "MAX_CONTENT_TYPE_LEN",
            "expected_content_type_8"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf8_to_16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "27-38",
          "snippet": "int git__utf8_to_16(wchar_t *dest, size_t dest_size, const char *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t* turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t* length. MultiByteToWideChar never returns int's minvalue, so underflow is not possible */\n\tif ((len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf8_to_16(wchar_t *dest, size_t dest_size, const char *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t* turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t* length. MultiByteToWideChar never returns int's minvalue, so underflow is not possible */\n\tif ((len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_snprintf",
          "args": [
            "expected_content_type_8",
            "MAX_CONTENT_TYPE_LEN",
            "\"application/x-git-%s-advertisement\"",
            "s->service"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "p_snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "548-558",
          "snippet": "int p_snprintf(char *buffer, size_t count, const char *format, ...)\n{\n\tva_list va;\n\tint r;\n\n\tva_start(va, format);\n\tr = p_vsnprintf(buffer, count, format, va);\n\tva_end(va);\n\n\treturn r;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_snprintf(char *buffer, size_t count, const char *format, ...)\n{\n\tva_list va;\n\tint r;\n\n\tva_start(va, format);\n\tr = p_vsnprintf(buffer, count, format, va);\n\tva_end(va);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Request failed with status code: %d\"",
            "status_code"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_stream_close",
          "args": [
            "s"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "249-272",
          "snippet": "static void winhttp_stream_close(winhttp_stream *s)\n{\n\tif (s->chunk_buffer) {\n\t\tgit__free(s->chunk_buffer);\n\t\ts->chunk_buffer = NULL;\n\t}\n\n\tif (s->post_body) {\n\t\tCloseHandle(s->post_body);\n\t\ts->post_body = NULL;\n\t}\n\n\tif (s->request_uri) {\n\t\tgit__free(s->request_uri);\n\t\ts->request_uri = NULL;\n\t}\n\n\tif (s->request) {\n\t\tWinHttpCloseHandle(s->request);\n\t\ts->request = NULL;\n\t}\n\n\ts->sent_request = 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic void winhttp_stream_close(winhttp_stream *s)\n{\n\tif (s->chunk_buffer) {\n\t\tgit__free(s->chunk_buffer);\n\t\ts->chunk_buffer = NULL;\n\t}\n\n\tif (s->post_body) {\n\t\tCloseHandle(s->post_body);\n\t\ts->post_body = NULL;\n\t}\n\n\tif (s->request_uri) {\n\t\tgit__free(s->request_uri);\n\t\ts->request_uri = NULL;\n\t}\n\n\tif (s->request) {\n\t\tWinHttpCloseHandle(s->request);\n\t\ts->request = NULL;\n\t}\n\n\ts->sent_request = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "t->cred"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fallback_cred_acquire_cb",
          "args": [
            "&t->cred",
            "t->owner->url",
            "t->connection_data.user",
            "allowed_types",
            "NULL"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "fallback_cred_acquire_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "160-214",
          "snippet": "static int fallback_cred_acquire_cb(\n\tgit_cred **cred,\n\tconst char *url,\n\tconst char *username_from_url,\n\tunsigned int allowed_types,\n\tvoid *payload)\n{\n\tint error = 1;\n\n\tGIT_UNUSED(username_from_url);\n\tGIT_UNUSED(payload);\n\n\t/* If the target URI supports integrated Windows authentication\n\t * as an authentication mechanism */\n\tif (GIT_CREDTYPE_DEFAULT & allowed_types) {\n\t\twchar_t *wide_url;\n\n\t\t/* Convert URL to wide characters */\n\t\tif (git__utf8_to_16_alloc(&wide_url, url) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED))) {\n\t\t\tIInternetSecurityManager* pISM;\n\n\t\t\t/* And if the target URI is in the My Computer, Intranet, or Trusted zones */\n\t\t\tif (SUCCEEDED(CoCreateInstance(&CLSID_InternetSecurityManager, NULL,\n\t\t\t\tCLSCTX_ALL, &IID_IInternetSecurityManager, (void **)&pISM))) {\n\t\t\t\tDWORD dwZone;\n\n\t\t\t\tif (SUCCEEDED(pISM->lpVtbl->MapUrlToZone(pISM, wide_url, &dwZone, 0)) &&\n\t\t\t\t\t(URLZONE_LOCAL_MACHINE == dwZone ||\n\t\t\t\t\tURLZONE_INTRANET == dwZone ||\n\t\t\t\t\tURLZONE_TRUSTED == dwZone)) {\n\t\t\t\t\tgit_cred *existing = *cred;\n\n\t\t\t\t\tif (existing)\n\t\t\t\t\t\texisting->free(existing);\n\n\t\t\t\t\t/* Then use default Windows credentials to authenticate this request */\n\t\t\t\t\terror = git_cred_default_new(cred);\n\t\t\t\t}\n\n\t\t\t\tpISM->lpVtbl->Release(pISM);\n\t\t\t}\n\n\t\t\tCoUninitialize();\n\t\t}\n\n\t\tgit__free(wide_url);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int fallback_cred_acquire_cb(\n\tgit_cred **cred,\n\tconst char *url,\n\tconst char *username_from_url,\n\tunsigned int allowed_types,\n\tvoid *payload)\n{\n\tint error = 1;\n\n\tGIT_UNUSED(username_from_url);\n\tGIT_UNUSED(payload);\n\n\t/* If the target URI supports integrated Windows authentication\n\t * as an authentication mechanism */\n\tif (GIT_CREDTYPE_DEFAULT & allowed_types) {\n\t\twchar_t *wide_url;\n\n\t\t/* Convert URL to wide characters */\n\t\tif (git__utf8_to_16_alloc(&wide_url, url) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED))) {\n\t\t\tIInternetSecurityManager* pISM;\n\n\t\t\t/* And if the target URI is in the My Computer, Intranet, or Trusted zones */\n\t\t\tif (SUCCEEDED(CoCreateInstance(&CLSID_InternetSecurityManager, NULL,\n\t\t\t\tCLSCTX_ALL, &IID_IInternetSecurityManager, (void **)&pISM))) {\n\t\t\t\tDWORD dwZone;\n\n\t\t\t\tif (SUCCEEDED(pISM->lpVtbl->MapUrlToZone(pISM, wide_url, &dwZone, 0)) &&\n\t\t\t\t\t(URLZONE_LOCAL_MACHINE == dwZone ||\n\t\t\t\t\tURLZONE_INTRANET == dwZone ||\n\t\t\t\t\tURLZONE_TRUSTED == dwZone)) {\n\t\t\t\t\tgit_cred *existing = *cred;\n\n\t\t\t\t\tif (existing)\n\t\t\t\t\t\texisting->free(existing);\n\n\t\t\t\t\t/* Then use default Windows credentials to authenticate this request */\n\t\t\t\t\terror = git_cred_default_new(cred);\n\t\t\t\t}\n\n\t\t\t\tpISM->lpVtbl->Release(pISM);\n\t\t\t}\n\n\t\t\tCoUninitialize();\n\t\t}\n\n\t\tgit__free(wide_url);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->owner->cred_acquire_cb",
          "args": [
            "&t->cred",
            "t->owner->url",
            "t->connection_data.user",
            "allowed_types",
            "t->owner->cred_acquire_payload"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_cred_free",
          "args": [
            "t->cred"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "git_cred_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/cred.c",
          "lines": "382-388",
          "snippet": "void git_cred_free(git_cred *cred)\n{\n\tif (!cred)\n\t\treturn;\n\n\tcred->free(cred);\n}",
          "includes": [
            "#include \"git2/cred_helpers.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/cred_helpers.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nvoid git_cred_free(git_cred *cred)\n{\n\tif (!cred)\n\t\treturn;\n\n\tcred->free(cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_unauthorized_response",
          "args": [
            "s->request",
            "&allowed_types",
            "&t->auth_mechanism"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "parse_unauthorized_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "479-509",
          "snippet": "static int parse_unauthorized_response(\n\tHINTERNET request,\n\tint *allowed_types,\n\tint *auth_mechanism)\n{\n\tDWORD supported, first, target;\n\n\t*allowed_types = 0;\n\t*auth_mechanism = 0;\n\n\t/* WinHttpQueryHeaders() must be called before WinHttpQueryAuthSchemes(). \n\t * We can assume this was already done, since we know we are unauthorized. \n\t */\n\tif (!WinHttpQueryAuthSchemes(request, &supported, &first, &target)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to parse supported auth schemes\"); \n\t\treturn -1;\n\t}\n\n\tif (WINHTTP_AUTH_SCHEME_BASIC & supported) {\n\t\t*allowed_types |= GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\t\t*auth_mechanism = GIT_WINHTTP_AUTH_BASIC;\n\t}\n\n\tif ((WINHTTP_AUTH_SCHEME_NTLM & supported) ||\n\t\t(WINHTTP_AUTH_SCHEME_NEGOTIATE & supported)) {\n\t\t*allowed_types |= GIT_CREDTYPE_DEFAULT;\n\t\t*auth_mechanism = GIT_WINHTTP_AUTH_NEGOTIATE;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int parse_unauthorized_response(\n\tHINTERNET request,\n\tint *allowed_types,\n\tint *auth_mechanism)\n{\n\tDWORD supported, first, target;\n\n\t*allowed_types = 0;\n\t*auth_mechanism = 0;\n\n\t/* WinHttpQueryHeaders() must be called before WinHttpQueryAuthSchemes(). \n\t * We can assume this was already done, since we know we are unauthorized. \n\t */\n\tif (!WinHttpQueryAuthSchemes(request, &supported, &first, &target)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to parse supported auth schemes\"); \n\t\treturn -1;\n\t}\n\n\tif (WINHTTP_AUTH_SCHEME_BASIC & supported) {\n\t\t*allowed_types |= GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\t\t*auth_mechanism = GIT_WINHTTP_AUTH_BASIC;\n\t}\n\n\tif ((WINHTTP_AUTH_SCHEME_NTLM & supported) ||\n\t\t(WINHTTP_AUTH_SCHEME_NEGOTIATE & supported)) {\n\t\t*allowed_types |= GIT_CREDTYPE_DEFAULT;\n\t\t*auth_mechanism = GIT_WINHTTP_AUTH_NEGOTIATE;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "location8"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_connect",
          "args": [
            "t"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "591-670",
          "snippet": "static int winhttp_connect(\n\twinhttp_subtransport *t)\n{\n\twchar_t *wide_host;\n\tint32_t port;\n\twchar_t *wide_ua;\n\tgit_buf ua = GIT_BUF_INIT;\n\tint error = -1;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\n\tt->session = NULL;\n\tt->connection = NULL;\n\n\t/* Prepare port */\n\tif (git__strtol32(&port, t->connection_data.port, NULL, 10) < 0)\n\t\treturn -1;\n\n\t/* Prepare host */\n\tif (git__utf8_to_16_alloc(&wide_host, t->connection_data.host) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\treturn -1;\n\t}\n\n\tif ((error = user_agent(&ua)) < 0) {\n\t\tgit__free(wide_host);\n\t\treturn error;\n\t}\n\n\tif (git__utf8_to_16_alloc(&wide_ua, git_buf_cstr(&ua)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\tgit__free(wide_host);\n\t\tgit_buf_free(&ua);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&ua);\n\n\t/* Establish session */\n\tt->session = WinHttpOpen(\n\t\twide_ua,\n\t\tWINHTTP_ACCESS_TYPE_DEFAULT_PROXY,\n\t\tWINHTTP_NO_PROXY_NAME,\n\t\tWINHTTP_NO_PROXY_BYPASS,\n\t\t0);\n\n\tif (!t->session) {\n\t\tgiterr_set(GITERR_OS, \"Failed to init WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(t->session, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t\n\t/* Establish connection */\n\tt->connection = WinHttpConnect(\n\t\tt->session,\n\t\twide_host,\n\t\t(INTERNET_PORT) port,\n\t\t0);\n\n\tif (!t->connection) {\n\t\tgiterr_set(GITERR_OS, \"Failed to connect to host\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_close_connection(t);\n\n\tgit__free(wide_host);\n\tgit__free(wide_ua);\n\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CONNECT_TIMEOUT 60000",
            "#define TIMEOUT_INFINITE -1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define DEFAULT_CONNECT_TIMEOUT 60000\n#define TIMEOUT_INFINITE -1\n\nstatic int winhttp_connect(\n\twinhttp_subtransport *t)\n{\n\twchar_t *wide_host;\n\tint32_t port;\n\twchar_t *wide_ua;\n\tgit_buf ua = GIT_BUF_INIT;\n\tint error = -1;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\n\tt->session = NULL;\n\tt->connection = NULL;\n\n\t/* Prepare port */\n\tif (git__strtol32(&port, t->connection_data.port, NULL, 10) < 0)\n\t\treturn -1;\n\n\t/* Prepare host */\n\tif (git__utf8_to_16_alloc(&wide_host, t->connection_data.host) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\treturn -1;\n\t}\n\n\tif ((error = user_agent(&ua)) < 0) {\n\t\tgit__free(wide_host);\n\t\treturn error;\n\t}\n\n\tif (git__utf8_to_16_alloc(&wide_ua, git_buf_cstr(&ua)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\tgit__free(wide_host);\n\t\tgit_buf_free(&ua);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&ua);\n\n\t/* Establish session */\n\tt->session = WinHttpOpen(\n\t\twide_ua,\n\t\tWINHTTP_ACCESS_TYPE_DEFAULT_PROXY,\n\t\tWINHTTP_NO_PROXY_NAME,\n\t\tWINHTTP_NO_PROXY_BYPASS,\n\t\t0);\n\n\tif (!t->session) {\n\t\tgiterr_set(GITERR_OS, \"Failed to init WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(t->session, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t\n\t/* Establish connection */\n\tt->connection = WinHttpConnect(\n\t\tt->session,\n\t\twide_host,\n\t\t(INTERNET_PORT) port,\n\t\t0);\n\n\tif (!t->connection) {\n\t\tgiterr_set(GITERR_OS, \"Failed to connect to host\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_close_connection(t);\n\n\tgit__free(wide_host);\n\tgit__free(wide_ua);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_close_connection",
          "args": [
            "t"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "551-574",
          "snippet": "static int winhttp_close_connection(winhttp_subtransport *t)\n{\n\tint ret = 0;\n\n\tif (t->connection) {\n\t\tif (!WinHttpCloseHandle(t->connection)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close connection\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->connection = NULL;\n\t}\n\n\tif (t->session) {\n\t\tif (!WinHttpCloseHandle(t->session)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close session\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->session = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close_connection(winhttp_subtransport *t)\n{\n\tint ret = 0;\n\n\tif (t->connection) {\n\t\tif (!WinHttpCloseHandle(t->connection)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close connection\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->connection = NULL;\n\t}\n\n\tif (t->session) {\n\t\tif (!WinHttpCloseHandle(t->session)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close session\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->session = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_connection_data_from_url",
          "args": [
            "&t->connection_data",
            "location8",
            "s->service_url"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_connection_data_from_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "125-198",
          "snippet": "int gitno_connection_data_from_url(\n\t\tgitno_connection_data *data,\n\t\tconst char *url,\n\t\tconst char *service_suffix)\n{\n\tint error = -1;\n\tconst char *default_port = NULL, *path_search_start = NULL;\n\tchar *original_host = NULL;\n\n\t/* service_suffix is optional */\n\tassert(data && url);\n\n\t/* Save these for comparison later */\n\toriginal_host = data->host;\n\tdata->host = NULL;\n\tgitno_connection_data_free_ptrs(data);\n\n\tif (!git__prefixcmp(url, prefix_http)) {\n\t\tpath_search_start = url + strlen(prefix_http);\n\t\tdefault_port = \"80\";\n\n\t\tif (data->use_ssl) {\n\t\t\tgiterr_set(GITERR_NET, \"Redirect from HTTPS to HTTP is not allowed\");\n\t\t\tgoto cleanup;\n\t\t}\n\t} else if (!git__prefixcmp(url, prefix_https)) {\n\t\tpath_search_start = url + strlen(prefix_https);\n\t\tdefault_port = \"443\";\n\t\tdata->use_ssl = true;\n\t} else if (url[0] == '/')\n\t\tdefault_port = data->use_ssl ? \"443\" : \"80\";\n\n\tif (!default_port) {\n\t\tgiterr_set(GITERR_NET, \"Unrecognized URL prefix\");\n\t\tgoto cleanup;\n\t}\n\n\terror = gitno_extract_url_parts(\n\t\t&data->host, &data->port, &data->path, &data->user, &data->pass,\n\t\turl, default_port);\n\n\tif (url[0] == '/') {\n\t\t/* Relative redirect; reuse original host name and port */\n\t\tpath_search_start = url;\n\t\tgit__free(data->host);\n\t\tdata->host = original_host;\n\t\toriginal_host = NULL;\n\t}\n\n\tif (!error) {\n\t\tconst char *path = strchr(path_search_start, '/');\n\t\tsize_t pathlen = strlen(path);\n\t\tsize_t suffixlen = service_suffix ? strlen(service_suffix) : 0;\n\n\t\tif (suffixlen &&\n\t\t    !memcmp(path + pathlen - suffixlen, service_suffix, suffixlen)) {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strndup(path, pathlen - suffixlen);\n\t\t} else {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strdup(path);\n\t\t}\n\n\t\t/* Check for errors in the resulting data */\n\t\tif (original_host && url[0] != '/' && strcmp(original_host, data->host)) {\n\t\t\tgiterr_set(GITERR_NET, \"Cross host redirect not allowed\");\n\t\t\terror = -1;\n\t\t}\n\t}\n\ncleanup:\n\tif (original_host) git__free(original_host);\n\treturn error;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prefix_http = \"http://\";",
            "static const char *prefix_https = \"https://\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nstatic const char *prefix_http = \"http://\";\nstatic const char *prefix_https = \"https://\";\n\nint gitno_connection_data_from_url(\n\t\tgitno_connection_data *data,\n\t\tconst char *url,\n\t\tconst char *service_suffix)\n{\n\tint error = -1;\n\tconst char *default_port = NULL, *path_search_start = NULL;\n\tchar *original_host = NULL;\n\n\t/* service_suffix is optional */\n\tassert(data && url);\n\n\t/* Save these for comparison later */\n\toriginal_host = data->host;\n\tdata->host = NULL;\n\tgitno_connection_data_free_ptrs(data);\n\n\tif (!git__prefixcmp(url, prefix_http)) {\n\t\tpath_search_start = url + strlen(prefix_http);\n\t\tdefault_port = \"80\";\n\n\t\tif (data->use_ssl) {\n\t\t\tgiterr_set(GITERR_NET, \"Redirect from HTTPS to HTTP is not allowed\");\n\t\t\tgoto cleanup;\n\t\t}\n\t} else if (!git__prefixcmp(url, prefix_https)) {\n\t\tpath_search_start = url + strlen(prefix_https);\n\t\tdefault_port = \"443\";\n\t\tdata->use_ssl = true;\n\t} else if (url[0] == '/')\n\t\tdefault_port = data->use_ssl ? \"443\" : \"80\";\n\n\tif (!default_port) {\n\t\tgiterr_set(GITERR_NET, \"Unrecognized URL prefix\");\n\t\tgoto cleanup;\n\t}\n\n\terror = gitno_extract_url_parts(\n\t\t&data->host, &data->port, &data->path, &data->user, &data->pass,\n\t\turl, default_port);\n\n\tif (url[0] == '/') {\n\t\t/* Relative redirect; reuse original host name and port */\n\t\tpath_search_start = url;\n\t\tgit__free(data->host);\n\t\tdata->host = original_host;\n\t\toriginal_host = NULL;\n\t}\n\n\tif (!error) {\n\t\tconst char *path = strchr(path_search_start, '/');\n\t\tsize_t pathlen = strlen(path);\n\t\tsize_t suffixlen = service_suffix ? strlen(service_suffix) : 0;\n\n\t\tif (suffixlen &&\n\t\t    !memcmp(path + pathlen - suffixlen, service_suffix, suffixlen)) {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strndup(path, pathlen - suffixlen);\n\t\t} else {\n\t\t\tgit__free(data->path);\n\t\t\tdata->path = git__strdup(path);\n\t\t}\n\n\t\t/* Check for errors in the resulting data */\n\t\tif (original_host && url[0] != '/' && strcmp(original_host, data->host)) {\n\t\t\tgiterr_set(GITERR_NET, \"Cross host redirect not allowed\");\n\t\t\terror = -1;\n\t\t}\n\t}\n\ncleanup:\n\tif (original_host) git__free(original_host);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp_icase",
          "args": [
            "location8",
            "prefix_https"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__utf16_to_8_alloc",
          "args": [
            "&location8",
            "location"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf16_to_8_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "113-147",
          "snippet": "int git__utf16_to_8_alloc(char **dest, const wchar_t *src)\n{\n\tint utf8_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf8_size = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, NULL, 0, NULL, NULL);\n\n\tif (!utf8_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\t*dest = git__malloc(utf8_size);\n\n\tif (!*dest) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf8_size = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, *dest, utf8_size, NULL, NULL);\n\n\tif (!utf8_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf8_size - 1;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf16_to_8_alloc(char **dest, const wchar_t *src)\n{\n\tint utf8_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf8_size = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, NULL, 0, NULL, NULL);\n\n\tif (!utf8_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\t*dest = git__malloc(utf8_size);\n\n\tif (!*dest) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf8_size = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, *dest, utf8_size, NULL, NULL);\n\n\tif (!utf8_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf8_size - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpQueryHeaders",
          "args": [
            "s->request",
            "WINHTTP_QUERY_LOCATION",
            "WINHTTP_HEADER_NAME_BY_INDEX",
            "location",
            "&location_length",
            "WINHTTP_NO_HEADER_INDEX"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "location"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "location_length"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpQueryHeaders",
          "args": [
            "s->request",
            "WINHTTP_QUERY_LOCATION",
            "WINHTTP_HEADER_NAME_BY_INDEX",
            "WINHTTP_NO_OUTPUT_BUFFER",
            "&location_length",
            "WINHTTP_NO_HEADER_INDEX"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpQueryHeaders",
          "args": [
            "s->request",
            "WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER",
            "WINHTTP_HEADER_NAME_BY_INDEX",
            "&status_code",
            "&status_code_length",
            "WINHTTP_NO_HEADER_INDEX"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpReceiveResponse",
          "args": [
            "s->request",
            "0"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "s->post_body"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bytes_read == bytes_written"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpWriteData",
          "args": [
            "s->request",
            "buffer",
            "bytes_read",
            "&bytes_written"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadFile",
          "args": [
            "s->post_body",
            "buffer",
            "min(CACHED_POST_BODY_BUF_SIZE, len)",
            "&bytes_read",
            "NULL"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "CACHED_POST_BODY_BUF_SIZE",
            "len"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "homing_search_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "130-143",
          "snippet": "static int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetFilePointer",
          "args": [
            "s->post_body",
            "0",
            "0",
            "FILE_BEGIN"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpWriteData",
          "args": [
            "s->request",
            "\"0\\r\\n\\r\\n\"",
            "5",
            "&bytes_written"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_chunk",
          "args": [
            "s->request",
            "s->chunk_buffer",
            "s->chunk_buffer_len"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_write_chunked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1152-1219",
          "snippet": "static int winhttp_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\tint error;\n\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\tif (!s->sent_request) {\n\t\t/* Send Transfer-Encoding: chunked header */\n\t\tif (!WinHttpAddRequestHeaders(s->request,\n\t\t\ttransfer_encoding, (ULONG) -1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((error = send_request(s, 0, 1)) < 0)\n\t\t\treturn error;\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CACHED_POST_BODY_BUF_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(s->request, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = (int)min(CACHED_POST_BODY_BUF_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CACHED_POST_BODY_BUF_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CACHED_POST_BODY_BUF_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Is there any remaining data from the source? */\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = (unsigned int)len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [
            "#define CACHED_POST_BODY_BUF_SIZE\t4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define CACHED_POST_BODY_BUF_SIZE\t4096\n\nstatic int winhttp_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\tint error;\n\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\tif (!s->sent_request) {\n\t\t/* Send Transfer-Encoding: chunked header */\n\t\tif (!WinHttpAddRequestHeaders(s->request,\n\t\t\ttransfer_encoding, (ULONG) -1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((error = send_request(s, 0, 1)) < 0)\n\t\t\treturn error;\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CACHED_POST_BODY_BUF_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(s->request, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = (int)min(CACHED_POST_BODY_BUF_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CACHED_POST_BODY_BUF_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CACHED_POST_BODY_BUF_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Is there any remaining data from the source? */\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = (unsigned int)len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "s->verb == post_verb"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_request",
          "args": [
            "s",
            "s->post_body_len",
            "0"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "send_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "693-733",
          "snippet": "static int send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tint request_failed = 0, cert_valid = 1, error = 0;\n\tDWORD ignore_flags;\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\trequest_failed = 1;\n\n\tif (request_failed) {\n\t\tif (GetLastError() != ERROR_WINHTTP_SECURE_FAILURE) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tcert_valid = 0;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\tif ((error = certificate_check(s, cert_valid)) < 0) {\n\t\tif (!giterr_last())\n\t\t\tgiterr_set(GITERR_OS, \"user cancelled certificate check\");\n\n\t\treturn error;\n\t}\n\n\t/* if neither the request nor the certificate check returned errors, we're done */\n\tif (!request_failed)\n\t\treturn 0;\n\n\tignore_flags = no_check_cert_flags;\n\t\n\tif (!WinHttpSetOption(s->request, WINHTTP_OPTION_SECURITY_FLAGS, &ignore_flags, sizeof(ignore_flags))) {\n\t\tgiterr_set(GITERR_OS, \"failed to set security options\");\n\t\treturn -1;\n\t}\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tint request_failed = 0, cert_valid = 1, error = 0;\n\tDWORD ignore_flags;\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\trequest_failed = 1;\n\n\tif (request_failed) {\n\t\tif (GetLastError() != ERROR_WINHTTP_SECURE_FAILURE) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tcert_valid = 0;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\tif ((error = certificate_check(s, cert_valid)) < 0) {\n\t\tif (!giterr_last())\n\t\t\tgiterr_set(GITERR_OS, \"user cancelled certificate check\");\n\n\t\treturn error;\n\t}\n\n\t/* if neither the request nor the certificate check returned errors, we're done */\n\tif (!request_failed)\n\t\treturn 0;\n\n\tignore_flags = no_check_cert_flags;\n\t\n\tif (!WinHttpSetOption(s->request, WINHTTP_OPTION_SECURITY_FLAGS, &ignore_flags, sizeof(ignore_flags))) {\n\t\tgiterr_set(GITERR_OS, \"failed to set security options\");\n\t\treturn -1;\n\t}\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_stream_connect",
          "args": [
            "s"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "274-477",
          "snippet": "static int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CONNECT_TIMEOUT 60000",
            "#define TIMEOUT_INFINITE -1",
            "#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109",
            "#define MAX_CONTENT_TYPE_LEN\t100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define DEFAULT_CONNECT_TIMEOUT 60000\n#define TIMEOUT_INFINITE -1\n#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109\n#define MAX_CONTENT_TYPE_LEN\t100\n\nstatic int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OWNING_SUBTRANSPORT",
          "args": [
            "s"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define CACHED_POST_BODY_BUF_SIZE\t4096\n#define MAX_CONTENT_TYPE_LEN\t100\n\nstatic int winhttp_stream_read(\n\tgit_smart_subtransport_stream *stream,\n\tchar *buffer,\n\tsize_t buf_size,\n\tsize_t *bytes_read)\n{\n\twinhttp_stream *s = (winhttp_stream *)stream;\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tDWORD dw_bytes_read;\n\tchar replay_count = 0;\n\tint error;\n\nreplay:\n\t/* Enforce a reasonable cap on the number of replays */\n\tif (++replay_count >= 7) {\n\t\tgiterr_set(GITERR_NET, \"Too many redirects or authentication replays\");\n\t\treturn -1;\n\t}\n\n\t/* Connect if necessary */\n\tif (!s->request && winhttp_stream_connect(s) < 0)\n\t\treturn -1;\n\n\tif (!s->received_response) {\n\t\tDWORD status_code, status_code_length, content_type_length, bytes_written;\n\t\tchar expected_content_type_8[MAX_CONTENT_TYPE_LEN];\n\t\twchar_t expected_content_type[MAX_CONTENT_TYPE_LEN], content_type[MAX_CONTENT_TYPE_LEN];\n\n\t\tif (!s->sent_request) {\n\n\t\t\tif ((error = send_request(s, s->post_body_len, 0)) < 0)\n\t\t\t\treturn error;\n\n\t\t\ts->sent_request = 1;\n\t\t}\n\n\t\tif (s->chunked) {\n\t\t\tassert(s->verb == post_verb);\n\n\t\t\t/* Flush, if necessary */\n\t\t\tif (s->chunk_buffer_len > 0 &&\n\t\t\t\twrite_chunk(s->request, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Write the final chunk. */\n\t\t\tif (!WinHttpWriteData(s->request,\n\t\t\t\t\"0\\r\\n\\r\\n\", 5,\n\t\t\t\t&bytes_written)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to write final chunk\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse if (s->post_body) {\n\t\t\tchar *buffer;\n\t\t\tDWORD len = s->post_body_len, bytes_read;\n\n\t\t\tif (INVALID_SET_FILE_POINTER == SetFilePointer(s->post_body,\n\t\t\t\t\t0, 0, FILE_BEGIN) &&\n\t\t\t\tNO_ERROR != GetLastError()) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to reset file pointer\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbuffer = git__malloc(CACHED_POST_BODY_BUF_SIZE);\n\n\t\t\twhile (len > 0) {\n\t\t\t\tDWORD bytes_written;\n\n\t\t\t\tif (!ReadFile(s->post_body, buffer,\n\t\t\t\t\tmin(CACHED_POST_BODY_BUF_SIZE, len),\n\t\t\t\t\t&bytes_read, NULL) ||\n\t\t\t\t\t!bytes_read) {\n\t\t\t\t\tgit__free(buffer);\n\t\t\t\t\tgiterr_set(GITERR_OS, \"Failed to read from temp file\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (!WinHttpWriteData(s->request, buffer,\n\t\t\t\t\tbytes_read, &bytes_written)) {\n\t\t\t\t\tgit__free(buffer);\n\t\t\t\t\tgiterr_set(GITERR_OS, \"Failed to write data\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tlen -= bytes_read;\n\t\t\t\tassert(bytes_read == bytes_written);\n\t\t\t}\n\n\t\t\tgit__free(buffer);\n\n\t\t\t/* Eagerly close the temp file */\n\t\t\tCloseHandle(s->post_body);\n\t\t\ts->post_body = NULL;\n\t\t}\n\n\t\tif (!WinHttpReceiveResponse(s->request, 0)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to receive response\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Verify that we got a 200 back */\n\t\tstatus_code_length = sizeof(status_code);\n\n\t\tif (!WinHttpQueryHeaders(s->request,\n\t\t\tWINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,\n\t\t\tWINHTTP_HEADER_NAME_BY_INDEX,\n\t\t\t&status_code, &status_code_length,\n\t\t\tWINHTTP_NO_HEADER_INDEX)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to retrieve status code\");\n\t\t\t\treturn -1;\n\t\t}\n\n\t\t/* The implementation of WinHTTP prior to Windows 7 will not\n\t\t * redirect to an identical URI. Some Git hosters use self-redirects\n\t\t * as part of their DoS mitigation strategy. Check first to see if we\n\t\t * have a redirect status code, and that we haven't already streamed\n\t\t * a post body. (We can't replay a streamed POST.) */\n\t\tif (!s->chunked &&\n\t\t\t(HTTP_STATUS_MOVED == status_code ||\n\t\t\t HTTP_STATUS_REDIRECT == status_code ||\n\t\t\t (HTTP_STATUS_REDIRECT_METHOD == status_code &&\n\t\t\t  get_verb == s->verb) ||\n\t\t\t HTTP_STATUS_REDIRECT_KEEP_VERB == status_code)) {\n\n\t\t\t/* Check for Windows 7. This workaround is only necessary on\n\t\t\t * Windows Vista and earlier. Windows 7 is version 6.1. */\n\t\t\twchar_t *location;\n\t\t\tDWORD location_length;\n\t\t\tchar *location8;\n\n\t\t\t/* OK, fetch the Location header from the redirect. */\n\t\t\tif (WinHttpQueryHeaders(s->request,\n\t\t\t\tWINHTTP_QUERY_LOCATION,\n\t\t\t\tWINHTTP_HEADER_NAME_BY_INDEX,\n\t\t\t\tWINHTTP_NO_OUTPUT_BUFFER,\n\t\t\t\t&location_length,\n\t\t\t\tWINHTTP_NO_HEADER_INDEX) ||\n\t\t\t\tGetLastError() != ERROR_INSUFFICIENT_BUFFER) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to read Location header\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tlocation = git__malloc(location_length);\n\t\t\tGITERR_CHECK_ALLOC(location);\n\n\t\t\tif (!WinHttpQueryHeaders(s->request,\n\t\t\t\tWINHTTP_QUERY_LOCATION,\n\t\t\t\tWINHTTP_HEADER_NAME_BY_INDEX,\n\t\t\t\tlocation,\n\t\t\t\t&location_length,\n\t\t\t\tWINHTTP_NO_HEADER_INDEX)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to read Location header\");\n\t\t\t\tgit__free(location);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* Convert the Location header to UTF-8 */\n\t\t\tif (git__utf16_to_8_alloc(&location8, location) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert Location header to UTF-8\");\n\t\t\t\tgit__free(location);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tgit__free(location);\n\n\t\t\t/* Replay the request */\n\t\t\twinhttp_stream_close(s);\n\n\t\t\tif (!git__prefixcmp_icase(location8, prefix_https)) {\n\t\t\t\t/* Upgrade to secure connection; disconnect and start over */\n\t\t\t\tif (gitno_connection_data_from_url(&t->connection_data, location8, s->service_url) < 0) {\n\t\t\t\t\tgit__free(location8);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\twinhttp_close_connection(t);\n\n\t\t\t\tif (winhttp_connect(t) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tgit__free(location8);\n\t\t\tgoto replay;\n\t\t}\n\n\t\t/* Handle authentication failures */\n\t\tif (HTTP_STATUS_DENIED == status_code && get_verb == s->verb) {\n\t\t\tint allowed_types;\n\n\t\t\tif (parse_unauthorized_response(s->request, &allowed_types, &t->auth_mechanism) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (allowed_types) {\n\t\t\t\tint cred_error = 1;\n\n\t\t\t\tgit_cred_free(t->cred);\n\t\t\t\tt->cred = NULL;\n\t\t\t\t/* Start with the user-supplied credential callback, if present */\n\t\t\t\tif (t->owner->cred_acquire_cb) {\n\t\t\t\t\tcred_error = t->owner->cred_acquire_cb(&t->cred, t->owner->url,\n\t\t\t\t\t\tt->connection_data.user, allowed_types,\tt->owner->cred_acquire_payload);\n\n\t\t\t\t\t/* Treat GIT_PASSTHROUGH as though git_cred_acquire_cb isn't set */\n\t\t\t\t\tif (cred_error == GIT_PASSTHROUGH)\n\t\t\t\t\t\tcred_error = 1;\n\t\t\t\t\telse if (cred_error < 0)\n\t\t\t\t\t\treturn cred_error;\n\t\t\t\t}\n\n\t\t\t\t/* Invoke the fallback credentials acquisition callback if necessary */\n\t\t\t\tif (cred_error > 0) {\n\t\t\t\t\tcred_error = fallback_cred_acquire_cb(&t->cred, t->owner->url,\n\t\t\t\t\t\tt->connection_data.user, allowed_types, NULL);\n\n\t\t\t\t\tif (cred_error < 0)\n\t\t\t\t\t\treturn cred_error;\n\t\t\t\t}\n\n\t\t\t\tif (!cred_error) {\n\t\t\t\t\tassert(t->cred);\n\n\t\t\t\t\twinhttp_stream_close(s);\n\n\t\t\t\t\t/* Successfully acquired a credential */\n\t\t\t\t\tgoto replay;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (HTTP_STATUS_OK != status_code) {\n\t\t\tgiterr_set(GITERR_NET, \"Request failed with status code: %d\", status_code);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Verify that we got the correct content-type back */\n\t\tif (post_verb == s->verb)\n\t\t\tp_snprintf(expected_content_type_8, MAX_CONTENT_TYPE_LEN, \"application/x-git-%s-result\", s->service);\n\t\telse\n\t\t\tp_snprintf(expected_content_type_8, MAX_CONTENT_TYPE_LEN, \"application/x-git-%s-advertisement\", s->service);\n\n\t\tif (git__utf8_to_16(expected_content_type, MAX_CONTENT_TYPE_LEN, expected_content_type_8) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert expected content-type to wide characters\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tcontent_type_length = sizeof(content_type);\n\n\t\tif (!WinHttpQueryHeaders(s->request,\n\t\t\tWINHTTP_QUERY_CONTENT_TYPE,\n\t\t\tWINHTTP_HEADER_NAME_BY_INDEX,\n\t\t\t&content_type, &content_type_length,\n\t\t\tWINHTTP_NO_HEADER_INDEX)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to retrieve response content-type\");\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (wcscmp(expected_content_type, content_type)) {\n\t\t\tgiterr_set(GITERR_NET, \"Received unexpected content-type\");\n\t\t\treturn -1;\n\t\t}\n\n\t\ts->received_response = 1;\n\t}\n\n\tif (!WinHttpReadData(s->request,\n\t\t(LPVOID)buffer,\n\t\t(DWORD)buf_size,\n\t\t&dw_bytes_read))\n\t{\n\t\tgiterr_set(GITERR_OS, \"Failed to read data\");\n\t\treturn -1;\n\t}\n\n\t*bytes_read = dw_bytes_read;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "send_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "693-733",
    "snippet": "static int send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tint request_failed = 0, cert_valid = 1, error = 0;\n\tDWORD ignore_flags;\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\trequest_failed = 1;\n\n\tif (request_failed) {\n\t\tif (GetLastError() != ERROR_WINHTTP_SECURE_FAILURE) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tcert_valid = 0;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\tif ((error = certificate_check(s, cert_valid)) < 0) {\n\t\tif (!giterr_last())\n\t\t\tgiterr_set(GITERR_OS, \"user cancelled certificate check\");\n\n\t\treturn error;\n\t}\n\n\t/* if neither the request nor the certificate check returned errors, we're done */\n\tif (!request_failed)\n\t\treturn 0;\n\n\tignore_flags = no_check_cert_flags;\n\t\n\tif (!WinHttpSetOption(s->request, WINHTTP_OPTION_SECURITY_FLAGS, &ignore_flags, sizeof(ignore_flags))) {\n\t\tgiterr_set(GITERR_OS, \"failed to set security options\");\n\t\treturn -1;\n\t}\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\n\treturn error;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to send request\""
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_send_request",
          "args": [
            "s",
            "len",
            "ignore_length"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "672-691",
          "snippet": "static int do_send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tif (ignore_length) {\n\t\tif (!WinHttpSendRequest(s->request,\n\t\t\tWINHTTP_NO_ADDITIONAL_HEADERS, 0,\n\t\t\tWINHTTP_NO_REQUEST_DATA, 0,\n\t\t\tWINHTTP_IGNORE_REQUEST_TOTAL_LENGTH, 0)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (!WinHttpSendRequest(s->request,\n\t\t\tWINHTTP_NO_ADDITIONAL_HEADERS, 0,\n\t\t\tWINHTTP_NO_REQUEST_DATA, 0,\n\t\t\tlen, 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [
            "#define WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH 0\n\nstatic int do_send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tif (ignore_length) {\n\t\tif (!WinHttpSendRequest(s->request,\n\t\t\tWINHTTP_NO_ADDITIONAL_HEADERS, 0,\n\t\t\tWINHTTP_NO_REQUEST_DATA, 0,\n\t\t\tWINHTTP_IGNORE_REQUEST_TOTAL_LENGTH, 0)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (!WinHttpSendRequest(s->request,\n\t\t\tWINHTTP_NO_ADDITIONAL_HEADERS, 0,\n\t\t\tWINHTTP_NO_REQUEST_DATA, 0,\n\t\t\tlen, 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpSetOption",
          "args": [
            "s->request",
            "WINHTTP_OPTION_SECURITY_FLAGS",
            "&ignore_flags",
            "sizeof(ignore_flags)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_last",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "134-137",
          "snippet": "const git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "certificate_check",
          "args": [
            "s",
            "cert_valid"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "certificate_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "216-247",
          "snippet": "static int certificate_check(winhttp_stream *s, int valid)\n{\n\tint error;\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tPCERT_CONTEXT cert_ctx;\n\tDWORD cert_ctx_size = sizeof(cert_ctx);\n\tgit_cert_x509 cert;\n\n\t/* If there is no override, we should fail if WinHTTP doesn't think it's fine */\n\tif (t->owner->certificate_check_cb == NULL && !valid)\n\t\treturn GIT_ECERTIFICATE;\n\n\tif (t->owner->certificate_check_cb == NULL || !t->connection_data.use_ssl)\n\t\treturn 0;\n\n\tif (!WinHttpQueryOption(s->request, WINHTTP_OPTION_SERVER_CERT_CONTEXT, &cert_ctx, &cert_ctx_size)) {\n\t\tgiterr_set(GITERR_OS, \"failed to get server certificate\");\n\t\treturn -1;\n\t}\n\n\tgiterr_clear();\n\tcert.parent.cert_type = GIT_CERT_X509;\n\tcert.data = cert_ctx->pbCertEncoded;\n\tcert.len = cert_ctx->cbCertEncoded;\n\terror = t->owner->certificate_check_cb((git_cert *) &cert, valid, t->connection_data.host, t->owner->cred_acquire_payload);\n\tCertFreeCertificateContext(cert_ctx);\n\n\tif (error < 0 && !giterr_last())\n\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int certificate_check(winhttp_stream *s, int valid)\n{\n\tint error;\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tPCERT_CONTEXT cert_ctx;\n\tDWORD cert_ctx_size = sizeof(cert_ctx);\n\tgit_cert_x509 cert;\n\n\t/* If there is no override, we should fail if WinHTTP doesn't think it's fine */\n\tif (t->owner->certificate_check_cb == NULL && !valid)\n\t\treturn GIT_ECERTIFICATE;\n\n\tif (t->owner->certificate_check_cb == NULL || !t->connection_data.use_ssl)\n\t\treturn 0;\n\n\tif (!WinHttpQueryOption(s->request, WINHTTP_OPTION_SERVER_CERT_CONTEXT, &cert_ctx, &cert_ctx_size)) {\n\t\tgiterr_set(GITERR_OS, \"failed to get server certificate\");\n\t\treturn -1;\n\t}\n\n\tgiterr_clear();\n\tcert.parent.cert_type = GIT_CERT_X509;\n\tcert.data = cert_ctx->pbCertEncoded;\n\tcert.len = cert_ctx->cbCertEncoded;\n\terror = t->owner->certificate_check_cb((git_cert *) &cert, valid, t->connection_data.host, t->owner->cred_acquire_payload);\n\tCertFreeCertificateContext(cert_ctx);\n\n\tif (error < 0 && !giterr_last())\n\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tint request_failed = 0, cert_valid = 1, error = 0;\n\tDWORD ignore_flags;\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\trequest_failed = 1;\n\n\tif (request_failed) {\n\t\tif (GetLastError() != ERROR_WINHTTP_SECURE_FAILURE) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tcert_valid = 0;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\tif ((error = certificate_check(s, cert_valid)) < 0) {\n\t\tif (!giterr_last())\n\t\t\tgiterr_set(GITERR_OS, \"user cancelled certificate check\");\n\n\t\treturn error;\n\t}\n\n\t/* if neither the request nor the certificate check returned errors, we're done */\n\tif (!request_failed)\n\t\treturn 0;\n\n\tignore_flags = no_check_cert_flags;\n\t\n\tif (!WinHttpSetOption(s->request, WINHTTP_OPTION_SECURITY_FLAGS, &ignore_flags, sizeof(ignore_flags))) {\n\t\tgiterr_set(GITERR_OS, \"failed to set security options\");\n\t\treturn -1;\n\t}\n\n\tif ((error = do_send_request(s, len, ignore_length)) < 0)\n\t\tgiterr_set(GITERR_OS, \"failed to send request\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "do_send_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "672-691",
    "snippet": "static int do_send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tif (ignore_length) {\n\t\tif (!WinHttpSendRequest(s->request,\n\t\t\tWINHTTP_NO_ADDITIONAL_HEADERS, 0,\n\t\t\tWINHTTP_NO_REQUEST_DATA, 0,\n\t\t\tWINHTTP_IGNORE_REQUEST_TOTAL_LENGTH, 0)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (!WinHttpSendRequest(s->request,\n\t\t\tWINHTTP_NO_ADDITIONAL_HEADERS, 0,\n\t\t\tWINHTTP_NO_REQUEST_DATA, 0,\n\t\t\tlen, 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WinHttpSendRequest",
          "args": [
            "s->request",
            "WINHTTP_NO_ADDITIONAL_HEADERS",
            "0",
            "WINHTTP_NO_REQUEST_DATA",
            "0",
            "len",
            "0"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpSendRequest",
          "args": [
            "s->request",
            "WINHTTP_NO_ADDITIONAL_HEADERS",
            "0",
            "WINHTTP_NO_REQUEST_DATA",
            "0",
            "WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH",
            "0"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH 0\n\nstatic int do_send_request(winhttp_stream *s, size_t len, int ignore_length)\n{\n\tif (ignore_length) {\n\t\tif (!WinHttpSendRequest(s->request,\n\t\t\tWINHTTP_NO_ADDITIONAL_HEADERS, 0,\n\t\t\tWINHTTP_NO_REQUEST_DATA, 0,\n\t\t\tWINHTTP_IGNORE_REQUEST_TOTAL_LENGTH, 0)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (!WinHttpSendRequest(s->request,\n\t\t\tWINHTTP_NO_ADDITIONAL_HEADERS, 0,\n\t\t\tWINHTTP_NO_REQUEST_DATA, 0,\n\t\t\tlen, 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "591-670",
    "snippet": "static int winhttp_connect(\n\twinhttp_subtransport *t)\n{\n\twchar_t *wide_host;\n\tint32_t port;\n\twchar_t *wide_ua;\n\tgit_buf ua = GIT_BUF_INIT;\n\tint error = -1;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\n\tt->session = NULL;\n\tt->connection = NULL;\n\n\t/* Prepare port */\n\tif (git__strtol32(&port, t->connection_data.port, NULL, 10) < 0)\n\t\treturn -1;\n\n\t/* Prepare host */\n\tif (git__utf8_to_16_alloc(&wide_host, t->connection_data.host) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\treturn -1;\n\t}\n\n\tif ((error = user_agent(&ua)) < 0) {\n\t\tgit__free(wide_host);\n\t\treturn error;\n\t}\n\n\tif (git__utf8_to_16_alloc(&wide_ua, git_buf_cstr(&ua)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\tgit__free(wide_host);\n\t\tgit_buf_free(&ua);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&ua);\n\n\t/* Establish session */\n\tt->session = WinHttpOpen(\n\t\twide_ua,\n\t\tWINHTTP_ACCESS_TYPE_DEFAULT_PROXY,\n\t\tWINHTTP_NO_PROXY_NAME,\n\t\tWINHTTP_NO_PROXY_BYPASS,\n\t\t0);\n\n\tif (!t->session) {\n\t\tgiterr_set(GITERR_OS, \"Failed to init WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(t->session, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t\n\t/* Establish connection */\n\tt->connection = WinHttpConnect(\n\t\tt->session,\n\t\twide_host,\n\t\t(INTERNET_PORT) port,\n\t\t0);\n\n\tif (!t->connection) {\n\t\tgiterr_set(GITERR_OS, \"Failed to connect to host\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_close_connection(t);\n\n\tgit__free(wide_host);\n\tgit__free(wide_ua);\n\n\treturn error;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define DEFAULT_CONNECT_TIMEOUT 60000",
      "#define TIMEOUT_INFINITE -1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "wide_ua"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_close_connection",
          "args": [
            "t"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "551-574",
          "snippet": "static int winhttp_close_connection(winhttp_subtransport *t)\n{\n\tint ret = 0;\n\n\tif (t->connection) {\n\t\tif (!WinHttpCloseHandle(t->connection)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close connection\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->connection = NULL;\n\t}\n\n\tif (t->session) {\n\t\tif (!WinHttpCloseHandle(t->session)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close session\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->session = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close_connection(winhttp_subtransport *t)\n{\n\tint ret = 0;\n\n\tif (t->connection) {\n\t\tif (!WinHttpCloseHandle(t->connection)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close connection\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->connection = NULL;\n\t}\n\n\tif (t->session) {\n\t\tif (!WinHttpCloseHandle(t->session)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close session\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->session = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to connect to host\""
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpConnect",
          "args": [
            "t->session",
            "wide_host",
            "(INTERNET_PORT) port",
            "0"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpSetTimeouts",
          "args": [
            "t->session",
            "default_timeout",
            "default_connect_timeout",
            "default_timeout",
            "default_timeout"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpOpen",
          "args": [
            "wide_ua",
            "WINHTTP_ACCESS_TYPE_DEFAULT_PROXY",
            "WINHTTP_NO_PROXY_NAME",
            "WINHTTP_NO_PROXY_BYPASS",
            "0"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ua"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__utf8_to_16_alloc",
          "args": [
            "&wide_ua",
            "git_buf_cstr(&ua)"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf8_to_16_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "70-102",
          "snippet": "int git__utf8_to_16_alloc(wchar_t **dest, const char *src)\n{\n\tint utf16_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, NULL, 0);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\tif (!(*dest = git__mallocarray(utf16_size, sizeof(wchar_t)))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, *dest, utf16_size);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf16_size - 1;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf8_to_16_alloc(wchar_t **dest, const char *src)\n{\n\tint utf16_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, NULL, 0);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\tif (!(*dest = git__mallocarray(utf16_size, sizeof(wchar_t)))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, *dest, utf16_size);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf16_size - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&ua"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_agent",
          "args": [
            "&ua"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "user_agent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "576-589",
          "snippet": "static int user_agent(git_buf *ua)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tgit_buf_clear(ua);\n\tgit_buf_PUTS(ua, \"git/1.0 (\");\n\n\tif (custom)\n\t\tgit_buf_puts(ua, custom);\n\telse\n\t\tgit_buf_PUTS(ua, \"libgit2 \" LIBGIT2_VERSION);\n\n\treturn git_buf_putc(ua, ')');\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int user_agent(git_buf *ua)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tgit_buf_clear(ua);\n\tgit_buf_PUTS(ua, \"git/1.0 (\");\n\n\tif (custom)\n\t\tgit_buf_puts(ua, custom);\n\telse\n\t\tgit_buf_PUTS(ua, \"libgit2 \" LIBGIT2_VERSION);\n\n\treturn git_buf_putc(ua, ')');\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strtol32",
          "args": [
            "&port",
            "t->connection_data.port",
            "NULL",
            "10"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "git__strtol32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "149-167",
          "snippet": "int git__strtol32(int32_t *result, const char *nptr, const char **endptr, int base)\n{\n\tint error;\n\tint32_t tmp_int;\n\tint64_t tmp_long;\n\n\tif ((error = git__strtol64(&tmp_long, nptr, endptr, base)) < 0)\n\t\treturn error;\n\n\ttmp_int = tmp_long & 0xFFFFFFFF;\n\tif (tmp_int != tmp_long) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert. '%s' is too large\", nptr);\n\t\treturn -1;\n\t}\n\n\t*result = tmp_int;\n\n\treturn error;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strtol32(int32_t *result, const char *nptr, const char **endptr, int base)\n{\n\tint error;\n\tint32_t tmp_int;\n\tint64_t tmp_long;\n\n\tif ((error = git__strtol64(&tmp_long, nptr, endptr, base)) < 0)\n\t\treturn error;\n\n\ttmp_int = tmp_long & 0xFFFFFFFF;\n\tif (tmp_int != tmp_long) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert. '%s' is too large\", nptr);\n\t\treturn -1;\n\t}\n\n\t*result = tmp_int;\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define DEFAULT_CONNECT_TIMEOUT 60000\n#define TIMEOUT_INFINITE -1\n\nstatic int winhttp_connect(\n\twinhttp_subtransport *t)\n{\n\twchar_t *wide_host;\n\tint32_t port;\n\twchar_t *wide_ua;\n\tgit_buf ua = GIT_BUF_INIT;\n\tint error = -1;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\n\tt->session = NULL;\n\tt->connection = NULL;\n\n\t/* Prepare port */\n\tif (git__strtol32(&port, t->connection_data.port, NULL, 10) < 0)\n\t\treturn -1;\n\n\t/* Prepare host */\n\tif (git__utf8_to_16_alloc(&wide_host, t->connection_data.host) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\treturn -1;\n\t}\n\n\tif ((error = user_agent(&ua)) < 0) {\n\t\tgit__free(wide_host);\n\t\treturn error;\n\t}\n\n\tif (git__utf8_to_16_alloc(&wide_ua, git_buf_cstr(&ua)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert host to wide characters\");\n\t\tgit__free(wide_host);\n\t\tgit_buf_free(&ua);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&ua);\n\n\t/* Establish session */\n\tt->session = WinHttpOpen(\n\t\twide_ua,\n\t\tWINHTTP_ACCESS_TYPE_DEFAULT_PROXY,\n\t\tWINHTTP_NO_PROXY_NAME,\n\t\tWINHTTP_NO_PROXY_BYPASS,\n\t\t0);\n\n\tif (!t->session) {\n\t\tgiterr_set(GITERR_OS, \"Failed to init WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(t->session, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t\n\t/* Establish connection */\n\tt->connection = WinHttpConnect(\n\t\tt->session,\n\t\twide_host,\n\t\t(INTERNET_PORT) port,\n\t\t0);\n\n\tif (!t->connection) {\n\t\tgiterr_set(GITERR_OS, \"Failed to connect to host\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_close_connection(t);\n\n\tgit__free(wide_host);\n\tgit__free(wide_ua);\n\n\treturn error;\n}"
  },
  {
    "function_name": "user_agent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "576-589",
    "snippet": "static int user_agent(git_buf *ua)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tgit_buf_clear(ua);\n\tgit_buf_PUTS(ua, \"git/1.0 (\");\n\n\tif (custom)\n\t\tgit_buf_puts(ua, custom);\n\telse\n\t\tgit_buf_PUTS(ua, \"libgit2 \" LIBGIT2_VERSION);\n\n\treturn git_buf_putc(ua, ')');\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "ua",
            "')'"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_PUTS",
          "args": [
            "ua",
            "\"libgit2 \" LIBGIT2_VERSION"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "ua",
            "custom"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_PUTS",
          "args": [
            "ua",
            "\"git/1.0 (\""
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "ua"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_libgit2__user_agent",
          "args": [],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "git_libgit2__user_agent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/settings.c",
          "lines": "76-79",
          "snippet": "const char *git_libgit2__user_agent()\n{\n\treturn git__user_agent;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"global.h\"",
            "#include \"cache.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\"",
            "#include <git2.h>",
            "# include <openssl/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *git__user_agent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"global.h\"\n#include \"cache.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n#include <git2.h>\n# include <openssl/err.h>\n\nextern char *git__user_agent;\n\nconst char *git_libgit2__user_agent()\n{\n\treturn git__user_agent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int user_agent(git_buf *ua)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tgit_buf_clear(ua);\n\tgit_buf_PUTS(ua, \"git/1.0 (\");\n\n\tif (custom)\n\t\tgit_buf_puts(ua, custom);\n\telse\n\t\tgit_buf_PUTS(ua, \"libgit2 \" LIBGIT2_VERSION);\n\n\treturn git_buf_putc(ua, ')');\n}"
  },
  {
    "function_name": "winhttp_close_connection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "551-574",
    "snippet": "static int winhttp_close_connection(winhttp_subtransport *t)\n{\n\tint ret = 0;\n\n\tif (t->connection) {\n\t\tif (!WinHttpCloseHandle(t->connection)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close connection\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->connection = NULL;\n\t}\n\n\tif (t->session) {\n\t\tif (!WinHttpCloseHandle(t->session)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close session\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->session = NULL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Unable to close session\""
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpCloseHandle",
          "args": [
            "t->session"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpCloseHandle",
          "args": [
            "t->connection"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close_connection(winhttp_subtransport *t)\n{\n\tint ret = 0;\n\n\tif (t->connection) {\n\t\tif (!WinHttpCloseHandle(t->connection)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close connection\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->connection = NULL;\n\t}\n\n\tif (t->session) {\n\t\tif (!WinHttpCloseHandle(t->session)) {\n\t\t\tgiterr_set(GITERR_OS, \"Unable to close session\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tt->session = NULL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "write_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "511-549",
    "snippet": "static int write_chunk(HINTERNET request, const char *buffer, size_t len)\n{\n\tDWORD bytes_written;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* Chunk header */\n\tgit_buf_printf(&buf, \"%X\\r\\n\", len);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tif (!WinHttpWriteData(request,\n\t\tgit_buf_cstr(&buf),\t(DWORD)git_buf_len(&buf),\n\t\t&bytes_written)) {\n\t\tgit_buf_free(&buf);\n\t\tgiterr_set(GITERR_OS, \"Failed to write chunk header\");\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&buf);\n\n\t/* Chunk body */\n\tif (!WinHttpWriteData(request,\n\t\tbuffer, (DWORD)len,\n\t\t&bytes_written)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to write chunk\");\n\t\treturn -1;\n\t}\n\n\t/* Chunk footer */\n\tif (!WinHttpWriteData(request,\n\t\t\"\\r\\n\", 2,\n\t\t&bytes_written)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to write chunk footer\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to write chunk footer\""
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpWriteData",
          "args": [
            "request",
            "\"\\r\\n\"",
            "2",
            "&bytes_written"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpWriteData",
          "args": [
            "request",
            "buffer",
            "(DWORD)len",
            "&bytes_written"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpWriteData",
          "args": [
            "request",
            "git_buf_cstr(&buf)",
            "(DWORD)git_buf_len(&buf)",
            "&bytes_written"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&buf"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&buf"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"%X\\r\\n\"",
            "len"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int write_chunk(HINTERNET request, const char *buffer, size_t len)\n{\n\tDWORD bytes_written;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* Chunk header */\n\tgit_buf_printf(&buf, \"%X\\r\\n\", len);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tif (!WinHttpWriteData(request,\n\t\tgit_buf_cstr(&buf),\t(DWORD)git_buf_len(&buf),\n\t\t&bytes_written)) {\n\t\tgit_buf_free(&buf);\n\t\tgiterr_set(GITERR_OS, \"Failed to write chunk header\");\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&buf);\n\n\t/* Chunk body */\n\tif (!WinHttpWriteData(request,\n\t\tbuffer, (DWORD)len,\n\t\t&bytes_written)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to write chunk\");\n\t\treturn -1;\n\t}\n\n\t/* Chunk footer */\n\tif (!WinHttpWriteData(request,\n\t\t\"\\r\\n\", 2,\n\t\t&bytes_written)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to write chunk footer\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_unauthorized_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "479-509",
    "snippet": "static int parse_unauthorized_response(\n\tHINTERNET request,\n\tint *allowed_types,\n\tint *auth_mechanism)\n{\n\tDWORD supported, first, target;\n\n\t*allowed_types = 0;\n\t*auth_mechanism = 0;\n\n\t/* WinHttpQueryHeaders() must be called before WinHttpQueryAuthSchemes(). \n\t * We can assume this was already done, since we know we are unauthorized. \n\t */\n\tif (!WinHttpQueryAuthSchemes(request, &supported, &first, &target)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to parse supported auth schemes\"); \n\t\treturn -1;\n\t}\n\n\tif (WINHTTP_AUTH_SCHEME_BASIC & supported) {\n\t\t*allowed_types |= GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\t\t*auth_mechanism = GIT_WINHTTP_AUTH_BASIC;\n\t}\n\n\tif ((WINHTTP_AUTH_SCHEME_NTLM & supported) ||\n\t\t(WINHTTP_AUTH_SCHEME_NEGOTIATE & supported)) {\n\t\t*allowed_types |= GIT_CREDTYPE_DEFAULT;\n\t\t*auth_mechanism = GIT_WINHTTP_AUTH_NEGOTIATE;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to parse supported auth schemes\""
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpQueryAuthSchemes",
          "args": [
            "request",
            "&supported",
            "&first",
            "&target"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int parse_unauthorized_response(\n\tHINTERNET request,\n\tint *allowed_types,\n\tint *auth_mechanism)\n{\n\tDWORD supported, first, target;\n\n\t*allowed_types = 0;\n\t*auth_mechanism = 0;\n\n\t/* WinHttpQueryHeaders() must be called before WinHttpQueryAuthSchemes(). \n\t * We can assume this was already done, since we know we are unauthorized. \n\t */\n\tif (!WinHttpQueryAuthSchemes(request, &supported, &first, &target)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to parse supported auth schemes\"); \n\t\treturn -1;\n\t}\n\n\tif (WINHTTP_AUTH_SCHEME_BASIC & supported) {\n\t\t*allowed_types |= GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\t\t*auth_mechanism = GIT_WINHTTP_AUTH_BASIC;\n\t}\n\n\tif ((WINHTTP_AUTH_SCHEME_NTLM & supported) ||\n\t\t(WINHTTP_AUTH_SCHEME_NEGOTIATE & supported)) {\n\t\t*allowed_types |= GIT_CREDTYPE_DEFAULT;\n\t\t*auth_mechanism = GIT_WINHTTP_AUTH_NEGOTIATE;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "winhttp_stream_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "274-477",
    "snippet": "static int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define DEFAULT_CONNECT_TIMEOUT 60000",
      "#define TIMEOUT_INFINITE -1",
      "#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109",
      "#define MAX_CONTENT_TYPE_LEN\t100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "proxy_url"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "winhttp_stream_close",
          "args": [
            "s"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_stream_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "249-272",
          "snippet": "static void winhttp_stream_close(winhttp_stream *s)\n{\n\tif (s->chunk_buffer) {\n\t\tgit__free(s->chunk_buffer);\n\t\ts->chunk_buffer = NULL;\n\t}\n\n\tif (s->post_body) {\n\t\tCloseHandle(s->post_body);\n\t\ts->post_body = NULL;\n\t}\n\n\tif (s->request_uri) {\n\t\tgit__free(s->request_uri);\n\t\ts->request_uri = NULL;\n\t}\n\n\tif (s->request) {\n\t\tWinHttpCloseHandle(s->request);\n\t\ts->request = NULL;\n\t}\n\n\ts->sent_request = 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic void winhttp_stream_close(winhttp_stream *s)\n{\n\tif (s->chunk_buffer) {\n\t\tgit__free(s->chunk_buffer);\n\t\ts->chunk_buffer = NULL;\n\t}\n\n\tif (s->post_body) {\n\t\tCloseHandle(s->post_body);\n\t\ts->post_body = NULL;\n\t}\n\n\tif (s->request_uri) {\n\t\tgit__free(s->request_uri);\n\t\ts->request_uri = NULL;\n\t}\n\n\tif (s->request) {\n\t\tWinHttpCloseHandle(s->request);\n\t\ts->request = NULL;\n\t}\n\n\ts->sent_request = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_basic_credential",
          "args": [
            "s->request",
            "t->url_cred"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "apply_basic_credential",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "101-142",
          "snippet": "static int apply_basic_credential(HINTERNET request, git_cred *cred)\n{\n\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *)cred;\n\tgit_buf buf = GIT_BUF_INIT, raw = GIT_BUF_INIT;\n\twchar_t *wide = NULL;\n\tint error = -1, wide_len;\n\n\tgit_buf_printf(&raw, \"%s:%s\", c->username, c->password);\n\n\tif (git_buf_oom(&raw) ||\n\t\tgit_buf_puts(&buf, \"Authorization: Basic \") < 0 ||\n\t\tgit_buf_encode_base64(&buf, git_buf_cstr(&raw), raw.size) < 0)\n\t\tgoto on_error;\n\n\tif ((wide_len = git__utf8_to_16_alloc(&wide, git_buf_cstr(&buf))) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpAddRequestHeaders(request, wide, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\t/* We were dealing with plaintext passwords, so clean up after ourselves a bit. */\n\tif (wide)\n\t\tmemset(wide, 0x0, wide_len * sizeof(wchar_t));\n\n\tif (buf.size)\n\t\tmemset(buf.ptr, 0x0, buf.size);\n\n\tif (raw.size)\n\t\tmemset(raw.ptr, 0x0, raw.size);\n\n\tgit__free(wide);\n\tgit_buf_free(&buf);\n\tgit_buf_free(&raw);\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int apply_basic_credential(HINTERNET request, git_cred *cred)\n{\n\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *)cred;\n\tgit_buf buf = GIT_BUF_INIT, raw = GIT_BUF_INIT;\n\twchar_t *wide = NULL;\n\tint error = -1, wide_len;\n\n\tgit_buf_printf(&raw, \"%s:%s\", c->username, c->password);\n\n\tif (git_buf_oom(&raw) ||\n\t\tgit_buf_puts(&buf, \"Authorization: Basic \") < 0 ||\n\t\tgit_buf_encode_base64(&buf, git_buf_cstr(&raw), raw.size) < 0)\n\t\tgoto on_error;\n\n\tif ((wide_len = git__utf8_to_16_alloc(&wide, git_buf_cstr(&buf))) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpAddRequestHeaders(request, wide, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\t/* We were dealing with plaintext passwords, so clean up after ourselves a bit. */\n\tif (wide)\n\t\tmemset(wide, 0x0, wide_len * sizeof(wchar_t));\n\n\tif (buf.size)\n\t\tmemset(buf.ptr, 0x0, buf.size);\n\n\tif (raw.size)\n\t\tmemset(raw.ptr, 0x0, raw.size);\n\n\tgit__free(wide);\n\tgit_buf_free(&buf);\n\tgit_buf_free(&raw);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_cred_userpass_plaintext_new",
          "args": [
            "&t->url_cred",
            "t->connection_data.user",
            "t->connection_data.pass"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "git_cred_userpass_plaintext_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/cred.c",
          "lines": "79-110",
          "snippet": "int git_cred_userpass_plaintext_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *password)\n{\n\tgit_cred_userpass_plaintext *c;\n\n\tassert(cred && username && password);\n\n\tc = git__malloc(sizeof(git_cred_userpass_plaintext));\n\tGITERR_CHECK_ALLOC(c);\n\n\tc->parent.credtype = GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\tc->parent.free = plaintext_free;\n\tc->username = git__strdup(username);\n\n\tif (!c->username) {\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\tc->password = git__strdup(password);\n\n\tif (!c->password) {\n\t\tgit__free(c->username);\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\t*cred = &c->parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/cred_helpers.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/cred_helpers.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);\n\nint git_cred_userpass_plaintext_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *password)\n{\n\tgit_cred_userpass_plaintext *c;\n\n\tassert(cred && username && password);\n\n\tc = git__malloc(sizeof(git_cred_userpass_plaintext));\n\tGITERR_CHECK_ALLOC(c);\n\n\tc->parent.credtype = GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\tc->parent.free = plaintext_free;\n\tc->username = git__strdup(username);\n\n\tif (!c->username) {\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\tc->password = git__strdup(password);\n\n\tif (!c->password) {\n\t\tgit__free(c->username);\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\t*cred = &c->parent;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_default_credentials",
          "args": [
            "s->request"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "apply_default_credentials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "144-158",
          "snippet": "static int apply_default_credentials(HINTERNET request)\n{\n\t/* Either the caller explicitly requested that default credentials be passed,\n\t * or our fallback credential callback was invoked and checked that the target\n\t * URI was in the appropriate Internet Explorer security zone. By setting this\n\t * flag, we guarantee that the credentials are delivered by WinHTTP. The default\n\t * is \"medium\" which applies to the intranet and sounds like it would correspond\n\t * to Internet Explorer security zones, but in fact does not. */\n\tDWORD data = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;\n\n\tif (!WinHttpSetOption(request, WINHTTP_OPTION_AUTOLOGON_POLICY, &data, sizeof(DWORD)))\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int apply_default_credentials(HINTERNET request)\n{\n\t/* Either the caller explicitly requested that default credentials be passed,\n\t * or our fallback credential callback was invoked and checked that the target\n\t * URI was in the appropriate Internet Explorer security zone. By setting this\n\t * flag, we guarantee that the credentials are delivered by WinHTTP. The default\n\t * is \"medium\" which applies to the intranet and sounds like it would correspond\n\t * to Internet Explorer security zones, but in fact does not. */\n\tDWORD data = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;\n\n\tif (!WinHttpSetOption(request, WINHTTP_OPTION_AUTOLOGON_POLICY, &data, sizeof(DWORD)))\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->owner->parent.read_flags",
          "args": [
            "&t->owner->parent",
            "&flags"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to add a header to the request\""
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpAddRequestHeaders",
          "args": [
            "s->request",
            "ct",
            "(ULONG)-1L",
            "WINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__utf8_to_16",
          "args": [
            "ct",
            "MAX_CONTENT_TYPE_LEN",
            "git_buf_cstr(&buf)"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf8_to_16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "27-38",
          "snippet": "int git__utf8_to_16(wchar_t *dest, size_t dest_size, const char *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t* turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t* length. MultiByteToWideChar never returns int's minvalue, so underflow is not possible */\n\tif ((len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf8_to_16(wchar_t *dest, size_t dest_size, const char *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t* turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t* length. MultiByteToWideChar never returns int's minvalue, so underflow is not possible */\n\tif ((len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&buf",
            "t->owner->custom_headers.strings[i]"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&buf"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpAddRequestHeaders",
          "args": [
            "s->request",
            "ct",
            "(ULONG)-1L",
            "WINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"Accept: application/x-git-%s-result\"",
            "s->service"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpAddRequestHeaders",
          "args": [
            "s->request",
            "ct",
            "(ULONG)-1L",
            "WINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpAddRequestHeaders",
          "args": [
            "s->request",
            "pragma_nocache",
            "(ULONG) -1L",
            "WINHTTP_ADDREQ_FLAG_ADD"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpSetOption",
          "args": [
            "s->request",
            "WINHTTP_OPTION_PEERDIST_EXTENSION_STATE",
            "&peerdist",
            "sizeof(peerdist)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpSetOption",
          "args": [
            "s->request",
            "WINHTTP_OPTION_DISABLE_FEATURE",
            "&disable_redirects",
            "sizeof(disable_redirects)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpSetOption",
          "args": [
            "s->request",
            "WINHTTP_OPTION_PROXY",
            "&proxy_info",
            "sizeof(WINHTTP_PROXY_INFO)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__utf8_to_16_alloc",
          "args": [
            "&proxy_wide",
            "proxy_url"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf8_to_16_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "70-102",
          "snippet": "int git__utf8_to_16_alloc(wchar_t **dest, const char *src)\n{\n\tint utf16_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, NULL, 0);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\tif (!(*dest = git__mallocarray(utf16_size, sizeof(wchar_t)))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, *dest, utf16_size);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf16_size - 1;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf8_to_16_alloc(wchar_t **dest, const char *src)\n{\n\tint utf16_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, NULL, 0);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\tif (!(*dest = git__mallocarray(utf16_size, sizeof(wchar_t)))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, *dest, utf16_size);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf16_size - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__get_http_proxy",
          "args": [
            "t->owner->owner",
            "!!t->connection_data.use_ssl",
            "&proxy_url"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__get_http_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "769-836",
          "snippet": "int git_remote__get_http_proxy(git_remote *remote, bool use_ssl, char **proxy_url)\n{\n\tgit_config *cfg;\n\tgit_config_entry *ce = NULL;\n\tgit_buf val = GIT_BUF_INIT;\n\tint error;\n\n\tassert(remote);\n\n\tif (!proxy_url || !remote->repo)\n\t\treturn -1;\n\n\t*proxy_url = NULL;\n\n\tif ((error = git_repository_config__weakptr(&cfg, remote->repo)) < 0)\n\t\treturn error;\n\n\t/* Go through the possible sources for proxy configuration, from most specific\n\t * to least specific. */\n\n\t/* remote.<name>.proxy config setting */\n\tif (remote->name && remote->name[0]) {\n\t\tgit_buf buf = GIT_BUF_INIT;\n\n\t\tif ((error = git_buf_printf(&buf, \"remote.%s.proxy\", remote->name)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\t\tgit_buf_free(&buf);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ce && ce->value) {\n\t\t\t*proxy_url = git__strdup(ce->value);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* http.proxy config setting */\n\tif ((error = git_config__lookup_entry(&ce, cfg, \"http.proxy\", false)) < 0)\n\t\treturn error;\n\n\tif (ce && ce->value) {\n\t\t*proxy_url = git__strdup(ce->value);\n\t\tgoto found;\n\t}\n\n\t/* HTTP_PROXY / HTTPS_PROXY environment variables */\n\terror = git__getenv(&val, use_ssl ? \"HTTPS_PROXY\" : \"HTTP_PROXY\");\n\n\tif (error < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\treturn error;\n\t}\n\n\t*proxy_url = git_buf_detach(&val);\n\nfound:\n\tGITERR_CHECK_ALLOC(*proxy_url);\n\tgit_config_entry_free(ce);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote__get_http_proxy(git_remote *remote, bool use_ssl, char **proxy_url)\n{\n\tgit_config *cfg;\n\tgit_config_entry *ce = NULL;\n\tgit_buf val = GIT_BUF_INIT;\n\tint error;\n\n\tassert(remote);\n\n\tif (!proxy_url || !remote->repo)\n\t\treturn -1;\n\n\t*proxy_url = NULL;\n\n\tif ((error = git_repository_config__weakptr(&cfg, remote->repo)) < 0)\n\t\treturn error;\n\n\t/* Go through the possible sources for proxy configuration, from most specific\n\t * to least specific. */\n\n\t/* remote.<name>.proxy config setting */\n\tif (remote->name && remote->name[0]) {\n\t\tgit_buf buf = GIT_BUF_INIT;\n\n\t\tif ((error = git_buf_printf(&buf, \"remote.%s.proxy\", remote->name)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\t\tgit_buf_free(&buf);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ce && ce->value) {\n\t\t\t*proxy_url = git__strdup(ce->value);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* http.proxy config setting */\n\tif ((error = git_config__lookup_entry(&ce, cfg, \"http.proxy\", false)) < 0)\n\t\treturn error;\n\n\tif (ce && ce->value) {\n\t\t*proxy_url = git__strdup(ce->value);\n\t\tgoto found;\n\t}\n\n\t/* HTTP_PROXY / HTTPS_PROXY environment variables */\n\terror = git__getenv(&val, use_ssl ? \"HTTPS_PROXY\" : \"HTTP_PROXY\");\n\n\tif (error < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\treturn error;\n\t}\n\n\t*proxy_url = git_buf_detach(&val);\n\nfound:\n\tGITERR_CHECK_ALLOC(*proxy_url);\n\tgit_config_entry_free(ce);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpSetTimeouts",
          "args": [
            "s->request",
            "default_timeout",
            "default_connect_timeout",
            "default_timeout",
            "default_timeout"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WinHttpOpenRequest",
          "args": [
            "t->connection",
            "s->verb",
            "s->request_uri",
            "NULL",
            "WINHTTP_NO_REFERER",
            "types",
            "t->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&buf"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OWNING_SUBTRANSPORT",
          "args": [
            "s"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\n#define DEFAULT_CONNECT_TIMEOUT 60000\n#define TIMEOUT_INFINITE -1\n#define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE\t109\n#define MAX_CONTENT_TYPE_LEN\t100\n\nstatic int winhttp_stream_connect(winhttp_stream *s)\n{\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf buf = GIT_BUF_INIT;\n\tchar *proxy_url = NULL;\n\twchar_t ct[MAX_CONTENT_TYPE_LEN];\n\tLPCWSTR types[] = { L\"*/*\", NULL };\n\tBOOL peerdist = FALSE;\n\tint error = -1;\n\tunsigned long disable_redirects = WINHTTP_DISABLE_REDIRECTS;\n\tint default_timeout = TIMEOUT_INFINITE;\n\tint default_connect_timeout = DEFAULT_CONNECT_TIMEOUT;\n\tsize_t i;\n\n\t/* Prepare URL */\n\tgit_buf_printf(&buf, \"%s%s\", t->connection_data.path, s->service_url);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\t/* Convert URL to wide characters */\n\tif (git__utf8_to_16_alloc(&s->request_uri, git_buf_cstr(&buf)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\t/* Establish request */\n\ts->request = WinHttpOpenRequest(\n\t\t\tt->connection,\n\t\t\ts->verb,\n\t\t\ts->request_uri,\n\t\t\tNULL,\n\t\t\tWINHTTP_NO_REFERER,\n\t\t\ttypes,\n\t\t\tt->connection_data.use_ssl ? WINHTTP_FLAG_SECURE : 0);\n\n\tif (!s->request) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open request\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpSetTimeouts(s->request, default_timeout, default_connect_timeout, default_timeout, default_timeout)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to set timeouts for WinHTTP\");\n\t\tgoto on_error;\n\t}\n\n\t/* Set proxy if necessary */\n\tif (git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url) < 0)\n\t\tgoto on_error;\n\n\tif (proxy_url) {\n\t\tWINHTTP_PROXY_INFO proxy_info;\n\t\twchar_t *proxy_wide;\n\n\t\t/* Convert URL to wide characters */\n\t\tint proxy_wide_len = git__utf8_to_16_alloc(&proxy_wide, proxy_url);\n\n\t\tif (proxy_wide_len < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Strip any trailing forward slash on the proxy URL;\n\t\t * WinHTTP doesn't like it if one is present */\n\t\tif (proxy_wide_len > 1 && L'/' == proxy_wide[proxy_wide_len - 2])\n\t\t\tproxy_wide[proxy_wide_len - 2] = L'\\0';\n\n\t\tproxy_info.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;\n\t\tproxy_info.lpszProxy = proxy_wide;\n\t\tproxy_info.lpszProxyBypass = NULL;\n\n\t\tif (!WinHttpSetOption(s->request,\n\t\t\tWINHTTP_OPTION_PROXY,\n\t\t\t&proxy_info,\n\t\t\tsizeof(WINHTTP_PROXY_INFO))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to set proxy\");\n\t\t\tgit__free(proxy_wide);\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit__free(proxy_wide);\n\t}\n\n\t/* Disable WinHTTP redirects so we can handle them manually. Why, you ask?\n\t * http://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/b2ff8879-ab9f-4218-8f09-16d25dff87ae\n\t */\n\tif (!WinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_DISABLE_FEATURE,\n\t\t&disable_redirects,\n\t\tsizeof(disable_redirects))) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to disable redirects\");\n\t\t\tgoto on_error;\n\t}\n\n\t/* Strip unwanted headers (X-P2P-PeerDist, X-P2P-PeerDistEx) that WinHTTP\n\t * adds itself. This option may not be supported by the underlying\n\t * platform, so we do not error-check it */\n\tWinHttpSetOption(s->request,\n\t\tWINHTTP_OPTION_PEERDIST_EXTENSION_STATE,\n\t\t&peerdist,\n\t\tsizeof(peerdist));\n\n\t/* Send Pragma: no-cache header */\n\tif (!WinHttpAddRequestHeaders(s->request, pragma_nocache, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_verb == s->verb) {\n\t\t/* Send Content-Type and Accept headers -- only necessary on a POST */\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Content-Type: application/x-git-%s-request\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert content-type to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf,\n\t\t\t\"Accept: application/x-git-%s-result\",\n\t\t\ts->service) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert accept header to wide characters\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i]) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_puts(&buf, t->owner->custom_headers.strings[i]);\n\t\t\tif (git__utf8_to_16(ct, MAX_CONTENT_TYPE_LEN, git_buf_cstr(&buf)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to convert custom header to wide characters\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (!WinHttpAddRequestHeaders(s->request, ct, (ULONG)-1L,\n\t\t\t\tWINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE)) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If requested, disable certificate validation */\n\tif (t->connection_data.use_ssl) {\n\t\tint flags;\n\n\t\tif (t->owner->parent.read_flags(&t->owner->parent, &flags) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* If we have a credential on the subtransport, apply it to the request */\n\tif (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_USERPASS_PLAINTEXT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_BASIC &&\n\t\tapply_basic_credential(s->request, t->cred) < 0)\n\t\tgoto on_error;\n\telse if (t->cred &&\n\t\tt->cred->credtype == GIT_CREDTYPE_DEFAULT &&\n\t\tt->auth_mechanism == GIT_WINHTTP_AUTH_NEGOTIATE &&\n\t\tapply_default_credentials(s->request) < 0)\n\t\tgoto on_error;\n\n\t/* If no other credentials have been applied and the URL has username and\n\t * password, use those */\n\tif (!t->cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred, t->connection_data.user, t->connection_data.pass) < 0)\n\t\t\tgoto on_error;\n\t\tif (apply_basic_credential(s->request, t->url_cred) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* We've done everything up to calling WinHttpSendRequest. */\n\n\terror = 0;\n\non_error:\n\tif (error < 0)\n\t\twinhttp_stream_close(s);\n\n\tgit__free(proxy_url);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
  },
  {
    "function_name": "winhttp_stream_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "249-272",
    "snippet": "static void winhttp_stream_close(winhttp_stream *s)\n{\n\tif (s->chunk_buffer) {\n\t\tgit__free(s->chunk_buffer);\n\t\ts->chunk_buffer = NULL;\n\t}\n\n\tif (s->post_body) {\n\t\tCloseHandle(s->post_body);\n\t\ts->post_body = NULL;\n\t}\n\n\tif (s->request_uri) {\n\t\tgit__free(s->request_uri);\n\t\ts->request_uri = NULL;\n\t}\n\n\tif (s->request) {\n\t\tWinHttpCloseHandle(s->request);\n\t\ts->request = NULL;\n\t}\n\n\ts->sent_request = 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WinHttpCloseHandle",
          "args": [
            "s->request"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "s->request_uri"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "s->post_body"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic void winhttp_stream_close(winhttp_stream *s)\n{\n\tif (s->chunk_buffer) {\n\t\tgit__free(s->chunk_buffer);\n\t\ts->chunk_buffer = NULL;\n\t}\n\n\tif (s->post_body) {\n\t\tCloseHandle(s->post_body);\n\t\ts->post_body = NULL;\n\t}\n\n\tif (s->request_uri) {\n\t\tgit__free(s->request_uri);\n\t\ts->request_uri = NULL;\n\t}\n\n\tif (s->request) {\n\t\tWinHttpCloseHandle(s->request);\n\t\ts->request = NULL;\n\t}\n\n\ts->sent_request = 0;\n}"
  },
  {
    "function_name": "certificate_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "216-247",
    "snippet": "static int certificate_check(winhttp_stream *s, int valid)\n{\n\tint error;\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tPCERT_CONTEXT cert_ctx;\n\tDWORD cert_ctx_size = sizeof(cert_ctx);\n\tgit_cert_x509 cert;\n\n\t/* If there is no override, we should fail if WinHTTP doesn't think it's fine */\n\tif (t->owner->certificate_check_cb == NULL && !valid)\n\t\treturn GIT_ECERTIFICATE;\n\n\tif (t->owner->certificate_check_cb == NULL || !t->connection_data.use_ssl)\n\t\treturn 0;\n\n\tif (!WinHttpQueryOption(s->request, WINHTTP_OPTION_SERVER_CERT_CONTEXT, &cert_ctx, &cert_ctx_size)) {\n\t\tgiterr_set(GITERR_OS, \"failed to get server certificate\");\n\t\treturn -1;\n\t}\n\n\tgiterr_clear();\n\tcert.parent.cert_type = GIT_CERT_X509;\n\tcert.data = cert_ctx->pbCertEncoded;\n\tcert.len = cert_ctx->cbCertEncoded;\n\terror = t->owner->certificate_check_cb((git_cert *) &cert, valid, t->connection_data.host, t->owner->cred_acquire_payload);\n\tCertFreeCertificateContext(cert_ctx);\n\n\tif (error < 0 && !giterr_last())\n\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\treturn error;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"user cancelled certificate check\""
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_last",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "134-137",
          "snippet": "const git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CertFreeCertificateContext",
          "args": [
            "cert_ctx"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->owner->certificate_check_cb",
          "args": [
            "(git_cert *) &cert",
            "valid",
            "t->connection_data.host",
            "t->owner->cred_acquire_payload"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpQueryOption",
          "args": [
            "s->request",
            "WINHTTP_OPTION_SERVER_CERT_CONTEXT",
            "&cert_ctx",
            "&cert_ctx_size"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWNING_SUBTRANSPORT",
          "args": [
            "s"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int certificate_check(winhttp_stream *s, int valid)\n{\n\tint error;\n\twinhttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tPCERT_CONTEXT cert_ctx;\n\tDWORD cert_ctx_size = sizeof(cert_ctx);\n\tgit_cert_x509 cert;\n\n\t/* If there is no override, we should fail if WinHTTP doesn't think it's fine */\n\tif (t->owner->certificate_check_cb == NULL && !valid)\n\t\treturn GIT_ECERTIFICATE;\n\n\tif (t->owner->certificate_check_cb == NULL || !t->connection_data.use_ssl)\n\t\treturn 0;\n\n\tif (!WinHttpQueryOption(s->request, WINHTTP_OPTION_SERVER_CERT_CONTEXT, &cert_ctx, &cert_ctx_size)) {\n\t\tgiterr_set(GITERR_OS, \"failed to get server certificate\");\n\t\treturn -1;\n\t}\n\n\tgiterr_clear();\n\tcert.parent.cert_type = GIT_CERT_X509;\n\tcert.data = cert_ctx->pbCertEncoded;\n\tcert.len = cert_ctx->cbCertEncoded;\n\terror = t->owner->certificate_check_cb((git_cert *) &cert, valid, t->connection_data.host, t->owner->cred_acquire_payload);\n\tCertFreeCertificateContext(cert_ctx);\n\n\tif (error < 0 && !giterr_last())\n\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "fallback_cred_acquire_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "160-214",
    "snippet": "static int fallback_cred_acquire_cb(\n\tgit_cred **cred,\n\tconst char *url,\n\tconst char *username_from_url,\n\tunsigned int allowed_types,\n\tvoid *payload)\n{\n\tint error = 1;\n\n\tGIT_UNUSED(username_from_url);\n\tGIT_UNUSED(payload);\n\n\t/* If the target URI supports integrated Windows authentication\n\t * as an authentication mechanism */\n\tif (GIT_CREDTYPE_DEFAULT & allowed_types) {\n\t\twchar_t *wide_url;\n\n\t\t/* Convert URL to wide characters */\n\t\tif (git__utf8_to_16_alloc(&wide_url, url) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED))) {\n\t\t\tIInternetSecurityManager* pISM;\n\n\t\t\t/* And if the target URI is in the My Computer, Intranet, or Trusted zones */\n\t\t\tif (SUCCEEDED(CoCreateInstance(&CLSID_InternetSecurityManager, NULL,\n\t\t\t\tCLSCTX_ALL, &IID_IInternetSecurityManager, (void **)&pISM))) {\n\t\t\t\tDWORD dwZone;\n\n\t\t\t\tif (SUCCEEDED(pISM->lpVtbl->MapUrlToZone(pISM, wide_url, &dwZone, 0)) &&\n\t\t\t\t\t(URLZONE_LOCAL_MACHINE == dwZone ||\n\t\t\t\t\tURLZONE_INTRANET == dwZone ||\n\t\t\t\t\tURLZONE_TRUSTED == dwZone)) {\n\t\t\t\t\tgit_cred *existing = *cred;\n\n\t\t\t\t\tif (existing)\n\t\t\t\t\t\texisting->free(existing);\n\n\t\t\t\t\t/* Then use default Windows credentials to authenticate this request */\n\t\t\t\t\terror = git_cred_default_new(cred);\n\t\t\t\t}\n\n\t\t\t\tpISM->lpVtbl->Release(pISM);\n\t\t\t}\n\n\t\t\tCoUninitialize();\n\t\t}\n\n\t\tgit__free(wide_url);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "wide_url"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CoUninitialize",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pISM->lpVtbl->Release",
          "args": [
            "pISM"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_cred_default_new",
          "args": [
            "cred"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "git_cred_default_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/cred.c",
          "lines": "344-358",
          "snippet": "int git_cred_default_new(git_cred **cred)\n{\n\tgit_cred_default *c;\n\n\tassert(cred);\n\n\tc = git__calloc(1, sizeof(git_cred_default));\n\tGITERR_CHECK_ALLOC(c);\n\n\tc->credtype = GIT_CREDTYPE_DEFAULT;\n\tc->free = default_free;\n\n\t*cred = c;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/cred_helpers.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/cred_helpers.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);\n\nint git_cred_default_new(git_cred **cred)\n{\n\tgit_cred_default *c;\n\n\tassert(cred);\n\n\tc = git__calloc(1, sizeof(git_cred_default));\n\tGITERR_CHECK_ALLOC(c);\n\n\tc->credtype = GIT_CREDTYPE_DEFAULT;\n\tc->free = default_free;\n\n\t*cred = c;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "existing->free",
          "args": [
            "existing"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SUCCEEDED",
          "args": [
            "pISM->lpVtbl->MapUrlToZone(pISM, wide_url, &dwZone, 0)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pISM->lpVtbl->MapUrlToZone",
          "args": [
            "pISM",
            "wide_url",
            "&dwZone",
            "0"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SUCCEEDED",
          "args": [
            "CoCreateInstance(&CLSID_InternetSecurityManager, NULL,\n\t\t\t\tCLSCTX_ALL, &IID_IInternetSecurityManager, (void **)&pISM)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CoCreateInstance",
          "args": [
            "&CLSID_InternetSecurityManager",
            "NULL",
            "CLSCTX_ALL",
            "&IID_IInternetSecurityManager",
            "(void **)&pISM"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SUCCEEDED",
          "args": [
            "CoInitializeEx(NULL, COINIT_MULTITHREADED)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CoInitializeEx",
          "args": [
            "NULL",
            "COINIT_MULTITHREADED"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to convert string to wide form\""
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__utf8_to_16_alloc",
          "args": [
            "&wide_url",
            "url"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf8_to_16_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "70-102",
          "snippet": "int git__utf8_to_16_alloc(wchar_t **dest, const char *src)\n{\n\tint utf16_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, NULL, 0);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\tif (!(*dest = git__mallocarray(utf16_size, sizeof(wchar_t)))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, *dest, utf16_size);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf16_size - 1;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf8_to_16_alloc(wchar_t **dest, const char *src)\n{\n\tint utf16_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, NULL, 0);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\tif (!(*dest = git__mallocarray(utf16_size, sizeof(wchar_t)))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, *dest, utf16_size);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf16_size - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "username_from_url"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int fallback_cred_acquire_cb(\n\tgit_cred **cred,\n\tconst char *url,\n\tconst char *username_from_url,\n\tunsigned int allowed_types,\n\tvoid *payload)\n{\n\tint error = 1;\n\n\tGIT_UNUSED(username_from_url);\n\tGIT_UNUSED(payload);\n\n\t/* If the target URI supports integrated Windows authentication\n\t * as an authentication mechanism */\n\tif (GIT_CREDTYPE_DEFAULT & allowed_types) {\n\t\twchar_t *wide_url;\n\n\t\t/* Convert URL to wide characters */\n\t\tif (git__utf8_to_16_alloc(&wide_url, url) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED))) {\n\t\t\tIInternetSecurityManager* pISM;\n\n\t\t\t/* And if the target URI is in the My Computer, Intranet, or Trusted zones */\n\t\t\tif (SUCCEEDED(CoCreateInstance(&CLSID_InternetSecurityManager, NULL,\n\t\t\t\tCLSCTX_ALL, &IID_IInternetSecurityManager, (void **)&pISM))) {\n\t\t\t\tDWORD dwZone;\n\n\t\t\t\tif (SUCCEEDED(pISM->lpVtbl->MapUrlToZone(pISM, wide_url, &dwZone, 0)) &&\n\t\t\t\t\t(URLZONE_LOCAL_MACHINE == dwZone ||\n\t\t\t\t\tURLZONE_INTRANET == dwZone ||\n\t\t\t\t\tURLZONE_TRUSTED == dwZone)) {\n\t\t\t\t\tgit_cred *existing = *cred;\n\n\t\t\t\t\tif (existing)\n\t\t\t\t\t\texisting->free(existing);\n\n\t\t\t\t\t/* Then use default Windows credentials to authenticate this request */\n\t\t\t\t\terror = git_cred_default_new(cred);\n\t\t\t\t}\n\n\t\t\t\tpISM->lpVtbl->Release(pISM);\n\t\t\t}\n\n\t\t\tCoUninitialize();\n\t\t}\n\n\t\tgit__free(wide_url);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "apply_default_credentials",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "144-158",
    "snippet": "static int apply_default_credentials(HINTERNET request)\n{\n\t/* Either the caller explicitly requested that default credentials be passed,\n\t * or our fallback credential callback was invoked and checked that the target\n\t * URI was in the appropriate Internet Explorer security zone. By setting this\n\t * flag, we guarantee that the credentials are delivered by WinHTTP. The default\n\t * is \"medium\" which applies to the intranet and sounds like it would correspond\n\t * to Internet Explorer security zones, but in fact does not. */\n\tDWORD data = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;\n\n\tif (!WinHttpSetOption(request, WINHTTP_OPTION_AUTOLOGON_POLICY, &data, sizeof(DWORD)))\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WinHttpSetOption",
          "args": [
            "request",
            "WINHTTP_OPTION_AUTOLOGON_POLICY",
            "&data",
            "sizeof(DWORD)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int apply_default_credentials(HINTERNET request)\n{\n\t/* Either the caller explicitly requested that default credentials be passed,\n\t * or our fallback credential callback was invoked and checked that the target\n\t * URI was in the appropriate Internet Explorer security zone. By setting this\n\t * flag, we guarantee that the credentials are delivered by WinHTTP. The default\n\t * is \"medium\" which applies to the intranet and sounds like it would correspond\n\t * to Internet Explorer security zones, but in fact does not. */\n\tDWORD data = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;\n\n\tif (!WinHttpSetOption(request, WINHTTP_OPTION_AUTOLOGON_POLICY, &data, sizeof(DWORD)))\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "apply_basic_credential",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
    "lines": "101-142",
    "snippet": "static int apply_basic_credential(HINTERNET request, git_cred *cred)\n{\n\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *)cred;\n\tgit_buf buf = GIT_BUF_INIT, raw = GIT_BUF_INIT;\n\twchar_t *wide = NULL;\n\tint error = -1, wide_len;\n\n\tgit_buf_printf(&raw, \"%s:%s\", c->username, c->password);\n\n\tif (git_buf_oom(&raw) ||\n\t\tgit_buf_puts(&buf, \"Authorization: Basic \") < 0 ||\n\t\tgit_buf_encode_base64(&buf, git_buf_cstr(&raw), raw.size) < 0)\n\t\tgoto on_error;\n\n\tif ((wide_len = git__utf8_to_16_alloc(&wide, git_buf_cstr(&buf))) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpAddRequestHeaders(request, wide, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\t/* We were dealing with plaintext passwords, so clean up after ourselves a bit. */\n\tif (wide)\n\t\tmemset(wide, 0x0, wide_len * sizeof(wchar_t));\n\n\tif (buf.size)\n\t\tmemset(buf.ptr, 0x0, buf.size);\n\n\tif (raw.size)\n\t\tmemset(raw.ptr, 0x0, raw.size);\n\n\tgit__free(wide);\n\tgit_buf_free(&buf);\n\tgit_buf_free(&raw);\n\treturn error;\n}",
    "includes": [
      "#include <urlmon.h>",
      "#include <objbase.h>",
      "#include <winhttp.h>",
      "#include <wincrypt.h>",
      "#include \"global.h\"",
      "#include \"repository.h\"",
      "#include \"remote.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&raw"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "wide"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "raw.ptr",
            "0x0",
            "raw.size"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf.ptr",
            "0x0",
            "buf.size"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "wide",
            "0x0",
            "wide_len * sizeof(wchar_t)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to add a header to the request\""
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinHttpAddRequestHeaders",
          "args": [
            "request",
            "wide",
            "(ULONG) -1L",
            "WINHTTP_ADDREQ_FLAG_ADD"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__utf8_to_16_alloc",
          "args": [
            "&wide",
            "git_buf_cstr(&buf)"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf8_to_16_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "70-102",
          "snippet": "int git__utf8_to_16_alloc(wchar_t **dest, const char *src)\n{\n\tint utf16_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, NULL, 0);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\tif (!(*dest = git__mallocarray(utf16_size, sizeof(wchar_t)))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, *dest, utf16_size);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf16_size - 1;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf8_to_16_alloc(wchar_t **dest, const char *src)\n{\n\tint utf16_size;\n\n\t*dest = NULL;\n\n\t/* Length of -1 indicates NULL termination of the input string */\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, NULL, 0);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\t\treturn -1;\n\t}\n\n\tif (!(*dest = git__mallocarray(utf16_size, sizeof(wchar_t)))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tutf16_size = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, *dest, utf16_size);\n\n\tif (!utf16_size) {\n\t\tgit__set_errno();\n\n\t\tgit__free(*dest);\n\t\t*dest = NULL;\n\t}\n\n\t/* Subtract 1 from the result to turn 0 into -1 (an error code) and to not count the NULL\n\t * terminator as part of the string's length. MultiByteToWideChar never returns int's minvalue,\n\t * so underflow is not possible */\n\treturn utf16_size - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_encode_base64",
          "args": [
            "&buf",
            "git_buf_cstr(&raw)",
            "raw.size"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_encode_base64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "234-274",
          "snippet": "int git_buf_encode_base64(git_buf *buf, const char *data, size_t len)\n{\n\tsize_t extra = len % 3;\n\tuint8_t *write, a, b, c;\n\tconst uint8_t *read = (const uint8_t *)data;\n\tsize_t blocks = (len / 3) + !!extra, alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&blocks, blocks, 1);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, blocks, 4);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, buf->size);\n\n\tENSURE_SIZE(buf, alloclen);\n\twrite = (uint8_t *)&buf->ptr[buf->size];\n\n\t/* convert each run of 3 bytes into 4 output bytes */\n\tfor (len -= extra; len > 0; len -= 3) {\n\t\ta = *read++;\n\t\tb = *read++;\n\t\tc = *read++;\n\n\t\t*write++ = base64_encode[a >> 2];\n\t\t*write++ = base64_encode[(a & 0x03) << 4 | b >> 4];\n\t\t*write++ = base64_encode[(b & 0x0f) << 2 | c >> 6];\n\t\t*write++ = base64_encode[c & 0x3f];\n\t}\n\n\tif (extra > 0) {\n\t\ta = *read++;\n\t\tb = (extra > 1) ? *read++ : 0;\n\n\t\t*write++ = base64_encode[a >> 2];\n\t\t*write++ = base64_encode[(a & 0x03) << 4 | b >> 4];\n\t\t*write++ = (extra > 1) ? base64_encode[(b & 0x0f) << 2] : '=';\n\t\t*write++ = '=';\n\t}\n\n\tbuf->size = ((char *)write) - buf->ptr;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char base64_encode[] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nstatic const char base64_encode[] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nint git_buf_encode_base64(git_buf *buf, const char *data, size_t len)\n{\n\tsize_t extra = len % 3;\n\tuint8_t *write, a, b, c;\n\tconst uint8_t *read = (const uint8_t *)data;\n\tsize_t blocks = (len / 3) + !!extra, alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&blocks, blocks, 1);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, blocks, 4);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, buf->size);\n\n\tENSURE_SIZE(buf, alloclen);\n\twrite = (uint8_t *)&buf->ptr[buf->size];\n\n\t/* convert each run of 3 bytes into 4 output bytes */\n\tfor (len -= extra; len > 0; len -= 3) {\n\t\ta = *read++;\n\t\tb = *read++;\n\t\tc = *read++;\n\n\t\t*write++ = base64_encode[a >> 2];\n\t\t*write++ = base64_encode[(a & 0x03) << 4 | b >> 4];\n\t\t*write++ = base64_encode[(b & 0x0f) << 2 | c >> 6];\n\t\t*write++ = base64_encode[c & 0x3f];\n\t}\n\n\tif (extra > 0) {\n\t\ta = *read++;\n\t\tb = (extra > 1) ? *read++ : 0;\n\n\t\t*write++ = base64_encode[a >> 2];\n\t\t*write++ = base64_encode[(a & 0x03) << 4 | b >> 4];\n\t\t*write++ = (extra > 1) ? base64_encode[(b & 0x0f) << 2] : '=';\n\t\t*write++ = '=';\n\t}\n\n\tbuf->size = ((char *)write) - buf->ptr;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&buf",
            "\"Authorization: Basic \""
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&raw"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&raw",
            "\"%s:%s\"",
            "c->username",
            "c->password"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int apply_basic_credential(HINTERNET request, git_cred *cred)\n{\n\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *)cred;\n\tgit_buf buf = GIT_BUF_INIT, raw = GIT_BUF_INIT;\n\twchar_t *wide = NULL;\n\tint error = -1, wide_len;\n\n\tgit_buf_printf(&raw, \"%s:%s\", c->username, c->password);\n\n\tif (git_buf_oom(&raw) ||\n\t\tgit_buf_puts(&buf, \"Authorization: Basic \") < 0 ||\n\t\tgit_buf_encode_base64(&buf, git_buf_cstr(&raw), raw.size) < 0)\n\t\tgoto on_error;\n\n\tif ((wide_len = git__utf8_to_16_alloc(&wide, git_buf_cstr(&buf))) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\tgoto on_error;\n\t}\n\n\tif (!WinHttpAddRequestHeaders(request, wide, (ULONG) -1L, WINHTTP_ADDREQ_FLAG_ADD)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to add a header to the request\");\n\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\t/* We were dealing with plaintext passwords, so clean up after ourselves a bit. */\n\tif (wide)\n\t\tmemset(wide, 0x0, wide_len * sizeof(wchar_t));\n\n\tif (buf.size)\n\t\tmemset(buf.ptr, 0x0, buf.size);\n\n\tif (raw.size)\n\t\tmemset(raw.ptr, 0x0, raw.size);\n\n\tgit__free(wide);\n\tgit_buf_free(&buf);\n\tgit_buf_free(&raw);\n\treturn error;\n}"
  }
]