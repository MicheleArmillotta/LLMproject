[
  {
    "function_name": "git_graph_descendant_of",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/graph.c",
    "lines": "175-192",
    "snippet": "int git_graph_descendant_of(git_repository *repo, const git_oid *commit, const git_oid *ancestor)\n{\n\tgit_oid merge_base;\n\tint error;\n\n\tif (git_oid_equal(commit, ancestor))\n\t\treturn 0;\n\n\terror = git_merge_base(&merge_base, repo, commit, ancestor);\n\t/* No merge-base found, it's not a descendant */\n\tif (error == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (error < 0)\n\t\treturn error;\n\n\treturn git_oid_equal(&merge_base, ancestor);\n}",
    "includes": [
      "#include \"git2/graph.h\"",
      "#include \"merge.h\"",
      "#include \"revwalk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "&merge_base",
            "ancestor"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge_base",
          "args": [
            "&merge_base",
            "repo",
            "commit",
            "ancestor"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_bases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "273-305",
          "snippet": "int git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n        git_revwalk *walk;\n\tgit_commit_list *result, *list;\n\tgit_array_oid_t array;\n\n\tgit_array_init(array);\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n        git_revwalk *walk;\n\tgit_commit_list *result, *list;\n\tgit_array_oid_t array;\n\n\tgit_array_init(array);\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/graph.h\"\n#include \"merge.h\"\n#include \"revwalk.h\"\n\nint git_graph_descendant_of(git_repository *repo, const git_oid *commit, const git_oid *ancestor)\n{\n\tgit_oid merge_base;\n\tint error;\n\n\tif (git_oid_equal(commit, ancestor))\n\t\treturn 0;\n\n\terror = git_merge_base(&merge_base, repo, commit, ancestor);\n\t/* No merge-base found, it's not a descendant */\n\tif (error == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (error < 0)\n\t\treturn error;\n\n\treturn git_oid_equal(&merge_base, ancestor);\n}"
  },
  {
    "function_name": "git_graph_ahead_behind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/graph.c",
    "lines": "144-173",
    "snippet": "int git_graph_ahead_behind(size_t *ahead, size_t *behind, git_repository *repo,\n\tconst git_oid *local, const git_oid *upstream)\n{\n\tgit_revwalk *walk;\n\tgit_commit_list_node *commit_u, *commit_l;\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\treturn -1;\n\n\tcommit_u = git_revwalk__commit_lookup(walk, upstream);\n\tif (commit_u == NULL)\n\t\tgoto on_error;\n\n\tcommit_l = git_revwalk__commit_lookup(walk, local);\n\tif (commit_l == NULL)\n\t\tgoto on_error;\n\n\tif (mark_parents(walk, commit_l, commit_u) < 0)\n\t\tgoto on_error;\n\tif (ahead_behind(commit_l, commit_u, ahead, behind) < 0)\n\t\tgoto on_error;\n\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/graph.h\"",
      "#include \"merge.h\"",
      "#include \"revwalk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahead_behind",
          "args": [
            "commit_l",
            "commit_u",
            "ahead",
            "behind"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ahead_behind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/graph.c",
          "lines": "106-142",
          "snippet": "static int ahead_behind(git_commit_list_node *one, git_commit_list_node *two,\n\tsize_t *ahead, size_t *behind)\n{\n\tgit_commit_list_node *commit;\n\tgit_pqueue pq;\n\tint error = 0, i;\n\t*ahead = 0;\n\t*behind = 0;\n\n\tif (git_pqueue_init(&pq, 0, 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tif ((error = git_pqueue_insert(&pq, one)) < 0 ||\n\t\t(error = git_pqueue_insert(&pq, two)) < 0)\n\t\tgoto done;\n\n\twhile ((commit = git_pqueue_pop(&pq)) != NULL) {\n\t\tif (commit->flags & RESULT ||\n\t\t\t(commit->flags & (PARENT1 | PARENT2)) == (PARENT1 | PARENT2))\n\t\t\tcontinue;\n\t\telse if (commit->flags & PARENT1)\n\t\t\t(*ahead)++;\n\t\telse if (commit->flags & PARENT2)\n\t\t\t(*behind)++;\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((error = git_pqueue_insert(&pq, p)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t\tcommit->flags |= RESULT;\n\t}\n\ndone:\n\tgit_pqueue_free(&pq);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/graph.h\"",
            "#include \"merge.h\"",
            "#include \"revwalk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/graph.h\"\n#include \"merge.h\"\n#include \"revwalk.h\"\n\nstatic int ahead_behind(git_commit_list_node *one, git_commit_list_node *two,\n\tsize_t *ahead, size_t *behind)\n{\n\tgit_commit_list_node *commit;\n\tgit_pqueue pq;\n\tint error = 0, i;\n\t*ahead = 0;\n\t*behind = 0;\n\n\tif (git_pqueue_init(&pq, 0, 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tif ((error = git_pqueue_insert(&pq, one)) < 0 ||\n\t\t(error = git_pqueue_insert(&pq, two)) < 0)\n\t\tgoto done;\n\n\twhile ((commit = git_pqueue_pop(&pq)) != NULL) {\n\t\tif (commit->flags & RESULT ||\n\t\t\t(commit->flags & (PARENT1 | PARENT2)) == (PARENT1 | PARENT2))\n\t\t\tcontinue;\n\t\telse if (commit->flags & PARENT1)\n\t\t\t(*ahead)++;\n\t\telse if (commit->flags & PARENT2)\n\t\t\t(*behind)++;\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((error = git_pqueue_insert(&pq, p)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t\tcommit->flags |= RESULT;\n\t}\n\ndone:\n\tgit_pqueue_free(&pq);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_parents",
          "args": [
            "walk",
            "commit_l",
            "commit_u"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "mark_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/graph.c",
          "lines": "31-103",
          "snippet": "static int mark_parents(git_revwalk *walk, git_commit_list_node *one,\n\tgit_commit_list_node *two)\n{\n\tunsigned int i;\n\tgit_commit_list *roots = NULL;\n\tgit_pqueue list;\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tif (one == two) {\n\t\tone->flags |= PARENT1 | PARENT2 | RESULT;\n\t\treturn 0;\n\t}\n\n\tif (git_pqueue_init(&list, 0, 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\tgoto on_error;\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\tgoto on_error;\n\n\tif (git_commit_list_parse(walk, two) < 0)\n\t\tgoto on_error;\n\ttwo->flags |= PARENT2;\n\tif (git_pqueue_insert(&list, two) < 0)\n\t\tgoto on_error;\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list, roots)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT))\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif (git_commit_list_parse(walk, p) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Keep track of root commits, to make sure the path gets marked */\n\t\tif (commit->out_degree == 0) {\n\t\t\tif (git_commit_list_insert(commit, &roots) == NULL)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tgit_commit_list_free(&roots);\n\tgit_pqueue_free(&list);\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&roots);\n\tgit_pqueue_free(&list);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/graph.h\"",
            "#include \"merge.h\"",
            "#include \"revwalk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/graph.h\"\n#include \"merge.h\"\n#include \"revwalk.h\"\n\nstatic int mark_parents(git_revwalk *walk, git_commit_list_node *one,\n\tgit_commit_list_node *two)\n{\n\tunsigned int i;\n\tgit_commit_list *roots = NULL;\n\tgit_pqueue list;\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tif (one == two) {\n\t\tone->flags |= PARENT1 | PARENT2 | RESULT;\n\t\treturn 0;\n\t}\n\n\tif (git_pqueue_init(&list, 0, 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\tgoto on_error;\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\tgoto on_error;\n\n\tif (git_commit_list_parse(walk, two) < 0)\n\t\tgoto on_error;\n\ttwo->flags |= PARENT2;\n\tif (git_pqueue_insert(&list, two) < 0)\n\t\tgoto on_error;\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list, roots)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT))\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif (git_commit_list_parse(walk, p) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Keep track of root commits, to make sure the path gets marked */\n\t\tif (commit->out_degree == 0) {\n\t\t\tif (git_commit_list_insert(commit, &roots) == NULL)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tgit_commit_list_free(&roots);\n\tgit_pqueue_free(&list);\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&roots);\n\tgit_pqueue_free(&list);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk__commit_lookup",
          "args": [
            "walk",
            "local"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk__commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "17-42",
          "snippet": "GIT__USE_OIDMAP\n\ngit_commit_list_node *git_revwalk__commit_lookup(\n\tgit_revwalk *walk, const git_oid *oid)\n{\n\tgit_commit_list_node *commit;\n\tkhiter_t pos;\n\tint ret;\n\n\t/* lookup and reserve space if not already present */\n\tpos = kh_get(oid, walk->commits, oid);\n\tif (pos != kh_end(walk->commits))\n\t\treturn kh_value(walk->commits, pos);\n\n\tcommit = git_commit_list_alloc_node(walk);\n\tif (commit == NULL)\n\t\treturn NULL;\n\n\tgit_oid_cpy(&commit->oid, oid);\n\n\tpos = kh_put(oid, walk->commits, &commit->oid, &ret);\n\tassert(ret != 0);\n\tkh_value(walk->commits, pos) = commit;\n\n\treturn commit;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nGIT__USE_OIDMAP\n\ngit_commit_list_node *git_revwalk__commit_lookup(\n\tgit_revwalk *walk, const git_oid *oid)\n{\n\tgit_commit_list_node *commit;\n\tkhiter_t pos;\n\tint ret;\n\n\t/* lookup and reserve space if not already present */\n\tpos = kh_get(oid, walk->commits, oid);\n\tif (pos != kh_end(walk->commits))\n\t\treturn kh_value(walk->commits, pos);\n\n\tcommit = git_commit_list_alloc_node(walk);\n\tif (commit == NULL)\n\t\treturn NULL;\n\n\tgit_oid_cpy(&commit->oid, oid);\n\n\tpos = kh_put(oid, walk->commits, &commit->oid, &ret);\n\tassert(ret != 0);\n\tkh_value(walk->commits, pos) = commit;\n\n\treturn commit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_new",
          "args": [
            "&walk",
            "repo"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "529-553",
          "snippet": "int git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/graph.h\"\n#include \"merge.h\"\n#include \"revwalk.h\"\n\nint git_graph_ahead_behind(size_t *ahead, size_t *behind, git_repository *repo,\n\tconst git_oid *local, const git_oid *upstream)\n{\n\tgit_revwalk *walk;\n\tgit_commit_list_node *commit_u, *commit_l;\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\treturn -1;\n\n\tcommit_u = git_revwalk__commit_lookup(walk, upstream);\n\tif (commit_u == NULL)\n\t\tgoto on_error;\n\n\tcommit_l = git_revwalk__commit_lookup(walk, local);\n\tif (commit_l == NULL)\n\t\tgoto on_error;\n\n\tif (mark_parents(walk, commit_l, commit_u) < 0)\n\t\tgoto on_error;\n\tif (ahead_behind(commit_l, commit_u, ahead, behind) < 0)\n\t\tgoto on_error;\n\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\treturn -1;\n}"
  },
  {
    "function_name": "ahead_behind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/graph.c",
    "lines": "106-142",
    "snippet": "static int ahead_behind(git_commit_list_node *one, git_commit_list_node *two,\n\tsize_t *ahead, size_t *behind)\n{\n\tgit_commit_list_node *commit;\n\tgit_pqueue pq;\n\tint error = 0, i;\n\t*ahead = 0;\n\t*behind = 0;\n\n\tif (git_pqueue_init(&pq, 0, 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tif ((error = git_pqueue_insert(&pq, one)) < 0 ||\n\t\t(error = git_pqueue_insert(&pq, two)) < 0)\n\t\tgoto done;\n\n\twhile ((commit = git_pqueue_pop(&pq)) != NULL) {\n\t\tif (commit->flags & RESULT ||\n\t\t\t(commit->flags & (PARENT1 | PARENT2)) == (PARENT1 | PARENT2))\n\t\t\tcontinue;\n\t\telse if (commit->flags & PARENT1)\n\t\t\t(*ahead)++;\n\t\telse if (commit->flags & PARENT2)\n\t\t\t(*behind)++;\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((error = git_pqueue_insert(&pq, p)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t\tcommit->flags |= RESULT;\n\t}\n\ndone:\n\tgit_pqueue_free(&pq);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/graph.h\"",
      "#include \"merge.h\"",
      "#include \"revwalk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pqueue_free",
          "args": [
            "&pq"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pqueue_insert",
          "args": [
            "&pq",
            "p"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "81-100",
          "snippet": "int git_pqueue_insert(git_pqueue *pq, void *item)\n{\n\tint error = 0;\n\n\t/* if heap is full, pop the top element if new one should replace it */\n\tif ((pq->flags & GIT_PQUEUE_FIXED_SIZE) != 0 &&\n\t\tpq->length >= pq->_alloc_size)\n\t{\n\t\t/* skip this item if below min item in heap */\n\t\tif (pq->_cmp(item, git_vector_get(pq, 0)) <= 0)\n\t\t\treturn 0;\n\t\t/* otherwise remove the min item before inserting new */\n\t\t(void)git_pqueue_pop(pq);\n\t}\n\n\tif (!(error = git_vector_insert(pq, item)))\n\t\tpqueue_up(pq, pq->length - 1);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nint git_pqueue_insert(git_pqueue *pq, void *item)\n{\n\tint error = 0;\n\n\t/* if heap is full, pop the top element if new one should replace it */\n\tif ((pq->flags & GIT_PQUEUE_FIXED_SIZE) != 0 &&\n\t\tpq->length >= pq->_alloc_size)\n\t{\n\t\t/* skip this item if below min item in heap */\n\t\tif (pq->_cmp(item, git_vector_get(pq, 0)) <= 0)\n\t\t\treturn 0;\n\t\t/* otherwise remove the min item before inserting new */\n\t\t(void)git_pqueue_pop(pq);\n\t}\n\n\tif (!(error = git_vector_insert(pq, item)))\n\t\tpqueue_up(pq, pq->length - 1);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pqueue_pop",
          "args": [
            "&pq"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "102-117",
          "snippet": "void *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nvoid *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pqueue_init",
          "args": [
            "&pq",
            "0",
            "2",
            "git_commit_list_time_cmp"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "15-33",
          "snippet": "int git_pqueue_init(\n\tgit_pqueue *pq,\n\tuint32_t flags,\n\tsize_t init_size,\n\tgit_vector_cmp cmp)\n{\n\tint error = git_vector_init(pq, init_size, cmp);\n\n\tif (!error) {\n\t\t/* mix in our flags */\n\t\tpq->flags |= flags;\n\n\t\t/* if fixed size heap, pretend vector is exactly init_size elements */\n\t\tif ((flags & GIT_PQUEUE_FIXED_SIZE) && init_size > 0)\n\t\t\tpq->_alloc_size = init_size;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nint git_pqueue_init(\n\tgit_pqueue *pq,\n\tuint32_t flags,\n\tsize_t init_size,\n\tgit_vector_cmp cmp)\n{\n\tint error = git_vector_init(pq, init_size, cmp);\n\n\tif (!error) {\n\t\t/* mix in our flags */\n\t\tpq->flags |= flags;\n\n\t\t/* if fixed size heap, pretend vector is exactly init_size elements */\n\t\tif ((flags & GIT_PQUEUE_FIXED_SIZE) && init_size > 0)\n\t\t\tpq->_alloc_size = init_size;\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/graph.h\"\n#include \"merge.h\"\n#include \"revwalk.h\"\n\nstatic int ahead_behind(git_commit_list_node *one, git_commit_list_node *two,\n\tsize_t *ahead, size_t *behind)\n{\n\tgit_commit_list_node *commit;\n\tgit_pqueue pq;\n\tint error = 0, i;\n\t*ahead = 0;\n\t*behind = 0;\n\n\tif (git_pqueue_init(&pq, 0, 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tif ((error = git_pqueue_insert(&pq, one)) < 0 ||\n\t\t(error = git_pqueue_insert(&pq, two)) < 0)\n\t\tgoto done;\n\n\twhile ((commit = git_pqueue_pop(&pq)) != NULL) {\n\t\tif (commit->flags & RESULT ||\n\t\t\t(commit->flags & (PARENT1 | PARENT2)) == (PARENT1 | PARENT2))\n\t\t\tcontinue;\n\t\telse if (commit->flags & PARENT1)\n\t\t\t(*ahead)++;\n\t\telse if (commit->flags & PARENT2)\n\t\t\t(*behind)++;\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((error = git_pqueue_insert(&pq, p)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t\tcommit->flags |= RESULT;\n\t}\n\ndone:\n\tgit_pqueue_free(&pq);\n\treturn error;\n}"
  },
  {
    "function_name": "mark_parents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/graph.c",
    "lines": "31-103",
    "snippet": "static int mark_parents(git_revwalk *walk, git_commit_list_node *one,\n\tgit_commit_list_node *two)\n{\n\tunsigned int i;\n\tgit_commit_list *roots = NULL;\n\tgit_pqueue list;\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tif (one == two) {\n\t\tone->flags |= PARENT1 | PARENT2 | RESULT;\n\t\treturn 0;\n\t}\n\n\tif (git_pqueue_init(&list, 0, 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\tgoto on_error;\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\tgoto on_error;\n\n\tif (git_commit_list_parse(walk, two) < 0)\n\t\tgoto on_error;\n\ttwo->flags |= PARENT2;\n\tif (git_pqueue_insert(&list, two) < 0)\n\t\tgoto on_error;\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list, roots)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT))\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif (git_commit_list_parse(walk, p) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Keep track of root commits, to make sure the path gets marked */\n\t\tif (commit->out_degree == 0) {\n\t\t\tif (git_commit_list_insert(commit, &roots) == NULL)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tgit_commit_list_free(&roots);\n\tgit_pqueue_free(&list);\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&roots);\n\tgit_pqueue_free(&list);\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/graph.h\"",
      "#include \"merge.h\"",
      "#include \"revwalk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pqueue_free",
          "args": [
            "&list"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_list_free",
          "args": [
            "&roots"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "75-89",
          "snippet": "void git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nvoid git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pqueue_free",
          "args": [
            "&list"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_list_insert",
          "args": [
            "commit",
            "&roots"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_insert_by_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "33-46",
          "snippet": "git_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\ngit_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pqueue_insert",
          "args": [
            "&list",
            "p"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "81-100",
          "snippet": "int git_pqueue_insert(git_pqueue *pq, void *item)\n{\n\tint error = 0;\n\n\t/* if heap is full, pop the top element if new one should replace it */\n\tif ((pq->flags & GIT_PQUEUE_FIXED_SIZE) != 0 &&\n\t\tpq->length >= pq->_alloc_size)\n\t{\n\t\t/* skip this item if below min item in heap */\n\t\tif (pq->_cmp(item, git_vector_get(pq, 0)) <= 0)\n\t\t\treturn 0;\n\t\t/* otherwise remove the min item before inserting new */\n\t\t(void)git_pqueue_pop(pq);\n\t}\n\n\tif (!(error = git_vector_insert(pq, item)))\n\t\tpqueue_up(pq, pq->length - 1);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nint git_pqueue_insert(git_pqueue *pq, void *item)\n{\n\tint error = 0;\n\n\t/* if heap is full, pop the top element if new one should replace it */\n\tif ((pq->flags & GIT_PQUEUE_FIXED_SIZE) != 0 &&\n\t\tpq->length >= pq->_alloc_size)\n\t{\n\t\t/* skip this item if below min item in heap */\n\t\tif (pq->_cmp(item, git_vector_get(pq, 0)) <= 0)\n\t\t\treturn 0;\n\t\t/* otherwise remove the min item before inserting new */\n\t\t(void)git_pqueue_pop(pq);\n\t}\n\n\tif (!(error = git_vector_insert(pq, item)))\n\t\tpqueue_up(pq, pq->length - 1);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_parse",
          "args": [
            "walk",
            "p"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "177-199",
          "snippet": "int git_commit_list_parse(git_revwalk *walk, git_commit_list_node *commit)\n{\n\tgit_odb_object *obj;\n\tint error;\n\n\tif (commit->parsed)\n\t\treturn 0;\n\n\tif ((error = git_odb_read(&obj, walk->odb, &commit->oid)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"Object is no commit object\");\n\t\terror = -1;\n\t} else\n\t\terror = commit_quick_parse(\n\t\t\twalk, commit,\n\t\t\t(const uint8_t *)git_odb_object_data(obj),\n\t\t\tgit_odb_object_size(obj));\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nint git_commit_list_parse(git_revwalk *walk, git_commit_list_node *commit)\n{\n\tgit_odb_object *obj;\n\tint error;\n\n\tif (commit->parsed)\n\t\treturn 0;\n\n\tif ((error = git_odb_read(&obj, walk->odb, &commit->oid)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"Object is no commit object\");\n\t\terror = -1;\n\t} else\n\t\terror = commit_quick_parse(\n\t\t\twalk, commit,\n\t\t\t(const uint8_t *)git_odb_object_data(obj),\n\t\t\tgit_odb_object_size(obj));\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pqueue_pop",
          "args": [
            "&list"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "102-117",
          "snippet": "void *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nvoid *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "interesting",
          "args": [
            "&list",
            "roots"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "interesting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/graph.c",
          "lines": "12-29",
          "snippet": "static int interesting(git_pqueue *list, git_commit_list *roots)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < git_pqueue_size(list); i++) {\n\t\tgit_commit_list_node *commit = git_pqueue_get(list, i);\n\t\tif ((commit->flags & STALE) == 0)\n\t\t\treturn 1;\n\t}\n\n\twhile(roots) {\n\t\tif ((roots->item->flags & STALE) == 0)\n\t\t\treturn 1;\n\t\troots = roots->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/graph.h\"",
            "#include \"merge.h\"",
            "#include \"revwalk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/graph.h\"\n#include \"merge.h\"\n#include \"revwalk.h\"\n\nstatic int interesting(git_pqueue *list, git_commit_list *roots)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < git_pqueue_size(list); i++) {\n\t\tgit_commit_list_node *commit = git_pqueue_get(list, i);\n\t\tif ((commit->flags & STALE) == 0)\n\t\t\treturn 1;\n\t}\n\n\twhile(roots) {\n\t\tif ((roots->item->flags & STALE) == 0)\n\t\t\treturn 1;\n\t\troots = roots->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pqueue_init",
          "args": [
            "&list",
            "0",
            "2",
            "git_commit_list_time_cmp"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "15-33",
          "snippet": "int git_pqueue_init(\n\tgit_pqueue *pq,\n\tuint32_t flags,\n\tsize_t init_size,\n\tgit_vector_cmp cmp)\n{\n\tint error = git_vector_init(pq, init_size, cmp);\n\n\tif (!error) {\n\t\t/* mix in our flags */\n\t\tpq->flags |= flags;\n\n\t\t/* if fixed size heap, pretend vector is exactly init_size elements */\n\t\tif ((flags & GIT_PQUEUE_FIXED_SIZE) && init_size > 0)\n\t\t\tpq->_alloc_size = init_size;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nint git_pqueue_init(\n\tgit_pqueue *pq,\n\tuint32_t flags,\n\tsize_t init_size,\n\tgit_vector_cmp cmp)\n{\n\tint error = git_vector_init(pq, init_size, cmp);\n\n\tif (!error) {\n\t\t/* mix in our flags */\n\t\tpq->flags |= flags;\n\n\t\t/* if fixed size heap, pretend vector is exactly init_size elements */\n\t\tif ((flags & GIT_PQUEUE_FIXED_SIZE) && init_size > 0)\n\t\t\tpq->_alloc_size = init_size;\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/graph.h\"\n#include \"merge.h\"\n#include \"revwalk.h\"\n\nstatic int mark_parents(git_revwalk *walk, git_commit_list_node *one,\n\tgit_commit_list_node *two)\n{\n\tunsigned int i;\n\tgit_commit_list *roots = NULL;\n\tgit_pqueue list;\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tif (one == two) {\n\t\tone->flags |= PARENT1 | PARENT2 | RESULT;\n\t\treturn 0;\n\t}\n\n\tif (git_pqueue_init(&list, 0, 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\tgoto on_error;\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\tgoto on_error;\n\n\tif (git_commit_list_parse(walk, two) < 0)\n\t\tgoto on_error;\n\ttwo->flags |= PARENT2;\n\tif (git_pqueue_insert(&list, two) < 0)\n\t\tgoto on_error;\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list, roots)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT))\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif (git_commit_list_parse(walk, p) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Keep track of root commits, to make sure the path gets marked */\n\t\tif (commit->out_degree == 0) {\n\t\t\tif (git_commit_list_insert(commit, &roots) == NULL)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tgit_commit_list_free(&roots);\n\tgit_pqueue_free(&list);\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&roots);\n\tgit_pqueue_free(&list);\n\treturn -1;\n}"
  },
  {
    "function_name": "interesting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/graph.c",
    "lines": "12-29",
    "snippet": "static int interesting(git_pqueue *list, git_commit_list *roots)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < git_pqueue_size(list); i++) {\n\t\tgit_commit_list_node *commit = git_pqueue_get(list, i);\n\t\tif ((commit->flags & STALE) == 0)\n\t\t\treturn 1;\n\t}\n\n\twhile(roots) {\n\t\tif ((roots->item->flags & STALE) == 0)\n\t\t\treturn 1;\n\t\troots = roots->next;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/graph.h\"",
      "#include \"merge.h\"",
      "#include \"revwalk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pqueue_get",
          "args": [
            "list",
            "i"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pqueue_size",
          "args": [
            "list"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/graph.h\"\n#include \"merge.h\"\n#include \"revwalk.h\"\n\nstatic int interesting(git_pqueue *list, git_commit_list *roots)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < git_pqueue_size(list); i++) {\n\t\tgit_commit_list_node *commit = git_pqueue_get(list, i);\n\t\tif ((commit->flags & STALE) == 0)\n\t\t\treturn 1;\n\t}\n\n\twhile(roots) {\n\t\tif ((roots->item->flags & STALE) == 0)\n\t\t\treturn 1;\n\t\troots = roots->next;\n\t}\n\n\treturn 0;\n}"
  }
]