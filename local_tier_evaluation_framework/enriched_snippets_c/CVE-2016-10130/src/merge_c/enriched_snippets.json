[
  {
    "function_name": "git_merge_file_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "3069-3075",
    "snippet": "int git_merge_file_init_options(\n\tgit_merge_file_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_merge_file_options, GIT_MERGE_FILE_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_merge_file_options",
            "GIT_MERGE_FILE_OPTIONS_INIT"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge_file_init_options(\n\tgit_merge_file_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_merge_file_options, GIT_MERGE_FILE_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_merge_file_init_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "3062-3067",
    "snippet": "int git_merge_file_init_input(git_merge_file_input *input, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\tinput, version, git_merge_file_input, GIT_MERGE_FILE_INPUT_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "input",
            "version",
            "git_merge_file_input",
            "GIT_MERGE_FILE_INPUT_INIT"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_file_init_input(git_merge_file_input *input, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\tinput, version, git_merge_file_input, GIT_MERGE_FILE_INPUT_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_merge_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "3055-3060",
    "snippet": "int git_merge_init_options(git_merge_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_merge_options, GIT_MERGE_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_merge_options",
            "GIT_MERGE_OPTIONS_INIT"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge_init_options(git_merge_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_merge_options, GIT_MERGE_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2985-3053",
    "snippet": "int git_merge(\n\tgit_repository *repo,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len,\n\tconst git_merge_options *merge_opts,\n\tconst git_checkout_options *given_checkout_opts)\n{\n\tgit_reference *our_ref = NULL;\n\tgit_checkout_options checkout_opts;\n\tgit_annotated_commit *our_head = NULL, *base = NULL;\n\tgit_index *index = NULL;\n\tgit_indexwriter indexwriter = GIT_INDEXWRITER_INIT;\n\tunsigned int checkout_strategy;\n\tint error = 0;\n\n\tassert(repo && their_heads);\n\n\tif (their_heads_len != 1) {\n\t\tgiterr_set(GITERR_MERGE, \"Can only merge a single branch\");\n\t\treturn -1;\n\t}\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"merge\")) < 0)\n\t\tgoto done;\n\n\tcheckout_strategy = given_checkout_opts ?\n\t\tgiven_checkout_opts->checkout_strategy :\n\t\tGIT_CHECKOUT_SAFE;\n\n\tif ((error = git_indexwriter_init_for_operation(&indexwriter, repo,\n\t\t&checkout_strategy)) < 0)\n\t\tgoto done;\n\n\t/* Write the merge setup files to the repository. */\n\tif ((error = git_annotated_commit_from_head(&our_head, repo)) < 0 ||\n\t\t(error = git_merge__setup(repo, our_head, their_heads,\n\t\t\ttheir_heads_len)) < 0)\n\t\tgoto done;\n\n\t/* TODO: octopus */\n\n\tif ((error = merge_annotated_commits(&index, &base, repo, our_head,\n\t\t\t(git_annotated_commit *)their_heads[0], 0, merge_opts)) < 0 ||\n\t\t(error = git_merge__check_result(repo, index)) < 0 ||\n\t\t(error = git_merge__append_conflicts_to_merge_msg(repo, index)) < 0)\n\t\tgoto done;\n\n\t/* check out the merge results */\n\n\tif ((error = merge_normalize_checkout_opts(&checkout_opts, repo,\n\t\t\tgiven_checkout_opts, checkout_strategy,\n\t\t\tbase, our_head, their_heads, their_heads_len)) < 0 ||\n\t\t(error = git_checkout_index(repo, index, &checkout_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_indexwriter_commit(&indexwriter);\n\ndone:\n\tif (error < 0)\n\t\tmerge_state_cleanup(repo);\n\n\tgit_indexwriter_cleanup(&indexwriter);\n\tgit_index_free(index);\n\tgit_annotated_commit_free(our_head);\n\tgit_annotated_commit_free(base);\n\tgit_reference_free(our_ref);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "our_ref"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_free",
          "args": [
            "base"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "181-202",
          "snippet": "void git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nvoid git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexwriter_cleanup",
          "args": [
            "&indexwriter"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3433-3439",
          "snippet": "void git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nvoid git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_state_cleanup",
          "args": [
            "repo"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "merge_state_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2847-2856",
          "snippet": "static int merge_state_cleanup(git_repository *repo)\n{\n\tconst char *state_files[] = {\n\t\tGIT_MERGE_HEAD_FILE,\n\t\tGIT_MERGE_MODE_FILE,\n\t\tGIT_MERGE_MSG_FILE,\n\t};\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_state_cleanup(git_repository *repo)\n{\n\tconst char *state_files[] = {\n\t\tGIT_MERGE_HEAD_FILE,\n\t\tGIT_MERGE_MODE_FILE,\n\t\tGIT_MERGE_MSG_FILE,\n\t};\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexwriter_commit",
          "args": [
            "&indexwriter"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3399-3431",
          "snippet": "int git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_checkout_index",
          "args": [
            "repo",
            "index",
            "&checkout_opts"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_normalize_checkout_opts",
          "args": [
            "&checkout_opts",
            "repo",
            "given_checkout_opts",
            "checkout_strategy",
            "base",
            "our_head",
            "their_heads",
            "their_heads_len"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "merge_normalize_checkout_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2596-2644",
          "snippet": "static int merge_normalize_checkout_opts(\n\tgit_checkout_options *out,\n\tgit_repository *repo,\n\tconst git_checkout_options *given_checkout_opts,\n\tunsigned int checkout_strategy,\n\tgit_annotated_commit *ancestor,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_checkout_options default_checkout_opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tint error = 0;\n\n\tGIT_UNUSED(repo);\n\n\tif (given_checkout_opts != NULL)\n\t\tmemcpy(out, given_checkout_opts, sizeof(git_checkout_options));\n\telse\n\t\tmemcpy(out, &default_checkout_opts, sizeof(git_checkout_options));\n\n\tout->checkout_strategy = checkout_strategy;\n\n\tif (!out->ancestor_label) {\n\t\tif (ancestor && ancestor->type == GIT_ANNOTATED_COMMIT_REAL)\n\t\t\tout->ancestor_label = git_commit_summary(ancestor->commit);\n\t\telse if (ancestor)\n\t\t\tout->ancestor_label = \"merged common ancestors\";\n\t\telse\n\t\t\tout->ancestor_label = \"empty base\";\n\t}\n\n\tif (!out->our_label) {\n\t\tif (our_head && our_head->ref_name)\n\t\t\tout->our_label = our_head->ref_name;\n\t\telse\n\t\t\tout->our_label = \"ours\";\n\t}\n\n\tif (!out->their_label) {\n\t\tif (their_heads_len == 1 && their_heads[0]->ref_name)\n\t\t\tout->their_label = merge_their_label(their_heads[0]->ref_name);\n\t\telse if (their_heads_len == 1)\n\t\t\tout->their_label = their_heads[0]->id_str;\n\t\telse\n\t\t\tout->their_label = \"theirs\";\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_normalize_checkout_opts(\n\tgit_checkout_options *out,\n\tgit_repository *repo,\n\tconst git_checkout_options *given_checkout_opts,\n\tunsigned int checkout_strategy,\n\tgit_annotated_commit *ancestor,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_checkout_options default_checkout_opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tint error = 0;\n\n\tGIT_UNUSED(repo);\n\n\tif (given_checkout_opts != NULL)\n\t\tmemcpy(out, given_checkout_opts, sizeof(git_checkout_options));\n\telse\n\t\tmemcpy(out, &default_checkout_opts, sizeof(git_checkout_options));\n\n\tout->checkout_strategy = checkout_strategy;\n\n\tif (!out->ancestor_label) {\n\t\tif (ancestor && ancestor->type == GIT_ANNOTATED_COMMIT_REAL)\n\t\t\tout->ancestor_label = git_commit_summary(ancestor->commit);\n\t\telse if (ancestor)\n\t\t\tout->ancestor_label = \"merged common ancestors\";\n\t\telse\n\t\t\tout->ancestor_label = \"empty base\";\n\t}\n\n\tif (!out->our_label) {\n\t\tif (our_head && our_head->ref_name)\n\t\t\tout->our_label = our_head->ref_name;\n\t\telse\n\t\t\tout->our_label = \"ours\";\n\t}\n\n\tif (!out->their_label) {\n\t\tif (their_heads_len == 1 && their_heads[0]->ref_name)\n\t\t\tout->their_label = merge_their_label(their_heads[0]->ref_name);\n\t\telse if (their_heads_len == 1)\n\t\t\tout->their_label = their_heads[0]->id_str;\n\t\telse\n\t\t\tout->their_label = \"theirs\";\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__append_conflicts_to_merge_msg",
          "args": [
            "repo",
            "index"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__append_conflicts_to_merge_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2805-2845",
          "snippet": "int git_merge__append_conflicts_to_merge_msg(\n\tgit_repository *repo,\n\tgit_index *index)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tconst char *last = NULL;\n\tsize_t i;\n\tint error;\n\n\tif (!git_index_has_conflicts(index))\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_APPEND, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tgit_filebuf_printf(&file, \"\\nConflicts:\\n\");\n\n\tfor (i = 0; i < git_index_entrycount(index); i++) {\n\t\tconst git_index_entry *e = git_index_get_byindex(index, i);\n\n\t\tif (!git_index_entry_is_conflict(e))\n\t\t\tcontinue;\n\n\t\tif (last == NULL || strcmp(e->path, last) != 0)\n\t\t\tgit_filebuf_printf(&file, \"\\t%s\\n\", e->path);\n\n\t\tlast = e->path;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge__append_conflicts_to_merge_msg(\n\tgit_repository *repo,\n\tgit_index *index)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tconst char *last = NULL;\n\tsize_t i;\n\tint error;\n\n\tif (!git_index_has_conflicts(index))\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_APPEND, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tgit_filebuf_printf(&file, \"\\nConflicts:\\n\");\n\n\tfor (i = 0; i < git_index_entrycount(index); i++) {\n\t\tconst git_index_entry *e = git_index_get_byindex(index, i);\n\n\t\tif (!git_index_entry_is_conflict(e))\n\t\t\tcontinue;\n\n\t\tif (last == NULL || strcmp(e->path, last) != 0)\n\t\t\tgit_filebuf_printf(&file, \"\\t%s\\n\", e->path);\n\n\t\tlast = e->path;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__check_result",
          "args": [
            "repo",
            "index"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__check_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2746-2803",
          "snippet": "int git_merge__check_result(git_repository *repo, git_index *index_new)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_iterator *iter_head = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *merged_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_delta *delta;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tsize_t i, index_conflicts = 0, wd_conflicts = 0, conflicts;\n\tconst git_index_entry *e;\n\tint error = 0;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_iterator_for_tree(&iter_head, head_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&merged_list, repo, iter_head, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&merged_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < git_index_entrycount(index_new); i++) {\n\t\te = git_index_get_byindex(index_new, i);\n\n\t\tif (git_index_entry_is_conflict(e) &&\n\t\t\t(git_vector_last(&paths) == NULL ||\n\t\t\tstrcmp(git_vector_last(&paths), e->path) != 0)) {\n\n\t\t\tif ((error = git_vector_insert(&paths, (char *)e->path)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Make sure the index and workdir state do not prevent merging */\n\tif ((error = merge_check_index(&index_conflicts, repo, index_new, &paths)) < 0 ||\n\t\t(error = merge_check_workdir(&wd_conflicts, repo, index_new, &paths)) < 0)\n\t\tgoto done;\n\n\tif ((conflicts = index_conflicts + wd_conflicts) > 0) {\n\t\tgiterr_set(GITERR_MERGE, \"%\" PRIuZ \" uncommitted change%s would be overwritten by merge\",\n\t\t\tconflicts, (conflicts != 1) ? \"s\" : \"\");\n\t\terror = GIT_ECONFLICT;\n\t}\n\ndone:\n\tgit_vector_free(&paths);\n\tgit_tree_free(head_tree);\n\tgit_iterator_free(iter_head);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(merged_list);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge__check_result(git_repository *repo, git_index *index_new)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_iterator *iter_head = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *merged_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_delta *delta;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tsize_t i, index_conflicts = 0, wd_conflicts = 0, conflicts;\n\tconst git_index_entry *e;\n\tint error = 0;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_iterator_for_tree(&iter_head, head_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&merged_list, repo, iter_head, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&merged_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < git_index_entrycount(index_new); i++) {\n\t\te = git_index_get_byindex(index_new, i);\n\n\t\tif (git_index_entry_is_conflict(e) &&\n\t\t\t(git_vector_last(&paths) == NULL ||\n\t\t\tstrcmp(git_vector_last(&paths), e->path) != 0)) {\n\n\t\t\tif ((error = git_vector_insert(&paths, (char *)e->path)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Make sure the index and workdir state do not prevent merging */\n\tif ((error = merge_check_index(&index_conflicts, repo, index_new, &paths)) < 0 ||\n\t\t(error = merge_check_workdir(&wd_conflicts, repo, index_new, &paths)) < 0)\n\t\tgoto done;\n\n\tif ((conflicts = index_conflicts + wd_conflicts) > 0) {\n\t\tgiterr_set(GITERR_MERGE, \"%\" PRIuZ \" uncommitted change%s would be overwritten by merge\",\n\t\t\tconflicts, (conflicts != 1) ? \"s\" : \"\");\n\t\terror = GIT_ECONFLICT;\n\t}\n\ndone:\n\tgit_vector_free(&paths);\n\tgit_tree_free(head_tree);\n\tgit_iterator_free(iter_head);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(merged_list);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_annotated_commits",
          "args": [
            "&index",
            "&base",
            "repo",
            "our_head",
            "(git_annotated_commit *)their_heads[0]",
            "0",
            "merge_opts"
          ],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "merge_annotated_commits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2101-2141",
          "snippet": "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *ours,\n\tgit_annotated_commit *theirs,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *base = NULL;\n\tgit_iterator *base_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tint error;\n\n    if ((error = compute_base(&base, repo, ours, theirs, opts,\n\t\trecursion_level)) < 0) {\n\n        if (error != GIT_ENOTFOUND)\n            goto done;\n\n        giterr_clear();\n    }\n\n\tif ((error = iterator_for_annotated_commit(&base_iter, base)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&our_iter, ours)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&their_iter, theirs)) < 0 ||\n\t\t(error = git_merge__iterators(index_out, repo, base_iter, our_iter,\n\t\t\ttheir_iter, opts)) < 0)\n\t\tgoto done;\n\n\tif (base_out) {\n\t\t*base_out = base;\n\t\tbase = NULL;\n\t}\n\ndone:\n\tgit_annotated_commit_free(base);\n\tgit_iterator_free(base_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *ours,\n\tgit_annotated_commit *theirs,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *base = NULL;\n\tgit_iterator *base_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tint error;\n\n    if ((error = compute_base(&base, repo, ours, theirs, opts,\n\t\trecursion_level)) < 0) {\n\n        if (error != GIT_ENOTFOUND)\n            goto done;\n\n        giterr_clear();\n    }\n\n\tif ((error = iterator_for_annotated_commit(&base_iter, base)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&our_iter, ours)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&their_iter, theirs)) < 0 ||\n\t\t(error = git_merge__iterators(index_out, repo, base_iter, our_iter,\n\t\t\ttheir_iter, opts)) < 0)\n\t\tgoto done;\n\n\tif (base_out) {\n\t\t*base_out = base;\n\t\tbase = NULL;\n\t}\n\ndone:\n\tgit_annotated_commit_free(base);\n\tgit_iterator_free(base_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__setup",
          "args": [
            "repo",
            "our_head",
            "their_heads",
            "their_heads_len"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2530-2547",
          "snippet": "int git_merge__setup(\n\tgit_repository *repo,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tint error = 0;\n\n\tassert (repo && our_head && heads);\n\n\tif ((error = git_repository__set_orig_head(repo, git_annotated_commit_id(our_head))) == 0 &&\n\t\t(error = write_merge_head(repo, heads, heads_len)) == 0 &&\n\t\t(error = write_merge_mode(repo)) == 0) {\n\t\terror = write_merge_msg(repo, heads, heads_len);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge__setup(\n\tgit_repository *repo,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tint error = 0;\n\n\tassert (repo && our_head && heads);\n\n\tif ((error = git_repository__set_orig_head(repo, git_annotated_commit_id(our_head))) == 0 &&\n\t\t(error = write_merge_head(repo, heads, heads_len)) == 0 &&\n\t\t(error = write_merge_mode(repo)) == 0) {\n\t\terror = write_merge_msg(repo, heads, heads_len);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_from_head",
          "args": [
            "&our_head",
            "repo"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_from_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "80-98",
          "snippet": "int git_annotated_commit_from_head(\n\tgit_annotated_commit **out,\n\tgit_repository *repo)\n{\n\tgit_reference *head;\n\tint error;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n    if ((error = git_reference_lookup(&head, repo, GIT_HEAD_FILE)) < 0)\n\t\treturn -1;\n\n\terror = git_annotated_commit_from_ref(out, repo, head);\n\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nint git_annotated_commit_from_head(\n\tgit_annotated_commit **out,\n\tgit_repository *repo)\n{\n\tgit_reference *head;\n\tint error;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n    if ((error = git_reference_lookup(&head, repo, GIT_HEAD_FILE)) < 0)\n\t\treturn -1;\n\n\terror = git_annotated_commit_from_ref(out, repo, head);\n\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexwriter_init_for_operation",
          "args": [
            "&indexwriter",
            "repo",
            "&checkout_strategy"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_init_for_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3381-3397",
          "snippet": "int git_indexwriter_init_for_operation(\n\tgit_indexwriter *writer,\n\tgit_repository *repo,\n\tunsigned int *checkout_strategy)\n{\n\tgit_index *index;\n\tint error;\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0 ||\n\t\t(error = git_indexwriter_init(writer, index)) < 0)\n\t\treturn error;\n\n\twriter->should_write = (*checkout_strategy & GIT_CHECKOUT_DONT_WRITE_INDEX) == 0;\n\t*checkout_strategy |= GIT_CHECKOUT_DONT_WRITE_INDEX;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_indexwriter_init_for_operation(\n\tgit_indexwriter *writer,\n\tgit_repository *repo,\n\tunsigned int *checkout_strategy)\n{\n\tgit_index *index;\n\tint error;\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0 ||\n\t\t(error = git_indexwriter_init(writer, index)) < 0)\n\t\treturn error;\n\n\twriter->should_write = (*checkout_strategy & GIT_CHECKOUT_DONT_WRITE_INDEX) == 0;\n\t*checkout_strategy |= GIT_CHECKOUT_DONT_WRITE_INDEX;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "\"merge\""
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_MERGE",
            "\"Can only merge a single branch\""
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && their_heads"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge(\n\tgit_repository *repo,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len,\n\tconst git_merge_options *merge_opts,\n\tconst git_checkout_options *given_checkout_opts)\n{\n\tgit_reference *our_ref = NULL;\n\tgit_checkout_options checkout_opts;\n\tgit_annotated_commit *our_head = NULL, *base = NULL;\n\tgit_index *index = NULL;\n\tgit_indexwriter indexwriter = GIT_INDEXWRITER_INIT;\n\tunsigned int checkout_strategy;\n\tint error = 0;\n\n\tassert(repo && their_heads);\n\n\tif (their_heads_len != 1) {\n\t\tgiterr_set(GITERR_MERGE, \"Can only merge a single branch\");\n\t\treturn -1;\n\t}\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"merge\")) < 0)\n\t\tgoto done;\n\n\tcheckout_strategy = given_checkout_opts ?\n\t\tgiven_checkout_opts->checkout_strategy :\n\t\tGIT_CHECKOUT_SAFE;\n\n\tif ((error = git_indexwriter_init_for_operation(&indexwriter, repo,\n\t\t&checkout_strategy)) < 0)\n\t\tgoto done;\n\n\t/* Write the merge setup files to the repository. */\n\tif ((error = git_annotated_commit_from_head(&our_head, repo)) < 0 ||\n\t\t(error = git_merge__setup(repo, our_head, their_heads,\n\t\t\ttheir_heads_len)) < 0)\n\t\tgoto done;\n\n\t/* TODO: octopus */\n\n\tif ((error = merge_annotated_commits(&index, &base, repo, our_head,\n\t\t\t(git_annotated_commit *)their_heads[0], 0, merge_opts)) < 0 ||\n\t\t(error = git_merge__check_result(repo, index)) < 0 ||\n\t\t(error = git_merge__append_conflicts_to_merge_msg(repo, index)) < 0)\n\t\tgoto done;\n\n\t/* check out the merge results */\n\n\tif ((error = merge_normalize_checkout_opts(&checkout_opts, repo,\n\t\t\tgiven_checkout_opts, checkout_strategy,\n\t\t\tbase, our_head, their_heads, their_heads_len)) < 0 ||\n\t\t(error = git_checkout_index(repo, index, &checkout_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_indexwriter_commit(&indexwriter);\n\ndone:\n\tif (error < 0)\n\t\tmerge_state_cleanup(repo);\n\n\tgit_indexwriter_cleanup(&indexwriter);\n\tgit_index_free(index);\n\tgit_annotated_commit_free(our_head);\n\tgit_annotated_commit_free(base);\n\tgit_reference_free(our_ref);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_merge_analysis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2934-2983",
    "snippet": "int git_merge_analysis(\n\tgit_merge_analysis_t *analysis_out,\n\tgit_merge_preference_t *preference_out,\n\tgit_repository *repo,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_annotated_commit *ancestor_head = NULL, *our_head = NULL;\n\tint error = 0;\n\n\tassert(analysis_out && preference_out && repo && their_heads);\n\n\tif (their_heads_len != 1) {\n\t\tgiterr_set(GITERR_MERGE, \"Can only merge a single branch\");\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t*analysis_out = GIT_MERGE_ANALYSIS_NONE;\n\n\tif ((error = merge_preference(preference_out, repo)) < 0)\n\t\tgoto done;\n\n\tif (git_repository_head_unborn(repo)) {\n\t\t*analysis_out |= GIT_MERGE_ANALYSIS_FASTFORWARD | GIT_MERGE_ANALYSIS_UNBORN;\n\t\tgoto done;\n\t}\n\n\tif ((error = merge_heads(&ancestor_head, &our_head, repo, their_heads, their_heads_len)) < 0)\n\t\tgoto done;\n\n\t/* We're up-to-date if we're trying to merge our own common ancestor. */\n\tif (ancestor_head && git_oid_equal(\n\t\tgit_annotated_commit_id(ancestor_head), git_annotated_commit_id(their_heads[0])))\n\t\t*analysis_out |= GIT_MERGE_ANALYSIS_UP_TO_DATE;\n\n\t/* We're fastforwardable if we're our own common ancestor. */\n\telse if (ancestor_head && git_oid_equal(\n\t\tgit_annotated_commit_id(ancestor_head), git_annotated_commit_id(our_head)))\n\t\t*analysis_out |= GIT_MERGE_ANALYSIS_FASTFORWARD | GIT_MERGE_ANALYSIS_NORMAL;\n\n\t/* Otherwise, just a normal merge is possible. */\n\telse\n\t\t*analysis_out |= GIT_MERGE_ANALYSIS_NORMAL;\n\ndone:\n\tgit_annotated_commit_free(ancestor_head);\n\tgit_annotated_commit_free(our_head);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_annotated_commit_free",
          "args": [
            "our_head"
          ],
          "line": 2981
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "181-202",
          "snippet": "void git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nvoid git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "git_annotated_commit_id(ancestor_head)",
            "git_annotated_commit_id(our_head)"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_id",
          "args": [
            "our_head"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "174-179",
          "snippet": "const git_oid *git_annotated_commit_id(\n\tconst git_annotated_commit *annotated_commit)\n{\n\tassert(annotated_commit);\n\treturn git_commit_id(annotated_commit->commit);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nconst git_oid *git_annotated_commit_id(\n\tconst git_annotated_commit *annotated_commit)\n{\n\tassert(annotated_commit);\n\treturn git_commit_id(annotated_commit->commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_heads",
          "args": [
            "&ancestor_head",
            "&our_head",
            "repo",
            "their_heads",
            "their_heads_len"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "merge_heads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2858-2899",
          "snippet": "static int merge_heads(\n\tgit_annotated_commit **ancestor_head_out,\n\tgit_annotated_commit **our_head_out,\n\tgit_repository *repo,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_annotated_commit *ancestor_head = NULL, *our_head = NULL;\n\tgit_reference *our_ref = NULL;\n\tint error = 0;\n\n\t*ancestor_head_out = NULL;\n\t*our_head_out = NULL;\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"merge\")) < 0)\n\t\tgoto done;\n\n\tif ((error = git_reference_lookup(&our_ref, repo, GIT_HEAD_FILE)) < 0 ||\n\t\t(error = git_annotated_commit_from_ref(&our_head, repo, our_ref)) < 0)\n\t\tgoto done;\n\n\tif ((error = merge_ancestor_head(&ancestor_head, repo, our_head, their_heads, their_heads_len)) < 0) {\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto done;\n\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\t*ancestor_head_out = ancestor_head;\n\t*our_head_out = our_head;\n\ndone:\n\tif (error < 0) {\n\t\tgit_annotated_commit_free(ancestor_head);\n\t\tgit_annotated_commit_free(our_head);\n\t}\n\n\tgit_reference_free(our_ref);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_heads(\n\tgit_annotated_commit **ancestor_head_out,\n\tgit_annotated_commit **our_head_out,\n\tgit_repository *repo,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_annotated_commit *ancestor_head = NULL, *our_head = NULL;\n\tgit_reference *our_ref = NULL;\n\tint error = 0;\n\n\t*ancestor_head_out = NULL;\n\t*our_head_out = NULL;\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"merge\")) < 0)\n\t\tgoto done;\n\n\tif ((error = git_reference_lookup(&our_ref, repo, GIT_HEAD_FILE)) < 0 ||\n\t\t(error = git_annotated_commit_from_ref(&our_head, repo, our_ref)) < 0)\n\t\tgoto done;\n\n\tif ((error = merge_ancestor_head(&ancestor_head, repo, our_head, their_heads, their_heads_len)) < 0) {\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto done;\n\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\t*ancestor_head_out = ancestor_head;\n\t*our_head_out = our_head;\n\ndone:\n\tif (error < 0) {\n\t\tgit_annotated_commit_free(ancestor_head);\n\t\tgit_annotated_commit_free(our_head);\n\t}\n\n\tgit_reference_free(our_ref);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head_unborn",
          "args": [
            "repo"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_unborn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1764-1781",
          "snippet": "int git_repository_head_unborn(git_repository *repo)\n{\n\tgit_reference *ref = NULL;\n\tint error;\n\n\terror = git_repository_head(&ref, repo);\n\tgit_reference_free(ref);\n\n\tif (error == GIT_EUNBORNBRANCH) {\n\t\tgiterr_clear();\n\t\treturn 1;\n\t}\n\n\tif (error < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_unborn(git_repository *repo)\n{\n\tgit_reference *ref = NULL;\n\tint error;\n\n\terror = git_repository_head(&ref, repo);\n\tgit_reference_free(ref);\n\n\tif (error == GIT_EUNBORNBRANCH) {\n\t\tgiterr_clear();\n\t\treturn 1;\n\t}\n\n\tif (error < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_preference",
          "args": [
            "preference_out",
            "repo"
          ],
          "line": 2954
        },
        "resolved": true,
        "details": {
          "function_name": "merge_preference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2901-2932",
          "snippet": "static int merge_preference(git_merge_preference_t *out, git_repository *repo)\n{\n\tgit_config *config;\n\tconst char *value;\n\tint bool_value, error = 0;\n\n\t*out = GIT_MERGE_PREFERENCE_NONE;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_config_get_string(&value, config, \"merge.ff\")) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\tif (git_config_parse_bool(&bool_value, value) == 0) {\n\t\tif (!bool_value)\n\t\t\t*out |= GIT_MERGE_PREFERENCE_NO_FASTFORWARD;\n\t} else {\n\t\tif (strcasecmp(value, \"only\") == 0)\n\t\t\t*out |= GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY;\n\t}\n\ndone:\n\tgit_config_free(config);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_preference(git_merge_preference_t *out, git_repository *repo)\n{\n\tgit_config *config;\n\tconst char *value;\n\tint bool_value, error = 0;\n\n\t*out = GIT_MERGE_PREFERENCE_NONE;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_config_get_string(&value, config, \"merge.ff\")) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\tif (git_config_parse_bool(&bool_value, value) == 0) {\n\t\tif (!bool_value)\n\t\t\t*out |= GIT_MERGE_PREFERENCE_NO_FASTFORWARD;\n\t} else {\n\t\tif (strcasecmp(value, \"only\") == 0)\n\t\t\t*out |= GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY;\n\t}\n\ndone:\n\tgit_config_free(config);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_MERGE",
            "\"Can only merge a single branch\""
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "analysis_out && preference_out && repo && their_heads"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_analysis(\n\tgit_merge_analysis_t *analysis_out,\n\tgit_merge_preference_t *preference_out,\n\tgit_repository *repo,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_annotated_commit *ancestor_head = NULL, *our_head = NULL;\n\tint error = 0;\n\n\tassert(analysis_out && preference_out && repo && their_heads);\n\n\tif (their_heads_len != 1) {\n\t\tgiterr_set(GITERR_MERGE, \"Can only merge a single branch\");\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t*analysis_out = GIT_MERGE_ANALYSIS_NONE;\n\n\tif ((error = merge_preference(preference_out, repo)) < 0)\n\t\tgoto done;\n\n\tif (git_repository_head_unborn(repo)) {\n\t\t*analysis_out |= GIT_MERGE_ANALYSIS_FASTFORWARD | GIT_MERGE_ANALYSIS_UNBORN;\n\t\tgoto done;\n\t}\n\n\tif ((error = merge_heads(&ancestor_head, &our_head, repo, their_heads, their_heads_len)) < 0)\n\t\tgoto done;\n\n\t/* We're up-to-date if we're trying to merge our own common ancestor. */\n\tif (ancestor_head && git_oid_equal(\n\t\tgit_annotated_commit_id(ancestor_head), git_annotated_commit_id(their_heads[0])))\n\t\t*analysis_out |= GIT_MERGE_ANALYSIS_UP_TO_DATE;\n\n\t/* We're fastforwardable if we're our own common ancestor. */\n\telse if (ancestor_head && git_oid_equal(\n\t\tgit_annotated_commit_id(ancestor_head), git_annotated_commit_id(our_head)))\n\t\t*analysis_out |= GIT_MERGE_ANALYSIS_FASTFORWARD | GIT_MERGE_ANALYSIS_NORMAL;\n\n\t/* Otherwise, just a normal merge is possible. */\n\telse\n\t\t*analysis_out |= GIT_MERGE_ANALYSIS_NORMAL;\n\ndone:\n\tgit_annotated_commit_free(ancestor_head);\n\tgit_annotated_commit_free(our_head);\n\treturn error;\n}"
  },
  {
    "function_name": "merge_preference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2901-2932",
    "snippet": "static int merge_preference(git_merge_preference_t *out, git_repository *repo)\n{\n\tgit_config *config;\n\tconst char *value;\n\tint bool_value, error = 0;\n\n\t*out = GIT_MERGE_PREFERENCE_NONE;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_config_get_string(&value, config, \"merge.ff\")) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\tif (git_config_parse_bool(&bool_value, value) == 0) {\n\t\tif (!bool_value)\n\t\t\t*out |= GIT_MERGE_PREFERENCE_NO_FASTFORWARD;\n\t} else {\n\t\tif (strcasecmp(value, \"only\") == 0)\n\t\t\t*out |= GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY;\n\t}\n\ndone:\n\tgit_config_free(config);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "config"
          ],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "value",
            "\"only\""
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_parse_bool",
          "args": [
            "&bool_value",
            "value"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_parse_bool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1263-1275",
          "snippet": "int git_config_parse_bool(int *out, const char *value)\n{\n\tif (git__parse_bool(out, value) == 0)\n\t\treturn 0;\n\n\tif (git_config_parse_int32(out, value) == 0) {\n\t\t*out = !!(*out);\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse '%s' as a boolean value\", value);\n\treturn -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_parse_bool(int *out, const char *value)\n{\n\tif (git__parse_bool(out, value) == 0)\n\t\treturn 0;\n\n\tif (git_config_parse_int32(out, value) == 0) {\n\t\t*out = !!(*out);\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse '%s' as a boolean value\", value);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_get_string",
          "args": [
            "&value",
            "config",
            "\"merge.ff\""
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_get_string_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "857-875",
          "snippet": "int git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config_snapshot",
          "args": [
            "&config",
            "repo"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "716-725",
          "snippet": "int git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_preference(git_merge_preference_t *out, git_repository *repo)\n{\n\tgit_config *config;\n\tconst char *value;\n\tint bool_value, error = 0;\n\n\t*out = GIT_MERGE_PREFERENCE_NONE;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_config_get_string(&value, config, \"merge.ff\")) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\tif (git_config_parse_bool(&bool_value, value) == 0) {\n\t\tif (!bool_value)\n\t\t\t*out |= GIT_MERGE_PREFERENCE_NO_FASTFORWARD;\n\t} else {\n\t\tif (strcasecmp(value, \"only\") == 0)\n\t\t\t*out |= GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY;\n\t}\n\ndone:\n\tgit_config_free(config);\n\treturn error;\n}"
  },
  {
    "function_name": "merge_heads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2858-2899",
    "snippet": "static int merge_heads(\n\tgit_annotated_commit **ancestor_head_out,\n\tgit_annotated_commit **our_head_out,\n\tgit_repository *repo,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_annotated_commit *ancestor_head = NULL, *our_head = NULL;\n\tgit_reference *our_ref = NULL;\n\tint error = 0;\n\n\t*ancestor_head_out = NULL;\n\t*our_head_out = NULL;\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"merge\")) < 0)\n\t\tgoto done;\n\n\tif ((error = git_reference_lookup(&our_ref, repo, GIT_HEAD_FILE)) < 0 ||\n\t\t(error = git_annotated_commit_from_ref(&our_head, repo, our_ref)) < 0)\n\t\tgoto done;\n\n\tif ((error = merge_ancestor_head(&ancestor_head, repo, our_head, their_heads, their_heads_len)) < 0) {\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto done;\n\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\t*ancestor_head_out = ancestor_head;\n\t*our_head_out = our_head;\n\ndone:\n\tif (error < 0) {\n\t\tgit_annotated_commit_free(ancestor_head);\n\t\tgit_annotated_commit_free(our_head);\n\t}\n\n\tgit_reference_free(our_ref);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "our_ref"
          ],
          "line": 2896
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_free",
          "args": [
            "our_head"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "181-202",
          "snippet": "void git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nvoid git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_ancestor_head",
          "args": [
            "&ancestor_head",
            "repo",
            "our_head",
            "their_heads",
            "their_heads_len"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "merge_ancestor_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2551-2581",
          "snippet": "static int merge_ancestor_head(\n\tgit_annotated_commit **ancestor_head,\n\tgit_repository *repo,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_oid *oids, ancestor_oid;\n\tsize_t i, alloc_len;\n\tint error = 0;\n\n\tassert(repo && our_head && their_heads);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, their_heads_len, 1);\n\toids = git__calloc(alloc_len, sizeof(git_oid));\n\tGITERR_CHECK_ALLOC(oids);\n\n\tgit_oid_cpy(&oids[0], git_commit_id(our_head->commit));\n\n\tfor (i = 0; i < their_heads_len; i++)\n\t\tgit_oid_cpy(&oids[i + 1], git_annotated_commit_id(their_heads[i]));\n\n\tif ((error = git_merge_base_many(&ancestor_oid, repo, their_heads_len + 1, oids)) < 0)\n\t\tgoto on_error;\n\n\terror = git_annotated_commit_lookup(ancestor_head, repo, &ancestor_oid);\n\non_error:\n\tgit__free(oids);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_ancestor_head(\n\tgit_annotated_commit **ancestor_head,\n\tgit_repository *repo,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_oid *oids, ancestor_oid;\n\tsize_t i, alloc_len;\n\tint error = 0;\n\n\tassert(repo && our_head && their_heads);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, their_heads_len, 1);\n\toids = git__calloc(alloc_len, sizeof(git_oid));\n\tGITERR_CHECK_ALLOC(oids);\n\n\tgit_oid_cpy(&oids[0], git_commit_id(our_head->commit));\n\n\tfor (i = 0; i < their_heads_len; i++)\n\t\tgit_oid_cpy(&oids[i + 1], git_annotated_commit_id(their_heads[i]));\n\n\tif ((error = git_merge_base_many(&ancestor_oid, repo, their_heads_len + 1, oids)) < 0)\n\t\tgoto on_error;\n\n\terror = git_annotated_commit_lookup(ancestor_head, repo, &ancestor_oid);\n\non_error:\n\tgit__free(oids);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_from_ref",
          "args": [
            "&our_head",
            "repo",
            "our_ref"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_from_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "58-78",
          "snippet": "int git_annotated_commit_from_ref(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_reference *ref)\n{\n\tgit_reference *resolved;\n\tint error = 0;\n\n\tassert(out && repo && ref);\n\n\t*out = NULL;\n\n\tif ((error = git_reference_resolve(&resolved, ref)) < 0)\n\t\treturn error;\n\t\n\terror = annotated_commit_init(out, repo, git_reference_target(resolved),\n\t\tgit_reference_name(ref), NULL);\n\n\tgit_reference_free(resolved);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nint git_annotated_commit_from_ref(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_reference *ref)\n{\n\tgit_reference *resolved;\n\tint error = 0;\n\n\tassert(out && repo && ref);\n\n\t*out = NULL;\n\n\tif ((error = git_reference_resolve(&resolved, ref)) < 0)\n\t\treturn error;\n\t\n\terror = annotated_commit_init(out, repo, git_reference_target(resolved),\n\t\tgit_reference_name(ref), NULL);\n\n\tgit_reference_free(resolved);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&our_ref",
            "repo",
            "GIT_HEAD_FILE"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "\"merge\""
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_heads(\n\tgit_annotated_commit **ancestor_head_out,\n\tgit_annotated_commit **our_head_out,\n\tgit_repository *repo,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_annotated_commit *ancestor_head = NULL, *our_head = NULL;\n\tgit_reference *our_ref = NULL;\n\tint error = 0;\n\n\t*ancestor_head_out = NULL;\n\t*our_head_out = NULL;\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"merge\")) < 0)\n\t\tgoto done;\n\n\tif ((error = git_reference_lookup(&our_ref, repo, GIT_HEAD_FILE)) < 0 ||\n\t\t(error = git_annotated_commit_from_ref(&our_head, repo, our_ref)) < 0)\n\t\tgoto done;\n\n\tif ((error = merge_ancestor_head(&ancestor_head, repo, our_head, their_heads, their_heads_len)) < 0) {\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto done;\n\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\t*ancestor_head_out = ancestor_head;\n\t*our_head_out = our_head;\n\ndone:\n\tif (error < 0) {\n\t\tgit_annotated_commit_free(ancestor_head);\n\t\tgit_annotated_commit_free(our_head);\n\t}\n\n\tgit_reference_free(our_ref);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_state_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2847-2856",
    "snippet": "static int merge_state_cleanup(git_repository *repo)\n{\n\tconst char *state_files[] = {\n\t\tGIT_MERGE_HEAD_FILE,\n\t\tGIT_MERGE_MODE_FILE,\n\t\tGIT_MERGE_MSG_FILE,\n\t};\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_repository__cleanup_files",
          "args": [
            "repo",
            "state_files",
            "ARRAY_SIZE(state_files)"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cleanup_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "2252-2279",
          "snippet": "int git_repository__cleanup_files(\n\tgit_repository *repo, const char *files[], size_t files_len)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t i;\n\tint error;\n\n\tfor (error = 0, i = 0; !error && i < files_len; ++i) {\n\t\tconst char *path;\n\n\t\tif (git_buf_joinpath(&buf, repo->path_repository, files[i]) < 0)\n\t\t\treturn -1;\n\n\t\tpath = git_buf_cstr(&buf);\n\n\t\tif (git_path_isfile(path)) {\n\t\t\terror = p_unlink(path);\n\t\t} else if (git_path_isdir(path)) {\n\t\t\terror = git_futils_rmdir_r(path, NULL,\n\t\t\t\tGIT_RMDIR_REMOVE_FILES | GIT_RMDIR_REMOVE_BLOCKERS);\n\t\t}\n\t\t\t\n\t\tgit_buf_clear(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository__cleanup_files(\n\tgit_repository *repo, const char *files[], size_t files_len)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t i;\n\tint error;\n\n\tfor (error = 0, i = 0; !error && i < files_len; ++i) {\n\t\tconst char *path;\n\n\t\tif (git_buf_joinpath(&buf, repo->path_repository, files[i]) < 0)\n\t\t\treturn -1;\n\n\t\tpath = git_buf_cstr(&buf);\n\n\t\tif (git_path_isfile(path)) {\n\t\t\terror = p_unlink(path);\n\t\t} else if (git_path_isdir(path)) {\n\t\t\terror = git_futils_rmdir_r(path, NULL,\n\t\t\t\tGIT_RMDIR_REMOVE_FILES | GIT_RMDIR_REMOVE_BLOCKERS);\n\t\t}\n\t\t\t\n\t\tgit_buf_clear(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "state_files"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_state_cleanup(git_repository *repo)\n{\n\tconst char *state_files[] = {\n\t\tGIT_MERGE_HEAD_FILE,\n\t\tGIT_MERGE_MODE_FILE,\n\t\tGIT_MERGE_MSG_FILE,\n\t};\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}"
  },
  {
    "function_name": "git_merge__append_conflicts_to_merge_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2805-2845",
    "snippet": "int git_merge__append_conflicts_to_merge_msg(\n\tgit_repository *repo,\n\tgit_index *index)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tconst char *last = NULL;\n\tsize_t i;\n\tint error;\n\n\tif (!git_index_has_conflicts(index))\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_APPEND, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tgit_filebuf_printf(&file, \"\\nConflicts:\\n\");\n\n\tfor (i = 0; i < git_index_entrycount(index); i++) {\n\t\tconst git_index_entry *e = git_index_get_byindex(index, i);\n\n\t\tif (!git_index_entry_is_conflict(e))\n\t\t\tcontinue;\n\n\t\tif (last == NULL || strcmp(e->path, last) != 0)\n\t\t\tgit_filebuf_printf(&file, \"\\t%s\\n\", e->path);\n\n\t\tlast = e->path;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&file_path"
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&file"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "&file",
            "\"\\t%s\\n\"",
            "e->path"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "e->path",
            "last"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_is_conflict",
          "args": [
            "e"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_is_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2809-2812",
          "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_get_byindex",
          "args": [
            "index",
            "i"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_get_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "799-805",
          "snippet": "const git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entrycount",
          "args": [
            "index"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "793-797",
          "snippet": "size_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nsize_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&file",
            "file_path.ptr",
            "GIT_FILEBUF_APPEND",
            "GIT_MERGE_FILE_MODE"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&file_path",
            "repo->path_repository",
            "GIT_MERGE_MSG_FILE"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_has_conflicts",
          "args": [
            "index"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_has_conflicts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1887-1900",
          "snippet": "int git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge__append_conflicts_to_merge_msg(\n\tgit_repository *repo,\n\tgit_index *index)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tconst char *last = NULL;\n\tsize_t i;\n\tint error;\n\n\tif (!git_index_has_conflicts(index))\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_APPEND, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tgit_filebuf_printf(&file, \"\\nConflicts:\\n\");\n\n\tfor (i = 0; i < git_index_entrycount(index); i++) {\n\t\tconst git_index_entry *e = git_index_get_byindex(index, i);\n\n\t\tif (!git_index_entry_is_conflict(e))\n\t\t\tcontinue;\n\n\t\tif (last == NULL || strcmp(e->path, last) != 0)\n\t\t\tgit_filebuf_printf(&file, \"\\t%s\\n\", e->path);\n\n\t\tlast = e->path;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_merge__check_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2746-2803",
    "snippet": "int git_merge__check_result(git_repository *repo, git_index *index_new)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_iterator *iter_head = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *merged_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_delta *delta;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tsize_t i, index_conflicts = 0, wd_conflicts = 0, conflicts;\n\tconst git_index_entry *e;\n\tint error = 0;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_iterator_for_tree(&iter_head, head_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&merged_list, repo, iter_head, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&merged_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < git_index_entrycount(index_new); i++) {\n\t\te = git_index_get_byindex(index_new, i);\n\n\t\tif (git_index_entry_is_conflict(e) &&\n\t\t\t(git_vector_last(&paths) == NULL ||\n\t\t\tstrcmp(git_vector_last(&paths), e->path) != 0)) {\n\n\t\t\tif ((error = git_vector_insert(&paths, (char *)e->path)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Make sure the index and workdir state do not prevent merging */\n\tif ((error = merge_check_index(&index_conflicts, repo, index_new, &paths)) < 0 ||\n\t\t(error = merge_check_workdir(&wd_conflicts, repo, index_new, &paths)) < 0)\n\t\tgoto done;\n\n\tif ((conflicts = index_conflicts + wd_conflicts) > 0) {\n\t\tgiterr_set(GITERR_MERGE, \"%\" PRIuZ \" uncommitted change%s would be overwritten by merge\",\n\t\t\tconflicts, (conflicts != 1) ? \"s\" : \"\");\n\t\terror = GIT_ECONFLICT;\n\t}\n\ndone:\n\tgit_vector_free(&paths);\n\tgit_tree_free(head_tree);\n\tgit_iterator_free(iter_head);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(merged_list);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "merged_list"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "iter_new"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "head_tree"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&paths"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_MERGE",
            "\"%\" PRIuZ \" uncommitted change%s would be overwritten by merge\"",
            "conflicts",
            "(conflicts != 1) ? \"s\" : \"\""
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_check_workdir",
          "args": [
            "&wd_conflicts",
            "repo",
            "index_new",
            "&paths"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "merge_check_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2704-2744",
          "snippet": "static int merge_check_workdir(size_t *conflicts, git_repository *repo, git_index *index_new, git_vector *merged_paths)\n{\n\tgit_diff *wd_diff_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tint error = 0;\n\n\tGIT_UNUSED(index_new);\n\n\t*conflicts = 0;\n\n\t/* We need to have merged at least 1 file for the possibility to exist to\n\t * have conflicts with the workdir. Passing 0 as the pathspec count paramter\n\t * will consider all files in the working directory, that is, we may detect\n\t * a conflict if there were untracked files in the workdir prior to starting\n\t * the merge. This typically happens when cherry-picking a commmit whose\n\t * changes have already been applied.\n\t */\n\tif (merged_paths->length == 0)\n\t\treturn 0;\n\n\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t/* Workdir changes may exist iff they do not conflict with changes that\n\t * will be applied by the merge (including conflicts).  Ensure that there\n\t * are no changes in the workdir to these paths.\n\t */\n\topts.flags |= GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\topts.pathspec.count = merged_paths->length;\n\topts.pathspec.strings = (char **)merged_paths->contents;\n\topts.ignore_submodules = GIT_SUBMODULE_IGNORE_ALL;\n\n\tif ((error = git_diff_index_to_workdir(&wd_diff_list, repo, NULL, &opts)) < 0)\n\t\tgoto done;\n\n\t*conflicts = wd_diff_list->deltas.length;\n\ndone:\n\tgit_diff_free(wd_diff_list);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_check_workdir(size_t *conflicts, git_repository *repo, git_index *index_new, git_vector *merged_paths)\n{\n\tgit_diff *wd_diff_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tint error = 0;\n\n\tGIT_UNUSED(index_new);\n\n\t*conflicts = 0;\n\n\t/* We need to have merged at least 1 file for the possibility to exist to\n\t * have conflicts with the workdir. Passing 0 as the pathspec count paramter\n\t * will consider all files in the working directory, that is, we may detect\n\t * a conflict if there were untracked files in the workdir prior to starting\n\t * the merge. This typically happens when cherry-picking a commmit whose\n\t * changes have already been applied.\n\t */\n\tif (merged_paths->length == 0)\n\t\treturn 0;\n\n\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t/* Workdir changes may exist iff they do not conflict with changes that\n\t * will be applied by the merge (including conflicts).  Ensure that there\n\t * are no changes in the workdir to these paths.\n\t */\n\topts.flags |= GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\topts.pathspec.count = merged_paths->length;\n\topts.pathspec.strings = (char **)merged_paths->contents;\n\topts.ignore_submodules = GIT_SUBMODULE_IGNORE_ALL;\n\n\tif ((error = git_diff_index_to_workdir(&wd_diff_list, repo, NULL, &opts)) < 0)\n\t\tgoto done;\n\n\t*conflicts = wd_diff_list->deltas.length;\n\ndone:\n\tgit_diff_free(wd_diff_list);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_check_index",
          "args": [
            "&index_conflicts",
            "repo",
            "index_new",
            "&paths"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "merge_check_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2646-2702",
          "snippet": "static int merge_check_index(size_t *conflicts, git_repository *repo, git_index *index_new, git_vector *merged_paths)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_index *index_repo = NULL;\n\tgit_iterator *iter_repo = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *staged_diff_list = NULL, *index_diff_list = NULL;\n\tgit_diff_delta *delta;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_vector staged_paths = GIT_VECTOR_INIT;\n\tsize_t i;\n\tint error = 0;\n\n\tGIT_UNUSED(merged_paths);\n\n\t*conflicts = 0;\n\n\t/* No staged changes may exist unless the change staged is identical to\n\t * the result of the merge.  This allows one to apply to merge manually,\n\t * then run merge.  Any other staged change would be overwritten by\n\t * a reset merge.\n\t */\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_repository_index(&index_repo, repo)) < 0 ||\n\t\t(error = git_diff_tree_to_index(&staged_diff_list, repo, head_tree, index_repo, &opts)) < 0)\n\t\tgoto done;\n\n\tif (staged_diff_list->deltas.length == 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&staged_diff_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&staged_paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\titer_opts.pathlist.strings = (char **)staged_paths.contents;\n\titer_opts.pathlist.count = staged_paths.length;\n\n\tif ((error = git_iterator_for_index(&iter_repo, repo, index_repo, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&index_diff_list, repo, iter_repo, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\t*conflicts = index_diff_list->deltas.length;\n\ndone:\n\tgit_tree_free(head_tree);\n\tgit_index_free(index_repo);\n\tgit_iterator_free(iter_repo);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(staged_diff_list);\n\tgit_diff_free(index_diff_list);\n\tgit_vector_free(&staged_paths);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_check_index(size_t *conflicts, git_repository *repo, git_index *index_new, git_vector *merged_paths)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_index *index_repo = NULL;\n\tgit_iterator *iter_repo = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *staged_diff_list = NULL, *index_diff_list = NULL;\n\tgit_diff_delta *delta;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_vector staged_paths = GIT_VECTOR_INIT;\n\tsize_t i;\n\tint error = 0;\n\n\tGIT_UNUSED(merged_paths);\n\n\t*conflicts = 0;\n\n\t/* No staged changes may exist unless the change staged is identical to\n\t * the result of the merge.  This allows one to apply to merge manually,\n\t * then run merge.  Any other staged change would be overwritten by\n\t * a reset merge.\n\t */\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_repository_index(&index_repo, repo)) < 0 ||\n\t\t(error = git_diff_tree_to_index(&staged_diff_list, repo, head_tree, index_repo, &opts)) < 0)\n\t\tgoto done;\n\n\tif (staged_diff_list->deltas.length == 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&staged_diff_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&staged_paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\titer_opts.pathlist.strings = (char **)staged_paths.contents;\n\titer_opts.pathlist.count = staged_paths.length;\n\n\tif ((error = git_iterator_for_index(&iter_repo, repo, index_repo, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&index_diff_list, repo, iter_repo, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\t*conflicts = index_diff_list->deltas.length;\n\ndone:\n\tgit_tree_free(head_tree);\n\tgit_index_free(index_repo);\n\tgit_iterator_free(iter_repo);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(staged_diff_list);\n\tgit_diff_free(index_diff_list);\n\tgit_vector_free(&staged_paths);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&paths",
            "(char *)e->path"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "git_vector_last(&paths)",
            "e->path"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_last",
          "args": [
            "&paths"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "72-75",
          "snippet": "GIT_INLINE(void *) git_vector_last(const git_vector *v)\n{\n\treturn (v->length > 0) ? git_vector_get(v, v->length - 1) : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_last(const git_vector *v)\n{\n\treturn (v->length > 0) ? git_vector_get(v, v->length - 1) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_is_conflict",
          "args": [
            "e"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_is_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2809-2812",
          "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_get_byindex",
          "args": [
            "index_new",
            "i"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_get_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "799-805",
          "snippet": "const git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entrycount",
          "args": [
            "index_new"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "793-797",
          "snippet": "size_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nsize_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&merged_list->deltas",
            "i",
            "delta"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_diff__from_iterators",
          "args": [
            "&merged_list",
            "repo",
            "iter_head",
            "iter_new",
            "&opts"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__from_iterators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1212-1289",
          "snippet": "int git_diff__from_iterators(\n\tgit_diff **diff_ptr,\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tdiff_in_progress info;\n\tgit_diff *diff;\n\n\t*diff_ptr = NULL;\n\n\tdiff = diff_list_alloc(repo, old_iter, new_iter);\n\tGITERR_CHECK_ALLOC(diff);\n\n\tinfo.repo = repo;\n\tinfo.old_iter = old_iter;\n\tinfo.new_iter = new_iter;\n\n\t/* make iterators have matching icase behavior */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE)) {\n\t\tif ((error = git_iterator_set_ignore_case(old_iter, true)) < 0 ||\n\t\t\t(error = git_iterator_set_ignore_case(new_iter, true)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* finish initialization */\n\tif ((error = diff_list_apply_options(diff, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = iterator_current(&info.oitem, old_iter)) < 0 ||\n\t\t(error = iterator_current(&info.nitem, new_iter)) < 0)\n\t\tgoto cleanup;\n\n\t/* run iterators building diffs */\n\twhile (!error && (info.oitem || info.nitem)) {\n\t\tint cmp;\n\n\t\t/* report progress */\n\t\tif (opts && opts->progress_cb) {\n\t\t\tif ((error = opts->progress_cb(diff,\n\t\t\t\t\tinfo.oitem ? info.oitem->path : NULL,\n\t\t\t\t\tinfo.nitem ? info.nitem->path : NULL,\n\t\t\t\t\topts->payload)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcmp = info.oitem ?\n\t\t\t(info.nitem ? diff->entrycomp(info.oitem, info.nitem) : -1) : 1;\n\n\t\t/* create DELETED records for old items not matched in new */\n\t\tif (cmp < 0)\n\t\t\terror = handle_unmatched_old_item(diff, &info);\n\n\t\t/* create ADDED, TRACKED, or IGNORED records for new items not\n\t\t * matched in old (and/or descend into directories as needed)\n\t\t */\n\t\telse if (cmp > 0)\n\t\t\terror = handle_unmatched_new_item(diff, &info);\n\n\t\t/* otherwise item paths match, so create MODIFIED record\n\t\t * (or ADDED and DELETED pair if type changed)\n\t\t */\n\t\telse\n\t\t\terror = handle_matched_item(diff, &info);\n\t}\n\n\tdiff->perf.stat_calls += old_iter->stat_calls + new_iter->stat_calls;\n\ncleanup:\n\tif (!error)\n\t\t*diff_ptr = diff;\n\telse\n\t\tgit_diff_free(diff);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__from_iterators(\n\tgit_diff **diff_ptr,\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tdiff_in_progress info;\n\tgit_diff *diff;\n\n\t*diff_ptr = NULL;\n\n\tdiff = diff_list_alloc(repo, old_iter, new_iter);\n\tGITERR_CHECK_ALLOC(diff);\n\n\tinfo.repo = repo;\n\tinfo.old_iter = old_iter;\n\tinfo.new_iter = new_iter;\n\n\t/* make iterators have matching icase behavior */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE)) {\n\t\tif ((error = git_iterator_set_ignore_case(old_iter, true)) < 0 ||\n\t\t\t(error = git_iterator_set_ignore_case(new_iter, true)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* finish initialization */\n\tif ((error = diff_list_apply_options(diff, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = iterator_current(&info.oitem, old_iter)) < 0 ||\n\t\t(error = iterator_current(&info.nitem, new_iter)) < 0)\n\t\tgoto cleanup;\n\n\t/* run iterators building diffs */\n\twhile (!error && (info.oitem || info.nitem)) {\n\t\tint cmp;\n\n\t\t/* report progress */\n\t\tif (opts && opts->progress_cb) {\n\t\t\tif ((error = opts->progress_cb(diff,\n\t\t\t\t\tinfo.oitem ? info.oitem->path : NULL,\n\t\t\t\t\tinfo.nitem ? info.nitem->path : NULL,\n\t\t\t\t\topts->payload)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcmp = info.oitem ?\n\t\t\t(info.nitem ? diff->entrycomp(info.oitem, info.nitem) : -1) : 1;\n\n\t\t/* create DELETED records for old items not matched in new */\n\t\tif (cmp < 0)\n\t\t\terror = handle_unmatched_old_item(diff, &info);\n\n\t\t/* create ADDED, TRACKED, or IGNORED records for new items not\n\t\t * matched in old (and/or descend into directories as needed)\n\t\t */\n\t\telse if (cmp > 0)\n\t\t\terror = handle_unmatched_new_item(diff, &info);\n\n\t\t/* otherwise item paths match, so create MODIFIED record\n\t\t * (or ADDED and DELETED pair if type changed)\n\t\t */\n\t\telse\n\t\t\terror = handle_matched_item(diff, &info);\n\t}\n\n\tdiff->perf.stat_calls += old_iter->stat_calls + new_iter->stat_calls;\n\ncleanup:\n\tif (!error)\n\t\t*diff_ptr = diff;\n\telse\n\t\tgit_diff_free(diff);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "&iter_new",
            "repo",
            "index_new",
            "&iter_opts"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "&iter_head",
            "head_tree",
            "&iter_opts"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head_tree",
          "args": [
            "&head_tree",
            "repo"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge__check_result(git_repository *repo, git_index *index_new)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_iterator *iter_head = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *merged_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_delta *delta;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tsize_t i, index_conflicts = 0, wd_conflicts = 0, conflicts;\n\tconst git_index_entry *e;\n\tint error = 0;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_iterator_for_tree(&iter_head, head_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&merged_list, repo, iter_head, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&merged_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < git_index_entrycount(index_new); i++) {\n\t\te = git_index_get_byindex(index_new, i);\n\n\t\tif (git_index_entry_is_conflict(e) &&\n\t\t\t(git_vector_last(&paths) == NULL ||\n\t\t\tstrcmp(git_vector_last(&paths), e->path) != 0)) {\n\n\t\t\tif ((error = git_vector_insert(&paths, (char *)e->path)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Make sure the index and workdir state do not prevent merging */\n\tif ((error = merge_check_index(&index_conflicts, repo, index_new, &paths)) < 0 ||\n\t\t(error = merge_check_workdir(&wd_conflicts, repo, index_new, &paths)) < 0)\n\t\tgoto done;\n\n\tif ((conflicts = index_conflicts + wd_conflicts) > 0) {\n\t\tgiterr_set(GITERR_MERGE, \"%\" PRIuZ \" uncommitted change%s would be overwritten by merge\",\n\t\t\tconflicts, (conflicts != 1) ? \"s\" : \"\");\n\t\terror = GIT_ECONFLICT;\n\t}\n\ndone:\n\tgit_vector_free(&paths);\n\tgit_tree_free(head_tree);\n\tgit_iterator_free(iter_head);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(merged_list);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_check_workdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2704-2744",
    "snippet": "static int merge_check_workdir(size_t *conflicts, git_repository *repo, git_index *index_new, git_vector *merged_paths)\n{\n\tgit_diff *wd_diff_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tint error = 0;\n\n\tGIT_UNUSED(index_new);\n\n\t*conflicts = 0;\n\n\t/* We need to have merged at least 1 file for the possibility to exist to\n\t * have conflicts with the workdir. Passing 0 as the pathspec count paramter\n\t * will consider all files in the working directory, that is, we may detect\n\t * a conflict if there were untracked files in the workdir prior to starting\n\t * the merge. This typically happens when cherry-picking a commmit whose\n\t * changes have already been applied.\n\t */\n\tif (merged_paths->length == 0)\n\t\treturn 0;\n\n\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t/* Workdir changes may exist iff they do not conflict with changes that\n\t * will be applied by the merge (including conflicts).  Ensure that there\n\t * are no changes in the workdir to these paths.\n\t */\n\topts.flags |= GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\topts.pathspec.count = merged_paths->length;\n\topts.pathspec.strings = (char **)merged_paths->contents;\n\topts.ignore_submodules = GIT_SUBMODULE_IGNORE_ALL;\n\n\tif ((error = git_diff_index_to_workdir(&wd_diff_list, repo, NULL, &opts)) < 0)\n\t\tgoto done;\n\n\t*conflicts = wd_diff_list->deltas.length;\n\ndone:\n\tgit_diff_free(wd_diff_list);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "wd_diff_list"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_index_to_workdir",
          "args": [
            "&wd_diff_list",
            "repo",
            "NULL",
            "&opts"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_index_to_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1384-1409",
          "snippet": "int git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "index_new"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_check_workdir(size_t *conflicts, git_repository *repo, git_index *index_new, git_vector *merged_paths)\n{\n\tgit_diff *wd_diff_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tint error = 0;\n\n\tGIT_UNUSED(index_new);\n\n\t*conflicts = 0;\n\n\t/* We need to have merged at least 1 file for the possibility to exist to\n\t * have conflicts with the workdir. Passing 0 as the pathspec count paramter\n\t * will consider all files in the working directory, that is, we may detect\n\t * a conflict if there were untracked files in the workdir prior to starting\n\t * the merge. This typically happens when cherry-picking a commmit whose\n\t * changes have already been applied.\n\t */\n\tif (merged_paths->length == 0)\n\t\treturn 0;\n\n\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t/* Workdir changes may exist iff they do not conflict with changes that\n\t * will be applied by the merge (including conflicts).  Ensure that there\n\t * are no changes in the workdir to these paths.\n\t */\n\topts.flags |= GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\topts.pathspec.count = merged_paths->length;\n\topts.pathspec.strings = (char **)merged_paths->contents;\n\topts.ignore_submodules = GIT_SUBMODULE_IGNORE_ALL;\n\n\tif ((error = git_diff_index_to_workdir(&wd_diff_list, repo, NULL, &opts)) < 0)\n\t\tgoto done;\n\n\t*conflicts = wd_diff_list->deltas.length;\n\ndone:\n\tgit_diff_free(wd_diff_list);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_check_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2646-2702",
    "snippet": "static int merge_check_index(size_t *conflicts, git_repository *repo, git_index *index_new, git_vector *merged_paths)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_index *index_repo = NULL;\n\tgit_iterator *iter_repo = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *staged_diff_list = NULL, *index_diff_list = NULL;\n\tgit_diff_delta *delta;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_vector staged_paths = GIT_VECTOR_INIT;\n\tsize_t i;\n\tint error = 0;\n\n\tGIT_UNUSED(merged_paths);\n\n\t*conflicts = 0;\n\n\t/* No staged changes may exist unless the change staged is identical to\n\t * the result of the merge.  This allows one to apply to merge manually,\n\t * then run merge.  Any other staged change would be overwritten by\n\t * a reset merge.\n\t */\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_repository_index(&index_repo, repo)) < 0 ||\n\t\t(error = git_diff_tree_to_index(&staged_diff_list, repo, head_tree, index_repo, &opts)) < 0)\n\t\tgoto done;\n\n\tif (staged_diff_list->deltas.length == 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&staged_diff_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&staged_paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\titer_opts.pathlist.strings = (char **)staged_paths.contents;\n\titer_opts.pathlist.count = staged_paths.length;\n\n\tif ((error = git_iterator_for_index(&iter_repo, repo, index_repo, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&index_diff_list, repo, iter_repo, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\t*conflicts = index_diff_list->deltas.length;\n\ndone:\n\tgit_tree_free(head_tree);\n\tgit_index_free(index_repo);\n\tgit_iterator_free(iter_repo);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(staged_diff_list);\n\tgit_diff_free(index_diff_list);\n\tgit_vector_free(&staged_paths);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&staged_paths"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "index_diff_list"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "iter_new"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index_repo"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "head_tree"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff__from_iterators",
          "args": [
            "&index_diff_list",
            "repo",
            "iter_repo",
            "iter_new",
            "&opts"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__from_iterators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1212-1289",
          "snippet": "int git_diff__from_iterators(\n\tgit_diff **diff_ptr,\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tdiff_in_progress info;\n\tgit_diff *diff;\n\n\t*diff_ptr = NULL;\n\n\tdiff = diff_list_alloc(repo, old_iter, new_iter);\n\tGITERR_CHECK_ALLOC(diff);\n\n\tinfo.repo = repo;\n\tinfo.old_iter = old_iter;\n\tinfo.new_iter = new_iter;\n\n\t/* make iterators have matching icase behavior */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE)) {\n\t\tif ((error = git_iterator_set_ignore_case(old_iter, true)) < 0 ||\n\t\t\t(error = git_iterator_set_ignore_case(new_iter, true)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* finish initialization */\n\tif ((error = diff_list_apply_options(diff, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = iterator_current(&info.oitem, old_iter)) < 0 ||\n\t\t(error = iterator_current(&info.nitem, new_iter)) < 0)\n\t\tgoto cleanup;\n\n\t/* run iterators building diffs */\n\twhile (!error && (info.oitem || info.nitem)) {\n\t\tint cmp;\n\n\t\t/* report progress */\n\t\tif (opts && opts->progress_cb) {\n\t\t\tif ((error = opts->progress_cb(diff,\n\t\t\t\t\tinfo.oitem ? info.oitem->path : NULL,\n\t\t\t\t\tinfo.nitem ? info.nitem->path : NULL,\n\t\t\t\t\topts->payload)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcmp = info.oitem ?\n\t\t\t(info.nitem ? diff->entrycomp(info.oitem, info.nitem) : -1) : 1;\n\n\t\t/* create DELETED records for old items not matched in new */\n\t\tif (cmp < 0)\n\t\t\terror = handle_unmatched_old_item(diff, &info);\n\n\t\t/* create ADDED, TRACKED, or IGNORED records for new items not\n\t\t * matched in old (and/or descend into directories as needed)\n\t\t */\n\t\telse if (cmp > 0)\n\t\t\terror = handle_unmatched_new_item(diff, &info);\n\n\t\t/* otherwise item paths match, so create MODIFIED record\n\t\t * (or ADDED and DELETED pair if type changed)\n\t\t */\n\t\telse\n\t\t\terror = handle_matched_item(diff, &info);\n\t}\n\n\tdiff->perf.stat_calls += old_iter->stat_calls + new_iter->stat_calls;\n\ncleanup:\n\tif (!error)\n\t\t*diff_ptr = diff;\n\telse\n\t\tgit_diff_free(diff);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__from_iterators(\n\tgit_diff **diff_ptr,\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tdiff_in_progress info;\n\tgit_diff *diff;\n\n\t*diff_ptr = NULL;\n\n\tdiff = diff_list_alloc(repo, old_iter, new_iter);\n\tGITERR_CHECK_ALLOC(diff);\n\n\tinfo.repo = repo;\n\tinfo.old_iter = old_iter;\n\tinfo.new_iter = new_iter;\n\n\t/* make iterators have matching icase behavior */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE)) {\n\t\tif ((error = git_iterator_set_ignore_case(old_iter, true)) < 0 ||\n\t\t\t(error = git_iterator_set_ignore_case(new_iter, true)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* finish initialization */\n\tif ((error = diff_list_apply_options(diff, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = iterator_current(&info.oitem, old_iter)) < 0 ||\n\t\t(error = iterator_current(&info.nitem, new_iter)) < 0)\n\t\tgoto cleanup;\n\n\t/* run iterators building diffs */\n\twhile (!error && (info.oitem || info.nitem)) {\n\t\tint cmp;\n\n\t\t/* report progress */\n\t\tif (opts && opts->progress_cb) {\n\t\t\tif ((error = opts->progress_cb(diff,\n\t\t\t\t\tinfo.oitem ? info.oitem->path : NULL,\n\t\t\t\t\tinfo.nitem ? info.nitem->path : NULL,\n\t\t\t\t\topts->payload)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcmp = info.oitem ?\n\t\t\t(info.nitem ? diff->entrycomp(info.oitem, info.nitem) : -1) : 1;\n\n\t\t/* create DELETED records for old items not matched in new */\n\t\tif (cmp < 0)\n\t\t\terror = handle_unmatched_old_item(diff, &info);\n\n\t\t/* create ADDED, TRACKED, or IGNORED records for new items not\n\t\t * matched in old (and/or descend into directories as needed)\n\t\t */\n\t\telse if (cmp > 0)\n\t\t\terror = handle_unmatched_new_item(diff, &info);\n\n\t\t/* otherwise item paths match, so create MODIFIED record\n\t\t * (or ADDED and DELETED pair if type changed)\n\t\t */\n\t\telse\n\t\t\terror = handle_matched_item(diff, &info);\n\t}\n\n\tdiff->perf.stat_calls += old_iter->stat_calls + new_iter->stat_calls;\n\ncleanup:\n\tif (!error)\n\t\t*diff_ptr = diff;\n\telse\n\t\tgit_diff_free(diff);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "&iter_new",
            "repo",
            "index_new",
            "&iter_opts"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&staged_paths",
            "(char *)delta->new_file.path"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&staged_diff_list->deltas",
            "i",
            "delta"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_index",
          "args": [
            "&staged_diff_list",
            "repo",
            "head_tree",
            "index_repo",
            "&opts"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1353-1382",
          "snippet": "int git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index",
          "args": [
            "&index_repo",
            "repo"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "852-859",
          "snippet": "int git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head_tree",
          "args": [
            "&head_tree",
            "repo"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "merged_paths"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_check_index(size_t *conflicts, git_repository *repo, git_index *index_new, git_vector *merged_paths)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_index *index_repo = NULL;\n\tgit_iterator *iter_repo = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *staged_diff_list = NULL, *index_diff_list = NULL;\n\tgit_diff_delta *delta;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_vector staged_paths = GIT_VECTOR_INIT;\n\tsize_t i;\n\tint error = 0;\n\n\tGIT_UNUSED(merged_paths);\n\n\t*conflicts = 0;\n\n\t/* No staged changes may exist unless the change staged is identical to\n\t * the result of the merge.  This allows one to apply to merge manually,\n\t * then run merge.  Any other staged change would be overwritten by\n\t * a reset merge.\n\t */\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_repository_index(&index_repo, repo)) < 0 ||\n\t\t(error = git_diff_tree_to_index(&staged_diff_list, repo, head_tree, index_repo, &opts)) < 0)\n\t\tgoto done;\n\n\tif (staged_diff_list->deltas.length == 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&staged_diff_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&staged_paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\titer_opts.pathlist.strings = (char **)staged_paths.contents;\n\titer_opts.pathlist.count = staged_paths.length;\n\n\tif ((error = git_iterator_for_index(&iter_repo, repo, index_repo, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&index_diff_list, repo, iter_repo, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\t*conflicts = index_diff_list->deltas.length;\n\ndone:\n\tgit_tree_free(head_tree);\n\tgit_index_free(index_repo);\n\tgit_iterator_free(iter_repo);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(staged_diff_list);\n\tgit_diff_free(index_diff_list);\n\tgit_vector_free(&staged_paths);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_normalize_checkout_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2596-2644",
    "snippet": "static int merge_normalize_checkout_opts(\n\tgit_checkout_options *out,\n\tgit_repository *repo,\n\tconst git_checkout_options *given_checkout_opts,\n\tunsigned int checkout_strategy,\n\tgit_annotated_commit *ancestor,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_checkout_options default_checkout_opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tint error = 0;\n\n\tGIT_UNUSED(repo);\n\n\tif (given_checkout_opts != NULL)\n\t\tmemcpy(out, given_checkout_opts, sizeof(git_checkout_options));\n\telse\n\t\tmemcpy(out, &default_checkout_opts, sizeof(git_checkout_options));\n\n\tout->checkout_strategy = checkout_strategy;\n\n\tif (!out->ancestor_label) {\n\t\tif (ancestor && ancestor->type == GIT_ANNOTATED_COMMIT_REAL)\n\t\t\tout->ancestor_label = git_commit_summary(ancestor->commit);\n\t\telse if (ancestor)\n\t\t\tout->ancestor_label = \"merged common ancestors\";\n\t\telse\n\t\t\tout->ancestor_label = \"empty base\";\n\t}\n\n\tif (!out->our_label) {\n\t\tif (our_head && our_head->ref_name)\n\t\t\tout->our_label = our_head->ref_name;\n\t\telse\n\t\t\tout->our_label = \"ours\";\n\t}\n\n\tif (!out->their_label) {\n\t\tif (their_heads_len == 1 && their_heads[0]->ref_name)\n\t\t\tout->their_label = merge_their_label(their_heads[0]->ref_name);\n\t\telse if (their_heads_len == 1)\n\t\t\tout->their_label = their_heads[0]->id_str;\n\t\telse\n\t\t\tout->their_label = \"theirs\";\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_their_label",
          "args": [
            "their_heads[0]->ref_name"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "merge_their_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2583-2594",
          "snippet": "const char *merge_their_label(const char *branchname)\n{\n\tconst char *slash;\n\n\tif ((slash = strrchr(branchname, '/')) == NULL)\n\t\treturn branchname;\n\n\tif (*(slash+1) == '\\0')\n\t\treturn \"theirs\";\n\n\treturn slash+1;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nconst char *merge_their_label(const char *branchname)\n{\n\tconst char *slash;\n\n\tif ((slash = strrchr(branchname, '/')) == NULL)\n\t\treturn branchname;\n\n\tif (*(slash+1) == '\\0')\n\t\treturn \"theirs\";\n\n\treturn slash+1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_summary",
          "args": [
            "ancestor->commit"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "458-501",
          "snippet": "const char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "&default_checkout_opts",
            "sizeof(git_checkout_options)"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "given_checkout_opts",
            "sizeof(git_checkout_options)"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "repo"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_normalize_checkout_opts(\n\tgit_checkout_options *out,\n\tgit_repository *repo,\n\tconst git_checkout_options *given_checkout_opts,\n\tunsigned int checkout_strategy,\n\tgit_annotated_commit *ancestor,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_checkout_options default_checkout_opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tint error = 0;\n\n\tGIT_UNUSED(repo);\n\n\tif (given_checkout_opts != NULL)\n\t\tmemcpy(out, given_checkout_opts, sizeof(git_checkout_options));\n\telse\n\t\tmemcpy(out, &default_checkout_opts, sizeof(git_checkout_options));\n\n\tout->checkout_strategy = checkout_strategy;\n\n\tif (!out->ancestor_label) {\n\t\tif (ancestor && ancestor->type == GIT_ANNOTATED_COMMIT_REAL)\n\t\t\tout->ancestor_label = git_commit_summary(ancestor->commit);\n\t\telse if (ancestor)\n\t\t\tout->ancestor_label = \"merged common ancestors\";\n\t\telse\n\t\t\tout->ancestor_label = \"empty base\";\n\t}\n\n\tif (!out->our_label) {\n\t\tif (our_head && our_head->ref_name)\n\t\t\tout->our_label = our_head->ref_name;\n\t\telse\n\t\t\tout->our_label = \"ours\";\n\t}\n\n\tif (!out->their_label) {\n\t\tif (their_heads_len == 1 && their_heads[0]->ref_name)\n\t\t\tout->their_label = merge_their_label(their_heads[0]->ref_name);\n\t\telse if (their_heads_len == 1)\n\t\t\tout->their_label = their_heads[0]->id_str;\n\t\telse\n\t\t\tout->their_label = \"theirs\";\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_their_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2583-2594",
    "snippet": "const char *merge_their_label(const char *branchname)\n{\n\tconst char *slash;\n\n\tif ((slash = strrchr(branchname, '/')) == NULL)\n\t\treturn branchname;\n\n\tif (*(slash+1) == '\\0')\n\t\treturn \"theirs\";\n\n\treturn slash+1;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "branchname",
            "'/'"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nconst char *merge_their_label(const char *branchname)\n{\n\tconst char *slash;\n\n\tif ((slash = strrchr(branchname, '/')) == NULL)\n\t\treturn branchname;\n\n\tif (*(slash+1) == '\\0')\n\t\treturn \"theirs\";\n\n\treturn slash+1;\n}"
  },
  {
    "function_name": "merge_ancestor_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2551-2581",
    "snippet": "static int merge_ancestor_head(\n\tgit_annotated_commit **ancestor_head,\n\tgit_repository *repo,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_oid *oids, ancestor_oid;\n\tsize_t i, alloc_len;\n\tint error = 0;\n\n\tassert(repo && our_head && their_heads);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, their_heads_len, 1);\n\toids = git__calloc(alloc_len, sizeof(git_oid));\n\tGITERR_CHECK_ALLOC(oids);\n\n\tgit_oid_cpy(&oids[0], git_commit_id(our_head->commit));\n\n\tfor (i = 0; i < their_heads_len; i++)\n\t\tgit_oid_cpy(&oids[i + 1], git_annotated_commit_id(their_heads[i]));\n\n\tif ((error = git_merge_base_many(&ancestor_oid, repo, their_heads_len + 1, oids)) < 0)\n\t\tgoto on_error;\n\n\terror = git_annotated_commit_lookup(ancestor_head, repo, &ancestor_oid);\n\non_error:\n\tgit__free(oids);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "oids"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_lookup",
          "args": [
            "ancestor_head",
            "repo",
            "&ancestor_oid"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "125-133",
          "snippet": "int git_annotated_commit_lookup(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_oid *id)\n{\n\tassert(out && repo && id);\n\n\treturn annotated_commit_init(out, repo, id, NULL, NULL);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nint git_annotated_commit_lookup(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_oid *id)\n{\n\tassert(out && repo && id);\n\n\treturn annotated_commit_init(out, repo, id, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge_base_many",
          "args": [
            "&ancestor_oid",
            "repo",
            "their_heads_len + 1",
            "oids"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_base_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "133-150",
          "snippet": "int git_merge_base_many(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk;\n\tgit_commit_list *result = NULL;\n\tint error = 0;\n\n\tassert(out && repo && input_array);\n\n\tif ((error = merge_bases_many(&result, &walk, repo, length, input_array)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, &result->item->oid);\n\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_base_many(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk;\n\tgit_commit_list *result = NULL;\n\tint error = 0;\n\n\tassert(out && repo && input_array);\n\n\tif ((error = merge_bases_many(&result, &walk, repo, length, input_array)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, &result->item->oid);\n\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&oids[i + 1]",
            "git_annotated_commit_id(their_heads[i])"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_id",
          "args": [
            "their_heads[i]"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "174-179",
          "snippet": "const git_oid *git_annotated_commit_id(\n\tconst git_annotated_commit *annotated_commit)\n{\n\tassert(annotated_commit);\n\treturn git_commit_id(annotated_commit->commit);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nconst git_oid *git_annotated_commit_id(\n\tconst git_annotated_commit *annotated_commit)\n{\n\tassert(annotated_commit);\n\treturn git_commit_id(annotated_commit->commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "our_head->commit"
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "oids"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "alloc_len",
            "sizeof(git_oid)"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "their_heads_len",
            "1"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && our_head && their_heads"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_ancestor_head(\n\tgit_annotated_commit **ancestor_head,\n\tgit_repository *repo,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit **their_heads,\n\tsize_t their_heads_len)\n{\n\tgit_oid *oids, ancestor_oid;\n\tsize_t i, alloc_len;\n\tint error = 0;\n\n\tassert(repo && our_head && their_heads);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, their_heads_len, 1);\n\toids = git__calloc(alloc_len, sizeof(git_oid));\n\tGITERR_CHECK_ALLOC(oids);\n\n\tgit_oid_cpy(&oids[0], git_commit_id(our_head->commit));\n\n\tfor (i = 0; i < their_heads_len; i++)\n\t\tgit_oid_cpy(&oids[i + 1], git_annotated_commit_id(their_heads[i]));\n\n\tif ((error = git_merge_base_many(&ancestor_oid, repo, their_heads_len + 1, oids)) < 0)\n\t\tgoto on_error;\n\n\terror = git_annotated_commit_lookup(ancestor_head, repo, &ancestor_oid);\n\non_error:\n\tgit__free(oids);\n\treturn error;\n}"
  },
  {
    "function_name": "git_merge__setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2530-2547",
    "snippet": "int git_merge__setup(\n\tgit_repository *repo,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tint error = 0;\n\n\tassert (repo && our_head && heads);\n\n\tif ((error = git_repository__set_orig_head(repo, git_annotated_commit_id(our_head))) == 0 &&\n\t\t(error = write_merge_head(repo, heads, heads_len)) == 0 &&\n\t\t(error = write_merge_mode(repo)) == 0) {\n\t\terror = write_merge_msg(repo, heads, heads_len);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_merge_msg",
          "args": [
            "repo",
            "heads",
            "heads_len"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "write_merge_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2414-2528",
          "snippet": "static int write_merge_msg(\n\tgit_repository *repo,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tstruct merge_msg_entry *entries;\n\tgit_vector matching = GIT_VECTOR_INIT;\n\tsize_t i;\n\tchar sep = 0;\n\tint error = 0;\n\n\tassert(repo && heads);\n\n\tentries = git__calloc(heads_len, sizeof(struct merge_msg_entry));\n\tGITERR_CHECK_ALLOC(entries);\n\n\tif (git_vector_init(&matching, heads_len, NULL) < 0) {\n\t\tgit__free(entries);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < heads_len; i++)\n\t\tentries[i].merge_head = heads[i];\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0 ||\n\t\t(error = git_filebuf_write(&file, \"Merge \", 6)) < 0)\n\t\tgoto cleanup;\n\n\t/*\n\t * This is to emulate the format of MERGE_MSG by core git.\n\t *\n\t * Core git will write all the commits specified by OID, in the order\n\t * provided, until the first named branch or tag is reached, at which\n\t * point all branches will be written in the order provided, then all\n\t * tags, then all remote tracking branches and finally all commits that\n\t * were specified by OID that were not already written.\n\t *\n\t * Yes.  Really.\n\t */\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (!msg_entry_is_oid(&entries[i]))\n\t\t\tbreak;\n\n\t\tif ((error = git_filebuf_printf(&file,\n\t\t\t\"%scommit '%s'\", (i > 0) ? \"; \" : \"\",\n\t\t\tentries[i].merge_head->id_str)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tentries[i].written = 1;\n\t}\n\n\tif (i)\n\t\tsep = ';';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_branch)) < 0 ||\n\t\t(error = merge_msg_write_branches(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_tracking)) < 0 ||\n\t\t(error = merge_msg_write_tracking(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_tag)) < 0 ||\n\t\t(error = merge_msg_write_tags(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\t/* We should never be called with multiple remote branches, but handle\n\t * it in case we are... */\n\twhile ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_remote)) > 0) {\n\t\tif ((error = merge_msg_write_remotes(&file, &matching, sep)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (matching.length)\n\t\t\tsep =',';\n\t}\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (merge_msg_entry_written(&entries[i]))\n\t\t\tcontinue;\n\n\t\tif ((error = git_filebuf_printf(&file, \"; commit '%s'\",\n\t\t\tentries[i].merge_head->id_str)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_filebuf_printf(&file, \"\\n\")) < 0 ||\n\t\t(error = git_filebuf_commit(&file)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\tgit_vector_free(&matching);\n\tgit__free(entries);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int write_merge_msg(\n\tgit_repository *repo,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tstruct merge_msg_entry *entries;\n\tgit_vector matching = GIT_VECTOR_INIT;\n\tsize_t i;\n\tchar sep = 0;\n\tint error = 0;\n\n\tassert(repo && heads);\n\n\tentries = git__calloc(heads_len, sizeof(struct merge_msg_entry));\n\tGITERR_CHECK_ALLOC(entries);\n\n\tif (git_vector_init(&matching, heads_len, NULL) < 0) {\n\t\tgit__free(entries);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < heads_len; i++)\n\t\tentries[i].merge_head = heads[i];\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0 ||\n\t\t(error = git_filebuf_write(&file, \"Merge \", 6)) < 0)\n\t\tgoto cleanup;\n\n\t/*\n\t * This is to emulate the format of MERGE_MSG by core git.\n\t *\n\t * Core git will write all the commits specified by OID, in the order\n\t * provided, until the first named branch or tag is reached, at which\n\t * point all branches will be written in the order provided, then all\n\t * tags, then all remote tracking branches and finally all commits that\n\t * were specified by OID that were not already written.\n\t *\n\t * Yes.  Really.\n\t */\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (!msg_entry_is_oid(&entries[i]))\n\t\t\tbreak;\n\n\t\tif ((error = git_filebuf_printf(&file,\n\t\t\t\"%scommit '%s'\", (i > 0) ? \"; \" : \"\",\n\t\t\tentries[i].merge_head->id_str)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tentries[i].written = 1;\n\t}\n\n\tif (i)\n\t\tsep = ';';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_branch)) < 0 ||\n\t\t(error = merge_msg_write_branches(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_tracking)) < 0 ||\n\t\t(error = merge_msg_write_tracking(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_tag)) < 0 ||\n\t\t(error = merge_msg_write_tags(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\t/* We should never be called with multiple remote branches, but handle\n\t * it in case we are... */\n\twhile ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_remote)) > 0) {\n\t\tif ((error = merge_msg_write_remotes(&file, &matching, sep)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (matching.length)\n\t\t\tsep =',';\n\t}\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (merge_msg_entry_written(&entries[i]))\n\t\t\tcontinue;\n\n\t\tif ((error = git_filebuf_printf(&file, \"; commit '%s'\",\n\t\t\tentries[i].merge_head->id_str)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_filebuf_printf(&file, \"\\n\")) < 0 ||\n\t\t(error = git_filebuf_commit(&file)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\tgit_vector_free(&matching);\n\tgit__free(entries);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_merge_mode",
          "args": [
            "repo"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "write_merge_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2201-2225",
          "snippet": "static int write_merge_mode(git_repository *repo)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tassert(repo);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MODE_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_filebuf_write(&file, \"no-ff\", 5)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int write_merge_mode(git_repository *repo)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tassert(repo);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MODE_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_filebuf_write(&file, \"no-ff\", 5)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_merge_head",
          "args": [
            "repo",
            "heads",
            "heads_len"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "write_merge_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2169-2199",
          "snippet": "static int write_merge_head(\n\tgit_repository *repo,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(repo && heads);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_HEAD_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif ((error = git_filebuf_printf(&file, \"%s\\n\", heads[i]->id_str)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int write_merge_head(\n\tgit_repository *repo,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(repo && heads);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_HEAD_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif ((error = git_filebuf_printf(&file, \"%s\\n\", heads[i]->id_str)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__set_orig_head",
          "args": [
            "repo",
            "git_annotated_commit_id(our_head)"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__set_orig_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1933-1953",
          "snippet": "int git_repository__set_orig_head(git_repository *repo, const git_oid *orig_head)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tchar orig_head_str[GIT_OID_HEXSZ];\n\tint error = 0;\n\n\tgit_oid_fmt(orig_head_str, orig_head);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_ORIG_HEAD_FILE)) == 0 &&\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) == 0 &&\n\t\t(error = git_filebuf_printf(&file, \"%.*s\\n\", GIT_OID_HEXSZ, orig_head_str)) == 0)\n\t\terror = git_filebuf_commit(&file);\n\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository__set_orig_head(git_repository *repo, const git_oid *orig_head)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tchar orig_head_str[GIT_OID_HEXSZ];\n\tint error = 0;\n\n\tgit_oid_fmt(orig_head_str, orig_head);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_ORIG_HEAD_FILE)) == 0 &&\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) == 0 &&\n\t\t(error = git_filebuf_printf(&file, \"%.*s\\n\", GIT_OID_HEXSZ, orig_head_str)) == 0)\n\t\terror = git_filebuf_commit(&file);\n\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_id",
          "args": [
            "our_head"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "174-179",
          "snippet": "const git_oid *git_annotated_commit_id(\n\tconst git_annotated_commit *annotated_commit)\n{\n\tassert(annotated_commit);\n\treturn git_commit_id(annotated_commit->commit);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nconst git_oid *git_annotated_commit_id(\n\tconst git_annotated_commit *annotated_commit)\n{\n\tassert(annotated_commit);\n\treturn git_commit_id(annotated_commit->commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && our_head && heads"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge__setup(\n\tgit_repository *repo,\n\tconst git_annotated_commit *our_head,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tint error = 0;\n\n\tassert (repo && our_head && heads);\n\n\tif ((error = git_repository__set_orig_head(repo, git_annotated_commit_id(our_head))) == 0 &&\n\t\t(error = write_merge_head(repo, heads, heads_len)) == 0 &&\n\t\t(error = write_merge_mode(repo)) == 0) {\n\t\terror = write_merge_msg(repo, heads, heads_len);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "write_merge_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2414-2528",
    "snippet": "static int write_merge_msg(\n\tgit_repository *repo,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tstruct merge_msg_entry *entries;\n\tgit_vector matching = GIT_VECTOR_INIT;\n\tsize_t i;\n\tchar sep = 0;\n\tint error = 0;\n\n\tassert(repo && heads);\n\n\tentries = git__calloc(heads_len, sizeof(struct merge_msg_entry));\n\tGITERR_CHECK_ALLOC(entries);\n\n\tif (git_vector_init(&matching, heads_len, NULL) < 0) {\n\t\tgit__free(entries);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < heads_len; i++)\n\t\tentries[i].merge_head = heads[i];\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0 ||\n\t\t(error = git_filebuf_write(&file, \"Merge \", 6)) < 0)\n\t\tgoto cleanup;\n\n\t/*\n\t * This is to emulate the format of MERGE_MSG by core git.\n\t *\n\t * Core git will write all the commits specified by OID, in the order\n\t * provided, until the first named branch or tag is reached, at which\n\t * point all branches will be written in the order provided, then all\n\t * tags, then all remote tracking branches and finally all commits that\n\t * were specified by OID that were not already written.\n\t *\n\t * Yes.  Really.\n\t */\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (!msg_entry_is_oid(&entries[i]))\n\t\t\tbreak;\n\n\t\tif ((error = git_filebuf_printf(&file,\n\t\t\t\"%scommit '%s'\", (i > 0) ? \"; \" : \"\",\n\t\t\tentries[i].merge_head->id_str)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tentries[i].written = 1;\n\t}\n\n\tif (i)\n\t\tsep = ';';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_branch)) < 0 ||\n\t\t(error = merge_msg_write_branches(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_tracking)) < 0 ||\n\t\t(error = merge_msg_write_tracking(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_tag)) < 0 ||\n\t\t(error = merge_msg_write_tags(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\t/* We should never be called with multiple remote branches, but handle\n\t * it in case we are... */\n\twhile ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_remote)) > 0) {\n\t\tif ((error = merge_msg_write_remotes(&file, &matching, sep)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (matching.length)\n\t\t\tsep =',';\n\t}\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (merge_msg_entry_written(&entries[i]))\n\t\t\tcontinue;\n\n\t\tif ((error = git_filebuf_printf(&file, \"; commit '%s'\",\n\t\t\tentries[i].merge_head->id_str)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_filebuf_printf(&file, \"\\n\")) < 0 ||\n\t\t(error = git_filebuf_commit(&file)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\tgit_vector_free(&matching);\n\tgit__free(entries);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "entries"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&matching"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&file_path"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&file"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "&file",
            "\"\\n\""
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_msg_entry_written",
          "args": [
            "&entries[i]"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_entry_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2300-2304",
          "snippet": "static int merge_msg_entry_written(\n\tconst struct merge_msg_entry *merge_msg_entry)\n{\n\treturn (merge_msg_entry->written == 1);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_entry_written(\n\tconst struct merge_msg_entry *merge_msg_entry)\n{\n\treturn (merge_msg_entry->written == 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_msg_write_remotes",
          "args": [
            "&file",
            "&matching",
            "sep"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_write_remotes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2398-2412",
          "snippet": "static int merge_msg_write_remotes(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\tconst char *source;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tsource = ((struct merge_msg_entry *)entries->contents[0])->merge_head->remote_url;\n\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"branch\", \"branches\", strlen(GIT_REFS_HEADS_DIR), source, sep);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_remotes(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\tconst char *source;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tsource = ((struct merge_msg_entry *)entries->contents[0])->merge_head->remote_url;\n\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"branch\", \"branches\", strlen(GIT_REFS_HEADS_DIR), source, sep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_msg_entries",
          "args": [
            "&matching",
            "entries",
            "heads_len",
            "msg_entry_is_remote"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2306-2328",
          "snippet": "static int merge_msg_entries(\n\tgit_vector *v,\n\tconst struct merge_msg_entry *entries,\n\tsize_t len,\n\tint (*match)(const struct merge_msg_entry *entry, git_vector *entries))\n{\n\tsize_t i;\n\tint matches, total = 0;\n\n\tgit_vector_clear(v);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif ((matches = match(&entries[i], v)) < 0)\n\t\t\treturn matches;\n\t\telse if (!matches)\n\t\t\tcontinue;\n\n\t\tgit_vector_insert(v, (struct merge_msg_entry *)&entries[i]);\n\t\ttotal++;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_entries(\n\tgit_vector *v,\n\tconst struct merge_msg_entry *entries,\n\tsize_t len,\n\tint (*match)(const struct merge_msg_entry *entry, git_vector *entries))\n{\n\tsize_t i;\n\tint matches, total = 0;\n\n\tgit_vector_clear(v);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif ((matches = match(&entries[i], v)) < 0)\n\t\t\treturn matches;\n\t\telse if (!matches)\n\t\t\tcontinue;\n\n\t\tgit_vector_insert(v, (struct merge_msg_entry *)&entries[i]);\n\t\ttotal++;\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_msg_write_tags",
          "args": [
            "&file",
            "&matching",
            "sep"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_write_tags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2389-2396",
          "snippet": "static int merge_msg_write_tags(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"tag\", \"tags\", strlen(GIT_REFS_TAGS_DIR), NULL, sep);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_tags(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"tag\", \"tags\", strlen(GIT_REFS_TAGS_DIR), NULL, sep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_msg_write_tracking",
          "args": [
            "&file",
            "&matching",
            "sep"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_write_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2380-2387",
          "snippet": "static int merge_msg_write_tracking(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"remote-tracking branch\", \"remote-tracking branches\", 0, NULL, sep);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_tracking(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"remote-tracking branch\", \"remote-tracking branches\", 0, NULL, sep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_msg_write_branches",
          "args": [
            "&file",
            "&matching",
            "sep"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_write_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2371-2378",
          "snippet": "static int merge_msg_write_branches(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"branch\", \"branches\", strlen(GIT_REFS_HEADS_DIR), NULL, sep);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_branches(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"branch\", \"branches\", strlen(GIT_REFS_HEADS_DIR), NULL, sep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg_entry_is_oid",
          "args": [
            "&entries[i]"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "msg_entry_is_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2292-2298",
          "snippet": "static int msg_entry_is_oid(\n\tconst struct merge_msg_entry *merge_msg_entry)\n{\n\treturn (merge_msg_entry->written == 0 &&\n\t\tmerge_msg_entry->merge_head->ref_name == NULL &&\n\t\tmerge_msg_entry->merge_head->remote_url == NULL);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int msg_entry_is_oid(\n\tconst struct merge_msg_entry *merge_msg_entry)\n{\n\treturn (merge_msg_entry->written == 0 &&\n\t\tmerge_msg_entry->merge_head->ref_name == NULL &&\n\t\tmerge_msg_entry->merge_head->remote_url == NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "&file",
            "\"Merge \"",
            "6"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&file",
            "file_path.ptr",
            "GIT_FILEBUF_FORCE",
            "GIT_MERGE_FILE_MODE"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&file_path",
            "repo->path_repository",
            "GIT_MERGE_MSG_FILE"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&matching",
            "heads_len",
            "NULL"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entries"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "heads_len",
            "sizeof(struct merge_msg_entry)"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && heads"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int write_merge_msg(\n\tgit_repository *repo,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tstruct merge_msg_entry *entries;\n\tgit_vector matching = GIT_VECTOR_INIT;\n\tsize_t i;\n\tchar sep = 0;\n\tint error = 0;\n\n\tassert(repo && heads);\n\n\tentries = git__calloc(heads_len, sizeof(struct merge_msg_entry));\n\tGITERR_CHECK_ALLOC(entries);\n\n\tif (git_vector_init(&matching, heads_len, NULL) < 0) {\n\t\tgit__free(entries);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < heads_len; i++)\n\t\tentries[i].merge_head = heads[i];\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0 ||\n\t\t(error = git_filebuf_write(&file, \"Merge \", 6)) < 0)\n\t\tgoto cleanup;\n\n\t/*\n\t * This is to emulate the format of MERGE_MSG by core git.\n\t *\n\t * Core git will write all the commits specified by OID, in the order\n\t * provided, until the first named branch or tag is reached, at which\n\t * point all branches will be written in the order provided, then all\n\t * tags, then all remote tracking branches and finally all commits that\n\t * were specified by OID that were not already written.\n\t *\n\t * Yes.  Really.\n\t */\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (!msg_entry_is_oid(&entries[i]))\n\t\t\tbreak;\n\n\t\tif ((error = git_filebuf_printf(&file,\n\t\t\t\"%scommit '%s'\", (i > 0) ? \"; \" : \"\",\n\t\t\tentries[i].merge_head->id_str)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tentries[i].written = 1;\n\t}\n\n\tif (i)\n\t\tsep = ';';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_branch)) < 0 ||\n\t\t(error = merge_msg_write_branches(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_tracking)) < 0 ||\n\t\t(error = merge_msg_write_tracking(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\tif ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_tag)) < 0 ||\n\t\t(error = merge_msg_write_tags(&file, &matching, sep)) < 0)\n\t\tgoto cleanup;\n\n\tif (matching.length)\n\t\tsep =',';\n\n\t/* We should never be called with multiple remote branches, but handle\n\t * it in case we are... */\n\twhile ((error = merge_msg_entries(&matching, entries, heads_len, msg_entry_is_remote)) > 0) {\n\t\tif ((error = merge_msg_write_remotes(&file, &matching, sep)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (matching.length)\n\t\t\tsep =',';\n\t}\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (merge_msg_entry_written(&entries[i]))\n\t\t\tcontinue;\n\n\t\tif ((error = git_filebuf_printf(&file, \"; commit '%s'\",\n\t\t\tentries[i].merge_head->id_str)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_filebuf_printf(&file, \"\\n\")) < 0 ||\n\t\t(error = git_filebuf_commit(&file)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\tgit_vector_free(&matching);\n\tgit__free(entries);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_msg_write_remotes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2398-2412",
    "snippet": "static int merge_msg_write_remotes(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\tconst char *source;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tsource = ((struct merge_msg_entry *)entries->contents[0])->merge_head->remote_url;\n\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"branch\", \"branches\", strlen(GIT_REFS_HEADS_DIR), source, sep);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_msg_write_entries",
          "args": [
            "file",
            "entries",
            "\"branch\"",
            "\"branches\"",
            "strlen(GIT_REFS_HEADS_DIR)",
            "source",
            "sep"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_write_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2330-2369",
          "snippet": "static int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_remotes(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\tconst char *source;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tsource = ((struct merge_msg_entry *)entries->contents[0])->merge_head->remote_url;\n\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"branch\", \"branches\", strlen(GIT_REFS_HEADS_DIR), source, sep);\n}"
  },
  {
    "function_name": "merge_msg_write_tags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2389-2396",
    "snippet": "static int merge_msg_write_tags(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"tag\", \"tags\", strlen(GIT_REFS_TAGS_DIR), NULL, sep);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_msg_write_entries",
          "args": [
            "file",
            "entries",
            "\"tag\"",
            "\"tags\"",
            "strlen(GIT_REFS_TAGS_DIR)",
            "NULL",
            "sep"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_write_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2330-2369",
          "snippet": "static int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_TAGS_DIR"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_tags(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"tag\", \"tags\", strlen(GIT_REFS_TAGS_DIR), NULL, sep);\n}"
  },
  {
    "function_name": "merge_msg_write_tracking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2380-2387",
    "snippet": "static int merge_msg_write_tracking(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"remote-tracking branch\", \"remote-tracking branches\", 0, NULL, sep);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_msg_write_entries",
          "args": [
            "file",
            "entries",
            "\"remote-tracking branch\"",
            "\"remote-tracking branches\"",
            "0",
            "NULL",
            "sep"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_write_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2330-2369",
          "snippet": "static int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_tracking(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"remote-tracking branch\", \"remote-tracking branches\", 0, NULL, sep);\n}"
  },
  {
    "function_name": "merge_msg_write_branches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2371-2378",
    "snippet": "static int merge_msg_write_branches(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"branch\", \"branches\", strlen(GIT_REFS_HEADS_DIR), NULL, sep);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_msg_write_entries",
          "args": [
            "file",
            "entries",
            "\"branch\"",
            "\"branches\"",
            "strlen(GIT_REFS_HEADS_DIR)",
            "NULL",
            "sep"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "merge_msg_write_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2330-2369",
          "snippet": "static int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_branches(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tchar sep)\n{\n\treturn merge_msg_write_entries(file, entries,\n\t\t\"branch\", \"branches\", strlen(GIT_REFS_HEADS_DIR), NULL, sep);\n}"
  },
  {
    "function_name": "merge_msg_write_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2330-2369",
    "snippet": "static int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "file",
            "\" of %s\"",
            "source"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "entries",
            "i",
            "entry"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_write_entries(\n\tgit_filebuf *file,\n\tgit_vector *entries,\n\tconst char *item_name,\n\tconst char *item_plural_name,\n\tsize_t ref_name_skip,\n\tconst char *source,\n\tchar sep)\n{\n\tstruct merge_msg_entry *entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif (entries->length == 0)\n\t\treturn 0;\n\n\tif (sep && (error = git_filebuf_printf(file, \"%c \", sep)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_filebuf_printf(file, \"%s \",\n\t\t(entries->length == 1) ? item_name : item_plural_name)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif (i > 0 &&\n\t\t\t(error = git_filebuf_printf(file, \"%s\", (i == entries->length - 1) ? \" and \" : \", \")) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_filebuf_printf(file, \"'%s'\", entry->merge_head->ref_name + ref_name_skip)) < 0)\n\t\t\tgoto done;\n\n\t\tentry->written = 1;\n\t}\n\n\tif (source)\n\t\terror = git_filebuf_printf(file, \" of %s\", source);\n\ndone:\n\treturn error;\n}"
  },
  {
    "function_name": "merge_msg_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2306-2328",
    "snippet": "static int merge_msg_entries(\n\tgit_vector *v,\n\tconst struct merge_msg_entry *entries,\n\tsize_t len,\n\tint (*match)(const struct merge_msg_entry *entry, git_vector *entries))\n{\n\tsize_t i;\n\tint matches, total = 0;\n\n\tgit_vector_clear(v);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif ((matches = match(&entries[i], v)) < 0)\n\t\t\treturn matches;\n\t\telse if (!matches)\n\t\t\tcontinue;\n\n\t\tgit_vector_insert(v, (struct merge_msg_entry *)&entries[i]);\n\t\ttotal++;\n\t}\n\n\treturn total;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "v",
            "(struct merge_msg_entry *)&entries[i]"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "&entries[i]",
            "v"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_rule__match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "431-441",
          "snippet": "bool git_attr_rule__match(\n\tgit_attr_rule *rule,\n\tgit_attr_path *path)\n{\n\tbool matched = git_attr_fnmatch__match(&rule->match, path);\n\n\tif (rule->match.flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\tmatched = !matched;\n\n\treturn matched;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nbool git_attr_rule__match(\n\tgit_attr_rule *rule,\n\tgit_attr_path *path)\n{\n\tbool matched = git_attr_fnmatch__match(&rule->match, path);\n\n\tif (rule->match.flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\tmatched = !matched;\n\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "v"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_entries(\n\tgit_vector *v,\n\tconst struct merge_msg_entry *entries,\n\tsize_t len,\n\tint (*match)(const struct merge_msg_entry *entry, git_vector *entries))\n{\n\tsize_t i;\n\tint matches, total = 0;\n\n\tgit_vector_clear(v);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif ((matches = match(&entries[i], v)) < 0)\n\t\t\treturn matches;\n\t\telse if (!matches)\n\t\t\tcontinue;\n\n\t\tgit_vector_insert(v, (struct merge_msg_entry *)&entries[i]);\n\t\ttotal++;\n\t}\n\n\treturn total;\n}"
  },
  {
    "function_name": "merge_msg_entry_written",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2300-2304",
    "snippet": "static int merge_msg_entry_written(\n\tconst struct merge_msg_entry *merge_msg_entry)\n{\n\treturn (merge_msg_entry->written == 1);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_msg_entry_written(\n\tconst struct merge_msg_entry *merge_msg_entry)\n{\n\treturn (merge_msg_entry->written == 1);\n}"
  },
  {
    "function_name": "msg_entry_is_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2292-2298",
    "snippet": "static int msg_entry_is_oid(\n\tconst struct merge_msg_entry *merge_msg_entry)\n{\n\treturn (merge_msg_entry->written == 0 &&\n\t\tmerge_msg_entry->merge_head->ref_name == NULL &&\n\t\tmerge_msg_entry->merge_head->remote_url == NULL);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int msg_entry_is_oid(\n\tconst struct merge_msg_entry *merge_msg_entry)\n{\n\treturn (merge_msg_entry->written == 0 &&\n\t\tmerge_msg_entry->merge_head->ref_name == NULL &&\n\t\tmerge_msg_entry->merge_head->remote_url == NULL);\n}"
  },
  {
    "function_name": "msg_entry_is_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2268-2290",
    "snippet": "static int msg_entry_is_remote(\n\tconst struct merge_msg_entry *entry,\n\tgit_vector *entries)\n{\n\tif (entry->written == 0 &&\n\t\tentry->merge_head->remote_url != NULL &&\n\t\tentry->merge_head->ref_name != NULL &&\n\t\tgit__strncmp(GIT_REFS_HEADS_DIR, entry->merge_head->ref_name, strlen(GIT_REFS_HEADS_DIR)) == 0)\n\t{\n\t\tstruct merge_msg_entry *existing;\n\n\t\t/* Match only branches from the same remote */\n\t\tif (entries->length == 0)\n\t\t\treturn 1;\n\n\t\texisting = git_vector_get(entries, 0);\n\n\t\treturn (git__strcmp(existing->merge_head->remote_url,\n\t\t\tentry->merge_head->remote_url) == 0);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strcmp",
          "args": [
            "existing->merge_head->remote_url",
            "entry->merge_head->remote_url"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "entries",
            "0"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strncmp",
          "args": [
            "GIT_REFS_HEADS_DIR",
            "entry->merge_head->ref_name",
            "strlen(GIT_REFS_HEADS_DIR)"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int msg_entry_is_remote(\n\tconst struct merge_msg_entry *entry,\n\tgit_vector *entries)\n{\n\tif (entry->written == 0 &&\n\t\tentry->merge_head->remote_url != NULL &&\n\t\tentry->merge_head->ref_name != NULL &&\n\t\tgit__strncmp(GIT_REFS_HEADS_DIR, entry->merge_head->ref_name, strlen(GIT_REFS_HEADS_DIR)) == 0)\n\t{\n\t\tstruct merge_msg_entry *existing;\n\n\t\t/* Match only branches from the same remote */\n\t\tif (entries->length == 0)\n\t\t\treturn 1;\n\n\t\texisting = git_vector_get(entries, 0);\n\n\t\treturn (git__strcmp(existing->merge_head->remote_url,\n\t\t\tentry->merge_head->remote_url) == 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "msg_entry_is_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2256-2266",
    "snippet": "static int msg_entry_is_tag(\n\tconst struct merge_msg_entry *entry,\n\tgit_vector *entries)\n{\n\tGIT_UNUSED(entries);\n\n\treturn (entry->written == 0 &&\n\t\tentry->merge_head->remote_url == NULL &&\n\t\tentry->merge_head->ref_name != NULL &&\n\t\tgit__strncmp(GIT_REFS_TAGS_DIR, entry->merge_head->ref_name, strlen(GIT_REFS_TAGS_DIR)) == 0);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strncmp",
          "args": [
            "GIT_REFS_TAGS_DIR",
            "entry->merge_head->ref_name",
            "strlen(GIT_REFS_TAGS_DIR)"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_TAGS_DIR"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "entries"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int msg_entry_is_tag(\n\tconst struct merge_msg_entry *entry,\n\tgit_vector *entries)\n{\n\tGIT_UNUSED(entries);\n\n\treturn (entry->written == 0 &&\n\t\tentry->merge_head->remote_url == NULL &&\n\t\tentry->merge_head->ref_name != NULL &&\n\t\tgit__strncmp(GIT_REFS_TAGS_DIR, entry->merge_head->ref_name, strlen(GIT_REFS_TAGS_DIR)) == 0);\n}"
  },
  {
    "function_name": "msg_entry_is_tracking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2244-2254",
    "snippet": "static int msg_entry_is_tracking(\n\tconst struct merge_msg_entry *entry,\n\tgit_vector *entries)\n{\n\tGIT_UNUSED(entries);\n\n\treturn (entry->written == 0 &&\n\t\tentry->merge_head->remote_url == NULL &&\n\t\tentry->merge_head->ref_name != NULL &&\n\t\tgit__strncmp(GIT_REFS_REMOTES_DIR, entry->merge_head->ref_name, strlen(GIT_REFS_REMOTES_DIR)) == 0);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strncmp",
          "args": [
            "GIT_REFS_REMOTES_DIR",
            "entry->merge_head->ref_name",
            "strlen(GIT_REFS_REMOTES_DIR)"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_REMOTES_DIR"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "entries"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int msg_entry_is_tracking(\n\tconst struct merge_msg_entry *entry,\n\tgit_vector *entries)\n{\n\tGIT_UNUSED(entries);\n\n\treturn (entry->written == 0 &&\n\t\tentry->merge_head->remote_url == NULL &&\n\t\tentry->merge_head->ref_name != NULL &&\n\t\tgit__strncmp(GIT_REFS_REMOTES_DIR, entry->merge_head->ref_name, strlen(GIT_REFS_REMOTES_DIR)) == 0);\n}"
  },
  {
    "function_name": "msg_entry_is_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2232-2242",
    "snippet": "static int msg_entry_is_branch(\n\tconst struct merge_msg_entry *entry,\n\tgit_vector *entries)\n{\n\tGIT_UNUSED(entries);\n\n\treturn (entry->written == 0 &&\n\t\tentry->merge_head->remote_url == NULL &&\n\t\tentry->merge_head->ref_name != NULL &&\n\t\tgit__strncmp(GIT_REFS_HEADS_DIR, entry->merge_head->ref_name, strlen(GIT_REFS_HEADS_DIR)) == 0);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strncmp",
          "args": [
            "GIT_REFS_HEADS_DIR",
            "entry->merge_head->ref_name",
            "strlen(GIT_REFS_HEADS_DIR)"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "entries"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int msg_entry_is_branch(\n\tconst struct merge_msg_entry *entry,\n\tgit_vector *entries)\n{\n\tGIT_UNUSED(entries);\n\n\treturn (entry->written == 0 &&\n\t\tentry->merge_head->remote_url == NULL &&\n\t\tentry->merge_head->ref_name != NULL &&\n\t\tgit__strncmp(GIT_REFS_HEADS_DIR, entry->merge_head->ref_name, strlen(GIT_REFS_HEADS_DIR)) == 0);\n}"
  },
  {
    "function_name": "write_merge_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2201-2225",
    "snippet": "static int write_merge_mode(git_repository *repo)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tassert(repo);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MODE_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_filebuf_write(&file, \"no-ff\", 5)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&file_path"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&file"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "&file",
            "\"no-ff\"",
            "5"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&file",
            "file_path.ptr",
            "GIT_FILEBUF_FORCE",
            "GIT_MERGE_FILE_MODE"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&file_path",
            "repo->path_repository",
            "GIT_MERGE_MODE_FILE"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int write_merge_mode(git_repository *repo)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tassert(repo);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MODE_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_filebuf_write(&file, \"no-ff\", 5)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "write_merge_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2169-2199",
    "snippet": "static int write_merge_head(\n\tgit_repository *repo,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(repo && heads);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_HEAD_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif ((error = git_filebuf_printf(&file, \"%s\\n\", heads[i]->id_str)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&file_path"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&file"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "&file",
            "\"%s\\n\"",
            "heads[i]->id_str"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&file",
            "file_path.ptr",
            "GIT_FILEBUF_FORCE",
            "GIT_MERGE_FILE_MODE"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&file_path",
            "repo->path_repository",
            "GIT_MERGE_HEAD_FILE"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && heads"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int write_merge_head(\n\tgit_repository *repo,\n\tconst git_annotated_commit *heads[],\n\tsize_t heads_len)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(repo && heads);\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_HEAD_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif ((error = git_filebuf_printf(&file, \"%s\\n\", heads[i]->id_str)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_merge_commits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2144-2165",
    "snippet": "int git_merge_commits(\n\tgit_index **out,\n\tgit_repository *repo,\n\tconst git_commit *our_commit,\n\tconst git_commit *their_commit,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *ours = NULL, *theirs = NULL, *base = NULL;\n\tint error = 0;\n\n\tif ((error = git_annotated_commit_from_commit(&ours, (git_commit *)our_commit)) < 0 ||\n\t\t(error = git_annotated_commit_from_commit(&theirs, (git_commit *)their_commit)) < 0)\n\t\tgoto done;\n\n\terror = merge_annotated_commits(out, &base, repo, ours, theirs, 0, opts);\n\ndone:\n\tgit_annotated_commit_free(ours);\n\tgit_annotated_commit_free(theirs);\n\tgit_annotated_commit_free(base);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_annotated_commit_free",
          "args": [
            "base"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "181-202",
          "snippet": "void git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nvoid git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_annotated_commits",
          "args": [
            "out",
            "&base",
            "repo",
            "ours",
            "theirs",
            "0",
            "opts"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "merge_annotated_commits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2101-2141",
          "snippet": "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *ours,\n\tgit_annotated_commit *theirs,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *base = NULL;\n\tgit_iterator *base_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tint error;\n\n    if ((error = compute_base(&base, repo, ours, theirs, opts,\n\t\trecursion_level)) < 0) {\n\n        if (error != GIT_ENOTFOUND)\n            goto done;\n\n        giterr_clear();\n    }\n\n\tif ((error = iterator_for_annotated_commit(&base_iter, base)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&our_iter, ours)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&their_iter, theirs)) < 0 ||\n\t\t(error = git_merge__iterators(index_out, repo, base_iter, our_iter,\n\t\t\ttheir_iter, opts)) < 0)\n\t\tgoto done;\n\n\tif (base_out) {\n\t\t*base_out = base;\n\t\tbase = NULL;\n\t}\n\ndone:\n\tgit_annotated_commit_free(base);\n\tgit_iterator_free(base_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *ours,\n\tgit_annotated_commit *theirs,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *base = NULL;\n\tgit_iterator *base_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tint error;\n\n    if ((error = compute_base(&base, repo, ours, theirs, opts,\n\t\trecursion_level)) < 0) {\n\n        if (error != GIT_ENOTFOUND)\n            goto done;\n\n        giterr_clear();\n    }\n\n\tif ((error = iterator_for_annotated_commit(&base_iter, base)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&our_iter, ours)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&their_iter, theirs)) < 0 ||\n\t\t(error = git_merge__iterators(index_out, repo, base_iter, our_iter,\n\t\t\ttheir_iter, opts)) < 0)\n\t\tgoto done;\n\n\tif (base_out) {\n\t\t*base_out = base;\n\t\tbase = NULL;\n\t}\n\ndone:\n\tgit_annotated_commit_free(base);\n\tgit_iterator_free(base_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_from_commit",
          "args": [
            "&theirs",
            "(git_commit *)their_commit"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_from_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "100-123",
          "snippet": "int git_annotated_commit_from_commit(\n\tgit_annotated_commit **out,\n\tgit_commit *commit)\n{\n\tgit_annotated_commit *annotated_commit;\n\n\tassert(out && commit);\n\n\t*out = NULL;\n\n\tannotated_commit = git__calloc(1, sizeof(git_annotated_commit));\n\tGITERR_CHECK_ALLOC(annotated_commit);\n\n\tannotated_commit->type = GIT_ANNOTATED_COMMIT_REAL;\n\n\tgit_cached_obj_incref(commit);\n\tannotated_commit->commit = commit;\n\n\tgit_oid_fmt(annotated_commit->id_str, git_commit_id(commit));\n\tannotated_commit->id_str[GIT_OID_HEXSZ] = '\\0';\n\n\t*out = annotated_commit;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nint git_annotated_commit_from_commit(\n\tgit_annotated_commit **out,\n\tgit_commit *commit)\n{\n\tgit_annotated_commit *annotated_commit;\n\n\tassert(out && commit);\n\n\t*out = NULL;\n\n\tannotated_commit = git__calloc(1, sizeof(git_annotated_commit));\n\tGITERR_CHECK_ALLOC(annotated_commit);\n\n\tannotated_commit->type = GIT_ANNOTATED_COMMIT_REAL;\n\n\tgit_cached_obj_incref(commit);\n\tannotated_commit->commit = commit;\n\n\tgit_oid_fmt(annotated_commit->id_str, git_commit_id(commit));\n\tannotated_commit->id_str[GIT_OID_HEXSZ] = '\\0';\n\n\t*out = annotated_commit;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge_commits(\n\tgit_index **out,\n\tgit_repository *repo,\n\tconst git_commit *our_commit,\n\tconst git_commit *their_commit,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *ours = NULL, *theirs = NULL, *base = NULL;\n\tint error = 0;\n\n\tif ((error = git_annotated_commit_from_commit(&ours, (git_commit *)our_commit)) < 0 ||\n\t\t(error = git_annotated_commit_from_commit(&theirs, (git_commit *)their_commit)) < 0)\n\t\tgoto done;\n\n\terror = merge_annotated_commits(out, &base, repo, ours, theirs, 0, opts);\n\ndone:\n\tgit_annotated_commit_free(ours);\n\tgit_annotated_commit_free(theirs);\n\tgit_annotated_commit_free(base);\n\treturn error;\n}"
  },
  {
    "function_name": "merge_annotated_commits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2101-2141",
    "snippet": "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *ours,\n\tgit_annotated_commit *theirs,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *base = NULL;\n\tgit_iterator *base_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tint error;\n\n    if ((error = compute_base(&base, repo, ours, theirs, opts,\n\t\trecursion_level)) < 0) {\n\n        if (error != GIT_ENOTFOUND)\n            goto done;\n\n        giterr_clear();\n    }\n\n\tif ((error = iterator_for_annotated_commit(&base_iter, base)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&our_iter, ours)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&their_iter, theirs)) < 0 ||\n\t\t(error = git_merge__iterators(index_out, repo, base_iter, our_iter,\n\t\t\ttheir_iter, opts)) < 0)\n\t\tgoto done;\n\n\tif (base_out) {\n\t\t*base_out = base;\n\t\tbase = NULL;\n\t}\n\ndone:\n\tgit_annotated_commit_free(base);\n\tgit_iterator_free(base_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "their_iter"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_free",
          "args": [
            "base"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "181-202",
          "snippet": "void git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nvoid git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__iterators",
          "args": [
            "index_out",
            "repo",
            "base_iter",
            "our_iter",
            "their_iter",
            "opts"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__iterators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1822-1908",
          "snippet": "int git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator_for_annotated_commit",
          "args": [
            "&their_iter",
            "theirs"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_for_annotated_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2076-2099",
          "snippet": "static int iterator_for_annotated_commit(\n\tgit_iterator **out,\n\tgit_annotated_commit *commit)\n{\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif (commit == NULL) {\n\t\terror = git_iterator_for_nothing(out, &opts);\n\t} else if (commit->type == GIT_ANNOTATED_COMMIT_VIRTUAL) {\n\t\terror = git_iterator_for_index(out, git_index_owner(commit->index), commit->index, &opts);\n\t} else {\n\t\tif (!commit->tree &&\n\t\t\t(error = git_commit_tree(&commit->tree, commit->commit)) < 0)\n\t\t\tgoto done;\n\n\t\terror = git_iterator_for_tree(out, commit->tree, &opts);\n\t}\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int iterator_for_annotated_commit(\n\tgit_iterator **out,\n\tgit_annotated_commit *commit)\n{\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif (commit == NULL) {\n\t\terror = git_iterator_for_nothing(out, &opts);\n\t} else if (commit->type == GIT_ANNOTATED_COMMIT_VIRTUAL) {\n\t\terror = git_iterator_for_index(out, git_index_owner(commit->index), commit->index, &opts);\n\t} else {\n\t\tif (!commit->tree &&\n\t\t\t(error = git_commit_tree(&commit->tree, commit->commit)) < 0)\n\t\t\tgoto done;\n\n\t\terror = git_iterator_for_tree(out, commit->tree, &opts);\n\t}\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "compute_base",
          "args": [
            "&base",
            "repo",
            "ours",
            "theirs",
            "opts",
            "recursion_level"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "compute_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2013-2074",
          "snippet": "static int compute_base(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_annotated_commit *one,\n\tconst git_annotated_commit *two,\n\tconst git_merge_options *given_opts,\n\tsize_t recursion_level)\n{\n\tgit_array_oid_t head_ids = GIT_ARRAY_INIT;\n\tgit_oidarray bases = {0};\n\tgit_annotated_commit *base = NULL, *other = NULL, *new_base = NULL;\n\tgit_merge_options opts = GIT_MERGE_OPTIONS_INIT;\n\tsize_t i;\n\tint error;\n\n\t*out = NULL;\n\n\tif (given_opts)\n\t\tmemcpy(&opts, given_opts, sizeof(git_merge_options));\n\n\tif ((error = insert_head_ids(&head_ids, one)) < 0 ||\n\t\t(error = insert_head_ids(&head_ids, two)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_merge_bases_many(&bases, repo,\n\t\t\thead_ids.size, head_ids.ptr)) < 0 ||\n\t\t(error = git_annotated_commit_lookup(&base, repo, &bases.ids[0])) < 0 ||\n\t\t(opts.flags & GIT_MERGE_NO_RECURSIVE))\n\t\tgoto done;\n\n\tfor (i = 1; i < bases.count; i++) {\n\t\trecursion_level++;\n\n\t\tif (opts.recursion_limit && recursion_level > opts.recursion_limit)\n\t\t\tbreak;\n\n\t\tif ((error = git_annotated_commit_lookup(&other, repo,\n\t\t\t\t&bases.ids[i])) < 0 ||\n\t\t\t(error = create_virtual_base(&new_base, repo, base, other, &opts,\n\t\t\t\trecursion_level)) < 0)\n\t\t\tgoto done;\n\n\t\tgit_annotated_commit_free(base);\n\t\tgit_annotated_commit_free(other);\n\n\t\tbase = new_base;\n\t\tnew_base = NULL;\n\t\tother = NULL;\n\t}\n\ndone:\n\tif (error == 0)\n\t\t*out = base;\n\telse\n\t\tgit_annotated_commit_free(base);\n\n\tgit_annotated_commit_free(other);\n\tgit_annotated_commit_free(new_base);\n\tgit_oidarray_free(&bases);\n\tgit_array_clear(head_ids);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int compute_base(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_annotated_commit *one,\n\tconst git_annotated_commit *two,\n\tconst git_merge_options *given_opts,\n\tsize_t recursion_level)\n{\n\tgit_array_oid_t head_ids = GIT_ARRAY_INIT;\n\tgit_oidarray bases = {0};\n\tgit_annotated_commit *base = NULL, *other = NULL, *new_base = NULL;\n\tgit_merge_options opts = GIT_MERGE_OPTIONS_INIT;\n\tsize_t i;\n\tint error;\n\n\t*out = NULL;\n\n\tif (given_opts)\n\t\tmemcpy(&opts, given_opts, sizeof(git_merge_options));\n\n\tif ((error = insert_head_ids(&head_ids, one)) < 0 ||\n\t\t(error = insert_head_ids(&head_ids, two)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_merge_bases_many(&bases, repo,\n\t\t\thead_ids.size, head_ids.ptr)) < 0 ||\n\t\t(error = git_annotated_commit_lookup(&base, repo, &bases.ids[0])) < 0 ||\n\t\t(opts.flags & GIT_MERGE_NO_RECURSIVE))\n\t\tgoto done;\n\n\tfor (i = 1; i < bases.count; i++) {\n\t\trecursion_level++;\n\n\t\tif (opts.recursion_limit && recursion_level > opts.recursion_limit)\n\t\t\tbreak;\n\n\t\tif ((error = git_annotated_commit_lookup(&other, repo,\n\t\t\t\t&bases.ids[i])) < 0 ||\n\t\t\t(error = create_virtual_base(&new_base, repo, base, other, &opts,\n\t\t\t\trecursion_level)) < 0)\n\t\t\tgoto done;\n\n\t\tgit_annotated_commit_free(base);\n\t\tgit_annotated_commit_free(other);\n\n\t\tbase = new_base;\n\t\tnew_base = NULL;\n\t\tother = NULL;\n\t}\n\ndone:\n\tif (error == 0)\n\t\t*out = base;\n\telse\n\t\tgit_annotated_commit_free(base);\n\n\tgit_annotated_commit_free(other);\n\tgit_annotated_commit_free(new_base);\n\tgit_oidarray_free(&bases);\n\tgit_array_clear(head_ids);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *ours,\n\tgit_annotated_commit *theirs,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *base = NULL;\n\tgit_iterator *base_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tint error;\n\n    if ((error = compute_base(&base, repo, ours, theirs, opts,\n\t\trecursion_level)) < 0) {\n\n        if (error != GIT_ENOTFOUND)\n            goto done;\n\n        giterr_clear();\n    }\n\n\tif ((error = iterator_for_annotated_commit(&base_iter, base)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&our_iter, ours)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&their_iter, theirs)) < 0 ||\n\t\t(error = git_merge__iterators(index_out, repo, base_iter, our_iter,\n\t\t\ttheir_iter, opts)) < 0)\n\t\tgoto done;\n\n\tif (base_out) {\n\t\t*base_out = base;\n\t\tbase = NULL;\n\t}\n\ndone:\n\tgit_annotated_commit_free(base);\n\tgit_iterator_free(base_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\treturn error;\n}"
  },
  {
    "function_name": "iterator_for_annotated_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2076-2099",
    "snippet": "static int iterator_for_annotated_commit(\n\tgit_iterator **out,\n\tgit_annotated_commit *commit)\n{\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif (commit == NULL) {\n\t\terror = git_iterator_for_nothing(out, &opts);\n\t} else if (commit->type == GIT_ANNOTATED_COMMIT_VIRTUAL) {\n\t\terror = git_iterator_for_index(out, git_index_owner(commit->index), commit->index, &opts);\n\t} else {\n\t\tif (!commit->tree &&\n\t\t\t(error = git_commit_tree(&commit->tree, commit->commit)) < 0)\n\t\t\tgoto done;\n\n\t\terror = git_iterator_for_tree(out, commit->tree, &opts);\n\t}\n\ndone:\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "out",
            "commit->tree",
            "&opts"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&commit->tree",
            "commit->commit"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "out",
            "git_index_owner(commit->index)",
            "commit->index",
            "&opts"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_owner",
          "args": [
            "commit->index"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3064-3067",
          "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_nothing",
          "args": [
            "out",
            "&opts"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_nothing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "302-320",
          "snippet": "int git_iterator_for_nothing(\n\tgit_iterator **iter,\n\tgit_iterator_options *options)\n{\n\tempty_iterator *i = git__calloc(1, sizeof(empty_iterator));\n\tGITERR_CHECK_ALLOC(i);\n\n#define empty_iterator__current empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__advance_into empty_iterator__noop\n\n\tITERATOR_BASE_INIT(i, empty, EMPTY, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\ti->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\t*iter = (git_iterator *)i;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define empty_iterator__advance_into empty_iterator__noop",
            "#define empty_iterator__advance empty_iterator__noop",
            "#define empty_iterator__current empty_iterator__noop"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define empty_iterator__advance_into empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__current empty_iterator__noop\n\nint git_iterator_for_nothing(\n\tgit_iterator **iter,\n\tgit_iterator_options *options)\n{\n\tempty_iterator *i = git__calloc(1, sizeof(empty_iterator));\n\tGITERR_CHECK_ALLOC(i);\n\n#define empty_iterator__current empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__advance_into empty_iterator__noop\n\n\tITERATOR_BASE_INIT(i, empty, EMPTY, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\ti->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\t*iter = (git_iterator *)i;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int iterator_for_annotated_commit(\n\tgit_iterator **out,\n\tgit_annotated_commit *commit)\n{\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif (commit == NULL) {\n\t\terror = git_iterator_for_nothing(out, &opts);\n\t} else if (commit->type == GIT_ANNOTATED_COMMIT_VIRTUAL) {\n\t\terror = git_iterator_for_index(out, git_index_owner(commit->index), commit->index, &opts);\n\t} else {\n\t\tif (!commit->tree &&\n\t\t\t(error = git_commit_tree(&commit->tree, commit->commit)) < 0)\n\t\t\tgoto done;\n\n\t\terror = git_iterator_for_tree(out, commit->tree, &opts);\n\t}\n\ndone:\n\treturn error;\n}"
  },
  {
    "function_name": "compute_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "2013-2074",
    "snippet": "static int compute_base(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_annotated_commit *one,\n\tconst git_annotated_commit *two,\n\tconst git_merge_options *given_opts,\n\tsize_t recursion_level)\n{\n\tgit_array_oid_t head_ids = GIT_ARRAY_INIT;\n\tgit_oidarray bases = {0};\n\tgit_annotated_commit *base = NULL, *other = NULL, *new_base = NULL;\n\tgit_merge_options opts = GIT_MERGE_OPTIONS_INIT;\n\tsize_t i;\n\tint error;\n\n\t*out = NULL;\n\n\tif (given_opts)\n\t\tmemcpy(&opts, given_opts, sizeof(git_merge_options));\n\n\tif ((error = insert_head_ids(&head_ids, one)) < 0 ||\n\t\t(error = insert_head_ids(&head_ids, two)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_merge_bases_many(&bases, repo,\n\t\t\thead_ids.size, head_ids.ptr)) < 0 ||\n\t\t(error = git_annotated_commit_lookup(&base, repo, &bases.ids[0])) < 0 ||\n\t\t(opts.flags & GIT_MERGE_NO_RECURSIVE))\n\t\tgoto done;\n\n\tfor (i = 1; i < bases.count; i++) {\n\t\trecursion_level++;\n\n\t\tif (opts.recursion_limit && recursion_level > opts.recursion_limit)\n\t\t\tbreak;\n\n\t\tif ((error = git_annotated_commit_lookup(&other, repo,\n\t\t\t\t&bases.ids[i])) < 0 ||\n\t\t\t(error = create_virtual_base(&new_base, repo, base, other, &opts,\n\t\t\t\trecursion_level)) < 0)\n\t\t\tgoto done;\n\n\t\tgit_annotated_commit_free(base);\n\t\tgit_annotated_commit_free(other);\n\n\t\tbase = new_base;\n\t\tnew_base = NULL;\n\t\tother = NULL;\n\t}\n\ndone:\n\tif (error == 0)\n\t\t*out = base;\n\telse\n\t\tgit_annotated_commit_free(base);\n\n\tgit_annotated_commit_free(other);\n\tgit_annotated_commit_free(new_base);\n\tgit_oidarray_free(&bases);\n\tgit_array_clear(head_ids);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_array_clear",
          "args": [
            "head_ids"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oidarray_free",
          "args": [
            "&bases"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "git_oidarray_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oidarray.c",
          "lines": "12-15",
          "snippet": "void git_oidarray_free(git_oidarray *arr)\n{\n\tgit__free(arr->ids);\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"oidarray.h\"",
            "#include \"git2/oidarray.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"oidarray.h\"\n#include \"git2/oidarray.h\"\n\nvoid git_oidarray_free(git_oidarray *arr)\n{\n\tgit__free(arr->ids);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_free",
          "args": [
            "new_base"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "181-202",
          "snippet": "void git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nvoid git_annotated_commit_free(git_annotated_commit *annotated_commit)\n{\n\tif (annotated_commit == NULL)\n\t\treturn;\n\n\tswitch (annotated_commit->type) {\n\t\tcase GIT_ANNOTATED_COMMIT_REAL:\n\t\t\tgit_commit_free(annotated_commit->commit);\n\t\t\tgit_tree_free(annotated_commit->tree);\n\t\t\tgit__free(annotated_commit->ref_name);\n\t\t\tgit__free(annotated_commit->remote_url);\n\t\t\tbreak;\n\t\tcase GIT_ANNOTATED_COMMIT_VIRTUAL:\n\t\t\tgit_index_free(annotated_commit->index);\n\t\t\tgit_array_clear(annotated_commit->parents);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t}\n\n\tgit__free(annotated_commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_virtual_base",
          "args": [
            "&new_base",
            "repo",
            "base",
            "other",
            "&opts",
            "recursion_level"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "create_virtual_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1976-2011",
          "snippet": "static int create_virtual_base(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tgit_annotated_commit *one,\n\tgit_annotated_commit *two,\n\tconst git_merge_options *opts,\n\tsize_t recursion_level)\n{\n\tgit_annotated_commit *result = NULL;\n\tgit_index *index = NULL;\n\tgit_merge_options virtual_opts = GIT_MERGE_OPTIONS_INIT;\n\n\t/* Conflicts in the merge base creation do not propagate to conflicts\n\t * in the result; the conflicted base will act as the common ancestor.\n\t */\n\tif (opts)\n\t\tmemcpy(&virtual_opts, opts, sizeof(git_merge_options));\n\n\tvirtual_opts.flags &= ~GIT_MERGE_FAIL_ON_CONFLICT;\n\tvirtual_opts.flags |= GIT_MERGE__VIRTUAL_BASE;\n\n\tif ((merge_annotated_commits(&index, NULL, repo, one, two,\n\t\t\trecursion_level + 1, &virtual_opts)) < 0)\n\t\treturn -1;\n\n\tresult = git__calloc(1, sizeof(git_annotated_commit));\n\tGITERR_CHECK_ALLOC(result);\n\tresult->type = GIT_ANNOTATED_COMMIT_VIRTUAL;\n\tresult->index = index;\n\n\tinsert_head_ids(&result->parents, one);\n\tinsert_head_ids(&result->parents, two);\n\n\t*out = result;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int create_virtual_base(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tgit_annotated_commit *one,\n\tgit_annotated_commit *two,\n\tconst git_merge_options *opts,\n\tsize_t recursion_level)\n{\n\tgit_annotated_commit *result = NULL;\n\tgit_index *index = NULL;\n\tgit_merge_options virtual_opts = GIT_MERGE_OPTIONS_INIT;\n\n\t/* Conflicts in the merge base creation do not propagate to conflicts\n\t * in the result; the conflicted base will act as the common ancestor.\n\t */\n\tif (opts)\n\t\tmemcpy(&virtual_opts, opts, sizeof(git_merge_options));\n\n\tvirtual_opts.flags &= ~GIT_MERGE_FAIL_ON_CONFLICT;\n\tvirtual_opts.flags |= GIT_MERGE__VIRTUAL_BASE;\n\n\tif ((merge_annotated_commits(&index, NULL, repo, one, two,\n\t\t\trecursion_level + 1, &virtual_opts)) < 0)\n\t\treturn -1;\n\n\tresult = git__calloc(1, sizeof(git_annotated_commit));\n\tGITERR_CHECK_ALLOC(result);\n\tresult->type = GIT_ANNOTATED_COMMIT_VIRTUAL;\n\tresult->index = index;\n\n\tinsert_head_ids(&result->parents, one);\n\tinsert_head_ids(&result->parents, two);\n\n\t*out = result;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_annotated_commit_lookup",
          "args": [
            "&other",
            "repo",
            "&bases.ids[i]"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "git_annotated_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/annotated_commit.c",
          "lines": "125-133",
          "snippet": "int git_annotated_commit_lookup(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_oid *id)\n{\n\tassert(out && repo && id);\n\n\treturn annotated_commit_init(out, repo, id, NULL, NULL);\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/commit.h\"",
            "#include \"cache.h\"",
            "#include \"refs.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/tree.h\"\n#include \"git2/revparse.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/commit.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"annotated_commit.h\"\n#include \"common.h\"\n\nint git_annotated_commit_lookup(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_oid *id)\n{\n\tassert(out && repo && id);\n\n\treturn annotated_commit_init(out, repo, id, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge_bases_many",
          "args": [
            "&bases",
            "repo",
            "head_ids.size",
            "head_ids.ptr"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_bases_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "152-185",
          "snippet": "int git_merge_bases_many(git_oidarray *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk;\n\tgit_commit_list *list, *result = NULL;\n\tint error = 0;\n\tgit_array_oid_t array;\n\n\tassert(out && repo && input_array);\n\n\tif ((error = merge_bases_many(&result, &walk, repo, length, input_array)) < 0)\n\t\treturn error;\n\n\tgit_array_init(array);\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL) {\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\ncleanup:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_bases_many(git_oidarray *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk;\n\tgit_commit_list *list, *result = NULL;\n\tint error = 0;\n\tgit_array_oid_t array;\n\n\tassert(out && repo && input_array);\n\n\tif ((error = merge_bases_many(&result, &walk, repo, length, input_array)) < 0)\n\t\treturn error;\n\n\tgit_array_init(array);\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL) {\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\ncleanup:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_head_ids",
          "args": [
            "&head_ids",
            "two"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "insert_head_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1952-1974",
          "snippet": "GIT_INLINE(int) insert_head_ids(\n\tgit_array_oid_t *ids,\n\tconst git_annotated_commit *annotated_commit)\n{\n\tgit_oid *id;\n\tsize_t i;\n\n\tif (annotated_commit->type == GIT_ANNOTATED_COMMIT_REAL) {\n\t\tid = git_array_alloc(*ids);\n\t\tGITERR_CHECK_ALLOC(id);\n\n\t\tgit_oid_cpy(id, git_commit_id(annotated_commit->commit));\n\t} else {\n\t\tfor (i = 0; i < annotated_commit->parents.size; i++) {\n\t\t\tid = git_array_alloc(*ids);\n\t\t\tGITERR_CHECK_ALLOC(id);\n\n\t\t\tgit_oid_cpy(id, &annotated_commit->parents.ptr[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) insert_head_ids(\n\tgit_array_oid_t *ids,\n\tconst git_annotated_commit *annotated_commit)\n{\n\tgit_oid *id;\n\tsize_t i;\n\n\tif (annotated_commit->type == GIT_ANNOTATED_COMMIT_REAL) {\n\t\tid = git_array_alloc(*ids);\n\t\tGITERR_CHECK_ALLOC(id);\n\n\t\tgit_oid_cpy(id, git_commit_id(annotated_commit->commit));\n\t} else {\n\t\tfor (i = 0; i < annotated_commit->parents.size; i++) {\n\t\t\tid = git_array_alloc(*ids);\n\t\t\tGITERR_CHECK_ALLOC(id);\n\n\t\t\tgit_oid_cpy(id, &annotated_commit->parents.ptr[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&opts",
            "given_opts",
            "sizeof(git_merge_options)"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int compute_base(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tconst git_annotated_commit *one,\n\tconst git_annotated_commit *two,\n\tconst git_merge_options *given_opts,\n\tsize_t recursion_level)\n{\n\tgit_array_oid_t head_ids = GIT_ARRAY_INIT;\n\tgit_oidarray bases = {0};\n\tgit_annotated_commit *base = NULL, *other = NULL, *new_base = NULL;\n\tgit_merge_options opts = GIT_MERGE_OPTIONS_INIT;\n\tsize_t i;\n\tint error;\n\n\t*out = NULL;\n\n\tif (given_opts)\n\t\tmemcpy(&opts, given_opts, sizeof(git_merge_options));\n\n\tif ((error = insert_head_ids(&head_ids, one)) < 0 ||\n\t\t(error = insert_head_ids(&head_ids, two)) < 0)\n\t\tgoto done;\n\n\tif ((error = git_merge_bases_many(&bases, repo,\n\t\t\thead_ids.size, head_ids.ptr)) < 0 ||\n\t\t(error = git_annotated_commit_lookup(&base, repo, &bases.ids[0])) < 0 ||\n\t\t(opts.flags & GIT_MERGE_NO_RECURSIVE))\n\t\tgoto done;\n\n\tfor (i = 1; i < bases.count; i++) {\n\t\trecursion_level++;\n\n\t\tif (opts.recursion_limit && recursion_level > opts.recursion_limit)\n\t\t\tbreak;\n\n\t\tif ((error = git_annotated_commit_lookup(&other, repo,\n\t\t\t\t&bases.ids[i])) < 0 ||\n\t\t\t(error = create_virtual_base(&new_base, repo, base, other, &opts,\n\t\t\t\trecursion_level)) < 0)\n\t\t\tgoto done;\n\n\t\tgit_annotated_commit_free(base);\n\t\tgit_annotated_commit_free(other);\n\n\t\tbase = new_base;\n\t\tnew_base = NULL;\n\t\tother = NULL;\n\t}\n\ndone:\n\tif (error == 0)\n\t\t*out = base;\n\telse\n\t\tgit_annotated_commit_free(base);\n\n\tgit_annotated_commit_free(other);\n\tgit_annotated_commit_free(new_base);\n\tgit_oidarray_free(&bases);\n\tgit_array_clear(head_ids);\n\treturn error;\n}"
  },
  {
    "function_name": "create_virtual_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1976-2011",
    "snippet": "static int create_virtual_base(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tgit_annotated_commit *one,\n\tgit_annotated_commit *two,\n\tconst git_merge_options *opts,\n\tsize_t recursion_level)\n{\n\tgit_annotated_commit *result = NULL;\n\tgit_index *index = NULL;\n\tgit_merge_options virtual_opts = GIT_MERGE_OPTIONS_INIT;\n\n\t/* Conflicts in the merge base creation do not propagate to conflicts\n\t * in the result; the conflicted base will act as the common ancestor.\n\t */\n\tif (opts)\n\t\tmemcpy(&virtual_opts, opts, sizeof(git_merge_options));\n\n\tvirtual_opts.flags &= ~GIT_MERGE_FAIL_ON_CONFLICT;\n\tvirtual_opts.flags |= GIT_MERGE__VIRTUAL_BASE;\n\n\tif ((merge_annotated_commits(&index, NULL, repo, one, two,\n\t\t\trecursion_level + 1, &virtual_opts)) < 0)\n\t\treturn -1;\n\n\tresult = git__calloc(1, sizeof(git_annotated_commit));\n\tGITERR_CHECK_ALLOC(result);\n\tresult->type = GIT_ANNOTATED_COMMIT_VIRTUAL;\n\tresult->index = index;\n\n\tinsert_head_ids(&result->parents, one);\n\tinsert_head_ids(&result->parents, two);\n\n\t*out = result;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_head_ids",
          "args": [
            "&result->parents",
            "two"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "insert_head_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1952-1974",
          "snippet": "GIT_INLINE(int) insert_head_ids(\n\tgit_array_oid_t *ids,\n\tconst git_annotated_commit *annotated_commit)\n{\n\tgit_oid *id;\n\tsize_t i;\n\n\tif (annotated_commit->type == GIT_ANNOTATED_COMMIT_REAL) {\n\t\tid = git_array_alloc(*ids);\n\t\tGITERR_CHECK_ALLOC(id);\n\n\t\tgit_oid_cpy(id, git_commit_id(annotated_commit->commit));\n\t} else {\n\t\tfor (i = 0; i < annotated_commit->parents.size; i++) {\n\t\t\tid = git_array_alloc(*ids);\n\t\t\tGITERR_CHECK_ALLOC(id);\n\n\t\t\tgit_oid_cpy(id, &annotated_commit->parents.ptr[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) insert_head_ids(\n\tgit_array_oid_t *ids,\n\tconst git_annotated_commit *annotated_commit)\n{\n\tgit_oid *id;\n\tsize_t i;\n\n\tif (annotated_commit->type == GIT_ANNOTATED_COMMIT_REAL) {\n\t\tid = git_array_alloc(*ids);\n\t\tGITERR_CHECK_ALLOC(id);\n\n\t\tgit_oid_cpy(id, git_commit_id(annotated_commit->commit));\n\t} else {\n\t\tfor (i = 0; i < annotated_commit->parents.size; i++) {\n\t\t\tid = git_array_alloc(*ids);\n\t\t\tGITERR_CHECK_ALLOC(id);\n\n\t\t\tgit_oid_cpy(id, &annotated_commit->parents.ptr[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "result"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_annotated_commit)"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_annotated_commits",
          "args": [
            "&index",
            "NULL",
            "repo",
            "one",
            "two",
            "recursion_level + 1",
            "&virtual_opts"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "merge_annotated_commits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2101-2141",
          "snippet": "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *ours,\n\tgit_annotated_commit *theirs,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *base = NULL;\n\tgit_iterator *base_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tint error;\n\n    if ((error = compute_base(&base, repo, ours, theirs, opts,\n\t\trecursion_level)) < 0) {\n\n        if (error != GIT_ENOTFOUND)\n            goto done;\n\n        giterr_clear();\n    }\n\n\tif ((error = iterator_for_annotated_commit(&base_iter, base)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&our_iter, ours)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&their_iter, theirs)) < 0 ||\n\t\t(error = git_merge__iterators(index_out, repo, base_iter, our_iter,\n\t\t\ttheir_iter, opts)) < 0)\n\t\tgoto done;\n\n\tif (base_out) {\n\t\t*base_out = base;\n\t\tbase = NULL;\n\t}\n\ndone:\n\tgit_annotated_commit_free(base);\n\tgit_iterator_free(base_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *ours,\n\tgit_annotated_commit *theirs,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts)\n{\n\tgit_annotated_commit *base = NULL;\n\tgit_iterator *base_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tint error;\n\n    if ((error = compute_base(&base, repo, ours, theirs, opts,\n\t\trecursion_level)) < 0) {\n\n        if (error != GIT_ENOTFOUND)\n            goto done;\n\n        giterr_clear();\n    }\n\n\tif ((error = iterator_for_annotated_commit(&base_iter, base)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&our_iter, ours)) < 0 ||\n\t\t(error = iterator_for_annotated_commit(&their_iter, theirs)) < 0 ||\n\t\t(error = git_merge__iterators(index_out, repo, base_iter, our_iter,\n\t\t\ttheir_iter, opts)) < 0)\n\t\tgoto done;\n\n\tif (base_out) {\n\t\t*base_out = base;\n\t\tbase = NULL;\n\t}\n\ndone:\n\tgit_annotated_commit_free(base);\n\tgit_iterator_free(base_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&virtual_opts",
            "opts",
            "sizeof(git_merge_options)"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int create_virtual_base(\n\tgit_annotated_commit **out,\n\tgit_repository *repo,\n\tgit_annotated_commit *one,\n\tgit_annotated_commit *two,\n\tconst git_merge_options *opts,\n\tsize_t recursion_level)\n{\n\tgit_annotated_commit *result = NULL;\n\tgit_index *index = NULL;\n\tgit_merge_options virtual_opts = GIT_MERGE_OPTIONS_INIT;\n\n\t/* Conflicts in the merge base creation do not propagate to conflicts\n\t * in the result; the conflicted base will act as the common ancestor.\n\t */\n\tif (opts)\n\t\tmemcpy(&virtual_opts, opts, sizeof(git_merge_options));\n\n\tvirtual_opts.flags &= ~GIT_MERGE_FAIL_ON_CONFLICT;\n\tvirtual_opts.flags |= GIT_MERGE__VIRTUAL_BASE;\n\n\tif ((merge_annotated_commits(&index, NULL, repo, one, two,\n\t\t\trecursion_level + 1, &virtual_opts)) < 0)\n\t\treturn -1;\n\n\tresult = git__calloc(1, sizeof(git_annotated_commit));\n\tGITERR_CHECK_ALLOC(result);\n\tresult->type = GIT_ANNOTATED_COMMIT_VIRTUAL;\n\tresult->index = index;\n\n\tinsert_head_ids(&result->parents, one);\n\tinsert_head_ids(&result->parents, two);\n\n\t*out = result;\n\treturn 0;\n}"
  },
  {
    "function_name": "insert_head_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1952-1974",
    "snippet": "GIT_INLINE(int) insert_head_ids(\n\tgit_array_oid_t *ids,\n\tconst git_annotated_commit *annotated_commit)\n{\n\tgit_oid *id;\n\tsize_t i;\n\n\tif (annotated_commit->type == GIT_ANNOTATED_COMMIT_REAL) {\n\t\tid = git_array_alloc(*ids);\n\t\tGITERR_CHECK_ALLOC(id);\n\n\t\tgit_oid_cpy(id, git_commit_id(annotated_commit->commit));\n\t} else {\n\t\tfor (i = 0; i < annotated_commit->parents.size; i++) {\n\t\t\tid = git_array_alloc(*ids);\n\t\t\tGITERR_CHECK_ALLOC(id);\n\n\t\t\tgit_oid_cpy(id, &annotated_commit->parents.ptr[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "id",
            "&annotated_commit->parents.ptr[i]"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "id"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_alloc",
          "args": [
            "*ids"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "annotated_commit->commit"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "id"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_alloc",
          "args": [
            "*ids"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) insert_head_ids(\n\tgit_array_oid_t *ids,\n\tconst git_annotated_commit *annotated_commit)\n{\n\tgit_oid *id;\n\tsize_t i;\n\n\tif (annotated_commit->type == GIT_ANNOTATED_COMMIT_REAL) {\n\t\tid = git_array_alloc(*ids);\n\t\tGITERR_CHECK_ALLOC(id);\n\n\t\tgit_oid_cpy(id, git_commit_id(annotated_commit->commit));\n\t} else {\n\t\tfor (i = 0; i < annotated_commit->parents.size; i++) {\n\t\t\tid = git_array_alloc(*ids);\n\t\t\tGITERR_CHECK_ALLOC(id);\n\n\t\t\tgit_oid_cpy(id, &annotated_commit->parents.ptr[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_merge_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1910-1941",
    "snippet": "int git_merge_trees(\n\tgit_index **out,\n\tgit_repository *repo,\n\tconst git_tree *ancestor_tree,\n\tconst git_tree *our_tree,\n\tconst git_tree *their_tree,\n\tconst git_merge_options *merge_opts)\n{\n\tgit_iterator *ancestor_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(\n\t\t\t&ancestor_iter, (git_tree *)ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&our_iter, (git_tree *)our_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&their_iter, (git_tree *)their_tree, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(\n\t\tout, repo, ancestor_iter, our_iter, their_iter, merge_opts);\n\ndone:\n\tgit_iterator_free(ancestor_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "their_iter"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__iterators",
          "args": [
            "out",
            "repo",
            "ancestor_iter",
            "our_iter",
            "their_iter",
            "merge_opts"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__iterators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1822-1908",
          "snippet": "int git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "&their_iter",
            "(git_tree *)their_tree",
            "&iter_opts"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_trees(\n\tgit_index **out,\n\tgit_repository *repo,\n\tconst git_tree *ancestor_tree,\n\tconst git_tree *our_tree,\n\tconst git_tree *their_tree,\n\tconst git_merge_options *merge_opts)\n{\n\tgit_iterator *ancestor_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(\n\t\t\t&ancestor_iter, (git_tree *)ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&our_iter, (git_tree *)our_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&their_iter, (git_tree *)their_tree, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(\n\t\tout, repo, ancestor_iter, our_iter, their_iter, merge_opts);\n\ndone:\n\tgit_iterator_free(ancestor_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_merge__iterators",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1822-1908",
    "snippet": "int git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "empty_theirs"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge_diff_list__free",
          "args": [
            "diff_list"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_diff_list__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1612-1622",
          "snippet": "void git_merge_diff_list__free(git_merge_diff_list *diff_list)\n{\n\tif (!diff_list)\n\t\treturn;\n\n\tgit_vector_free(&diff_list->staged);\n\tgit_vector_free(&diff_list->conflicts);\n\tgit_vector_free(&diff_list->resolved);\n\tgit_pool_clear(&diff_list->pool);\n\tgit__free(diff_list);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nvoid git_merge_diff_list__free(git_merge_diff_list *diff_list)\n{\n\tif (!diff_list)\n\t\treturn;\n\n\tgit_vector_free(&diff_list->staged);\n\tgit_vector_free(&diff_list->conflicts);\n\tgit_vector_free(&diff_list->resolved);\n\tgit_pool_clear(&diff_list->pool);\n\tgit__free(diff_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "opts.metric"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_from_diff_list",
          "args": [
            "out",
            "diff_list",
            "(opts.flags & GIT_MERGE_SKIP_REUC)"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "index_from_diff_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1737-1805",
          "snippet": "static int index_from_diff_list(git_index **out,\n\tgit_merge_diff_list *diff_list, bool skip_reuc)\n{\n\tgit_index *index;\n\tsize_t i;\n\tgit_merge_diff *conflict;\n\tint error = 0;\n\n\t*out = NULL;\n\n\tif ((error = git_index_new(&index)) < 0)\n\t\treturn error;\n\n\tif ((error = git_index__fill(index, &diff_list->staged)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict) {\n\t\tconst git_index_entry *ancestor =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t\t&conflict->ancestor_entry : NULL;\n\n\t\tconst git_index_entry *ours =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\t&conflict->our_entry : NULL;\n\n\t\tconst git_index_entry *theirs =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\t&conflict->their_entry : NULL;\n\n\t\tif ((error = git_index_conflict_add(index, ancestor, ours, theirs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* Add each rename entry to the rename portion of the index. */\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict) {\n\t\tconst char *ancestor_path, *our_path, *their_path;\n\n\t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry))\n\t\t\tcontinue;\n\n\t\tancestor_path = conflict->ancestor_entry.path;\n\n\t\tour_path =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\tconflict->our_entry.path : NULL;\n\n\t\ttheir_path =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\tconflict->their_entry.path : NULL;\n\n\t\tif ((our_path && strcmp(ancestor_path, our_path) != 0) ||\n\t\t\t(their_path && strcmp(ancestor_path, their_path) != 0)) {\n\t\t\tif ((error = git_index_name_add(index, ancestor_path, our_path, their_path)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif (!skip_reuc) {\n\t\tif ((error = index_update_reuc(index, diff_list)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t*out = index;\n\treturn 0;\n\non_error:\n\tgit_index_free(index);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int index_from_diff_list(git_index **out,\n\tgit_merge_diff_list *diff_list, bool skip_reuc)\n{\n\tgit_index *index;\n\tsize_t i;\n\tgit_merge_diff *conflict;\n\tint error = 0;\n\n\t*out = NULL;\n\n\tif ((error = git_index_new(&index)) < 0)\n\t\treturn error;\n\n\tif ((error = git_index__fill(index, &diff_list->staged)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict) {\n\t\tconst git_index_entry *ancestor =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t\t&conflict->ancestor_entry : NULL;\n\n\t\tconst git_index_entry *ours =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\t&conflict->our_entry : NULL;\n\n\t\tconst git_index_entry *theirs =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\t&conflict->their_entry : NULL;\n\n\t\tif ((error = git_index_conflict_add(index, ancestor, ours, theirs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* Add each rename entry to the rename portion of the index. */\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict) {\n\t\tconst char *ancestor_path, *our_path, *their_path;\n\n\t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry))\n\t\t\tcontinue;\n\n\t\tancestor_path = conflict->ancestor_entry.path;\n\n\t\tour_path =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\tconflict->our_entry.path : NULL;\n\n\t\ttheir_path =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\tconflict->their_entry.path : NULL;\n\n\t\tif ((our_path && strcmp(ancestor_path, our_path) != 0) ||\n\t\t\t(their_path && strcmp(ancestor_path, their_path) != 0)) {\n\t\t\tif ((error = git_index_name_add(index, ancestor_path, our_path, their_path)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif (!skip_reuc) {\n\t\tif ((error = index_update_reuc(index, diff_list)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t*out = index;\n\treturn 0;\n\non_error:\n\tgit_index_free(index);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&diff_list->conflicts",
            "conflict"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_MERGE",
            "\"merge conflicts exist\""
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_conflict_resolve",
          "args": [
            "&resolved",
            "diff_list",
            "conflict",
            "&file_opts"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "merge_conflict_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "894-921",
          "snippet": "static int merge_conflict_resolve(\n\tint *out,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict,\n\tconst git_merge_file_options *file_opts)\n{\n\tint resolved = 0;\n\tint error = 0;\n\n\t*out = 0;\n\n\tif ((error = merge_conflict_resolve_trivial(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_one_removed(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_one_renamed(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_automerge(&resolved, diff_list, conflict, file_opts)) < 0)\n\t\tgoto done;\n\n\t*out = resolved;\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve(\n\tint *out,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict,\n\tconst git_merge_file_options *file_opts)\n{\n\tint resolved = 0;\n\tint error = 0;\n\n\t*out = 0;\n\n\tif ((error = merge_conflict_resolve_trivial(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_one_removed(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_one_renamed(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_automerge(&resolved, diff_list, conflict, file_opts)) < 0)\n\t\tgoto done;\n\n\t*out = resolved;\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&changes",
            "i",
            "conflict"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&diff_list->conflicts"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&changes",
            "&diff_list->conflicts",
            "sizeof(git_vector)"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_merge_diff_list__find_renames",
          "args": [
            "repo",
            "diff_list",
            "&opts"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_diff_list__find_renames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1294-1364",
          "snippet": "int git_merge_diff_list__find_renames(\n\tgit_repository *repo,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_options *opts)\n{\n\tstruct merge_diff_similarity *similarity_ours, *similarity_theirs;\n\tvoid **cache = NULL;\n\tsize_t cache_size = 0;\n\tsize_t src_count, tgt_count, i;\n\tint error = 0;\n\n\tassert(diff_list && opts);\n\n\tif ((opts->flags & GIT_MERGE_FIND_RENAMES) == 0)\n\t\treturn 0;\n\n\tsimilarity_ours = git__calloc(diff_list->conflicts.length,\n\t\tsizeof(struct merge_diff_similarity));\n\tGITERR_CHECK_ALLOC(similarity_ours);\n\n\tsimilarity_theirs = git__calloc(diff_list->conflicts.length,\n\t\tsizeof(struct merge_diff_similarity));\n\tGITERR_CHECK_ALLOC(similarity_theirs);\n\n\t/* Calculate similarity between items that were deleted from the ancestor\n\t * and added in the other branch.\n\t */\n\tif ((error = merge_diff_mark_similarity(repo, diff_list, similarity_ours,\n\t\tsimilarity_theirs, index_entry_similarity_exact, NULL, opts)) < 0)\n\t\tgoto done;\n\n\tif (diff_list->conflicts.length <= opts->target_limit) {\n\t\tGITERR_CHECK_ALLOC_MULTIPLY(&cache_size, diff_list->conflicts.length, 3);\n\t\tcache = git__calloc(cache_size, sizeof(void *));\n\t\tGITERR_CHECK_ALLOC(cache);\n\n\t\tmerge_diff_list_count_candidates(diff_list, &src_count, &tgt_count);\n\n\t\tif (src_count > opts->target_limit || tgt_count > opts->target_limit) {\n\t\t\t/* TODO: report! */\n\t\t} else {\n\t\t\tif ((error = merge_diff_mark_similarity(\n\t\t\t\trepo, diff_list, similarity_ours, similarity_theirs,\n\t\t\t\tindex_entry_similarity_inexact, cache, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* For entries that are appropriately similar, merge the new name's entry\n\t * into the old name.\n\t */\n\tmerge_diff_list_coalesce_renames(diff_list, similarity_ours, similarity_theirs, opts);\n\n\t/* And remove any entries that were merged and are now empty. */\n\tgit_vector_remove_matching(&diff_list->conflicts, merge_diff_empty, NULL);\n\ndone:\n\tif (cache != NULL) {\n\t\tfor (i = 0; i < cache_size; ++i) {\n\t\t\tif (cache[i] != NULL)\n\t\t\t\topts->metric->free_signature(cache[i], opts->metric->payload);\n\t\t}\n\n\t\tgit__free(cache);\n\t}\n\n\tgit__free(similarity_ours);\n\tgit__free(similarity_theirs);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge_diff_list__find_renames(\n\tgit_repository *repo,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_options *opts)\n{\n\tstruct merge_diff_similarity *similarity_ours, *similarity_theirs;\n\tvoid **cache = NULL;\n\tsize_t cache_size = 0;\n\tsize_t src_count, tgt_count, i;\n\tint error = 0;\n\n\tassert(diff_list && opts);\n\n\tif ((opts->flags & GIT_MERGE_FIND_RENAMES) == 0)\n\t\treturn 0;\n\n\tsimilarity_ours = git__calloc(diff_list->conflicts.length,\n\t\tsizeof(struct merge_diff_similarity));\n\tGITERR_CHECK_ALLOC(similarity_ours);\n\n\tsimilarity_theirs = git__calloc(diff_list->conflicts.length,\n\t\tsizeof(struct merge_diff_similarity));\n\tGITERR_CHECK_ALLOC(similarity_theirs);\n\n\t/* Calculate similarity between items that were deleted from the ancestor\n\t * and added in the other branch.\n\t */\n\tif ((error = merge_diff_mark_similarity(repo, diff_list, similarity_ours,\n\t\tsimilarity_theirs, index_entry_similarity_exact, NULL, opts)) < 0)\n\t\tgoto done;\n\n\tif (diff_list->conflicts.length <= opts->target_limit) {\n\t\tGITERR_CHECK_ALLOC_MULTIPLY(&cache_size, diff_list->conflicts.length, 3);\n\t\tcache = git__calloc(cache_size, sizeof(void *));\n\t\tGITERR_CHECK_ALLOC(cache);\n\n\t\tmerge_diff_list_count_candidates(diff_list, &src_count, &tgt_count);\n\n\t\tif (src_count > opts->target_limit || tgt_count > opts->target_limit) {\n\t\t\t/* TODO: report! */\n\t\t} else {\n\t\t\tif ((error = merge_diff_mark_similarity(\n\t\t\t\trepo, diff_list, similarity_ours, similarity_theirs,\n\t\t\t\tindex_entry_similarity_inexact, cache, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* For entries that are appropriately similar, merge the new name's entry\n\t * into the old name.\n\t */\n\tmerge_diff_list_coalesce_renames(diff_list, similarity_ours, similarity_theirs, opts);\n\n\t/* And remove any entries that were merged and are now empty. */\n\tgit_vector_remove_matching(&diff_list->conflicts, merge_diff_empty, NULL);\n\ndone:\n\tif (cache != NULL) {\n\t\tfor (i = 0; i < cache_size; ++i) {\n\t\t\tif (cache[i] != NULL)\n\t\t\t\topts->metric->free_signature(cache[i], opts->metric->payload);\n\t\t}\n\n\t\tgit__free(cache);\n\t}\n\n\tgit__free(similarity_ours);\n\tgit__free(similarity_theirs);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge_diff_list__find_differences",
          "args": [
            "diff_list",
            "ancestor_iter",
            "our_iter",
            "theirs_iter"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_diff_list__find_differences",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1579-1589",
          "snippet": "int git_merge_diff_list__find_differences(\n\tgit_merge_diff_list *diff_list,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *their_iter)\n{\n\tgit_iterator *iterators[3] = { ancestor_iter, our_iter, their_iter };\n\tstruct merge_diff_find_data find_data = { diff_list };\n\n\treturn git_iterator_walk(iterators, 3, queue_difference, &find_data);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_diff_list__find_differences(\n\tgit_merge_diff_list *diff_list,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *their_iter)\n{\n\tgit_iterator *iterators[3] = { ancestor_iter, our_iter, their_iter };\n\tstruct merge_diff_find_data find_data = { diff_list };\n\n\treturn git_iterator_walk(iterators, 3, queue_difference, &find_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator_given_or_empty",
          "args": [
            "&empty_theirs",
            "theirs_iter"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_given_or_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1807-1820",
          "snippet": "static git_iterator *iterator_given_or_empty(git_iterator **empty, git_iterator *given)\n{\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\n\tif (given)\n\t\treturn given;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif (git_iterator_for_nothing(empty, &opts) < 0)\n\t\treturn NULL;\n\n\treturn *empty;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic git_iterator *iterator_given_or_empty(git_iterator **empty, git_iterator *given)\n{\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\n\tif (given)\n\t\treturn given;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif (git_iterator_for_nothing(empty, &opts) < 0)\n\t\treturn NULL;\n\n\treturn *empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "diff_list"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_merge_diff_list__alloc",
          "args": [
            "repo"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_diff_list__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1591-1610",
          "snippet": "git_merge_diff_list *git_merge_diff_list__alloc(git_repository *repo)\n{\n\tgit_merge_diff_list *diff_list = git__calloc(1, sizeof(git_merge_diff_list));\n\n\tif (diff_list == NULL)\n\t\treturn NULL;\n\n\tdiff_list->repo = repo;\n\n\tgit_pool_init(&diff_list->pool, 1);\n\n\tif (git_vector_init(&diff_list->staged, 0, NULL) < 0 ||\n\t\tgit_vector_init(&diff_list->conflicts, 0, NULL) < 0 ||\n\t\tgit_vector_init(&diff_list->resolved, 0, NULL) < 0) {\n\t\tgit_merge_diff_list__free(diff_list);\n\t\treturn NULL;\n\t}\n\n\treturn diff_list;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\ngit_merge_diff_list *git_merge_diff_list__alloc(git_repository *repo)\n{\n\tgit_merge_diff_list *diff_list = git__calloc(1, sizeof(git_merge_diff_list));\n\n\tif (diff_list == NULL)\n\t\treturn NULL;\n\n\tdiff_list->repo = repo;\n\n\tgit_pool_init(&diff_list->pool, 1);\n\n\tif (git_vector_init(&diff_list->staged, 0, NULL) < 0 ||\n\t\tgit_vector_init(&diff_list->conflicts, 0, NULL) < 0 ||\n\t\tgit_vector_init(&diff_list->resolved, 0, NULL) < 0) {\n\t\tgit_merge_diff_list__free(diff_list);\n\t\treturn NULL;\n\t}\n\n\treturn diff_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_normalize_opts",
          "args": [
            "repo",
            "&opts",
            "given_opts"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "merge_normalize_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1624-1670",
          "snippet": "static int merge_normalize_opts(\n\tgit_repository *repo,\n\tgit_merge_options *opts,\n\tconst git_merge_options *given)\n{\n\tgit_config *cfg = NULL;\n\tint error = 0;\n\n\tassert(repo && opts);\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif (given != NULL)\n\t\tmemcpy(opts, given, sizeof(git_merge_options));\n\telse {\n\t\tgit_merge_options init = GIT_MERGE_OPTIONS_INIT;\n\t\tmemcpy(opts, &init, sizeof(init));\n\n\t\topts->flags = GIT_MERGE_FIND_RENAMES;\n\t\topts->rename_threshold = GIT_MERGE_DEFAULT_RENAME_THRESHOLD;\n\t}\n\n\tif (!opts->target_limit) {\n\t\tint limit = git_config__get_int_force(cfg, \"merge.renamelimit\", 0);\n\n\t\tif (!limit)\n\t\t\tlimit = git_config__get_int_force(cfg, \"diff.renamelimit\", 0);\n\n\t\topts->target_limit = (limit <= 0) ?\n\t\t\tGIT_MERGE_DEFAULT_TARGET_LIMIT : (unsigned int)limit;\n\t}\n\n\t/* assign the internal metric with whitespace flag as payload */\n\tif (!opts->metric) {\n\t\topts->metric = git__malloc(sizeof(git_diff_similarity_metric));\n\t\tGITERR_CHECK_ALLOC(opts->metric);\n\n\t\topts->metric->file_signature = git_diff_find_similar__hashsig_for_file;\n\t\topts->metric->buffer_signature = git_diff_find_similar__hashsig_for_buf;\n\t\topts->metric->free_signature = git_diff_find_similar__hashsig_free;\n\t\topts->metric->similarity = git_diff_find_similar__calc_similarity;\n\t\topts->metric->payload = (void *)GIT_HASHSIG_SMART_WHITESPACE;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_normalize_opts(\n\tgit_repository *repo,\n\tgit_merge_options *opts,\n\tconst git_merge_options *given)\n{\n\tgit_config *cfg = NULL;\n\tint error = 0;\n\n\tassert(repo && opts);\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif (given != NULL)\n\t\tmemcpy(opts, given, sizeof(git_merge_options));\n\telse {\n\t\tgit_merge_options init = GIT_MERGE_OPTIONS_INIT;\n\t\tmemcpy(opts, &init, sizeof(init));\n\n\t\topts->flags = GIT_MERGE_FIND_RENAMES;\n\t\topts->rename_threshold = GIT_MERGE_DEFAULT_RENAME_THRESHOLD;\n\t}\n\n\tif (!opts->target_limit) {\n\t\tint limit = git_config__get_int_force(cfg, \"merge.renamelimit\", 0);\n\n\t\tif (!limit)\n\t\t\tlimit = git_config__get_int_force(cfg, \"diff.renamelimit\", 0);\n\n\t\topts->target_limit = (limit <= 0) ?\n\t\t\tGIT_MERGE_DEFAULT_TARGET_LIMIT : (unsigned int)limit;\n\t}\n\n\t/* assign the internal metric with whitespace flag as payload */\n\tif (!opts->metric) {\n\t\topts->metric = git__malloc(sizeof(git_diff_similarity_metric));\n\t\tGITERR_CHECK_ALLOC(opts->metric);\n\n\t\topts->metric->file_signature = git_diff_find_similar__hashsig_for_file;\n\t\topts->metric->buffer_signature = git_diff_find_similar__hashsig_for_buf;\n\t\topts->metric->free_signature = git_diff_find_similar__hashsig_free;\n\t\topts->metric->similarity = git_diff_find_similar__calc_similarity;\n\t\topts->metric->payload = (void *)GIT_HASHSIG_SMART_WHITESPACE;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "given_opts",
            "GIT_MERGE_OPTIONS_VERSION",
            "\"git_merge_options\""
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}"
  },
  {
    "function_name": "iterator_given_or_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1807-1820",
    "snippet": "static git_iterator *iterator_given_or_empty(git_iterator **empty, git_iterator *given)\n{\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\n\tif (given)\n\t\treturn given;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif (git_iterator_for_nothing(empty, &opts) < 0)\n\t\treturn NULL;\n\n\treturn *empty;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_for_nothing",
          "args": [
            "empty",
            "&opts"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_nothing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "302-320",
          "snippet": "int git_iterator_for_nothing(\n\tgit_iterator **iter,\n\tgit_iterator_options *options)\n{\n\tempty_iterator *i = git__calloc(1, sizeof(empty_iterator));\n\tGITERR_CHECK_ALLOC(i);\n\n#define empty_iterator__current empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__advance_into empty_iterator__noop\n\n\tITERATOR_BASE_INIT(i, empty, EMPTY, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\ti->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\t*iter = (git_iterator *)i;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define empty_iterator__advance_into empty_iterator__noop",
            "#define empty_iterator__advance empty_iterator__noop",
            "#define empty_iterator__current empty_iterator__noop"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define empty_iterator__advance_into empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__current empty_iterator__noop\n\nint git_iterator_for_nothing(\n\tgit_iterator **iter,\n\tgit_iterator_options *options)\n{\n\tempty_iterator *i = git__calloc(1, sizeof(empty_iterator));\n\tGITERR_CHECK_ALLOC(i);\n\n#define empty_iterator__current empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__advance_into empty_iterator__noop\n\n\tITERATOR_BASE_INIT(i, empty, EMPTY, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\ti->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\t*iter = (git_iterator *)i;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic git_iterator *iterator_given_or_empty(git_iterator **empty, git_iterator *given)\n{\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\n\tif (given)\n\t\treturn given;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif (git_iterator_for_nothing(empty, &opts) < 0)\n\t\treturn NULL;\n\n\treturn *empty;\n}"
  },
  {
    "function_name": "index_from_diff_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1737-1805",
    "snippet": "static int index_from_diff_list(git_index **out,\n\tgit_merge_diff_list *diff_list, bool skip_reuc)\n{\n\tgit_index *index;\n\tsize_t i;\n\tgit_merge_diff *conflict;\n\tint error = 0;\n\n\t*out = NULL;\n\n\tif ((error = git_index_new(&index)) < 0)\n\t\treturn error;\n\n\tif ((error = git_index__fill(index, &diff_list->staged)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict) {\n\t\tconst git_index_entry *ancestor =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t\t&conflict->ancestor_entry : NULL;\n\n\t\tconst git_index_entry *ours =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\t&conflict->our_entry : NULL;\n\n\t\tconst git_index_entry *theirs =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\t&conflict->their_entry : NULL;\n\n\t\tif ((error = git_index_conflict_add(index, ancestor, ours, theirs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* Add each rename entry to the rename portion of the index. */\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict) {\n\t\tconst char *ancestor_path, *our_path, *their_path;\n\n\t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry))\n\t\t\tcontinue;\n\n\t\tancestor_path = conflict->ancestor_entry.path;\n\n\t\tour_path =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\tconflict->our_entry.path : NULL;\n\n\t\ttheir_path =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\tconflict->their_entry.path : NULL;\n\n\t\tif ((our_path && strcmp(ancestor_path, our_path) != 0) ||\n\t\t\t(their_path && strcmp(ancestor_path, their_path) != 0)) {\n\t\t\tif ((error = git_index_name_add(index, ancestor_path, our_path, their_path)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif (!skip_reuc) {\n\t\tif ((error = index_update_reuc(index, diff_list)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t*out = index;\n\treturn 0;\n\non_error:\n\tgit_index_free(index);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_update_reuc",
          "args": [
            "index",
            "diff_list"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "index_update_reuc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1700-1735",
          "snippet": "static int index_update_reuc(git_index *index, git_merge_diff_list *diff_list)\n{\n\tint error;\n\tsize_t i;\n\tgit_merge_diff *conflict;\n\n\t/* Add each entry in the resolved conflict to the REUC independently, since\n\t * the paths may differ due to renames. */\n\tgit_vector_foreach(&diff_list->resolved, i, conflict) {\n\t\tconst git_index_entry *ancestor =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t\t&conflict->ancestor_entry : NULL;\n\n\t\tconst git_index_entry *ours =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\t&conflict->our_entry : NULL;\n\n\t\tconst git_index_entry *theirs =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\t&conflict->their_entry : NULL;\n\n\t\tif (ancestor != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_ANCESTOR, ancestor)) < 0)\n\t\t\treturn error;\n\n\t\tif (ours != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_OURS, ours)) < 0)\n\t\t\treturn error;\n\n\t\tif (theirs != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_THEIRS, theirs)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int index_update_reuc(git_index *index, git_merge_diff_list *diff_list)\n{\n\tint error;\n\tsize_t i;\n\tgit_merge_diff *conflict;\n\n\t/* Add each entry in the resolved conflict to the REUC independently, since\n\t * the paths may differ due to renames. */\n\tgit_vector_foreach(&diff_list->resolved, i, conflict) {\n\t\tconst git_index_entry *ancestor =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t\t&conflict->ancestor_entry : NULL;\n\n\t\tconst git_index_entry *ours =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\t&conflict->our_entry : NULL;\n\n\t\tconst git_index_entry *theirs =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\t&conflict->their_entry : NULL;\n\n\t\tif (ancestor != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_ANCESTOR, ancestor)) < 0)\n\t\t\treturn error;\n\n\t\tif (ours != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_OURS, ours)) < 0)\n\t\t\treturn error;\n\n\t\tif (theirs != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_THEIRS, theirs)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_name_add",
          "args": [
            "index",
            "ancestor_path",
            "our_path",
            "their_path"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_name_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1989-2009",
          "snippet": "int git_index_name_add(git_index *index,\n\tconst char *ancestor, const char *ours, const char *theirs)\n{\n\tgit_index_name_entry *conflict_name;\n\n\tassert((ancestor && ours) || (ancestor && theirs) || (ours && theirs));\n\n\tconflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\tGITERR_CHECK_ALLOC(conflict_name);\n\n\tif ((ancestor && !(conflict_name->ancestor = git__strdup(ancestor))) ||\n\t\t(ours     && !(conflict_name->ours     = git__strdup(ours))) ||\n\t\t(theirs   && !(conflict_name->theirs   = git__strdup(theirs))) ||\n\t\tgit_vector_insert(&index->names, conflict_name) < 0)\n\t{\n\t\tindex_name_entry_free(conflict_name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_name_add(git_index *index,\n\tconst char *ancestor, const char *ours, const char *theirs)\n{\n\tgit_index_name_entry *conflict_name;\n\n\tassert((ancestor && ours) || (ancestor && theirs) || (ours && theirs));\n\n\tconflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\tGITERR_CHECK_ALLOC(conflict_name);\n\n\tif ((ancestor && !(conflict_name->ancestor = git__strdup(ancestor))) ||\n\t\t(ours     && !(conflict_name->ours     = git__strdup(ours))) ||\n\t\t(theirs   && !(conflict_name->theirs   = git__strdup(theirs))) ||\n\t\tgit_vector_insert(&index->names, conflict_name) < 0)\n\t{\n\t\tindex_name_entry_free(conflict_name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ancestor_path",
            "their_path"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->ancestor_entry"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff_list->conflicts",
            "i",
            "conflict"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_index_conflict_add",
          "args": [
            "index",
            "ancestor",
            "ours",
            "theirs"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_conflict_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1705-1770",
          "snippet": "int git_index_conflict_add(git_index *index,\n\tconst git_index_entry *ancestor_entry,\n\tconst git_index_entry *our_entry,\n\tconst git_index_entry *their_entry)\n{\n\tgit_index_entry *entries[3] = { 0 };\n\tunsigned short i;\n\tint ret = 0;\n\n\tassert (index);\n\n\tif ((ancestor_entry &&\n\t\t\t(ret = index_entry_dup(&entries[0], index, ancestor_entry)) < 0) ||\n\t\t(our_entry &&\n\t\t\t(ret = index_entry_dup(&entries[1], index, our_entry)) < 0) ||\n\t\t(their_entry &&\n\t\t\t(ret = index_entry_dup(&entries[2], index, their_entry)) < 0))\n\t\tgoto on_error;\n\n\t/* Validate entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] && !valid_filemode(entries[i]->mode)) {\n\t\t\tgiterr_set(GITERR_INDEX, \"invalid filemode for stage %d entry\",\n\t\t\t\ti + 1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Remove existing index entries for each path */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((ret = git_index_remove(index, entries[i]->path, 0)) != 0) {\n\t\t\tif (ret != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* Add the conflict entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\t/* Make sure stage is correct */\n\t\tGIT_IDXENTRY_STAGE_SET(entries[i], i + 1);\n\n\t\tif ((ret = index_insert(index, &entries[i], 1, true, true, false)) < 0)\n\t\t\tgoto on_error;\n\n\t\tentries[i] = NULL; /* don't free if later entry fails */\n\t}\n\n\treturn 0;\n\non_error:\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] != NULL)\n\t\t\tindex_entry_free(entries[i]);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_conflict_add(git_index *index,\n\tconst git_index_entry *ancestor_entry,\n\tconst git_index_entry *our_entry,\n\tconst git_index_entry *their_entry)\n{\n\tgit_index_entry *entries[3] = { 0 };\n\tunsigned short i;\n\tint ret = 0;\n\n\tassert (index);\n\n\tif ((ancestor_entry &&\n\t\t\t(ret = index_entry_dup(&entries[0], index, ancestor_entry)) < 0) ||\n\t\t(our_entry &&\n\t\t\t(ret = index_entry_dup(&entries[1], index, our_entry)) < 0) ||\n\t\t(their_entry &&\n\t\t\t(ret = index_entry_dup(&entries[2], index, their_entry)) < 0))\n\t\tgoto on_error;\n\n\t/* Validate entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] && !valid_filemode(entries[i]->mode)) {\n\t\t\tgiterr_set(GITERR_INDEX, \"invalid filemode for stage %d entry\",\n\t\t\t\ti + 1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Remove existing index entries for each path */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((ret = git_index_remove(index, entries[i]->path, 0)) != 0) {\n\t\t\tif (ret != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* Add the conflict entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\t/* Make sure stage is correct */\n\t\tGIT_IDXENTRY_STAGE_SET(entries[i], i + 1);\n\n\t\tif ((ret = index_insert(index, &entries[i], 1, true, true, false)) < 0)\n\t\t\tgoto on_error;\n\n\t\tentries[i] = NULL; /* don't free if later entry fails */\n\t}\n\n\treturn 0;\n\non_error:\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] != NULL)\n\t\t\tindex_entry_free(entries[i]);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->ancestor_entry"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff_list->conflicts",
            "i",
            "conflict"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_index__fill",
          "args": [
            "index",
            "&diff_list->staged"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "git_index__fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1541-1577",
          "snippet": "int git_index__fill(git_index *index, const git_vector *source_entries)\n{\n\tconst git_index_entry *source_entry = NULL;\n\tsize_t i;\n\tint ret = 0;\n\n\tassert(index);\n\n\tif (!source_entries->length)\n\t\treturn 0;\n\n\tgit_vector_size_hint(&index->entries, source_entries->length);\n\tgit_idxmap_resize(index->entries_map, (khint_t)(source_entries->length * 1.3));\n\n\tgit_vector_foreach(source_entries, i, source_entry) {\n\t\tgit_index_entry *entry = NULL;\n\n\t\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0)\n\t\t\tbreak;\n\n\t\tindex_entry_adjust_namemask(entry, ((struct entry_internal *)entry)->pathlen);\n\t\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\t\tentry->mode = git_index__create_mode(entry->mode);\n\n\t\tif ((ret = git_vector_insert(&index->entries, entry)) < 0)\n\t\t\tbreak;\n\n\t\tINSERT_IN_MAP(index, entry, ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tgit_vector_sort(&index->entries);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index__fill(git_index *index, const git_vector *source_entries)\n{\n\tconst git_index_entry *source_entry = NULL;\n\tsize_t i;\n\tint ret = 0;\n\n\tassert(index);\n\n\tif (!source_entries->length)\n\t\treturn 0;\n\n\tgit_vector_size_hint(&index->entries, source_entries->length);\n\tgit_idxmap_resize(index->entries_map, (khint_t)(source_entries->length * 1.3));\n\n\tgit_vector_foreach(source_entries, i, source_entry) {\n\t\tgit_index_entry *entry = NULL;\n\n\t\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0)\n\t\t\tbreak;\n\n\t\tindex_entry_adjust_namemask(entry, ((struct entry_internal *)entry)->pathlen);\n\t\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\t\tentry->mode = git_index__create_mode(entry->mode);\n\n\t\tif ((ret = git_vector_insert(&index->entries, entry)) < 0)\n\t\t\tbreak;\n\n\t\tINSERT_IN_MAP(index, entry, ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tgit_vector_sort(&index->entries);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_new",
          "args": [
            "&index"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "452-455",
          "snippet": "int git_index_new(git_index **out)\n{\n\treturn git_index_open(out, NULL);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_new(git_index **out)\n{\n\treturn git_index_open(out, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int index_from_diff_list(git_index **out,\n\tgit_merge_diff_list *diff_list, bool skip_reuc)\n{\n\tgit_index *index;\n\tsize_t i;\n\tgit_merge_diff *conflict;\n\tint error = 0;\n\n\t*out = NULL;\n\n\tif ((error = git_index_new(&index)) < 0)\n\t\treturn error;\n\n\tif ((error = git_index__fill(index, &diff_list->staged)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict) {\n\t\tconst git_index_entry *ancestor =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t\t&conflict->ancestor_entry : NULL;\n\n\t\tconst git_index_entry *ours =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\t&conflict->our_entry : NULL;\n\n\t\tconst git_index_entry *theirs =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\t&conflict->their_entry : NULL;\n\n\t\tif ((error = git_index_conflict_add(index, ancestor, ours, theirs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* Add each rename entry to the rename portion of the index. */\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict) {\n\t\tconst char *ancestor_path, *our_path, *their_path;\n\n\t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry))\n\t\t\tcontinue;\n\n\t\tancestor_path = conflict->ancestor_entry.path;\n\n\t\tour_path =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\tconflict->our_entry.path : NULL;\n\n\t\ttheir_path =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\tconflict->their_entry.path : NULL;\n\n\t\tif ((our_path && strcmp(ancestor_path, our_path) != 0) ||\n\t\t\t(their_path && strcmp(ancestor_path, their_path) != 0)) {\n\t\t\tif ((error = git_index_name_add(index, ancestor_path, our_path, their_path)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif (!skip_reuc) {\n\t\tif ((error = index_update_reuc(index, diff_list)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t*out = index;\n\treturn 0;\n\non_error:\n\tgit_index_free(index);\n\treturn error;\n}"
  },
  {
    "function_name": "index_update_reuc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1700-1735",
    "snippet": "static int index_update_reuc(git_index *index, git_merge_diff_list *diff_list)\n{\n\tint error;\n\tsize_t i;\n\tgit_merge_diff *conflict;\n\n\t/* Add each entry in the resolved conflict to the REUC independently, since\n\t * the paths may differ due to renames. */\n\tgit_vector_foreach(&diff_list->resolved, i, conflict) {\n\t\tconst git_index_entry *ancestor =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t\t&conflict->ancestor_entry : NULL;\n\n\t\tconst git_index_entry *ours =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\t&conflict->our_entry : NULL;\n\n\t\tconst git_index_entry *theirs =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\t&conflict->their_entry : NULL;\n\n\t\tif (ancestor != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_ANCESTOR, ancestor)) < 0)\n\t\t\treturn error;\n\n\t\tif (ours != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_OURS, ours)) < 0)\n\t\t\treturn error;\n\n\t\tif (theirs != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_THEIRS, theirs)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_index_insert_reuc",
          "args": [
            "index",
            "TREE_IDX_THEIRS",
            "theirs"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "merge_index_insert_reuc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1673-1698",
          "snippet": "static int merge_index_insert_reuc(\n\tgit_index *index,\n\tsize_t idx,\n\tconst git_index_entry *entry)\n{\n\tconst git_index_reuc_entry *reuc;\n\tint mode[3] = { 0, 0, 0 };\n\tgit_oid const *oid[3] = { NULL, NULL, NULL };\n\tsize_t i;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(*entry))\n\t\treturn 0;\n\n\tif ((reuc = git_index_reuc_get_bypath(index, entry->path)) != NULL) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tmode[i] = reuc->mode[i];\n\t\t\toid[i] = &reuc->oid[i];\n\t\t}\n\t}\n\n\tmode[idx] = entry->mode;\n\toid[idx] = &entry->id;\n\n\treturn git_index_reuc_add(index, entry->path,\n\t\tmode[0], oid[0], mode[1], oid[1], mode[2], oid[2]);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_index_insert_reuc(\n\tgit_index *index,\n\tsize_t idx,\n\tconst git_index_entry *entry)\n{\n\tconst git_index_reuc_entry *reuc;\n\tint mode[3] = { 0, 0, 0 };\n\tgit_oid const *oid[3] = { NULL, NULL, NULL };\n\tsize_t i;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(*entry))\n\t\treturn 0;\n\n\tif ((reuc = git_index_reuc_get_bypath(index, entry->path)) != NULL) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tmode[i] = reuc->mode[i];\n\t\t\toid[i] = &reuc->oid[i];\n\t\t}\n\t}\n\n\tmode[idx] = entry->mode;\n\toid[idx] = &entry->id;\n\n\treturn git_index_reuc_add(index, entry->path,\n\t\tmode[0], oid[0], mode[1], oid[1], mode[2], oid[2]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->ancestor_entry"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff_list->resolved",
            "i",
            "conflict"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int index_update_reuc(git_index *index, git_merge_diff_list *diff_list)\n{\n\tint error;\n\tsize_t i;\n\tgit_merge_diff *conflict;\n\n\t/* Add each entry in the resolved conflict to the REUC independently, since\n\t * the paths may differ due to renames. */\n\tgit_vector_foreach(&diff_list->resolved, i, conflict) {\n\t\tconst git_index_entry *ancestor =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t\t&conflict->ancestor_entry : NULL;\n\n\t\tconst git_index_entry *ours =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t\t&conflict->our_entry : NULL;\n\n\t\tconst git_index_entry *theirs =\n\t\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t\t&conflict->their_entry : NULL;\n\n\t\tif (ancestor != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_ANCESTOR, ancestor)) < 0)\n\t\t\treturn error;\n\n\t\tif (ours != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_OURS, ours)) < 0)\n\t\t\treturn error;\n\n\t\tif (theirs != NULL &&\n\t\t\t(error = merge_index_insert_reuc(index, TREE_IDX_THEIRS, theirs)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "merge_index_insert_reuc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1673-1698",
    "snippet": "static int merge_index_insert_reuc(\n\tgit_index *index,\n\tsize_t idx,\n\tconst git_index_entry *entry)\n{\n\tconst git_index_reuc_entry *reuc;\n\tint mode[3] = { 0, 0, 0 };\n\tgit_oid const *oid[3] = { NULL, NULL, NULL };\n\tsize_t i;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(*entry))\n\t\treturn 0;\n\n\tif ((reuc = git_index_reuc_get_bypath(index, entry->path)) != NULL) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tmode[i] = reuc->mode[i];\n\t\t\toid[i] = &reuc->oid[i];\n\t\t}\n\t}\n\n\tmode[idx] = entry->mode;\n\toid[idx] = &entry->id;\n\n\treturn git_index_reuc_add(index, entry->path,\n\t\tmode[0], oid[0], mode[1], oid[1], mode[2], oid[2]);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_reuc_add",
          "args": [
            "index",
            "entry->path",
            "mode[0]",
            "oid[0]",
            "mode[1]",
            "oid[1]",
            "mode[2]",
            "oid[2]"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_reuc_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2050-2066",
          "snippet": "int git_index_reuc_add(git_index *index, const char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\tint error = 0;\n\n\tassert(index && path);\n\n\tif ((error = index_entry_reuc_init(&reuc, path, ancestor_mode,\n\t\t\tancestor_oid, our_mode, our_oid, their_mode, their_oid)) < 0 ||\n\t\t(error = index_reuc_insert(index, reuc)) < 0)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_reuc_add(git_index *index, const char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\tint error = 0;\n\n\tassert(index && path);\n\n\tif ((error = index_entry_reuc_init(&reuc, path, ancestor_mode,\n\t\t\tancestor_oid, our_mode, our_oid, their_mode, their_oid)) < 0 ||\n\t\t(error = index_reuc_insert(index, reuc)) < 0)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_reuc_get_bypath",
          "args": [
            "index",
            "entry->path"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_reuc_get_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2073-2088",
          "snippet": "const git_index_reuc_entry *git_index_reuc_get_bypath(\n\tgit_index *index, const char *path)\n{\n\tsize_t pos;\n\tassert(index && path);\n\n\tif (!index->reuc.length)\n\t\treturn NULL;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tif (git_index_reuc_find(&pos, index, path) < 0)\n\t\treturn NULL;\n\n\treturn git_vector_get(&index->reuc, pos);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nconst git_index_reuc_entry *git_index_reuc_get_bypath(\n\tgit_index *index, const char *path)\n{\n\tsize_t pos;\n\tassert(index && path);\n\n\tif (!index->reuc.length)\n\t\treturn NULL;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tif (git_index_reuc_find(&pos, index, path) < 0)\n\t\treturn NULL;\n\n\treturn git_vector_get(&index->reuc, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "*entry"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_index_insert_reuc(\n\tgit_index *index,\n\tsize_t idx,\n\tconst git_index_entry *entry)\n{\n\tconst git_index_reuc_entry *reuc;\n\tint mode[3] = { 0, 0, 0 };\n\tgit_oid const *oid[3] = { NULL, NULL, NULL };\n\tsize_t i;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(*entry))\n\t\treturn 0;\n\n\tif ((reuc = git_index_reuc_get_bypath(index, entry->path)) != NULL) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tmode[i] = reuc->mode[i];\n\t\t\toid[i] = &reuc->oid[i];\n\t\t}\n\t}\n\n\tmode[idx] = entry->mode;\n\toid[idx] = &entry->id;\n\n\treturn git_index_reuc_add(index, entry->path,\n\t\tmode[0], oid[0], mode[1], oid[1], mode[2], oid[2]);\n}"
  },
  {
    "function_name": "merge_normalize_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1624-1670",
    "snippet": "static int merge_normalize_opts(\n\tgit_repository *repo,\n\tgit_merge_options *opts,\n\tconst git_merge_options *given)\n{\n\tgit_config *cfg = NULL;\n\tint error = 0;\n\n\tassert(repo && opts);\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif (given != NULL)\n\t\tmemcpy(opts, given, sizeof(git_merge_options));\n\telse {\n\t\tgit_merge_options init = GIT_MERGE_OPTIONS_INIT;\n\t\tmemcpy(opts, &init, sizeof(init));\n\n\t\topts->flags = GIT_MERGE_FIND_RENAMES;\n\t\topts->rename_threshold = GIT_MERGE_DEFAULT_RENAME_THRESHOLD;\n\t}\n\n\tif (!opts->target_limit) {\n\t\tint limit = git_config__get_int_force(cfg, \"merge.renamelimit\", 0);\n\n\t\tif (!limit)\n\t\t\tlimit = git_config__get_int_force(cfg, \"diff.renamelimit\", 0);\n\n\t\topts->target_limit = (limit <= 0) ?\n\t\t\tGIT_MERGE_DEFAULT_TARGET_LIMIT : (unsigned int)limit;\n\t}\n\n\t/* assign the internal metric with whitespace flag as payload */\n\tif (!opts->metric) {\n\t\topts->metric = git__malloc(sizeof(git_diff_similarity_metric));\n\t\tGITERR_CHECK_ALLOC(opts->metric);\n\n\t\topts->metric->file_signature = git_diff_find_similar__hashsig_for_file;\n\t\topts->metric->buffer_signature = git_diff_find_similar__hashsig_for_buf;\n\t\topts->metric->free_signature = git_diff_find_similar__hashsig_free;\n\t\topts->metric->similarity = git_diff_find_similar__calc_similarity;\n\t\topts->metric->payload = (void *)GIT_HASHSIG_SMART_WHITESPACE;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "opts->metric"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "sizeof(git_diff_similarity_metric)"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__get_int_force",
          "args": [
            "cfg",
            "\"diff.renamelimit\"",
            "0"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__get_int_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "905-918",
          "snippet": "int git_config__get_int_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint32_t val = (int32_t)fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_int32(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn (int)val;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__get_int_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint32_t val = (int32_t)fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_int32(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn (int)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "opts",
            "&init",
            "sizeof(init)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "opts",
            "given",
            "sizeof(git_merge_options)"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "repo"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && opts"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_normalize_opts(\n\tgit_repository *repo,\n\tgit_merge_options *opts,\n\tconst git_merge_options *given)\n{\n\tgit_config *cfg = NULL;\n\tint error = 0;\n\n\tassert(repo && opts);\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif (given != NULL)\n\t\tmemcpy(opts, given, sizeof(git_merge_options));\n\telse {\n\t\tgit_merge_options init = GIT_MERGE_OPTIONS_INIT;\n\t\tmemcpy(opts, &init, sizeof(init));\n\n\t\topts->flags = GIT_MERGE_FIND_RENAMES;\n\t\topts->rename_threshold = GIT_MERGE_DEFAULT_RENAME_THRESHOLD;\n\t}\n\n\tif (!opts->target_limit) {\n\t\tint limit = git_config__get_int_force(cfg, \"merge.renamelimit\", 0);\n\n\t\tif (!limit)\n\t\t\tlimit = git_config__get_int_force(cfg, \"diff.renamelimit\", 0);\n\n\t\topts->target_limit = (limit <= 0) ?\n\t\t\tGIT_MERGE_DEFAULT_TARGET_LIMIT : (unsigned int)limit;\n\t}\n\n\t/* assign the internal metric with whitespace flag as payload */\n\tif (!opts->metric) {\n\t\topts->metric = git__malloc(sizeof(git_diff_similarity_metric));\n\t\tGITERR_CHECK_ALLOC(opts->metric);\n\n\t\topts->metric->file_signature = git_diff_find_similar__hashsig_for_file;\n\t\topts->metric->buffer_signature = git_diff_find_similar__hashsig_for_buf;\n\t\topts->metric->free_signature = git_diff_find_similar__hashsig_free;\n\t\topts->metric->similarity = git_diff_find_similar__calc_similarity;\n\t\topts->metric->payload = (void *)GIT_HASHSIG_SMART_WHITESPACE;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_merge_diff_list__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1612-1622",
    "snippet": "void git_merge_diff_list__free(git_merge_diff_list *diff_list)\n{\n\tif (!diff_list)\n\t\treturn;\n\n\tgit_vector_free(&diff_list->staged);\n\tgit_vector_free(&diff_list->conflicts);\n\tgit_vector_free(&diff_list->resolved);\n\tgit_pool_clear(&diff_list->pool);\n\tgit__free(diff_list);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "diff_list"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&diff_list->pool"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&diff_list->resolved"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nvoid git_merge_diff_list__free(git_merge_diff_list *diff_list)\n{\n\tif (!diff_list)\n\t\treturn;\n\n\tgit_vector_free(&diff_list->staged);\n\tgit_vector_free(&diff_list->conflicts);\n\tgit_vector_free(&diff_list->resolved);\n\tgit_pool_clear(&diff_list->pool);\n\tgit__free(diff_list);\n}"
  },
  {
    "function_name": "git_merge_diff_list__alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1591-1610",
    "snippet": "git_merge_diff_list *git_merge_diff_list__alloc(git_repository *repo)\n{\n\tgit_merge_diff_list *diff_list = git__calloc(1, sizeof(git_merge_diff_list));\n\n\tif (diff_list == NULL)\n\t\treturn NULL;\n\n\tdiff_list->repo = repo;\n\n\tgit_pool_init(&diff_list->pool, 1);\n\n\tif (git_vector_init(&diff_list->staged, 0, NULL) < 0 ||\n\t\tgit_vector_init(&diff_list->conflicts, 0, NULL) < 0 ||\n\t\tgit_vector_init(&diff_list->resolved, 0, NULL) < 0) {\n\t\tgit_merge_diff_list__free(diff_list);\n\t\treturn NULL;\n\t}\n\n\treturn diff_list;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_merge_diff_list__free",
          "args": [
            "diff_list"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_diff_list__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1612-1622",
          "snippet": "void git_merge_diff_list__free(git_merge_diff_list *diff_list)\n{\n\tif (!diff_list)\n\t\treturn;\n\n\tgit_vector_free(&diff_list->staged);\n\tgit_vector_free(&diff_list->conflicts);\n\tgit_vector_free(&diff_list->resolved);\n\tgit_pool_clear(&diff_list->pool);\n\tgit__free(diff_list);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nvoid git_merge_diff_list__free(git_merge_diff_list *diff_list)\n{\n\tif (!diff_list)\n\t\treturn;\n\n\tgit_vector_free(&diff_list->staged);\n\tgit_vector_free(&diff_list->conflicts);\n\tgit_vector_free(&diff_list->resolved);\n\tgit_pool_clear(&diff_list->pool);\n\tgit__free(diff_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&diff_list->resolved",
            "0",
            "NULL"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_init",
          "args": [
            "&diff_list->pool",
            "1"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "120-129",
          "snippet": "void git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_merge_diff_list)"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\ngit_merge_diff_list *git_merge_diff_list__alloc(git_repository *repo)\n{\n\tgit_merge_diff_list *diff_list = git__calloc(1, sizeof(git_merge_diff_list));\n\n\tif (diff_list == NULL)\n\t\treturn NULL;\n\n\tdiff_list->repo = repo;\n\n\tgit_pool_init(&diff_list->pool, 1);\n\n\tif (git_vector_init(&diff_list->staged, 0, NULL) < 0 ||\n\t\tgit_vector_init(&diff_list->conflicts, 0, NULL) < 0 ||\n\t\tgit_vector_init(&diff_list->resolved, 0, NULL) < 0) {\n\t\tgit_merge_diff_list__free(diff_list);\n\t\treturn NULL;\n\t}\n\n\treturn diff_list;\n}"
  },
  {
    "function_name": "git_merge_diff_list__find_differences",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1579-1589",
    "snippet": "int git_merge_diff_list__find_differences(\n\tgit_merge_diff_list *diff_list,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *their_iter)\n{\n\tgit_iterator *iterators[3] = { ancestor_iter, our_iter, their_iter };\n\tstruct merge_diff_find_data find_data = { diff_list };\n\n\treturn git_iterator_walk(iterators, 3, queue_difference, &find_data);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_walk",
          "args": [
            "iterators",
            "3",
            "queue_difference",
            "&find_data"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2116-2201",
          "snippet": "int git_iterator_walk(\n\tgit_iterator **iterators,\n\tsize_t cnt,\n\tgit_iterator_walk_cb cb,\n\tvoid *data)\n{\n\tconst git_index_entry **iterator_item;\t/* next in each iterator */\n\tconst git_index_entry **cur_items;\t\t/* current path in each iter */\n\tconst git_index_entry *first_match;\n\tsize_t i, j;\n\tint error = 0;\n\n\titerator_item = git__calloc(cnt, sizeof(git_index_entry *));\n\tcur_items = git__calloc(cnt, sizeof(git_index_entry *));\n\n\tGITERR_CHECK_ALLOC(iterator_item);\n\tGITERR_CHECK_ALLOC(cur_items);\n\n\t/* Set up the iterators */\n\tfor (i = 0; i < cnt; i++) {\n\t\terror = git_iterator_current(&iterator_item[i], iterators[i]);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\twhile (true) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tcur_items[i] = NULL;\n\n\t\tfirst_match = NULL;\n\n\t\t/* Find the next path(s) to consume from each iterator */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (iterator_item[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (first_match == NULL) {\n\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t} else {\n\t\t\t\tint path_diff = git_index_entry_cmp(iterator_item[i], first_match);\n\n\t\t\t\tif (path_diff < 0) {\n\t\t\t\t\t/* Found an index entry that sorts before the one we're\n\t\t\t\t\t * looking at.  Forget that we've seen the other and\n\t\t\t\t\t * look at the other iterators for this path.\n\t\t\t\t\t */\n\t\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\t\tcur_items[j] = NULL;\n\n\t\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t} else if (path_diff == 0) {\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (first_match == NULL)\n\t\t\tbreak;\n\n\t\tif ((error = cb(cur_items, data)) != 0)\n\t\t\tgoto done;\n\n\t\t/* Advance each iterator that participated */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (cur_items[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_iterator_advance(&iterator_item[i], iterators[i]);\n\n\t\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tgit__free((git_index_entry **)iterator_item);\n\tgit__free((git_index_entry **)cur_items);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_walk(\n\tgit_iterator **iterators,\n\tsize_t cnt,\n\tgit_iterator_walk_cb cb,\n\tvoid *data)\n{\n\tconst git_index_entry **iterator_item;\t/* next in each iterator */\n\tconst git_index_entry **cur_items;\t\t/* current path in each iter */\n\tconst git_index_entry *first_match;\n\tsize_t i, j;\n\tint error = 0;\n\n\titerator_item = git__calloc(cnt, sizeof(git_index_entry *));\n\tcur_items = git__calloc(cnt, sizeof(git_index_entry *));\n\n\tGITERR_CHECK_ALLOC(iterator_item);\n\tGITERR_CHECK_ALLOC(cur_items);\n\n\t/* Set up the iterators */\n\tfor (i = 0; i < cnt; i++) {\n\t\terror = git_iterator_current(&iterator_item[i], iterators[i]);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\twhile (true) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tcur_items[i] = NULL;\n\n\t\tfirst_match = NULL;\n\n\t\t/* Find the next path(s) to consume from each iterator */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (iterator_item[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (first_match == NULL) {\n\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t} else {\n\t\t\t\tint path_diff = git_index_entry_cmp(iterator_item[i], first_match);\n\n\t\t\t\tif (path_diff < 0) {\n\t\t\t\t\t/* Found an index entry that sorts before the one we're\n\t\t\t\t\t * looking at.  Forget that we've seen the other and\n\t\t\t\t\t * look at the other iterators for this path.\n\t\t\t\t\t */\n\t\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\t\tcur_items[j] = NULL;\n\n\t\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t} else if (path_diff == 0) {\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (first_match == NULL)\n\t\t\tbreak;\n\n\t\tif ((error = cb(cur_items, data)) != 0)\n\t\t\tgoto done;\n\n\t\t/* Advance each iterator that participated */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (cur_items[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_iterator_advance(&iterator_item[i], iterators[i]);\n\n\t\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tgit__free((git_index_entry **)iterator_item);\n\tgit__free((git_index_entry **)cur_items);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_diff_list__find_differences(\n\tgit_merge_diff_list *diff_list,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *their_iter)\n{\n\tgit_iterator *iterators[3] = { ancestor_iter, our_iter, their_iter };\n\tstruct merge_diff_find_data find_data = { diff_list };\n\n\treturn git_iterator_walk(iterators, 3, queue_difference, &find_data);\n}"
  },
  {
    "function_name": "queue_difference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1556-1577",
    "snippet": "static int queue_difference(const git_index_entry **entries, void *data)\n{\n\tstruct merge_diff_find_data *find_data = data;\n\tbool item_modified = false;\n\tsize_t i;\n\n\tif (!entries[0] || !entries[1] || !entries[2]) {\n\t\titem_modified = true;\n\t} else {\n\t\tfor (i = 1; i < 3; i++) {\n\t\t\tif (index_entry_cmp(entries[0], entries[i]) != 0) {\n\t\t\t\titem_modified = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn item_modified ?\n\t\tmerge_diff_list_insert_conflict(\n\t\t\tfind_data->diff_list, &find_data->df_data, entries) :\n\t\tmerge_diff_list_insert_unmodified(find_data->diff_list, entries);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_diff_list_insert_unmodified",
          "args": [
            "find_data->diff_list",
            "entries"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_list_insert_unmodified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1535-1549",
          "snippet": "static int merge_diff_list_insert_unmodified(\n\tgit_merge_diff_list *diff_list,\n\tconst git_index_entry *tree_items[3])\n{\n\tint error = 0;\n\tgit_index_entry *entry;\n\n\tentry = git_pool_malloc(&diff_list->pool, sizeof(git_index_entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tif ((error = index_entry_dup_pool(entry, &diff_list->pool, tree_items[0])) >= 0)\n\t\terror = git_vector_insert(&diff_list->staged, entry);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_diff_list_insert_unmodified(\n\tgit_merge_diff_list *diff_list,\n\tconst git_index_entry *tree_items[3])\n{\n\tint error = 0;\n\tgit_index_entry *entry;\n\n\tentry = git_pool_malloc(&diff_list->pool, sizeof(git_index_entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tif ((error = index_entry_dup_pool(entry, &diff_list->pool, tree_items[0])) >= 0)\n\t\terror = git_vector_insert(&diff_list->staged, entry);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_list_insert_conflict",
          "args": [
            "find_data->diff_list",
            "&find_data->df_data",
            "entries"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_list_insert_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1519-1533",
          "snippet": "static int merge_diff_list_insert_conflict(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_df_data *merge_df_data,\n\tconst git_index_entry *tree_items[3])\n{\n\tgit_merge_diff *conflict;\n\n\tif ((conflict = merge_diff_from_index_entries(diff_list, tree_items)) == NULL ||\n\t\tmerge_diff_detect_type(conflict) < 0 ||\n\t\tmerge_diff_detect_df_conflict(merge_df_data, conflict) < 0 ||\n\t\tgit_vector_insert(&diff_list->conflicts, conflict) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_diff_list_insert_conflict(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_df_data *merge_df_data,\n\tconst git_index_entry *tree_items[3])\n{\n\tgit_merge_diff *conflict;\n\n\tif ((conflict = merge_diff_from_index_entries(diff_list, tree_items)) == NULL ||\n\t\tmerge_diff_detect_type(conflict) < 0 ||\n\t\tmerge_diff_detect_df_conflict(merge_df_data, conflict) < 0 ||\n\t\tgit_vector_insert(&diff_list->conflicts, conflict) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_cmp",
          "args": [
            "entries[0]",
            "entries[i]"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "615-627",
          "snippet": "GIT_INLINE(int) index_entry_cmp(const git_index_entry *a, const git_index_entry *b)\n{\n\tint value = 0;\n\n\tif (a->path == NULL)\n\t\treturn (b->path == NULL) ? 0 : 1;\n\n\tif ((value = a->mode - b->mode) == 0 &&\n\t\t(value = git_oid__cmp(&a->id, &b->id)) == 0)\n\t\tvalue = strcmp(a->path, b->path);\n\n\treturn value;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) index_entry_cmp(const git_index_entry *a, const git_index_entry *b)\n{\n\tint value = 0;\n\n\tif (a->path == NULL)\n\t\treturn (b->path == NULL) ? 0 : 1;\n\n\tif ((value = a->mode - b->mode) == 0 &&\n\t\t(value = git_oid__cmp(&a->id, &b->id)) == 0)\n\t\tvalue = strcmp(a->path, b->path);\n\n\treturn value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int queue_difference(const git_index_entry **entries, void *data)\n{\n\tstruct merge_diff_find_data *find_data = data;\n\tbool item_modified = false;\n\tsize_t i;\n\n\tif (!entries[0] || !entries[1] || !entries[2]) {\n\t\titem_modified = true;\n\t} else {\n\t\tfor (i = 1; i < 3; i++) {\n\t\t\tif (index_entry_cmp(entries[0], entries[i]) != 0) {\n\t\t\t\titem_modified = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn item_modified ?\n\t\tmerge_diff_list_insert_conflict(\n\t\t\tfind_data->diff_list, &find_data->df_data, entries) :\n\t\tmerge_diff_list_insert_unmodified(find_data->diff_list, entries);\n}"
  },
  {
    "function_name": "merge_diff_list_insert_unmodified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1535-1549",
    "snippet": "static int merge_diff_list_insert_unmodified(\n\tgit_merge_diff_list *diff_list,\n\tconst git_index_entry *tree_items[3])\n{\n\tint error = 0;\n\tgit_index_entry *entry;\n\n\tentry = git_pool_malloc(&diff_list->pool, sizeof(git_index_entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tif ((error = index_entry_dup_pool(entry, &diff_list->pool, tree_items[0])) >= 0)\n\t\terror = git_vector_insert(&diff_list->staged, entry);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&diff_list->staged",
            "entry"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_dup_pool",
          "args": [
            "entry",
            "&diff_list->pool",
            "tree_items[0]"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_dup_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1459-1471",
          "snippet": "GIT_INLINE(int) index_entry_dup_pool(\n\tgit_index_entry *out,\n\tgit_pool *pool,\n\tconst git_index_entry *src)\n{\n\tif (src != NULL) {\n\t\tmemcpy(out, src, sizeof(git_index_entry));\n\t\tif ((out->path = git_pool_strdup(pool, src->path)) == NULL)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) index_entry_dup_pool(\n\tgit_index_entry *out,\n\tgit_pool *pool,\n\tconst git_index_entry *src)\n{\n\tif (src != NULL) {\n\t\tmemcpy(out, src, sizeof(git_index_entry));\n\t\tif ((out->path = git_pool_strdup(pool, src->path)) == NULL)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entry"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_malloc",
          "args": [
            "&diff_list->pool",
            "sizeof(git_index_entry)"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_diff_list_insert_unmodified(\n\tgit_merge_diff_list *diff_list,\n\tconst git_index_entry *tree_items[3])\n{\n\tint error = 0;\n\tgit_index_entry *entry;\n\n\tentry = git_pool_malloc(&diff_list->pool, sizeof(git_index_entry));\n\tGITERR_CHECK_ALLOC(entry);\n\n\tif ((error = index_entry_dup_pool(entry, &diff_list->pool, tree_items[0])) >= 0)\n\t\terror = git_vector_insert(&diff_list->staged, entry);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_diff_list_insert_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1519-1533",
    "snippet": "static int merge_diff_list_insert_conflict(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_df_data *merge_df_data,\n\tconst git_index_entry *tree_items[3])\n{\n\tgit_merge_diff *conflict;\n\n\tif ((conflict = merge_diff_from_index_entries(diff_list, tree_items)) == NULL ||\n\t\tmerge_diff_detect_type(conflict) < 0 ||\n\t\tmerge_diff_detect_df_conflict(merge_df_data, conflict) < 0 ||\n\t\tgit_vector_insert(&diff_list->conflicts, conflict) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&diff_list->conflicts",
            "conflict"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_detect_df_conflict",
          "args": [
            "merge_df_data",
            "conflict"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_detect_df_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1405-1431",
          "snippet": "GIT_INLINE(int) merge_diff_detect_df_conflict(\n\tstruct merge_diff_df_data *df_data,\n\tgit_merge_diff *conflict)\n{\n\tconst char *cur_path = merge_diff_path(conflict);\n\n\t/* Determine if this is a D/F conflict or the child of one */\n\tif (df_data->df_path &&\n\t\tpath_is_prefixed(df_data->df_path, cur_path))\n\t\tconflict->type = GIT_MERGE_DIFF_DF_CHILD;\n\telse if(df_data->df_path)\n\t\tdf_data->df_path = NULL;\n\telse if (df_data->prev_path &&\n\t\tmerge_diff_any_side_added_or_modified(df_data->prev_conflict) &&\n\t\tmerge_diff_any_side_added_or_modified(conflict) &&\n\t\tpath_is_prefixed(df_data->prev_path, cur_path)) {\n\t\tconflict->type = GIT_MERGE_DIFF_DF_CHILD;\n\n\t\tdf_data->prev_conflict->type = GIT_MERGE_DIFF_DIRECTORY_FILE;\n\t\tdf_data->df_path = df_data->prev_path;\n\t}\n\n\tdf_data->prev_path = cur_path;\n\tdf_data->prev_conflict = conflict;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) merge_diff_detect_df_conflict(\n\tstruct merge_diff_df_data *df_data,\n\tgit_merge_diff *conflict)\n{\n\tconst char *cur_path = merge_diff_path(conflict);\n\n\t/* Determine if this is a D/F conflict or the child of one */\n\tif (df_data->df_path &&\n\t\tpath_is_prefixed(df_data->df_path, cur_path))\n\t\tconflict->type = GIT_MERGE_DIFF_DF_CHILD;\n\telse if(df_data->df_path)\n\t\tdf_data->df_path = NULL;\n\telse if (df_data->prev_path &&\n\t\tmerge_diff_any_side_added_or_modified(df_data->prev_conflict) &&\n\t\tmerge_diff_any_side_added_or_modified(conflict) &&\n\t\tpath_is_prefixed(df_data->prev_path, cur_path)) {\n\t\tconflict->type = GIT_MERGE_DIFF_DF_CHILD;\n\n\t\tdf_data->prev_conflict->type = GIT_MERGE_DIFF_DIRECTORY_FILE;\n\t\tdf_data->df_path = df_data->prev_path;\n\t}\n\n\tdf_data->prev_path = cur_path;\n\tdf_data->prev_conflict = conflict;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_detect_type",
          "args": [
            "conflict"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_detect_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1435-1457",
          "snippet": "GIT_INLINE(int) merge_diff_detect_type(\n\tgit_merge_diff *conflict)\n{\n\tif (conflict->our_status == GIT_DELTA_ADDED &&\n\t\tconflict->their_status == GIT_DELTA_ADDED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_ADDED;\n\telse if (conflict->our_status == GIT_DELTA_MODIFIED &&\n\t\t\t conflict->their_status == GIT_DELTA_MODIFIED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_MODIFIED;\n\telse if (conflict->our_status == GIT_DELTA_DELETED &&\n\t\t\t conflict->their_status == GIT_DELTA_DELETED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_DELETED;\n\telse if (conflict->our_status == GIT_DELTA_MODIFIED &&\n\t\t\t conflict->their_status == GIT_DELTA_DELETED)\n\t\tconflict->type = GIT_MERGE_DIFF_MODIFIED_DELETED;\n\telse if (conflict->our_status == GIT_DELTA_DELETED &&\n\t\t\t conflict->their_status == GIT_DELTA_MODIFIED)\n\t\tconflict->type = GIT_MERGE_DIFF_MODIFIED_DELETED;\n\telse\n\t\tconflict->type = GIT_MERGE_DIFF_NONE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) merge_diff_detect_type(\n\tgit_merge_diff *conflict)\n{\n\tif (conflict->our_status == GIT_DELTA_ADDED &&\n\t\tconflict->their_status == GIT_DELTA_ADDED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_ADDED;\n\telse if (conflict->our_status == GIT_DELTA_MODIFIED &&\n\t\t\t conflict->their_status == GIT_DELTA_MODIFIED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_MODIFIED;\n\telse if (conflict->our_status == GIT_DELTA_DELETED &&\n\t\t\t conflict->their_status == GIT_DELTA_DELETED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_DELETED;\n\telse if (conflict->our_status == GIT_DELTA_MODIFIED &&\n\t\t\t conflict->their_status == GIT_DELTA_DELETED)\n\t\tconflict->type = GIT_MERGE_DIFF_MODIFIED_DELETED;\n\telse if (conflict->our_status == GIT_DELTA_DELETED &&\n\t\t\t conflict->their_status == GIT_DELTA_MODIFIED)\n\t\tconflict->type = GIT_MERGE_DIFF_MODIFIED_DELETED;\n\telse\n\t\tconflict->type = GIT_MERGE_DIFF_NONE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_from_index_entries",
          "args": [
            "diff_list",
            "tree_items"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_from_index_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1494-1515",
          "snippet": "static git_merge_diff *merge_diff_from_index_entries(\n\tgit_merge_diff_list *diff_list,\n\tconst git_index_entry **entries)\n{\n\tgit_merge_diff *conflict;\n\tgit_pool *pool = &diff_list->pool;\n\n\tif ((conflict = git_pool_mallocz(pool, sizeof(git_merge_diff))) == NULL)\n\t\treturn NULL;\n\n\tif (index_entry_dup_pool(&conflict->ancestor_entry, pool, entries[TREE_IDX_ANCESTOR]) < 0 ||\n\t\tindex_entry_dup_pool(&conflict->our_entry, pool, entries[TREE_IDX_OURS]) < 0 ||\n\t\tindex_entry_dup_pool(&conflict->their_entry, pool, entries[TREE_IDX_THEIRS]) < 0)\n\t\treturn NULL;\n\n\tconflict->our_status = merge_delta_type_from_index_entries(\n\t\tentries[TREE_IDX_ANCESTOR], entries[TREE_IDX_OURS]);\n\tconflict->their_status = merge_delta_type_from_index_entries(\n\t\tentries[TREE_IDX_ANCESTOR], entries[TREE_IDX_THEIRS]);\n\n\treturn conflict;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic git_merge_diff *merge_diff_from_index_entries(\n\tgit_merge_diff_list *diff_list,\n\tconst git_index_entry **entries)\n{\n\tgit_merge_diff *conflict;\n\tgit_pool *pool = &diff_list->pool;\n\n\tif ((conflict = git_pool_mallocz(pool, sizeof(git_merge_diff))) == NULL)\n\t\treturn NULL;\n\n\tif (index_entry_dup_pool(&conflict->ancestor_entry, pool, entries[TREE_IDX_ANCESTOR]) < 0 ||\n\t\tindex_entry_dup_pool(&conflict->our_entry, pool, entries[TREE_IDX_OURS]) < 0 ||\n\t\tindex_entry_dup_pool(&conflict->their_entry, pool, entries[TREE_IDX_THEIRS]) < 0)\n\t\treturn NULL;\n\n\tconflict->our_status = merge_delta_type_from_index_entries(\n\t\tentries[TREE_IDX_ANCESTOR], entries[TREE_IDX_OURS]);\n\tconflict->their_status = merge_delta_type_from_index_entries(\n\t\tentries[TREE_IDX_ANCESTOR], entries[TREE_IDX_THEIRS]);\n\n\treturn conflict;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_diff_list_insert_conflict(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_df_data *merge_df_data,\n\tconst git_index_entry *tree_items[3])\n{\n\tgit_merge_diff *conflict;\n\n\tif ((conflict = merge_diff_from_index_entries(diff_list, tree_items)) == NULL ||\n\t\tmerge_diff_detect_type(conflict) < 0 ||\n\t\tmerge_diff_detect_df_conflict(merge_df_data, conflict) < 0 ||\n\t\tgit_vector_insert(&diff_list->conflicts, conflict) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "merge_diff_from_index_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1494-1515",
    "snippet": "static git_merge_diff *merge_diff_from_index_entries(\n\tgit_merge_diff_list *diff_list,\n\tconst git_index_entry **entries)\n{\n\tgit_merge_diff *conflict;\n\tgit_pool *pool = &diff_list->pool;\n\n\tif ((conflict = git_pool_mallocz(pool, sizeof(git_merge_diff))) == NULL)\n\t\treturn NULL;\n\n\tif (index_entry_dup_pool(&conflict->ancestor_entry, pool, entries[TREE_IDX_ANCESTOR]) < 0 ||\n\t\tindex_entry_dup_pool(&conflict->our_entry, pool, entries[TREE_IDX_OURS]) < 0 ||\n\t\tindex_entry_dup_pool(&conflict->their_entry, pool, entries[TREE_IDX_THEIRS]) < 0)\n\t\treturn NULL;\n\n\tconflict->our_status = merge_delta_type_from_index_entries(\n\t\tentries[TREE_IDX_ANCESTOR], entries[TREE_IDX_OURS]);\n\tconflict->their_status = merge_delta_type_from_index_entries(\n\t\tentries[TREE_IDX_ANCESTOR], entries[TREE_IDX_THEIRS]);\n\n\treturn conflict;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_delta_type_from_index_entries",
          "args": [
            "entries[TREE_IDX_ANCESTOR]",
            "entries[TREE_IDX_THEIRS]"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "merge_delta_type_from_index_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1473-1492",
          "snippet": "GIT_INLINE(int) merge_delta_type_from_index_entries(\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *other)\n{\n\tif (ancestor == NULL && other == NULL)\n\t\treturn GIT_DELTA_UNMODIFIED;\n\telse if (ancestor == NULL && other != NULL)\n\t\treturn GIT_DELTA_ADDED;\n\telse if (ancestor != NULL && other == NULL)\n\t\treturn GIT_DELTA_DELETED;\n\telse if (S_ISDIR(ancestor->mode) ^ S_ISDIR(other->mode))\n\t\treturn GIT_DELTA_TYPECHANGE;\n\telse if(S_ISLNK(ancestor->mode) ^ S_ISLNK(other->mode))\n\t\treturn GIT_DELTA_TYPECHANGE;\n\telse if (git_oid__cmp(&ancestor->id, &other->id) ||\n\t\t\t ancestor->mode != other->mode)\n\t\treturn GIT_DELTA_MODIFIED;\n\n\treturn GIT_DELTA_UNMODIFIED;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) merge_delta_type_from_index_entries(\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *other)\n{\n\tif (ancestor == NULL && other == NULL)\n\t\treturn GIT_DELTA_UNMODIFIED;\n\telse if (ancestor == NULL && other != NULL)\n\t\treturn GIT_DELTA_ADDED;\n\telse if (ancestor != NULL && other == NULL)\n\t\treturn GIT_DELTA_DELETED;\n\telse if (S_ISDIR(ancestor->mode) ^ S_ISDIR(other->mode))\n\t\treturn GIT_DELTA_TYPECHANGE;\n\telse if(S_ISLNK(ancestor->mode) ^ S_ISLNK(other->mode))\n\t\treturn GIT_DELTA_TYPECHANGE;\n\telse if (git_oid__cmp(&ancestor->id, &other->id) ||\n\t\t\t ancestor->mode != other->mode)\n\t\treturn GIT_DELTA_MODIFIED;\n\n\treturn GIT_DELTA_UNMODIFIED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_dup_pool",
          "args": [
            "&conflict->their_entry",
            "pool",
            "entries[TREE_IDX_THEIRS]"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_dup_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1459-1471",
          "snippet": "GIT_INLINE(int) index_entry_dup_pool(\n\tgit_index_entry *out,\n\tgit_pool *pool,\n\tconst git_index_entry *src)\n{\n\tif (src != NULL) {\n\t\tmemcpy(out, src, sizeof(git_index_entry));\n\t\tif ((out->path = git_pool_strdup(pool, src->path)) == NULL)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) index_entry_dup_pool(\n\tgit_index_entry *out,\n\tgit_pool *pool,\n\tconst git_index_entry *src)\n{\n\tif (src != NULL) {\n\t\tmemcpy(out, src, sizeof(git_index_entry));\n\t\tif ((out->path = git_pool_strdup(pool, src->path)) == NULL)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_mallocz",
          "args": [
            "pool",
            "sizeof(git_merge_diff)"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic git_merge_diff *merge_diff_from_index_entries(\n\tgit_merge_diff_list *diff_list,\n\tconst git_index_entry **entries)\n{\n\tgit_merge_diff *conflict;\n\tgit_pool *pool = &diff_list->pool;\n\n\tif ((conflict = git_pool_mallocz(pool, sizeof(git_merge_diff))) == NULL)\n\t\treturn NULL;\n\n\tif (index_entry_dup_pool(&conflict->ancestor_entry, pool, entries[TREE_IDX_ANCESTOR]) < 0 ||\n\t\tindex_entry_dup_pool(&conflict->our_entry, pool, entries[TREE_IDX_OURS]) < 0 ||\n\t\tindex_entry_dup_pool(&conflict->their_entry, pool, entries[TREE_IDX_THEIRS]) < 0)\n\t\treturn NULL;\n\n\tconflict->our_status = merge_delta_type_from_index_entries(\n\t\tentries[TREE_IDX_ANCESTOR], entries[TREE_IDX_OURS]);\n\tconflict->their_status = merge_delta_type_from_index_entries(\n\t\tentries[TREE_IDX_ANCESTOR], entries[TREE_IDX_THEIRS]);\n\n\treturn conflict;\n}"
  },
  {
    "function_name": "merge_delta_type_from_index_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1473-1492",
    "snippet": "GIT_INLINE(int) merge_delta_type_from_index_entries(\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *other)\n{\n\tif (ancestor == NULL && other == NULL)\n\t\treturn GIT_DELTA_UNMODIFIED;\n\telse if (ancestor == NULL && other != NULL)\n\t\treturn GIT_DELTA_ADDED;\n\telse if (ancestor != NULL && other == NULL)\n\t\treturn GIT_DELTA_DELETED;\n\telse if (S_ISDIR(ancestor->mode) ^ S_ISDIR(other->mode))\n\t\treturn GIT_DELTA_TYPECHANGE;\n\telse if(S_ISLNK(ancestor->mode) ^ S_ISLNK(other->mode))\n\t\treturn GIT_DELTA_TYPECHANGE;\n\telse if (git_oid__cmp(&ancestor->id, &other->id) ||\n\t\t\t ancestor->mode != other->mode)\n\t\treturn GIT_DELTA_MODIFIED;\n\n\treturn GIT_DELTA_UNMODIFIED;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&ancestor->id",
            "&other->id"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "other->mode"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "ancestor->mode"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "other->mode"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ancestor->mode"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) merge_delta_type_from_index_entries(\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *other)\n{\n\tif (ancestor == NULL && other == NULL)\n\t\treturn GIT_DELTA_UNMODIFIED;\n\telse if (ancestor == NULL && other != NULL)\n\t\treturn GIT_DELTA_ADDED;\n\telse if (ancestor != NULL && other == NULL)\n\t\treturn GIT_DELTA_DELETED;\n\telse if (S_ISDIR(ancestor->mode) ^ S_ISDIR(other->mode))\n\t\treturn GIT_DELTA_TYPECHANGE;\n\telse if(S_ISLNK(ancestor->mode) ^ S_ISLNK(other->mode))\n\t\treturn GIT_DELTA_TYPECHANGE;\n\telse if (git_oid__cmp(&ancestor->id, &other->id) ||\n\t\t\t ancestor->mode != other->mode)\n\t\treturn GIT_DELTA_MODIFIED;\n\n\treturn GIT_DELTA_UNMODIFIED;\n}"
  },
  {
    "function_name": "index_entry_dup_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1459-1471",
    "snippet": "GIT_INLINE(int) index_entry_dup_pool(\n\tgit_index_entry *out,\n\tgit_pool *pool,\n\tconst git_index_entry *src)\n{\n\tif (src != NULL) {\n\t\tmemcpy(out, src, sizeof(git_index_entry));\n\t\tif ((out->path = git_pool_strdup(pool, src->path)) == NULL)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "pool",
            "src->path"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "src",
            "sizeof(git_index_entry)"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) index_entry_dup_pool(\n\tgit_index_entry *out,\n\tgit_pool *pool,\n\tconst git_index_entry *src)\n{\n\tif (src != NULL) {\n\t\tmemcpy(out, src, sizeof(git_index_entry));\n\t\tif ((out->path = git_pool_strdup(pool, src->path)) == NULL)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "merge_diff_detect_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1435-1457",
    "snippet": "GIT_INLINE(int) merge_diff_detect_type(\n\tgit_merge_diff *conflict)\n{\n\tif (conflict->our_status == GIT_DELTA_ADDED &&\n\t\tconflict->their_status == GIT_DELTA_ADDED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_ADDED;\n\telse if (conflict->our_status == GIT_DELTA_MODIFIED &&\n\t\t\t conflict->their_status == GIT_DELTA_MODIFIED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_MODIFIED;\n\telse if (conflict->our_status == GIT_DELTA_DELETED &&\n\t\t\t conflict->their_status == GIT_DELTA_DELETED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_DELETED;\n\telse if (conflict->our_status == GIT_DELTA_MODIFIED &&\n\t\t\t conflict->their_status == GIT_DELTA_DELETED)\n\t\tconflict->type = GIT_MERGE_DIFF_MODIFIED_DELETED;\n\telse if (conflict->our_status == GIT_DELTA_DELETED &&\n\t\t\t conflict->their_status == GIT_DELTA_MODIFIED)\n\t\tconflict->type = GIT_MERGE_DIFF_MODIFIED_DELETED;\n\telse\n\t\tconflict->type = GIT_MERGE_DIFF_NONE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) merge_diff_detect_type(\n\tgit_merge_diff *conflict)\n{\n\tif (conflict->our_status == GIT_DELTA_ADDED &&\n\t\tconflict->their_status == GIT_DELTA_ADDED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_ADDED;\n\telse if (conflict->our_status == GIT_DELTA_MODIFIED &&\n\t\t\t conflict->their_status == GIT_DELTA_MODIFIED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_MODIFIED;\n\telse if (conflict->our_status == GIT_DELTA_DELETED &&\n\t\t\t conflict->their_status == GIT_DELTA_DELETED)\n\t\tconflict->type = GIT_MERGE_DIFF_BOTH_DELETED;\n\telse if (conflict->our_status == GIT_DELTA_MODIFIED &&\n\t\t\t conflict->their_status == GIT_DELTA_DELETED)\n\t\tconflict->type = GIT_MERGE_DIFF_MODIFIED_DELETED;\n\telse if (conflict->our_status == GIT_DELTA_DELETED &&\n\t\t\t conflict->their_status == GIT_DELTA_MODIFIED)\n\t\tconflict->type = GIT_MERGE_DIFF_MODIFIED_DELETED;\n\telse\n\t\tconflict->type = GIT_MERGE_DIFF_NONE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "merge_diff_detect_df_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1405-1431",
    "snippet": "GIT_INLINE(int) merge_diff_detect_df_conflict(\n\tstruct merge_diff_df_data *df_data,\n\tgit_merge_diff *conflict)\n{\n\tconst char *cur_path = merge_diff_path(conflict);\n\n\t/* Determine if this is a D/F conflict or the child of one */\n\tif (df_data->df_path &&\n\t\tpath_is_prefixed(df_data->df_path, cur_path))\n\t\tconflict->type = GIT_MERGE_DIFF_DF_CHILD;\n\telse if(df_data->df_path)\n\t\tdf_data->df_path = NULL;\n\telse if (df_data->prev_path &&\n\t\tmerge_diff_any_side_added_or_modified(df_data->prev_conflict) &&\n\t\tmerge_diff_any_side_added_or_modified(conflict) &&\n\t\tpath_is_prefixed(df_data->prev_path, cur_path)) {\n\t\tconflict->type = GIT_MERGE_DIFF_DF_CHILD;\n\n\t\tdf_data->prev_conflict->type = GIT_MERGE_DIFF_DIRECTORY_FILE;\n\t\tdf_data->df_path = df_data->prev_path;\n\t}\n\n\tdf_data->prev_path = cur_path;\n\tdf_data->prev_conflict = conflict;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_is_prefixed",
          "args": [
            "df_data->prev_path",
            "cur_path"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "path_is_prefixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1393-1403",
          "snippet": "GIT_INLINE(bool) path_is_prefixed(const char *parent, const char *child)\n{\n\tsize_t child_len = strlen(child);\n\tsize_t parent_len = strlen(parent);\n\n\tif (child_len < parent_len ||\n\t\tstrncmp(parent, child, parent_len) != 0)\n\t\treturn 0;\n\n\treturn (child[parent_len] == '/');\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) path_is_prefixed(const char *parent, const char *child)\n{\n\tsize_t child_len = strlen(child);\n\tsize_t parent_len = strlen(parent);\n\n\tif (child_len < parent_len ||\n\t\tstrncmp(parent, child, parent_len) != 0)\n\t\treturn 0;\n\n\treturn (child[parent_len] == '/');\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_any_side_added_or_modified",
          "args": [
            "conflict"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_any_side_added_or_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1381-1391",
          "snippet": "GIT_INLINE(bool) merge_diff_any_side_added_or_modified(\n\tconst git_merge_diff *conflict)\n{\n\tif (conflict->our_status == GIT_DELTA_ADDED ||\n\t\tconflict->our_status == GIT_DELTA_MODIFIED ||\n\t\tconflict->their_status == GIT_DELTA_ADDED ||\n\t\tconflict->their_status == GIT_DELTA_MODIFIED)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) merge_diff_any_side_added_or_modified(\n\tconst git_merge_diff *conflict)\n{\n\tif (conflict->our_status == GIT_DELTA_ADDED ||\n\t\tconflict->our_status == GIT_DELTA_MODIFIED ||\n\t\tconflict->their_status == GIT_DELTA_ADDED ||\n\t\tconflict->their_status == GIT_DELTA_MODIFIED)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_path",
          "args": [
            "conflict"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1368-1379",
          "snippet": "GIT_INLINE(const char *) merge_diff_path(\n\tconst git_merge_diff *conflict)\n{\n\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry))\n\t\treturn conflict->ancestor_entry.path;\n\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry))\n\t\treturn conflict->our_entry.path;\n\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn conflict->their_entry.path;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) merge_diff_path(\n\tconst git_merge_diff *conflict)\n{\n\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry))\n\t\treturn conflict->ancestor_entry.path;\n\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry))\n\t\treturn conflict->our_entry.path;\n\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn conflict->their_entry.path;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) merge_diff_detect_df_conflict(\n\tstruct merge_diff_df_data *df_data,\n\tgit_merge_diff *conflict)\n{\n\tconst char *cur_path = merge_diff_path(conflict);\n\n\t/* Determine if this is a D/F conflict or the child of one */\n\tif (df_data->df_path &&\n\t\tpath_is_prefixed(df_data->df_path, cur_path))\n\t\tconflict->type = GIT_MERGE_DIFF_DF_CHILD;\n\telse if(df_data->df_path)\n\t\tdf_data->df_path = NULL;\n\telse if (df_data->prev_path &&\n\t\tmerge_diff_any_side_added_or_modified(df_data->prev_conflict) &&\n\t\tmerge_diff_any_side_added_or_modified(conflict) &&\n\t\tpath_is_prefixed(df_data->prev_path, cur_path)) {\n\t\tconflict->type = GIT_MERGE_DIFF_DF_CHILD;\n\n\t\tdf_data->prev_conflict->type = GIT_MERGE_DIFF_DIRECTORY_FILE;\n\t\tdf_data->df_path = df_data->prev_path;\n\t}\n\n\tdf_data->prev_path = cur_path;\n\tdf_data->prev_conflict = conflict;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "path_is_prefixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1393-1403",
    "snippet": "GIT_INLINE(bool) path_is_prefixed(const char *parent, const char *child)\n{\n\tsize_t child_len = strlen(child);\n\tsize_t parent_len = strlen(parent);\n\n\tif (child_len < parent_len ||\n\t\tstrncmp(parent, child, parent_len) != 0)\n\t\treturn 0;\n\n\treturn (child[parent_len] == '/');\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "parent",
            "child",
            "parent_len"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "parent"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "child"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) path_is_prefixed(const char *parent, const char *child)\n{\n\tsize_t child_len = strlen(child);\n\tsize_t parent_len = strlen(parent);\n\n\tif (child_len < parent_len ||\n\t\tstrncmp(parent, child, parent_len) != 0)\n\t\treturn 0;\n\n\treturn (child[parent_len] == '/');\n}"
  },
  {
    "function_name": "merge_diff_any_side_added_or_modified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1381-1391",
    "snippet": "GIT_INLINE(bool) merge_diff_any_side_added_or_modified(\n\tconst git_merge_diff *conflict)\n{\n\tif (conflict->our_status == GIT_DELTA_ADDED ||\n\t\tconflict->our_status == GIT_DELTA_MODIFIED ||\n\t\tconflict->their_status == GIT_DELTA_ADDED ||\n\t\tconflict->their_status == GIT_DELTA_MODIFIED)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) merge_diff_any_side_added_or_modified(\n\tconst git_merge_diff *conflict)\n{\n\tif (conflict->our_status == GIT_DELTA_ADDED ||\n\t\tconflict->our_status == GIT_DELTA_MODIFIED ||\n\t\tconflict->their_status == GIT_DELTA_ADDED ||\n\t\tconflict->their_status == GIT_DELTA_MODIFIED)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "merge_diff_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1368-1379",
    "snippet": "GIT_INLINE(const char *) merge_diff_path(\n\tconst git_merge_diff *conflict)\n{\n\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry))\n\t\treturn conflict->ancestor_entry.path;\n\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry))\n\t\treturn conflict->our_entry.path;\n\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn conflict->their_entry.path;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->ancestor_entry"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) merge_diff_path(\n\tconst git_merge_diff *conflict)\n{\n\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry))\n\t\treturn conflict->ancestor_entry.path;\n\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry))\n\t\treturn conflict->our_entry.path;\n\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn conflict->their_entry.path;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "git_merge_diff_list__find_renames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1294-1364",
    "snippet": "int git_merge_diff_list__find_renames(\n\tgit_repository *repo,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_options *opts)\n{\n\tstruct merge_diff_similarity *similarity_ours, *similarity_theirs;\n\tvoid **cache = NULL;\n\tsize_t cache_size = 0;\n\tsize_t src_count, tgt_count, i;\n\tint error = 0;\n\n\tassert(diff_list && opts);\n\n\tif ((opts->flags & GIT_MERGE_FIND_RENAMES) == 0)\n\t\treturn 0;\n\n\tsimilarity_ours = git__calloc(diff_list->conflicts.length,\n\t\tsizeof(struct merge_diff_similarity));\n\tGITERR_CHECK_ALLOC(similarity_ours);\n\n\tsimilarity_theirs = git__calloc(diff_list->conflicts.length,\n\t\tsizeof(struct merge_diff_similarity));\n\tGITERR_CHECK_ALLOC(similarity_theirs);\n\n\t/* Calculate similarity between items that were deleted from the ancestor\n\t * and added in the other branch.\n\t */\n\tif ((error = merge_diff_mark_similarity(repo, diff_list, similarity_ours,\n\t\tsimilarity_theirs, index_entry_similarity_exact, NULL, opts)) < 0)\n\t\tgoto done;\n\n\tif (diff_list->conflicts.length <= opts->target_limit) {\n\t\tGITERR_CHECK_ALLOC_MULTIPLY(&cache_size, diff_list->conflicts.length, 3);\n\t\tcache = git__calloc(cache_size, sizeof(void *));\n\t\tGITERR_CHECK_ALLOC(cache);\n\n\t\tmerge_diff_list_count_candidates(diff_list, &src_count, &tgt_count);\n\n\t\tif (src_count > opts->target_limit || tgt_count > opts->target_limit) {\n\t\t\t/* TODO: report! */\n\t\t} else {\n\t\t\tif ((error = merge_diff_mark_similarity(\n\t\t\t\trepo, diff_list, similarity_ours, similarity_theirs,\n\t\t\t\tindex_entry_similarity_inexact, cache, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* For entries that are appropriately similar, merge the new name's entry\n\t * into the old name.\n\t */\n\tmerge_diff_list_coalesce_renames(diff_list, similarity_ours, similarity_theirs, opts);\n\n\t/* And remove any entries that were merged and are now empty. */\n\tgit_vector_remove_matching(&diff_list->conflicts, merge_diff_empty, NULL);\n\ndone:\n\tif (cache != NULL) {\n\t\tfor (i = 0; i < cache_size; ++i) {\n\t\t\tif (cache[i] != NULL)\n\t\t\t\topts->metric->free_signature(cache[i], opts->metric->payload);\n\t\t}\n\n\t\tgit__free(cache);\n\t}\n\n\tgit__free(similarity_ours);\n\tgit__free(similarity_theirs);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "similarity_theirs"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opts->metric->free_signature",
          "args": [
            "cache[i]",
            "opts->metric->payload"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_remove_matching",
          "args": [
            "&diff_list->conflicts",
            "merge_diff_empty",
            "NULL"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove_matching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "281-296",
          "snippet": "void git_vector_remove_matching(\n\tgit_vector *v,\n\tint (*match)(const git_vector *v, size_t idx, void *payload),\n\tvoid *payload)\n{\n\tsize_t i, j;\n\n\tfor (i = 0, j = 0; j < v->length; ++j) {\n\t\tv->contents[i] = v->contents[j];\n\n\t\tif (!match(v, i, payload))\n\t\t\ti++;\n\t}\n\n\tv->length = i;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_remove_matching(\n\tgit_vector *v,\n\tint (*match)(const git_vector *v, size_t idx, void *payload),\n\tvoid *payload)\n{\n\tsize_t i, j;\n\n\tfor (i = 0, j = 0; j < v->length; ++j) {\n\t\tv->contents[i] = v->contents[j];\n\n\t\tif (!match(v, i, payload))\n\t\t\ti++;\n\t}\n\n\tv->length = i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_list_coalesce_renames",
          "args": [
            "diff_list",
            "similarity_ours",
            "similarity_theirs",
            "opts"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_list_coalesce_renames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1201-1260",
          "snippet": "static void merge_diff_list_coalesce_renames(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tconst git_merge_options *opts)\n{\n\tsize_t i;\n\tbool ours_renamed = 0, theirs_renamed = 0;\n\tsize_t ours_source_idx = 0, theirs_source_idx = 0;\n\tgit_merge_diff *ours_source, *theirs_source, *target;\n\n\tfor (i = 0; i < diff_list->conflicts.length; i++) {\n\t\ttarget = diff_list->conflicts.contents[i];\n\n\t\tours_renamed = 0;\n\t\ttheirs_renamed = 0;\n\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(target->our_entry) &&\n\t\t\tsimilarity_ours[i].similarity >= opts->rename_threshold) {\n\t\t\tours_source_idx = similarity_ours[i].other_idx;\n\n\t\t\tours_source = diff_list->conflicts.contents[ours_source_idx];\n\n\t\t\tmerge_diff_coalesce_rename(\n\t\t\t\t&ours_source->our_entry,\n\t\t\t\t&ours_source->our_status,\n\t\t\t\t&target->our_entry,\n\t\t\t\t&target->our_status);\n\n\t\t\tsimilarity_ours[ours_source_idx].similarity = 0;\n\t\t\tsimilarity_ours[i].similarity = 0;\n\n\t\t\tours_renamed = 1;\n\t\t}\n\n\t\t/* insufficient to determine direction */\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(target->their_entry) &&\n\t\t\tsimilarity_theirs[i].similarity >= opts->rename_threshold) {\n\t\t\ttheirs_source_idx = similarity_theirs[i].other_idx;\n\n\t\t\ttheirs_source = diff_list->conflicts.contents[theirs_source_idx];\n\n\t\t\tmerge_diff_coalesce_rename(\n\t\t\t\t&theirs_source->their_entry,\n\t\t\t\t&theirs_source->their_status,\n\t\t\t\t&target->their_entry,\n\t\t\t\t&target->their_status);\n\n\t\t\tsimilarity_theirs[theirs_source_idx].similarity = 0;\n\t\t\tsimilarity_theirs[i].similarity = 0;\n\n\t\t\ttheirs_renamed = 1;\n\t\t}\n\n\t\tmerge_diff_mark_rename_conflict(diff_list,\n\t\t\tsimilarity_ours, ours_renamed, ours_source_idx,\n\t\t\tsimilarity_theirs, theirs_renamed, theirs_source_idx,\n\t\t\ttarget, opts);\n\t}\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic void merge_diff_list_coalesce_renames(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tconst git_merge_options *opts)\n{\n\tsize_t i;\n\tbool ours_renamed = 0, theirs_renamed = 0;\n\tsize_t ours_source_idx = 0, theirs_source_idx = 0;\n\tgit_merge_diff *ours_source, *theirs_source, *target;\n\n\tfor (i = 0; i < diff_list->conflicts.length; i++) {\n\t\ttarget = diff_list->conflicts.contents[i];\n\n\t\tours_renamed = 0;\n\t\ttheirs_renamed = 0;\n\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(target->our_entry) &&\n\t\t\tsimilarity_ours[i].similarity >= opts->rename_threshold) {\n\t\t\tours_source_idx = similarity_ours[i].other_idx;\n\n\t\t\tours_source = diff_list->conflicts.contents[ours_source_idx];\n\n\t\t\tmerge_diff_coalesce_rename(\n\t\t\t\t&ours_source->our_entry,\n\t\t\t\t&ours_source->our_status,\n\t\t\t\t&target->our_entry,\n\t\t\t\t&target->our_status);\n\n\t\t\tsimilarity_ours[ours_source_idx].similarity = 0;\n\t\t\tsimilarity_ours[i].similarity = 0;\n\n\t\t\tours_renamed = 1;\n\t\t}\n\n\t\t/* insufficient to determine direction */\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(target->their_entry) &&\n\t\t\tsimilarity_theirs[i].similarity >= opts->rename_threshold) {\n\t\t\ttheirs_source_idx = similarity_theirs[i].other_idx;\n\n\t\t\ttheirs_source = diff_list->conflicts.contents[theirs_source_idx];\n\n\t\t\tmerge_diff_coalesce_rename(\n\t\t\t\t&theirs_source->their_entry,\n\t\t\t\t&theirs_source->their_status,\n\t\t\t\t&target->their_entry,\n\t\t\t\t&target->their_status);\n\n\t\t\tsimilarity_theirs[theirs_source_idx].similarity = 0;\n\t\t\tsimilarity_theirs[i].similarity = 0;\n\n\t\t\ttheirs_renamed = 1;\n\t\t}\n\n\t\tmerge_diff_mark_rename_conflict(diff_list,\n\t\t\tsimilarity_ours, ours_renamed, ours_source_idx,\n\t\t\tsimilarity_theirs, theirs_renamed, theirs_source_idx,\n\t\t\ttarget, opts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_mark_similarity",
          "args": [
            "repo",
            "diff_list",
            "similarity_ours",
            "similarity_theirs",
            "index_entry_similarity_inexact",
            "cache",
            "opts"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_mark_similarity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1027-1105",
          "snippet": "static int merge_diff_mark_similarity(\n\tgit_repository *repo,\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tint (*similarity_fn)(git_repository *, git_index_entry *, size_t, git_index_entry *, size_t, void **, const git_merge_options *),\n\tvoid **cache,\n\tconst git_merge_options *opts)\n{\n\tsize_t i, j;\n\tgit_merge_diff *conflict_src, *conflict_tgt;\n\tint similarity;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict_src) {\n\t\t/* Items can be the source of a rename iff they have an item in the\n\t\t * ancestor slot and lack an item in the ours or theirs slot. */\n\t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->ancestor_entry) ||\n\t\t\t(GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->our_entry) &&\n\t\t\t GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->their_entry)))\n\t\t\tcontinue;\n\n\t\tgit_vector_foreach(&diff_list->conflicts, j, conflict_tgt) {\n\t\t\tsize_t our_idx = diff_list->conflicts.length + j;\n\t\t\tsize_t their_idx = (diff_list->conflicts.length * 2) + j;\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->ancestor_entry))\n\t\t\t\tcontinue;\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->our_entry) &&\n\t\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->our_entry)) {\n\t\t\t\tsimilarity = similarity_fn(repo, &conflict_src->ancestor_entry, i, &conflict_tgt->our_entry, our_idx, cache, opts);\n\n\t\t\t\tif (similarity == GIT_EBUFS)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (similarity < 0)\n\t\t\t\t\treturn similarity;\n\n\t\t\t\tif (similarity > similarity_ours[i].similarity &&\n\t\t\t\t\tsimilarity > similarity_ours[j].similarity) {\n\t\t\t\t\t/* Clear previous best similarity */\n\t\t\t\t\tif (similarity_ours[i].similarity > 0)\n\t\t\t\t\t\tsimilarity_ours[similarity_ours[i].other_idx].similarity = 0;\n\n\t\t\t\t\tif (similarity_ours[j].similarity > 0)\n\t\t\t\t\t\tsimilarity_ours[similarity_ours[j].other_idx].similarity = 0;\n\n\t\t\t\t\tsimilarity_ours[i].similarity = similarity;\n\t\t\t\t\tsimilarity_ours[i].other_idx = j;\n\n\t\t\t\t\tsimilarity_ours[j].similarity = similarity;\n\t\t\t\t\tsimilarity_ours[j].other_idx = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->their_entry) &&\n\t\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->their_entry)) {\n\t\t\t\tsimilarity = similarity_fn(repo, &conflict_src->ancestor_entry, i, &conflict_tgt->their_entry, their_idx, cache, opts);\n\n\t\t\t\tif (similarity > similarity_theirs[i].similarity &&\n\t\t\t\t\tsimilarity > similarity_theirs[j].similarity) {\n\t\t\t\t\t/* Clear previous best similarity */\n\t\t\t\t\tif (similarity_theirs[i].similarity > 0)\n\t\t\t\t\t\tsimilarity_theirs[similarity_theirs[i].other_idx].similarity = 0;\n\n\t\t\t\t\tif (similarity_theirs[j].similarity > 0)\n\t\t\t\t\t\tsimilarity_theirs[similarity_theirs[j].other_idx].similarity = 0;\n\n\t\t\t\t\tsimilarity_theirs[i].similarity = similarity;\n\t\t\t\t\tsimilarity_theirs[i].other_idx = j;\n\n\t\t\t\t\tsimilarity_theirs[j].similarity = similarity;\n\t\t\t\t\tsimilarity_theirs[j].other_idx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_diff_mark_similarity(\n\tgit_repository *repo,\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tint (*similarity_fn)(git_repository *, git_index_entry *, size_t, git_index_entry *, size_t, void **, const git_merge_options *),\n\tvoid **cache,\n\tconst git_merge_options *opts)\n{\n\tsize_t i, j;\n\tgit_merge_diff *conflict_src, *conflict_tgt;\n\tint similarity;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict_src) {\n\t\t/* Items can be the source of a rename iff they have an item in the\n\t\t * ancestor slot and lack an item in the ours or theirs slot. */\n\t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->ancestor_entry) ||\n\t\t\t(GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->our_entry) &&\n\t\t\t GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->their_entry)))\n\t\t\tcontinue;\n\n\t\tgit_vector_foreach(&diff_list->conflicts, j, conflict_tgt) {\n\t\t\tsize_t our_idx = diff_list->conflicts.length + j;\n\t\t\tsize_t their_idx = (diff_list->conflicts.length * 2) + j;\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->ancestor_entry))\n\t\t\t\tcontinue;\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->our_entry) &&\n\t\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->our_entry)) {\n\t\t\t\tsimilarity = similarity_fn(repo, &conflict_src->ancestor_entry, i, &conflict_tgt->our_entry, our_idx, cache, opts);\n\n\t\t\t\tif (similarity == GIT_EBUFS)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (similarity < 0)\n\t\t\t\t\treturn similarity;\n\n\t\t\t\tif (similarity > similarity_ours[i].similarity &&\n\t\t\t\t\tsimilarity > similarity_ours[j].similarity) {\n\t\t\t\t\t/* Clear previous best similarity */\n\t\t\t\t\tif (similarity_ours[i].similarity > 0)\n\t\t\t\t\t\tsimilarity_ours[similarity_ours[i].other_idx].similarity = 0;\n\n\t\t\t\t\tif (similarity_ours[j].similarity > 0)\n\t\t\t\t\t\tsimilarity_ours[similarity_ours[j].other_idx].similarity = 0;\n\n\t\t\t\t\tsimilarity_ours[i].similarity = similarity;\n\t\t\t\t\tsimilarity_ours[i].other_idx = j;\n\n\t\t\t\t\tsimilarity_ours[j].similarity = similarity;\n\t\t\t\t\tsimilarity_ours[j].other_idx = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->their_entry) &&\n\t\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->their_entry)) {\n\t\t\t\tsimilarity = similarity_fn(repo, &conflict_src->ancestor_entry, i, &conflict_tgt->their_entry, their_idx, cache, opts);\n\n\t\t\t\tif (similarity > similarity_theirs[i].similarity &&\n\t\t\t\t\tsimilarity > similarity_theirs[j].similarity) {\n\t\t\t\t\t/* Clear previous best similarity */\n\t\t\t\t\tif (similarity_theirs[i].similarity > 0)\n\t\t\t\t\t\tsimilarity_theirs[similarity_theirs[i].other_idx].similarity = 0;\n\n\t\t\t\t\tif (similarity_theirs[j].similarity > 0)\n\t\t\t\t\t\tsimilarity_theirs[similarity_theirs[j].other_idx].similarity = 0;\n\n\t\t\t\t\tsimilarity_theirs[i].similarity = similarity;\n\t\t\t\t\tsimilarity_theirs[i].other_idx = j;\n\n\t\t\t\t\tsimilarity_theirs[j].similarity = similarity;\n\t\t\t\t\tsimilarity_theirs[j].other_idx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_list_count_candidates",
          "args": [
            "diff_list",
            "&src_count",
            "&tgt_count"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_list_count_candidates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1273-1292",
          "snippet": "static void merge_diff_list_count_candidates(\n\tgit_merge_diff_list *diff_list,\n\tsize_t *src_count,\n\tsize_t *tgt_count)\n{\n\tgit_merge_diff *entry;\n\tsize_t i;\n\n\t*src_count = 0;\n\t*tgt_count = 0;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, entry) {\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(entry->ancestor_entry) &&\n\t\t\t(!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->our_entry) ||\n\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->their_entry)))\n\t\t\t(*src_count)++;\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->ancestor_entry))\n\t\t\t(*tgt_count)++;\n\t}\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void merge_diff_list_count_candidates(\n\tgit_merge_diff_list *diff_list,\n\tsize_t *src_count,\n\tsize_t *tgt_count)\n{\n\tgit_merge_diff *entry;\n\tsize_t i;\n\n\t*src_count = 0;\n\t*tgt_count = 0;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, entry) {\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(entry->ancestor_entry) &&\n\t\t\t(!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->our_entry) ||\n\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->their_entry)))\n\t\t\t(*src_count)++;\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->ancestor_entry))\n\t\t\t(*tgt_count)++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "cache"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "cache_size",
            "sizeof(void *)"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&cache_size",
            "diff_list->conflicts.length",
            "3"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "similarity_theirs"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "similarity_ours"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff_list && opts"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge_diff_list__find_renames(\n\tgit_repository *repo,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_options *opts)\n{\n\tstruct merge_diff_similarity *similarity_ours, *similarity_theirs;\n\tvoid **cache = NULL;\n\tsize_t cache_size = 0;\n\tsize_t src_count, tgt_count, i;\n\tint error = 0;\n\n\tassert(diff_list && opts);\n\n\tif ((opts->flags & GIT_MERGE_FIND_RENAMES) == 0)\n\t\treturn 0;\n\n\tsimilarity_ours = git__calloc(diff_list->conflicts.length,\n\t\tsizeof(struct merge_diff_similarity));\n\tGITERR_CHECK_ALLOC(similarity_ours);\n\n\tsimilarity_theirs = git__calloc(diff_list->conflicts.length,\n\t\tsizeof(struct merge_diff_similarity));\n\tGITERR_CHECK_ALLOC(similarity_theirs);\n\n\t/* Calculate similarity between items that were deleted from the ancestor\n\t * and added in the other branch.\n\t */\n\tif ((error = merge_diff_mark_similarity(repo, diff_list, similarity_ours,\n\t\tsimilarity_theirs, index_entry_similarity_exact, NULL, opts)) < 0)\n\t\tgoto done;\n\n\tif (diff_list->conflicts.length <= opts->target_limit) {\n\t\tGITERR_CHECK_ALLOC_MULTIPLY(&cache_size, diff_list->conflicts.length, 3);\n\t\tcache = git__calloc(cache_size, sizeof(void *));\n\t\tGITERR_CHECK_ALLOC(cache);\n\n\t\tmerge_diff_list_count_candidates(diff_list, &src_count, &tgt_count);\n\n\t\tif (src_count > opts->target_limit || tgt_count > opts->target_limit) {\n\t\t\t/* TODO: report! */\n\t\t} else {\n\t\t\tif ((error = merge_diff_mark_similarity(\n\t\t\t\trepo, diff_list, similarity_ours, similarity_theirs,\n\t\t\t\tindex_entry_similarity_inexact, cache, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* For entries that are appropriately similar, merge the new name's entry\n\t * into the old name.\n\t */\n\tmerge_diff_list_coalesce_renames(diff_list, similarity_ours, similarity_theirs, opts);\n\n\t/* And remove any entries that were merged and are now empty. */\n\tgit_vector_remove_matching(&diff_list->conflicts, merge_diff_empty, NULL);\n\ndone:\n\tif (cache != NULL) {\n\t\tfor (i = 0; i < cache_size; ++i) {\n\t\t\tif (cache[i] != NULL)\n\t\t\t\topts->metric->free_signature(cache[i], opts->metric->payload);\n\t\t}\n\n\t\tgit__free(cache);\n\t}\n\n\tgit__free(similarity_ours);\n\tgit__free(similarity_theirs);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_diff_list_count_candidates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1273-1292",
    "snippet": "static void merge_diff_list_count_candidates(\n\tgit_merge_diff_list *diff_list,\n\tsize_t *src_count,\n\tsize_t *tgt_count)\n{\n\tgit_merge_diff *entry;\n\tsize_t i;\n\n\t*src_count = 0;\n\t*tgt_count = 0;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, entry) {\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(entry->ancestor_entry) &&\n\t\t\t(!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->our_entry) ||\n\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->their_entry)))\n\t\t\t(*src_count)++;\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->ancestor_entry))\n\t\t\t(*tgt_count)++;\n\t}\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "entry->ancestor_entry"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "entry->their_entry"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "entry->our_entry"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "entry->ancestor_entry"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff_list->conflicts",
            "i",
            "entry"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void merge_diff_list_count_candidates(\n\tgit_merge_diff_list *diff_list,\n\tsize_t *src_count,\n\tsize_t *tgt_count)\n{\n\tgit_merge_diff *entry;\n\tsize_t i;\n\n\t*src_count = 0;\n\t*tgt_count = 0;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, entry) {\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(entry->ancestor_entry) &&\n\t\t\t(!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->our_entry) ||\n\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->their_entry)))\n\t\t\t(*src_count)++;\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(entry->ancestor_entry))\n\t\t\t(*tgt_count)++;\n\t}\n}"
  },
  {
    "function_name": "merge_diff_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1262-1271",
    "snippet": "static int merge_diff_empty(const git_vector *conflicts, size_t idx, void *p)\n{\n\tgit_merge_diff *conflict = conflicts->contents[idx];\n\n\tGIT_UNUSED(p);\n\n\treturn (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) &&\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) &&\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry));\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->ancestor_entry"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "p"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_diff_empty(const git_vector *conflicts, size_t idx, void *p)\n{\n\tgit_merge_diff *conflict = conflicts->contents[idx];\n\n\tGIT_UNUSED(p);\n\n\treturn (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) &&\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) &&\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry));\n}"
  },
  {
    "function_name": "merge_diff_list_coalesce_renames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1201-1260",
    "snippet": "static void merge_diff_list_coalesce_renames(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tconst git_merge_options *opts)\n{\n\tsize_t i;\n\tbool ours_renamed = 0, theirs_renamed = 0;\n\tsize_t ours_source_idx = 0, theirs_source_idx = 0;\n\tgit_merge_diff *ours_source, *theirs_source, *target;\n\n\tfor (i = 0; i < diff_list->conflicts.length; i++) {\n\t\ttarget = diff_list->conflicts.contents[i];\n\n\t\tours_renamed = 0;\n\t\ttheirs_renamed = 0;\n\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(target->our_entry) &&\n\t\t\tsimilarity_ours[i].similarity >= opts->rename_threshold) {\n\t\t\tours_source_idx = similarity_ours[i].other_idx;\n\n\t\t\tours_source = diff_list->conflicts.contents[ours_source_idx];\n\n\t\t\tmerge_diff_coalesce_rename(\n\t\t\t\t&ours_source->our_entry,\n\t\t\t\t&ours_source->our_status,\n\t\t\t\t&target->our_entry,\n\t\t\t\t&target->our_status);\n\n\t\t\tsimilarity_ours[ours_source_idx].similarity = 0;\n\t\t\tsimilarity_ours[i].similarity = 0;\n\n\t\t\tours_renamed = 1;\n\t\t}\n\n\t\t/* insufficient to determine direction */\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(target->their_entry) &&\n\t\t\tsimilarity_theirs[i].similarity >= opts->rename_threshold) {\n\t\t\ttheirs_source_idx = similarity_theirs[i].other_idx;\n\n\t\t\ttheirs_source = diff_list->conflicts.contents[theirs_source_idx];\n\n\t\t\tmerge_diff_coalesce_rename(\n\t\t\t\t&theirs_source->their_entry,\n\t\t\t\t&theirs_source->their_status,\n\t\t\t\t&target->their_entry,\n\t\t\t\t&target->their_status);\n\n\t\t\tsimilarity_theirs[theirs_source_idx].similarity = 0;\n\t\t\tsimilarity_theirs[i].similarity = 0;\n\n\t\t\ttheirs_renamed = 1;\n\t\t}\n\n\t\tmerge_diff_mark_rename_conflict(diff_list,\n\t\t\tsimilarity_ours, ours_renamed, ours_source_idx,\n\t\t\tsimilarity_theirs, theirs_renamed, theirs_source_idx,\n\t\t\ttarget, opts);\n\t}\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_diff_mark_rename_conflict",
          "args": [
            "diff_list",
            "similarity_ours",
            "ours_renamed",
            "ours_source_idx",
            "similarity_theirs",
            "theirs_renamed",
            "theirs_source_idx",
            "target",
            "opts"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_mark_rename_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1126-1185",
          "snippet": "static void merge_diff_mark_rename_conflict(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tbool ours_renamed,\n\tsize_t ours_source_idx,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tbool theirs_renamed,\n\tsize_t theirs_source_idx,\n\tgit_merge_diff *target,\n\tconst git_merge_options *opts)\n{\n\tgit_merge_diff *ours_source = NULL, *theirs_source = NULL;\n\n\tif (ours_renamed)\n\t\tours_source = diff_list->conflicts.contents[ours_source_idx];\n\n\tif (theirs_renamed)\n\t\ttheirs_source = diff_list->conflicts.contents[theirs_source_idx];\n\n\t/* Detect 2->1 conflicts */\n\tif (ours_renamed && theirs_renamed) {\n\t\t/* Both renamed to the same target name. */\n\t\tif (ours_source_idx == theirs_source_idx)\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED;\n\t\telse {\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1;\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1;\n\t\t}\n\t} else if (ours_renamed) {\n\t\t/* If our source was also renamed in theirs, this is a 1->2 */\n\t\tif (similarity_theirs[ours_source_idx].similarity >= opts->rename_threshold)\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2;\n\n\t\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(target->their_entry)) {\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t\ttarget->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t}\n\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(ours_source->their_entry))\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_DELETED;\n\n\t\telse if (ours_source->type == GIT_MERGE_DIFF_MODIFIED_DELETED)\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_MODIFIED;\n\t} else if (theirs_renamed) {\n\t\t/* If their source was also renamed in ours, this is a 1->2 */\n\t\tif (similarity_ours[theirs_source_idx].similarity >= opts->rename_threshold)\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2;\n\n\t\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(target->our_entry)) {\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t\ttarget->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t}\n\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(theirs_source->our_entry))\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_DELETED;\n\n\t\telse if (theirs_source->type == GIT_MERGE_DIFF_MODIFIED_DELETED)\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_MODIFIED;\n\t}\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic void merge_diff_mark_rename_conflict(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tbool ours_renamed,\n\tsize_t ours_source_idx,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tbool theirs_renamed,\n\tsize_t theirs_source_idx,\n\tgit_merge_diff *target,\n\tconst git_merge_options *opts)\n{\n\tgit_merge_diff *ours_source = NULL, *theirs_source = NULL;\n\n\tif (ours_renamed)\n\t\tours_source = diff_list->conflicts.contents[ours_source_idx];\n\n\tif (theirs_renamed)\n\t\ttheirs_source = diff_list->conflicts.contents[theirs_source_idx];\n\n\t/* Detect 2->1 conflicts */\n\tif (ours_renamed && theirs_renamed) {\n\t\t/* Both renamed to the same target name. */\n\t\tif (ours_source_idx == theirs_source_idx)\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED;\n\t\telse {\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1;\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1;\n\t\t}\n\t} else if (ours_renamed) {\n\t\t/* If our source was also renamed in theirs, this is a 1->2 */\n\t\tif (similarity_theirs[ours_source_idx].similarity >= opts->rename_threshold)\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2;\n\n\t\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(target->their_entry)) {\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t\ttarget->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t}\n\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(ours_source->their_entry))\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_DELETED;\n\n\t\telse if (ours_source->type == GIT_MERGE_DIFF_MODIFIED_DELETED)\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_MODIFIED;\n\t} else if (theirs_renamed) {\n\t\t/* If their source was also renamed in ours, this is a 1->2 */\n\t\tif (similarity_ours[theirs_source_idx].similarity >= opts->rename_threshold)\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2;\n\n\t\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(target->our_entry)) {\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t\ttarget->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t}\n\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(theirs_source->our_entry))\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_DELETED;\n\n\t\telse if (theirs_source->type == GIT_MERGE_DIFF_MODIFIED_DELETED)\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_MODIFIED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_diff_coalesce_rename",
          "args": [
            "&theirs_source->their_entry",
            "&theirs_source->their_status",
            "&target->their_entry",
            "&target->their_status"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "merge_diff_coalesce_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1187-1199",
          "snippet": "GIT_INLINE(void) merge_diff_coalesce_rename(\n\tgit_index_entry *source_entry,\n\tgit_delta_t *source_status,\n\tgit_index_entry *target_entry,\n\tgit_delta_t *target_status)\n{\n\t/* Coalesce the rename target into the rename source. */\n\tmemcpy(source_entry, target_entry, sizeof(git_index_entry));\n\t*source_status = GIT_DELTA_RENAMED;\n\n\tmemset(target_entry, 0x0, sizeof(git_index_entry));\n\t*target_status = GIT_DELTA_UNMODIFIED;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) merge_diff_coalesce_rename(\n\tgit_index_entry *source_entry,\n\tgit_delta_t *source_status,\n\tgit_index_entry *target_entry,\n\tgit_delta_t *target_status)\n{\n\t/* Coalesce the rename target into the rename source. */\n\tmemcpy(source_entry, target_entry, sizeof(git_index_entry));\n\t*source_status = GIT_DELTA_RENAMED;\n\n\tmemset(target_entry, 0x0, sizeof(git_index_entry));\n\t*target_status = GIT_DELTA_UNMODIFIED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "target->their_entry"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "target->our_entry"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic void merge_diff_list_coalesce_renames(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tconst git_merge_options *opts)\n{\n\tsize_t i;\n\tbool ours_renamed = 0, theirs_renamed = 0;\n\tsize_t ours_source_idx = 0, theirs_source_idx = 0;\n\tgit_merge_diff *ours_source, *theirs_source, *target;\n\n\tfor (i = 0; i < diff_list->conflicts.length; i++) {\n\t\ttarget = diff_list->conflicts.contents[i];\n\n\t\tours_renamed = 0;\n\t\ttheirs_renamed = 0;\n\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(target->our_entry) &&\n\t\t\tsimilarity_ours[i].similarity >= opts->rename_threshold) {\n\t\t\tours_source_idx = similarity_ours[i].other_idx;\n\n\t\t\tours_source = diff_list->conflicts.contents[ours_source_idx];\n\n\t\t\tmerge_diff_coalesce_rename(\n\t\t\t\t&ours_source->our_entry,\n\t\t\t\t&ours_source->our_status,\n\t\t\t\t&target->our_entry,\n\t\t\t\t&target->our_status);\n\n\t\t\tsimilarity_ours[ours_source_idx].similarity = 0;\n\t\t\tsimilarity_ours[i].similarity = 0;\n\n\t\t\tours_renamed = 1;\n\t\t}\n\n\t\t/* insufficient to determine direction */\n\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(target->their_entry) &&\n\t\t\tsimilarity_theirs[i].similarity >= opts->rename_threshold) {\n\t\t\ttheirs_source_idx = similarity_theirs[i].other_idx;\n\n\t\t\ttheirs_source = diff_list->conflicts.contents[theirs_source_idx];\n\n\t\t\tmerge_diff_coalesce_rename(\n\t\t\t\t&theirs_source->their_entry,\n\t\t\t\t&theirs_source->their_status,\n\t\t\t\t&target->their_entry,\n\t\t\t\t&target->their_status);\n\n\t\t\tsimilarity_theirs[theirs_source_idx].similarity = 0;\n\t\t\tsimilarity_theirs[i].similarity = 0;\n\n\t\t\ttheirs_renamed = 1;\n\t\t}\n\n\t\tmerge_diff_mark_rename_conflict(diff_list,\n\t\t\tsimilarity_ours, ours_renamed, ours_source_idx,\n\t\t\tsimilarity_theirs, theirs_renamed, theirs_source_idx,\n\t\t\ttarget, opts);\n\t}\n}"
  },
  {
    "function_name": "merge_diff_coalesce_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1187-1199",
    "snippet": "GIT_INLINE(void) merge_diff_coalesce_rename(\n\tgit_index_entry *source_entry,\n\tgit_delta_t *source_status,\n\tgit_index_entry *target_entry,\n\tgit_delta_t *target_status)\n{\n\t/* Coalesce the rename target into the rename source. */\n\tmemcpy(source_entry, target_entry, sizeof(git_index_entry));\n\t*source_status = GIT_DELTA_RENAMED;\n\n\tmemset(target_entry, 0x0, sizeof(git_index_entry));\n\t*target_status = GIT_DELTA_UNMODIFIED;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "target_entry",
            "0x0",
            "sizeof(git_index_entry)"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "source_entry",
            "target_entry",
            "sizeof(git_index_entry)"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) merge_diff_coalesce_rename(\n\tgit_index_entry *source_entry,\n\tgit_delta_t *source_status,\n\tgit_index_entry *target_entry,\n\tgit_delta_t *target_status)\n{\n\t/* Coalesce the rename target into the rename source. */\n\tmemcpy(source_entry, target_entry, sizeof(git_index_entry));\n\t*source_status = GIT_DELTA_RENAMED;\n\n\tmemset(target_entry, 0x0, sizeof(git_index_entry));\n\t*target_status = GIT_DELTA_UNMODIFIED;\n}"
  },
  {
    "function_name": "merge_diff_mark_rename_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1126-1185",
    "snippet": "static void merge_diff_mark_rename_conflict(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tbool ours_renamed,\n\tsize_t ours_source_idx,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tbool theirs_renamed,\n\tsize_t theirs_source_idx,\n\tgit_merge_diff *target,\n\tconst git_merge_options *opts)\n{\n\tgit_merge_diff *ours_source = NULL, *theirs_source = NULL;\n\n\tif (ours_renamed)\n\t\tours_source = diff_list->conflicts.contents[ours_source_idx];\n\n\tif (theirs_renamed)\n\t\ttheirs_source = diff_list->conflicts.contents[theirs_source_idx];\n\n\t/* Detect 2->1 conflicts */\n\tif (ours_renamed && theirs_renamed) {\n\t\t/* Both renamed to the same target name. */\n\t\tif (ours_source_idx == theirs_source_idx)\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED;\n\t\telse {\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1;\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1;\n\t\t}\n\t} else if (ours_renamed) {\n\t\t/* If our source was also renamed in theirs, this is a 1->2 */\n\t\tif (similarity_theirs[ours_source_idx].similarity >= opts->rename_threshold)\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2;\n\n\t\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(target->their_entry)) {\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t\ttarget->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t}\n\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(ours_source->their_entry))\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_DELETED;\n\n\t\telse if (ours_source->type == GIT_MERGE_DIFF_MODIFIED_DELETED)\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_MODIFIED;\n\t} else if (theirs_renamed) {\n\t\t/* If their source was also renamed in ours, this is a 1->2 */\n\t\tif (similarity_ours[theirs_source_idx].similarity >= opts->rename_threshold)\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2;\n\n\t\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(target->our_entry)) {\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t\ttarget->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t}\n\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(theirs_source->our_entry))\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_DELETED;\n\n\t\telse if (theirs_source->type == GIT_MERGE_DIFF_MODIFIED_DELETED)\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_MODIFIED;\n\t}\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "theirs_source->our_entry"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "target->our_entry"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "ours_source->their_entry"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "target->their_entry"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic void merge_diff_mark_rename_conflict(\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tbool ours_renamed,\n\tsize_t ours_source_idx,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tbool theirs_renamed,\n\tsize_t theirs_source_idx,\n\tgit_merge_diff *target,\n\tconst git_merge_options *opts)\n{\n\tgit_merge_diff *ours_source = NULL, *theirs_source = NULL;\n\n\tif (ours_renamed)\n\t\tours_source = diff_list->conflicts.contents[ours_source_idx];\n\n\tif (theirs_renamed)\n\t\ttheirs_source = diff_list->conflicts.contents[theirs_source_idx];\n\n\t/* Detect 2->1 conflicts */\n\tif (ours_renamed && theirs_renamed) {\n\t\t/* Both renamed to the same target name. */\n\t\tif (ours_source_idx == theirs_source_idx)\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED;\n\t\telse {\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1;\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1;\n\t\t}\n\t} else if (ours_renamed) {\n\t\t/* If our source was also renamed in theirs, this is a 1->2 */\n\t\tif (similarity_theirs[ours_source_idx].similarity >= opts->rename_threshold)\n\t\t\tours_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2;\n\n\t\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(target->their_entry)) {\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t\ttarget->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t}\n\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(ours_source->their_entry))\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_DELETED;\n\n\t\telse if (ours_source->type == GIT_MERGE_DIFF_MODIFIED_DELETED)\n\t\t\tours_source->type = GIT_MERGE_DIFF_RENAMED_MODIFIED;\n\t} else if (theirs_renamed) {\n\t\t/* If their source was also renamed in ours, this is a 1->2 */\n\t\tif (similarity_ours[theirs_source_idx].similarity >= opts->rename_threshold)\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2;\n\n\t\telse if (GIT_MERGE_INDEX_ENTRY_EXISTS(target->our_entry)) {\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t\ttarget->type = GIT_MERGE_DIFF_RENAMED_ADDED;\n\t\t}\n\n\t\telse if (!GIT_MERGE_INDEX_ENTRY_EXISTS(theirs_source->our_entry))\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_DELETED;\n\n\t\telse if (theirs_source->type == GIT_MERGE_DIFF_MODIFIED_DELETED)\n\t\t\ttheirs_source->type = GIT_MERGE_DIFF_RENAMED_MODIFIED;\n\t}\n}"
  },
  {
    "function_name": "merge_diff_mark_similarity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "1027-1105",
    "snippet": "static int merge_diff_mark_similarity(\n\tgit_repository *repo,\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tint (*similarity_fn)(git_repository *, git_index_entry *, size_t, git_index_entry *, size_t, void **, const git_merge_options *),\n\tvoid **cache,\n\tconst git_merge_options *opts)\n{\n\tsize_t i, j;\n\tgit_merge_diff *conflict_src, *conflict_tgt;\n\tint similarity;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict_src) {\n\t\t/* Items can be the source of a rename iff they have an item in the\n\t\t * ancestor slot and lack an item in the ours or theirs slot. */\n\t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->ancestor_entry) ||\n\t\t\t(GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->our_entry) &&\n\t\t\t GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->their_entry)))\n\t\t\tcontinue;\n\n\t\tgit_vector_foreach(&diff_list->conflicts, j, conflict_tgt) {\n\t\t\tsize_t our_idx = diff_list->conflicts.length + j;\n\t\t\tsize_t their_idx = (diff_list->conflicts.length * 2) + j;\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->ancestor_entry))\n\t\t\t\tcontinue;\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->our_entry) &&\n\t\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->our_entry)) {\n\t\t\t\tsimilarity = similarity_fn(repo, &conflict_src->ancestor_entry, i, &conflict_tgt->our_entry, our_idx, cache, opts);\n\n\t\t\t\tif (similarity == GIT_EBUFS)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (similarity < 0)\n\t\t\t\t\treturn similarity;\n\n\t\t\t\tif (similarity > similarity_ours[i].similarity &&\n\t\t\t\t\tsimilarity > similarity_ours[j].similarity) {\n\t\t\t\t\t/* Clear previous best similarity */\n\t\t\t\t\tif (similarity_ours[i].similarity > 0)\n\t\t\t\t\t\tsimilarity_ours[similarity_ours[i].other_idx].similarity = 0;\n\n\t\t\t\t\tif (similarity_ours[j].similarity > 0)\n\t\t\t\t\t\tsimilarity_ours[similarity_ours[j].other_idx].similarity = 0;\n\n\t\t\t\t\tsimilarity_ours[i].similarity = similarity;\n\t\t\t\t\tsimilarity_ours[i].other_idx = j;\n\n\t\t\t\t\tsimilarity_ours[j].similarity = similarity;\n\t\t\t\t\tsimilarity_ours[j].other_idx = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->their_entry) &&\n\t\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->their_entry)) {\n\t\t\t\tsimilarity = similarity_fn(repo, &conflict_src->ancestor_entry, i, &conflict_tgt->their_entry, their_idx, cache, opts);\n\n\t\t\t\tif (similarity > similarity_theirs[i].similarity &&\n\t\t\t\t\tsimilarity > similarity_theirs[j].similarity) {\n\t\t\t\t\t/* Clear previous best similarity */\n\t\t\t\t\tif (similarity_theirs[i].similarity > 0)\n\t\t\t\t\t\tsimilarity_theirs[similarity_theirs[i].other_idx].similarity = 0;\n\n\t\t\t\t\tif (similarity_theirs[j].similarity > 0)\n\t\t\t\t\t\tsimilarity_theirs[similarity_theirs[j].other_idx].similarity = 0;\n\n\t\t\t\t\tsimilarity_theirs[i].similarity = similarity;\n\t\t\t\t\tsimilarity_theirs[i].other_idx = j;\n\n\t\t\t\t\tsimilarity_theirs[j].similarity = similarity;\n\t\t\t\t\tsimilarity_theirs[j].other_idx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "similarity_fn",
          "args": [
            "repo",
            "&conflict_src->ancestor_entry",
            "i",
            "&conflict_tgt->their_entry",
            "their_idx",
            "cache",
            "opts"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict_src->their_entry"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict_tgt->their_entry"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "similarity_fn",
          "args": [
            "repo",
            "&conflict_src->ancestor_entry",
            "i",
            "&conflict_tgt->our_entry",
            "our_idx",
            "cache",
            "opts"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict_src->our_entry"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict_tgt->our_entry"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict_tgt->ancestor_entry"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff_list->conflicts",
            "j",
            "conflict_tgt"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict_src->their_entry"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict_src->our_entry"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict_src->ancestor_entry"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff_list->conflicts",
            "i",
            "conflict_src"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int merge_diff_mark_similarity(\n\tgit_repository *repo,\n\tgit_merge_diff_list *diff_list,\n\tstruct merge_diff_similarity *similarity_ours,\n\tstruct merge_diff_similarity *similarity_theirs,\n\tint (*similarity_fn)(git_repository *, git_index_entry *, size_t, git_index_entry *, size_t, void **, const git_merge_options *),\n\tvoid **cache,\n\tconst git_merge_options *opts)\n{\n\tsize_t i, j;\n\tgit_merge_diff *conflict_src, *conflict_tgt;\n\tint similarity;\n\n\tgit_vector_foreach(&diff_list->conflicts, i, conflict_src) {\n\t\t/* Items can be the source of a rename iff they have an item in the\n\t\t * ancestor slot and lack an item in the ours or theirs slot. */\n\t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->ancestor_entry) ||\n\t\t\t(GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->our_entry) &&\n\t\t\t GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->their_entry)))\n\t\t\tcontinue;\n\n\t\tgit_vector_foreach(&diff_list->conflicts, j, conflict_tgt) {\n\t\t\tsize_t our_idx = diff_list->conflicts.length + j;\n\t\t\tsize_t their_idx = (diff_list->conflicts.length * 2) + j;\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->ancestor_entry))\n\t\t\t\tcontinue;\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->our_entry) &&\n\t\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->our_entry)) {\n\t\t\t\tsimilarity = similarity_fn(repo, &conflict_src->ancestor_entry, i, &conflict_tgt->our_entry, our_idx, cache, opts);\n\n\t\t\t\tif (similarity == GIT_EBUFS)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (similarity < 0)\n\t\t\t\t\treturn similarity;\n\n\t\t\t\tif (similarity > similarity_ours[i].similarity &&\n\t\t\t\t\tsimilarity > similarity_ours[j].similarity) {\n\t\t\t\t\t/* Clear previous best similarity */\n\t\t\t\t\tif (similarity_ours[i].similarity > 0)\n\t\t\t\t\t\tsimilarity_ours[similarity_ours[i].other_idx].similarity = 0;\n\n\t\t\t\t\tif (similarity_ours[j].similarity > 0)\n\t\t\t\t\t\tsimilarity_ours[similarity_ours[j].other_idx].similarity = 0;\n\n\t\t\t\t\tsimilarity_ours[i].similarity = similarity;\n\t\t\t\t\tsimilarity_ours[i].other_idx = j;\n\n\t\t\t\t\tsimilarity_ours[j].similarity = similarity;\n\t\t\t\t\tsimilarity_ours[j].other_idx = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->their_entry) &&\n\t\t\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->their_entry)) {\n\t\t\t\tsimilarity = similarity_fn(repo, &conflict_src->ancestor_entry, i, &conflict_tgt->their_entry, their_idx, cache, opts);\n\n\t\t\t\tif (similarity > similarity_theirs[i].similarity &&\n\t\t\t\t\tsimilarity > similarity_theirs[j].similarity) {\n\t\t\t\t\t/* Clear previous best similarity */\n\t\t\t\t\tif (similarity_theirs[i].similarity > 0)\n\t\t\t\t\t\tsimilarity_theirs[similarity_theirs[i].other_idx].similarity = 0;\n\n\t\t\t\t\tif (similarity_theirs[j].similarity > 0)\n\t\t\t\t\t\tsimilarity_theirs[similarity_theirs[j].other_idx].similarity = 0;\n\n\t\t\t\t\tsimilarity_theirs[i].similarity = similarity;\n\t\t\t\t\tsimilarity_theirs[i].other_idx = j;\n\n\t\t\t\t\tsimilarity_theirs[j].similarity = similarity;\n\t\t\t\t\tsimilarity_theirs[j].other_idx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "index_entry_similarity_inexact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "988-1025",
    "snippet": "static int index_entry_similarity_inexact(\n\tgit_repository *repo,\n\tgit_index_entry *a,\n\tsize_t a_idx,\n\tgit_index_entry *b,\n\tsize_t b_idx,\n\tvoid **cache,\n\tconst git_merge_options *opts)\n{\n\tint score = 0;\n\tint error = 0;\n\n\tif (GIT_MODE_TYPE(a->mode) != GIT_MODE_TYPE(b->mode))\n\t\treturn 0;\n\n\t/* update signature cache if needed */\n\tif (!cache[a_idx] && (error = index_entry_similarity_calc(&cache[a_idx], repo, a, opts)) < 0)\n\t\treturn error;\n\tif (!cache[b_idx] && (error = index_entry_similarity_calc(&cache[b_idx], repo, b, opts)) < 0)\n\t\treturn error;\n\n\t/* some metrics may not wish to process this file (too big / too small) */\n\tif (!cache[a_idx] || !cache[b_idx])\n\t\treturn 0;\n\n\t/* compare signatures */\n\tif (opts->metric->similarity(\n\t\t&score, cache[a_idx], cache[b_idx], opts->metric->payload) < 0)\n\t\treturn -1;\n\n\t/* clip score */\n\tif (score < 0)\n\t\tscore = 0;\n\telse if (score > 100)\n\t\tscore = 100;\n\n\treturn score;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "opts->metric->similarity",
          "args": [
            "&score",
            "cache[a_idx]",
            "cache[b_idx]",
            "opts->metric->payload"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_entry_similarity_calc",
          "args": [
            "&cache[b_idx]",
            "repo",
            "b",
            "opts"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_similarity_calc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "951-986",
          "snippet": "static int index_entry_similarity_calc(\n\tvoid **out,\n\tgit_repository *repo,\n\tgit_index_entry *entry,\n\tconst git_merge_options *opts)\n{\n\tgit_blob *blob;\n\tgit_diff_file diff_file = {{{0}}};\n\tgit_off_t blobsize;\n\tint error;\n\n\t*out = NULL;\n\n\tif ((error = git_blob_lookup(&blob, repo, &entry->id)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&diff_file.id, &entry->id);\n\tdiff_file.path = entry->path;\n\tdiff_file.size = entry->file_size;\n\tdiff_file.mode = entry->mode;\n\tdiff_file.flags = 0;\n\n\tblobsize = git_blob_rawsize(blob);\n\n\t/* file too big for rename processing */\n\tif (!git__is_sizet(blobsize))\n\t\treturn 0;\n\n\terror = opts->metric->buffer_signature(out, &diff_file,\n\t\tgit_blob_rawcontent(blob), (size_t)blobsize,\n\t\topts->metric->payload);\n\n\tgit_blob_free(blob);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int index_entry_similarity_calc(\n\tvoid **out,\n\tgit_repository *repo,\n\tgit_index_entry *entry,\n\tconst git_merge_options *opts)\n{\n\tgit_blob *blob;\n\tgit_diff_file diff_file = {{{0}}};\n\tgit_off_t blobsize;\n\tint error;\n\n\t*out = NULL;\n\n\tif ((error = git_blob_lookup(&blob, repo, &entry->id)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&diff_file.id, &entry->id);\n\tdiff_file.path = entry->path;\n\tdiff_file.size = entry->file_size;\n\tdiff_file.mode = entry->mode;\n\tdiff_file.flags = 0;\n\n\tblobsize = git_blob_rawsize(blob);\n\n\t/* file too big for rename processing */\n\tif (!git__is_sizet(blobsize))\n\t\treturn 0;\n\n\terror = opts->metric->buffer_signature(out, &diff_file,\n\t\tgit_blob_rawcontent(blob), (size_t)blobsize,\n\t\topts->metric->payload);\n\n\tgit_blob_free(blob);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MODE_TYPE",
          "args": [
            "b->mode"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MODE_TYPE",
          "args": [
            "a->mode"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int index_entry_similarity_inexact(\n\tgit_repository *repo,\n\tgit_index_entry *a,\n\tsize_t a_idx,\n\tgit_index_entry *b,\n\tsize_t b_idx,\n\tvoid **cache,\n\tconst git_merge_options *opts)\n{\n\tint score = 0;\n\tint error = 0;\n\n\tif (GIT_MODE_TYPE(a->mode) != GIT_MODE_TYPE(b->mode))\n\t\treturn 0;\n\n\t/* update signature cache if needed */\n\tif (!cache[a_idx] && (error = index_entry_similarity_calc(&cache[a_idx], repo, a, opts)) < 0)\n\t\treturn error;\n\tif (!cache[b_idx] && (error = index_entry_similarity_calc(&cache[b_idx], repo, b, opts)) < 0)\n\t\treturn error;\n\n\t/* some metrics may not wish to process this file (too big / too small) */\n\tif (!cache[a_idx] || !cache[b_idx])\n\t\treturn 0;\n\n\t/* compare signatures */\n\tif (opts->metric->similarity(\n\t\t&score, cache[a_idx], cache[b_idx], opts->metric->payload) < 0)\n\t\treturn -1;\n\n\t/* clip score */\n\tif (score < 0)\n\t\tscore = 0;\n\telse if (score > 100)\n\t\tscore = 100;\n\n\treturn score;\n}"
  },
  {
    "function_name": "index_entry_similarity_calc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "951-986",
    "snippet": "static int index_entry_similarity_calc(\n\tvoid **out,\n\tgit_repository *repo,\n\tgit_index_entry *entry,\n\tconst git_merge_options *opts)\n{\n\tgit_blob *blob;\n\tgit_diff_file diff_file = {{{0}}};\n\tgit_off_t blobsize;\n\tint error;\n\n\t*out = NULL;\n\n\tif ((error = git_blob_lookup(&blob, repo, &entry->id)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&diff_file.id, &entry->id);\n\tdiff_file.path = entry->path;\n\tdiff_file.size = entry->file_size;\n\tdiff_file.mode = entry->mode;\n\tdiff_file.flags = 0;\n\n\tblobsize = git_blob_rawsize(blob);\n\n\t/* file too big for rename processing */\n\tif (!git__is_sizet(blobsize))\n\t\treturn 0;\n\n\terror = opts->metric->buffer_signature(out, &diff_file,\n\t\tgit_blob_rawcontent(blob), (size_t)blobsize,\n\t\topts->metric->payload);\n\n\tgit_blob_free(blob);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_blob_free",
          "args": [
            "blob"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "116-119",
          "snippet": "void git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opts->metric->buffer_signature",
          "args": [
            "out",
            "&diff_file",
            "git_blob_rawcontent(blob)",
            "(size_t)blobsize",
            "opts->metric->payload"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_blob_rawcontent",
          "args": [
            "blob"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawcontent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "19-23",
          "snippet": "const void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__is_sizet",
          "args": [
            "blobsize"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_sizet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "11-15",
          "snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawsize",
          "args": [
            "blob"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "25-29",
          "snippet": "git_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\ngit_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&diff_file.id",
            "&entry->id"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_lookup",
          "args": [
            "&blob",
            "repo",
            "&entry->id"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "106-109",
          "snippet": "int git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int index_entry_similarity_calc(\n\tvoid **out,\n\tgit_repository *repo,\n\tgit_index_entry *entry,\n\tconst git_merge_options *opts)\n{\n\tgit_blob *blob;\n\tgit_diff_file diff_file = {{{0}}};\n\tgit_off_t blobsize;\n\tint error;\n\n\t*out = NULL;\n\n\tif ((error = git_blob_lookup(&blob, repo, &entry->id)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&diff_file.id, &entry->id);\n\tdiff_file.path = entry->path;\n\tdiff_file.size = entry->file_size;\n\tdiff_file.mode = entry->mode;\n\tdiff_file.flags = 0;\n\n\tblobsize = git_blob_rawsize(blob);\n\n\t/* file too big for rename processing */\n\tif (!git__is_sizet(blobsize))\n\t\treturn 0;\n\n\terror = opts->metric->buffer_signature(out, &diff_file,\n\t\tgit_blob_rawcontent(blob), (size_t)blobsize,\n\t\topts->metric->payload);\n\n\tgit_blob_free(blob);\n\n\treturn error;\n}"
  },
  {
    "function_name": "index_entry_similarity_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "930-949",
    "snippet": "static int index_entry_similarity_exact(\n\tgit_repository *repo,\n\tgit_index_entry *a,\n\tsize_t a_idx,\n\tgit_index_entry *b,\n\tsize_t b_idx,\n\tvoid **cache,\n\tconst git_merge_options *opts)\n{\n\tGIT_UNUSED(repo);\n\tGIT_UNUSED(a_idx);\n\tGIT_UNUSED(b_idx);\n\tGIT_UNUSED(cache);\n\tGIT_UNUSED(opts);\n\n\tif (git_oid__cmp(&a->id, &b->id) == 0)\n\t\treturn 100;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&a->id",
            "&b->id"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "opts"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "cache"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "b_idx"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "a_idx"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "repo"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nstatic int index_entry_similarity_exact(\n\tgit_repository *repo,\n\tgit_index_entry *a,\n\tsize_t a_idx,\n\tgit_index_entry *b,\n\tsize_t b_idx,\n\tvoid **cache,\n\tconst git_merge_options *opts)\n{\n\tGIT_UNUSED(repo);\n\tGIT_UNUSED(a_idx);\n\tGIT_UNUSED(b_idx);\n\tGIT_UNUSED(cache);\n\tGIT_UNUSED(opts);\n\n\tif (git_oid__cmp(&a->id, &b->id) == 0)\n\t\treturn 100;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "merge_conflict_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "894-921",
    "snippet": "static int merge_conflict_resolve(\n\tint *out,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict,\n\tconst git_merge_file_options *file_opts)\n{\n\tint resolved = 0;\n\tint error = 0;\n\n\t*out = 0;\n\n\tif ((error = merge_conflict_resolve_trivial(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_one_removed(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_one_renamed(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_automerge(&resolved, diff_list, conflict, file_opts)) < 0)\n\t\tgoto done;\n\n\t*out = resolved;\n\ndone:\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_conflict_resolve_automerge",
          "args": [
            "&resolved",
            "diff_list",
            "conflict",
            "file_opts"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "merge_conflict_resolve_automerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "813-892",
          "snippet": "static int merge_conflict_resolve_automerge(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict,\n\tconst git_merge_file_options *file_opts)\n{\n\tconst git_index_entry *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_merge_file_result result = {0};\n\tgit_index_entry *index_entry;\n\tgit_odb *odb = NULL;\n\tgit_oid automerge_oid;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ||\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn 0;\n\n\t/* Reject D/F conflicts */\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE)\n\t\treturn 0;\n\n\t/* Reject submodules. */\n\tif (S_ISGITLINK(conflict->ancestor_entry.mode) ||\n\t\tS_ISGITLINK(conflict->our_entry.mode) ||\n\t\tS_ISGITLINK(conflict->their_entry.mode))\n\t\treturn 0;\n\n\t/* Reject link/file conflicts. */\n\tif ((S_ISLNK(conflict->ancestor_entry.mode) ^ S_ISLNK(conflict->our_entry.mode)) ||\n\t\t(S_ISLNK(conflict->ancestor_entry.mode) ^ S_ISLNK(conflict->their_entry.mode)))\n\t\treturn 0;\n\n\t/* Reject name conflicts */\n\tif (conflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1 ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tif ((conflict->our_status & GIT_DELTA_RENAMED) == GIT_DELTA_RENAMED &&\n\t\t(conflict->their_status & GIT_DELTA_RENAMED) == GIT_DELTA_RENAMED &&\n\t\tstrcmp(conflict->ancestor_entry.path, conflict->their_entry.path) != 0)\n\t\treturn 0;\n\n\tancestor = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t&conflict->ancestor_entry : NULL;\n\tours = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t&conflict->our_entry : NULL;\n\ttheirs = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t&conflict->their_entry : NULL;\n\n\tif ((error = git_repository_odb(&odb, diff_list->repo)) < 0 ||\n\t\t(error = git_merge_file_from_index(&result, diff_list->repo, ancestor, ours, theirs, file_opts)) < 0 ||\n\t\t(!result.automergeable && !(file_opts->flags & GIT_MERGE_FILE_FAVOR__CONFLICTED)) ||\n\t\t(error = git_odb_write(&automerge_oid, odb, result.ptr, result.len, GIT_OBJ_BLOB)) < 0)\n\t\tgoto done;\n\n\tif ((index_entry = git_pool_mallocz(&diff_list->pool, sizeof(git_index_entry))) == NULL)\n\tGITERR_CHECK_ALLOC(index_entry);\n\n\tindex_entry->path = git_pool_strdup(&diff_list->pool, result.path);\n\tGITERR_CHECK_ALLOC(index_entry->path);\n\n\tindex_entry->file_size = result.len;\n\tindex_entry->mode = result.mode;\n\tgit_oid_cpy(&index_entry->id, &automerge_oid);\n\n\tgit_vector_insert(&diff_list->staged, index_entry);\n\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\t*resolved = 1;\n\ndone:\n\tgit_merge_file_result_free(&result);\n\tgit_odb_free(odb);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve_automerge(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict,\n\tconst git_merge_file_options *file_opts)\n{\n\tconst git_index_entry *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_merge_file_result result = {0};\n\tgit_index_entry *index_entry;\n\tgit_odb *odb = NULL;\n\tgit_oid automerge_oid;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ||\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn 0;\n\n\t/* Reject D/F conflicts */\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE)\n\t\treturn 0;\n\n\t/* Reject submodules. */\n\tif (S_ISGITLINK(conflict->ancestor_entry.mode) ||\n\t\tS_ISGITLINK(conflict->our_entry.mode) ||\n\t\tS_ISGITLINK(conflict->their_entry.mode))\n\t\treturn 0;\n\n\t/* Reject link/file conflicts. */\n\tif ((S_ISLNK(conflict->ancestor_entry.mode) ^ S_ISLNK(conflict->our_entry.mode)) ||\n\t\t(S_ISLNK(conflict->ancestor_entry.mode) ^ S_ISLNK(conflict->their_entry.mode)))\n\t\treturn 0;\n\n\t/* Reject name conflicts */\n\tif (conflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1 ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tif ((conflict->our_status & GIT_DELTA_RENAMED) == GIT_DELTA_RENAMED &&\n\t\t(conflict->their_status & GIT_DELTA_RENAMED) == GIT_DELTA_RENAMED &&\n\t\tstrcmp(conflict->ancestor_entry.path, conflict->their_entry.path) != 0)\n\t\treturn 0;\n\n\tancestor = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t&conflict->ancestor_entry : NULL;\n\tours = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t&conflict->our_entry : NULL;\n\ttheirs = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t&conflict->their_entry : NULL;\n\n\tif ((error = git_repository_odb(&odb, diff_list->repo)) < 0 ||\n\t\t(error = git_merge_file_from_index(&result, diff_list->repo, ancestor, ours, theirs, file_opts)) < 0 ||\n\t\t(!result.automergeable && !(file_opts->flags & GIT_MERGE_FILE_FAVOR__CONFLICTED)) ||\n\t\t(error = git_odb_write(&automerge_oid, odb, result.ptr, result.len, GIT_OBJ_BLOB)) < 0)\n\t\tgoto done;\n\n\tif ((index_entry = git_pool_mallocz(&diff_list->pool, sizeof(git_index_entry))) == NULL)\n\tGITERR_CHECK_ALLOC(index_entry);\n\n\tindex_entry->path = git_pool_strdup(&diff_list->pool, result.path);\n\tGITERR_CHECK_ALLOC(index_entry->path);\n\n\tindex_entry->file_size = result.len;\n\tindex_entry->mode = result.mode;\n\tgit_oid_cpy(&index_entry->id, &automerge_oid);\n\n\tgit_vector_insert(&diff_list->staged, index_entry);\n\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\t*resolved = 1;\n\ndone:\n\tgit_merge_file_result_free(&result);\n\tgit_odb_free(odb);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_conflict_resolve_one_renamed",
          "args": [
            "&resolved",
            "diff_list",
            "conflict"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "merge_conflict_resolve_one_renamed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "754-811",
          "snippet": "static int merge_conflict_resolve_one_renamed(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_renamed, theirs_renamed;\n\tint ours_changed, theirs_changed;\n\tgit_index_entry *merged;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ||\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn 0;\n\n\tours_renamed = (conflict->our_status == GIT_DELTA_RENAMED);\n\ttheirs_renamed = (conflict->their_status == GIT_DELTA_RENAMED);\n\n\tif (!ours_renamed && !theirs_renamed)\n\t\treturn 0;\n\n\t/* Reject one file in a 2->1 conflict */\n\tif (conflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1 ||\n\t\tconflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2 ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tours_changed = (git_oid__cmp(&conflict->ancestor_entry.id, &conflict->our_entry.id) != 0);\n\ttheirs_changed = (git_oid__cmp(&conflict->ancestor_entry.id, &conflict->their_entry.id) != 0);\n\n\t/* if both are modified (and not to a common target) require a merge */\n\tif (ours_changed && theirs_changed &&\n\t\tgit_oid__cmp(&conflict->our_entry.id, &conflict->their_entry.id) != 0)\n\t\treturn 0;\n\n\tif ((merged = git_pool_malloc(&diff_list->pool, sizeof(git_index_entry))) == NULL)\n\t\treturn -1;\n\n\tif (ours_changed)\n\t\tmemcpy(merged, &conflict->our_entry, sizeof(git_index_entry));\n\telse\n\t\tmemcpy(merged, &conflict->their_entry, sizeof(git_index_entry));\n\n\tif (ours_renamed)\n\t\tmerged->path = conflict->our_entry.path;\n\telse\n\t\tmerged->path = conflict->their_entry.path;\n\n\t*resolved = 1;\n\n\tgit_vector_insert(&diff_list->staged, merged);\n\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve_one_renamed(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_renamed, theirs_renamed;\n\tint ours_changed, theirs_changed;\n\tgit_index_entry *merged;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ||\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn 0;\n\n\tours_renamed = (conflict->our_status == GIT_DELTA_RENAMED);\n\ttheirs_renamed = (conflict->their_status == GIT_DELTA_RENAMED);\n\n\tif (!ours_renamed && !theirs_renamed)\n\t\treturn 0;\n\n\t/* Reject one file in a 2->1 conflict */\n\tif (conflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1 ||\n\t\tconflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2 ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tours_changed = (git_oid__cmp(&conflict->ancestor_entry.id, &conflict->our_entry.id) != 0);\n\ttheirs_changed = (git_oid__cmp(&conflict->ancestor_entry.id, &conflict->their_entry.id) != 0);\n\n\t/* if both are modified (and not to a common target) require a merge */\n\tif (ours_changed && theirs_changed &&\n\t\tgit_oid__cmp(&conflict->our_entry.id, &conflict->their_entry.id) != 0)\n\t\treturn 0;\n\n\tif ((merged = git_pool_malloc(&diff_list->pool, sizeof(git_index_entry))) == NULL)\n\t\treturn -1;\n\n\tif (ours_changed)\n\t\tmemcpy(merged, &conflict->our_entry, sizeof(git_index_entry));\n\telse\n\t\tmemcpy(merged, &conflict->their_entry, sizeof(git_index_entry));\n\n\tif (ours_renamed)\n\t\tmerged->path = conflict->our_entry.path;\n\telse\n\t\tmerged->path = conflict->their_entry.path;\n\n\t*resolved = 1;\n\n\tgit_vector_insert(&diff_list->staged, merged);\n\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_conflict_resolve_one_removed",
          "args": [
            "&resolved",
            "diff_list",
            "conflict"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "merge_conflict_resolve_one_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "715-752",
          "snippet": "static int merge_conflict_resolve_one_removed(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_empty, theirs_empty;\n\tint ours_changed, theirs_changed;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tours_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry);\n\ttheirs_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry);\n\n\tours_changed = (conflict->our_status != GIT_DELTA_UNMODIFIED);\n\ttheirs_changed = (conflict->their_status != GIT_DELTA_UNMODIFIED);\n\n\t/* Removed in both */\n\tif (ours_changed && ours_empty && theirs_empty)\n\t\t*resolved = 1;\n\t/* Removed in ours */\n\telse if (ours_empty && !theirs_changed)\n\t\t*resolved = 1;\n\t/* Removed in theirs */\n\telse if (!ours_changed && theirs_empty)\n\t\t*resolved = 1;\n\n\tif (*resolved)\n\t\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve_one_removed(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_empty, theirs_empty;\n\tint ours_changed, theirs_changed;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tours_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry);\n\ttheirs_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry);\n\n\tours_changed = (conflict->our_status != GIT_DELTA_UNMODIFIED);\n\ttheirs_changed = (conflict->their_status != GIT_DELTA_UNMODIFIED);\n\n\t/* Removed in both */\n\tif (ours_changed && ours_empty && theirs_empty)\n\t\t*resolved = 1;\n\t/* Removed in ours */\n\telse if (ours_empty && !theirs_changed)\n\t\t*resolved = 1;\n\t/* Removed in theirs */\n\telse if (!ours_changed && theirs_empty)\n\t\t*resolved = 1;\n\n\tif (*resolved)\n\t\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_conflict_resolve_trivial",
          "args": [
            "&resolved",
            "diff_list",
            "conflict"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "merge_conflict_resolve_trivial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "631-713",
          "snippet": "static int merge_conflict_resolve_trivial(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_empty, theirs_empty;\n\tint ours_changed, theirs_changed, ours_theirs_differ;\n\tgit_index_entry const *result = NULL;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tif (conflict->our_status == GIT_DELTA_RENAMED ||\n\t\tconflict->their_status == GIT_DELTA_RENAMED)\n\t\treturn 0;\n\n\tours_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry);\n\ttheirs_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry);\n\n\tours_changed = (conflict->our_status != GIT_DELTA_UNMODIFIED);\n\ttheirs_changed = (conflict->their_status != GIT_DELTA_UNMODIFIED);\n\tours_theirs_differ = ours_changed && theirs_changed &&\n\t\tindex_entry_cmp(&conflict->our_entry, &conflict->their_entry);\n\n\t/*\n\t * Note: with only one ancestor, some cases are not distinct:\n\t *\n\t * 16: ancest:anc1/anc2, head:anc1, remote:anc2 = result:no merge\n\t * 3: ancest:(empty)^, head:head, remote:(empty) = result:no merge\n\t * 2: ancest:(empty)^, head:(empty), remote:remote = result:no merge\n\t *\n\t * Note that the two cases that take D/F conflicts into account\n\t * specifically do not need to be explicitly tested, as D/F conflicts\n\t * would fail the *empty* test:\n\t *\n\t * 3ALT: ancest:(empty)+, head:head, remote:*empty* = result:head\n\t * 2ALT: ancest:(empty)+, head:*empty*, remote:remote = result:remote\n\t *\n\t * Note that many of these cases need not be explicitly tested, as\n\t * they simply degrade to \"all different\" cases (eg, 11):\n\t *\n\t * 4: ancest:(empty)^, head:head, remote:remote = result:no merge\n\t * 7: ancest:ancest+, head:(empty), remote:remote = result:no merge\n\t * 9: ancest:ancest+, head:head, remote:(empty) = result:no merge\n\t * 11: ancest:ancest+, head:head, remote:remote = result:no merge\n\t */\n\n\t/* 5ALT: ancest:*, head:head, remote:head = result:head */\n\tif (ours_changed && !ours_empty && !ours_theirs_differ)\n\t\tresult = &conflict->our_entry;\n\t/* 6: ancest:ancest+, head:(empty), remote:(empty) = result:no merge */\n\telse if (ours_changed && ours_empty && theirs_empty)\n\t\t*resolved = 0;\n\t/* 8: ancest:ancest^, head:(empty), remote:ancest = result:no merge */\n\telse if (ours_empty && !theirs_changed)\n\t\t*resolved = 0;\n\t/* 10: ancest:ancest^, head:ancest, remote:(empty) = result:no merge */\n\telse if (!ours_changed && theirs_empty)\n\t\t*resolved = 0;\n\t/* 13: ancest:ancest+, head:head, remote:ancest = result:head */\n\telse if (ours_changed && !theirs_changed)\n\t\tresult = &conflict->our_entry;\n\t/* 14: ancest:ancest+, head:ancest, remote:remote = result:remote */\n\telse if (!ours_changed && theirs_changed)\n\t\tresult = &conflict->their_entry;\n\telse\n\t\t*resolved = 0;\n\n\tif (result != NULL &&\n\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(*result) &&\n\t\t(error = git_vector_insert(&diff_list->staged, (void *)result)) >= 0)\n\t\t*resolved = 1;\n\n\t/* Note: trivial resolution does not update the REUC. */\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve_trivial(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_empty, theirs_empty;\n\tint ours_changed, theirs_changed, ours_theirs_differ;\n\tgit_index_entry const *result = NULL;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tif (conflict->our_status == GIT_DELTA_RENAMED ||\n\t\tconflict->their_status == GIT_DELTA_RENAMED)\n\t\treturn 0;\n\n\tours_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry);\n\ttheirs_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry);\n\n\tours_changed = (conflict->our_status != GIT_DELTA_UNMODIFIED);\n\ttheirs_changed = (conflict->their_status != GIT_DELTA_UNMODIFIED);\n\tours_theirs_differ = ours_changed && theirs_changed &&\n\t\tindex_entry_cmp(&conflict->our_entry, &conflict->their_entry);\n\n\t/*\n\t * Note: with only one ancestor, some cases are not distinct:\n\t *\n\t * 16: ancest:anc1/anc2, head:anc1, remote:anc2 = result:no merge\n\t * 3: ancest:(empty)^, head:head, remote:(empty) = result:no merge\n\t * 2: ancest:(empty)^, head:(empty), remote:remote = result:no merge\n\t *\n\t * Note that the two cases that take D/F conflicts into account\n\t * specifically do not need to be explicitly tested, as D/F conflicts\n\t * would fail the *empty* test:\n\t *\n\t * 3ALT: ancest:(empty)+, head:head, remote:*empty* = result:head\n\t * 2ALT: ancest:(empty)+, head:*empty*, remote:remote = result:remote\n\t *\n\t * Note that many of these cases need not be explicitly tested, as\n\t * they simply degrade to \"all different\" cases (eg, 11):\n\t *\n\t * 4: ancest:(empty)^, head:head, remote:remote = result:no merge\n\t * 7: ancest:ancest+, head:(empty), remote:remote = result:no merge\n\t * 9: ancest:ancest+, head:head, remote:(empty) = result:no merge\n\t * 11: ancest:ancest+, head:head, remote:remote = result:no merge\n\t */\n\n\t/* 5ALT: ancest:*, head:head, remote:head = result:head */\n\tif (ours_changed && !ours_empty && !ours_theirs_differ)\n\t\tresult = &conflict->our_entry;\n\t/* 6: ancest:ancest+, head:(empty), remote:(empty) = result:no merge */\n\telse if (ours_changed && ours_empty && theirs_empty)\n\t\t*resolved = 0;\n\t/* 8: ancest:ancest^, head:(empty), remote:ancest = result:no merge */\n\telse if (ours_empty && !theirs_changed)\n\t\t*resolved = 0;\n\t/* 10: ancest:ancest^, head:ancest, remote:(empty) = result:no merge */\n\telse if (!ours_changed && theirs_empty)\n\t\t*resolved = 0;\n\t/* 13: ancest:ancest+, head:head, remote:ancest = result:head */\n\telse if (ours_changed && !theirs_changed)\n\t\tresult = &conflict->our_entry;\n\t/* 14: ancest:ancest+, head:ancest, remote:remote = result:remote */\n\telse if (!ours_changed && theirs_changed)\n\t\tresult = &conflict->their_entry;\n\telse\n\t\t*resolved = 0;\n\n\tif (result != NULL &&\n\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(*result) &&\n\t\t(error = git_vector_insert(&diff_list->staged, (void *)result)) >= 0)\n\t\t*resolved = 1;\n\n\t/* Note: trivial resolution does not update the REUC. */\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve(\n\tint *out,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict,\n\tconst git_merge_file_options *file_opts)\n{\n\tint resolved = 0;\n\tint error = 0;\n\n\t*out = 0;\n\n\tif ((error = merge_conflict_resolve_trivial(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_one_removed(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_one_renamed(&resolved, diff_list, conflict)) < 0)\n\t\tgoto done;\n\n\tif (!resolved && (error = merge_conflict_resolve_automerge(&resolved, diff_list, conflict, file_opts)) < 0)\n\t\tgoto done;\n\n\t*out = resolved;\n\ndone:\n\treturn error;\n}"
  },
  {
    "function_name": "merge_conflict_resolve_automerge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "813-892",
    "snippet": "static int merge_conflict_resolve_automerge(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict,\n\tconst git_merge_file_options *file_opts)\n{\n\tconst git_index_entry *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_merge_file_result result = {0};\n\tgit_index_entry *index_entry;\n\tgit_odb *odb = NULL;\n\tgit_oid automerge_oid;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ||\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn 0;\n\n\t/* Reject D/F conflicts */\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE)\n\t\treturn 0;\n\n\t/* Reject submodules. */\n\tif (S_ISGITLINK(conflict->ancestor_entry.mode) ||\n\t\tS_ISGITLINK(conflict->our_entry.mode) ||\n\t\tS_ISGITLINK(conflict->their_entry.mode))\n\t\treturn 0;\n\n\t/* Reject link/file conflicts. */\n\tif ((S_ISLNK(conflict->ancestor_entry.mode) ^ S_ISLNK(conflict->our_entry.mode)) ||\n\t\t(S_ISLNK(conflict->ancestor_entry.mode) ^ S_ISLNK(conflict->their_entry.mode)))\n\t\treturn 0;\n\n\t/* Reject name conflicts */\n\tif (conflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1 ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tif ((conflict->our_status & GIT_DELTA_RENAMED) == GIT_DELTA_RENAMED &&\n\t\t(conflict->their_status & GIT_DELTA_RENAMED) == GIT_DELTA_RENAMED &&\n\t\tstrcmp(conflict->ancestor_entry.path, conflict->their_entry.path) != 0)\n\t\treturn 0;\n\n\tancestor = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t&conflict->ancestor_entry : NULL;\n\tours = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t&conflict->our_entry : NULL;\n\ttheirs = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t&conflict->their_entry : NULL;\n\n\tif ((error = git_repository_odb(&odb, diff_list->repo)) < 0 ||\n\t\t(error = git_merge_file_from_index(&result, diff_list->repo, ancestor, ours, theirs, file_opts)) < 0 ||\n\t\t(!result.automergeable && !(file_opts->flags & GIT_MERGE_FILE_FAVOR__CONFLICTED)) ||\n\t\t(error = git_odb_write(&automerge_oid, odb, result.ptr, result.len, GIT_OBJ_BLOB)) < 0)\n\t\tgoto done;\n\n\tif ((index_entry = git_pool_mallocz(&diff_list->pool, sizeof(git_index_entry))) == NULL)\n\tGITERR_CHECK_ALLOC(index_entry);\n\n\tindex_entry->path = git_pool_strdup(&diff_list->pool, result.path);\n\tGITERR_CHECK_ALLOC(index_entry->path);\n\n\tindex_entry->file_size = result.len;\n\tindex_entry->mode = result.mode;\n\tgit_oid_cpy(&index_entry->id, &automerge_oid);\n\n\tgit_vector_insert(&diff_list->staged, index_entry);\n\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\t*resolved = 1;\n\ndone:\n\tgit_merge_file_result_free(&result);\n\tgit_odb_free(odb);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb_free",
          "args": [
            "odb"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "619-625",
          "snippet": "void git_odb_free(git_odb *db)\n{\n\tif (db == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(db, odb_free);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_free(git_odb *db)\n{\n\tif (db == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(db, odb_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge_file_result_free",
          "args": [
            "&result"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_file_result_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge_file.c",
          "lines": "339-346",
          "snippet": "void git_merge_file_result_free(git_merge_file_result *result)\n{\n\tif (result == NULL)\n\t\treturn;\n\n\tgit__free((char *)result->path);\n\tgit__free((char *)result->ptr);\n}",
          "includes": [
            "#include \"xdiff/xdiff.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"diff_xdiff.h\"",
            "#include \"index.h\"",
            "#include \"fileops.h\"",
            "#include \"posix.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff/xdiff.h\"\n#include \"git2/merge.h\"\n#include \"git2/index.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"diff_xdiff.h\"\n#include \"index.h\"\n#include \"fileops.h\"\n#include \"posix.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_merge_file_result_free(git_merge_file_result *result)\n{\n\tif (result == NULL)\n\t\treturn;\n\n\tgit__free((char *)result->path);\n\tgit__free((char *)result->ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&diff_list->resolved",
            "(git_merge_diff *)conflict"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&index_entry->id",
            "&automerge_oid"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "index_entry->path"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "&diff_list->pool",
            "result.path"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "index_entry"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_mallocz",
          "args": [
            "&diff_list->pool",
            "sizeof(git_index_entry)"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_write",
          "args": [
            "&automerge_oid",
            "odb",
            "result.ptr",
            "result.len",
            "GIT_OBJ_BLOB"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "984-1024",
          "snippet": "int git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge_file_from_index",
          "args": [
            "&result",
            "diff_list->repo",
            "ancestor",
            "ours",
            "theirs",
            "file_opts"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_file_from_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge_file.c",
          "lines": "292-337",
          "snippet": "int git_merge_file_from_index(\n\tgit_merge_file_result *out,\n\tgit_repository *repo,\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *ours,\n\tconst git_index_entry *theirs,\n\tconst git_merge_file_options *options)\n{\n\tgit_merge_file_input *ancestor_ptr = NULL,\n\t\tancestor_input = {0}, our_input = {0}, their_input = {0};\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_object[3] = { 0 };\n\tint error = 0;\n\n\tassert(out && repo && ours && theirs);\n\n\tmemset(out, 0x0, sizeof(git_merge_file_result));\n\n\tif ((error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (ancestor) {\n\t\tif ((error = git_merge_file__input_from_index(\n\t\t\t&ancestor_input, &odb_object[0], odb, ancestor)) < 0)\n\t\t\tgoto done;\n\n\t\tancestor_ptr = &ancestor_input;\n\t}\n\n\tif ((error = git_merge_file__input_from_index(\n\t\t\t&our_input, &odb_object[1], odb, ours)) < 0 ||\n\t\t(error = git_merge_file__input_from_index(\n\t\t\t&their_input, &odb_object[2], odb, theirs)) < 0)\n\t\tgoto done;\n\n\terror = merge_file__from_inputs(out,\n\t\tancestor_ptr, &our_input, &their_input, options);\n\ndone:\n\tgit_odb_object_free(odb_object[0]);\n\tgit_odb_object_free(odb_object[1]);\n\tgit_odb_object_free(odb_object[2]);\n\tgit_odb_free(odb);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xdiff/xdiff.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"diff_xdiff.h\"",
            "#include \"index.h\"",
            "#include \"fileops.h\"",
            "#include \"posix.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdiff/xdiff.h\"\n#include \"git2/merge.h\"\n#include \"git2/index.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"diff_xdiff.h\"\n#include \"index.h\"\n#include \"fileops.h\"\n#include \"posix.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_merge_file_from_index(\n\tgit_merge_file_result *out,\n\tgit_repository *repo,\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *ours,\n\tconst git_index_entry *theirs,\n\tconst git_merge_file_options *options)\n{\n\tgit_merge_file_input *ancestor_ptr = NULL,\n\t\tancestor_input = {0}, our_input = {0}, their_input = {0};\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_object[3] = { 0 };\n\tint error = 0;\n\n\tassert(out && repo && ours && theirs);\n\n\tmemset(out, 0x0, sizeof(git_merge_file_result));\n\n\tif ((error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (ancestor) {\n\t\tif ((error = git_merge_file__input_from_index(\n\t\t\t&ancestor_input, &odb_object[0], odb, ancestor)) < 0)\n\t\t\tgoto done;\n\n\t\tancestor_ptr = &ancestor_input;\n\t}\n\n\tif ((error = git_merge_file__input_from_index(\n\t\t\t&our_input, &odb_object[1], odb, ours)) < 0 ||\n\t\t(error = git_merge_file__input_from_index(\n\t\t\t&their_input, &odb_object[2], odb, theirs)) < 0)\n\t\tgoto done;\n\n\terror = merge_file__from_inputs(out,\n\t\tancestor_ptr, &our_input, &their_input, options);\n\ndone:\n\tgit_odb_object_free(odb_object[0]);\n\tgit_odb_object_free(odb_object[1]);\n\tgit_odb_object_free(odb_object[2]);\n\tgit_odb_free(odb);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb",
          "args": [
            "&odb",
            "diff_list->repo"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "764-771",
          "snippet": "int git_repository_odb(git_odb **out, git_repository *repo)\n{\n\tif (git_repository_odb__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb(git_odb **out, git_repository *repo)\n{\n\tif (git_repository_odb__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->ancestor_entry"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "conflict->ancestor_entry.path",
            "conflict->their_entry.path"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "conflict->their_entry.mode"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "conflict->ancestor_entry.mode"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "conflict->our_entry.mode"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "conflict->ancestor_entry.mode"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "conflict->their_entry.mode"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "conflict->our_entry.mode"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "conflict->ancestor_entry.mode"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "resolved && diff_list && conflict"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve_automerge(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict,\n\tconst git_merge_file_options *file_opts)\n{\n\tconst git_index_entry *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_merge_file_result result = {0};\n\tgit_index_entry *index_entry;\n\tgit_odb *odb = NULL;\n\tgit_oid automerge_oid;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ||\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn 0;\n\n\t/* Reject D/F conflicts */\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE)\n\t\treturn 0;\n\n\t/* Reject submodules. */\n\tif (S_ISGITLINK(conflict->ancestor_entry.mode) ||\n\t\tS_ISGITLINK(conflict->our_entry.mode) ||\n\t\tS_ISGITLINK(conflict->their_entry.mode))\n\t\treturn 0;\n\n\t/* Reject link/file conflicts. */\n\tif ((S_ISLNK(conflict->ancestor_entry.mode) ^ S_ISLNK(conflict->our_entry.mode)) ||\n\t\t(S_ISLNK(conflict->ancestor_entry.mode) ^ S_ISLNK(conflict->their_entry.mode)))\n\t\treturn 0;\n\n\t/* Reject name conflicts */\n\tif (conflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1 ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tif ((conflict->our_status & GIT_DELTA_RENAMED) == GIT_DELTA_RENAMED &&\n\t\t(conflict->their_status & GIT_DELTA_RENAMED) == GIT_DELTA_RENAMED &&\n\t\tstrcmp(conflict->ancestor_entry.path, conflict->their_entry.path) != 0)\n\t\treturn 0;\n\n\tancestor = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->ancestor_entry) ?\n\t\t&conflict->ancestor_entry : NULL;\n\tours = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ?\n\t\t&conflict->our_entry : NULL;\n\ttheirs = GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry) ?\n\t\t&conflict->their_entry : NULL;\n\n\tif ((error = git_repository_odb(&odb, diff_list->repo)) < 0 ||\n\t\t(error = git_merge_file_from_index(&result, diff_list->repo, ancestor, ours, theirs, file_opts)) < 0 ||\n\t\t(!result.automergeable && !(file_opts->flags & GIT_MERGE_FILE_FAVOR__CONFLICTED)) ||\n\t\t(error = git_odb_write(&automerge_oid, odb, result.ptr, result.len, GIT_OBJ_BLOB)) < 0)\n\t\tgoto done;\n\n\tif ((index_entry = git_pool_mallocz(&diff_list->pool, sizeof(git_index_entry))) == NULL)\n\tGITERR_CHECK_ALLOC(index_entry);\n\n\tindex_entry->path = git_pool_strdup(&diff_list->pool, result.path);\n\tGITERR_CHECK_ALLOC(index_entry->path);\n\n\tindex_entry->file_size = result.len;\n\tindex_entry->mode = result.mode;\n\tgit_oid_cpy(&index_entry->id, &automerge_oid);\n\n\tgit_vector_insert(&diff_list->staged, index_entry);\n\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\t*resolved = 1;\n\ndone:\n\tgit_merge_file_result_free(&result);\n\tgit_odb_free(odb);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_conflict_resolve_one_renamed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "754-811",
    "snippet": "static int merge_conflict_resolve_one_renamed(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_renamed, theirs_renamed;\n\tint ours_changed, theirs_changed;\n\tgit_index_entry *merged;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ||\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn 0;\n\n\tours_renamed = (conflict->our_status == GIT_DELTA_RENAMED);\n\ttheirs_renamed = (conflict->their_status == GIT_DELTA_RENAMED);\n\n\tif (!ours_renamed && !theirs_renamed)\n\t\treturn 0;\n\n\t/* Reject one file in a 2->1 conflict */\n\tif (conflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1 ||\n\t\tconflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2 ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tours_changed = (git_oid__cmp(&conflict->ancestor_entry.id, &conflict->our_entry.id) != 0);\n\ttheirs_changed = (git_oid__cmp(&conflict->ancestor_entry.id, &conflict->their_entry.id) != 0);\n\n\t/* if both are modified (and not to a common target) require a merge */\n\tif (ours_changed && theirs_changed &&\n\t\tgit_oid__cmp(&conflict->our_entry.id, &conflict->their_entry.id) != 0)\n\t\treturn 0;\n\n\tif ((merged = git_pool_malloc(&diff_list->pool, sizeof(git_index_entry))) == NULL)\n\t\treturn -1;\n\n\tif (ours_changed)\n\t\tmemcpy(merged, &conflict->our_entry, sizeof(git_index_entry));\n\telse\n\t\tmemcpy(merged, &conflict->their_entry, sizeof(git_index_entry));\n\n\tif (ours_renamed)\n\t\tmerged->path = conflict->our_entry.path;\n\telse\n\t\tmerged->path = conflict->their_entry.path;\n\n\t*resolved = 1;\n\n\tgit_vector_insert(&diff_list->staged, merged);\n\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&diff_list->resolved",
            "(git_merge_diff *)conflict"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "merged",
            "&conflict->their_entry",
            "sizeof(git_index_entry)"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "merged",
            "&conflict->our_entry",
            "sizeof(git_index_entry)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_malloc",
          "args": [
            "&diff_list->pool",
            "sizeof(git_index_entry)"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&conflict->our_entry.id",
            "&conflict->their_entry.id"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "resolved && diff_list && conflict"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve_one_renamed(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_renamed, theirs_renamed;\n\tint ours_changed, theirs_changed;\n\tgit_index_entry *merged;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry) ||\n\t\t!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry))\n\t\treturn 0;\n\n\tours_renamed = (conflict->our_status == GIT_DELTA_RENAMED);\n\ttheirs_renamed = (conflict->their_status == GIT_DELTA_RENAMED);\n\n\tif (!ours_renamed && !theirs_renamed)\n\t\treturn 0;\n\n\t/* Reject one file in a 2->1 conflict */\n\tif (conflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_2_TO_1 ||\n\t\tconflict->type == GIT_MERGE_DIFF_BOTH_RENAMED_1_TO_2 ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tours_changed = (git_oid__cmp(&conflict->ancestor_entry.id, &conflict->our_entry.id) != 0);\n\ttheirs_changed = (git_oid__cmp(&conflict->ancestor_entry.id, &conflict->their_entry.id) != 0);\n\n\t/* if both are modified (and not to a common target) require a merge */\n\tif (ours_changed && theirs_changed &&\n\t\tgit_oid__cmp(&conflict->our_entry.id, &conflict->their_entry.id) != 0)\n\t\treturn 0;\n\n\tif ((merged = git_pool_malloc(&diff_list->pool, sizeof(git_index_entry))) == NULL)\n\t\treturn -1;\n\n\tif (ours_changed)\n\t\tmemcpy(merged, &conflict->our_entry, sizeof(git_index_entry));\n\telse\n\t\tmemcpy(merged, &conflict->their_entry, sizeof(git_index_entry));\n\n\tif (ours_renamed)\n\t\tmerged->path = conflict->our_entry.path;\n\telse\n\t\tmerged->path = conflict->their_entry.path;\n\n\t*resolved = 1;\n\n\tgit_vector_insert(&diff_list->staged, merged);\n\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_conflict_resolve_one_removed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "715-752",
    "snippet": "static int merge_conflict_resolve_one_removed(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_empty, theirs_empty;\n\tint ours_changed, theirs_changed;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tours_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry);\n\ttheirs_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry);\n\n\tours_changed = (conflict->our_status != GIT_DELTA_UNMODIFIED);\n\ttheirs_changed = (conflict->their_status != GIT_DELTA_UNMODIFIED);\n\n\t/* Removed in both */\n\tif (ours_changed && ours_empty && theirs_empty)\n\t\t*resolved = 1;\n\t/* Removed in ours */\n\telse if (ours_empty && !theirs_changed)\n\t\t*resolved = 1;\n\t/* Removed in theirs */\n\telse if (!ours_changed && theirs_empty)\n\t\t*resolved = 1;\n\n\tif (*resolved)\n\t\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&diff_list->resolved",
            "(git_merge_diff *)conflict"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "resolved && diff_list && conflict"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve_one_removed(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_empty, theirs_empty;\n\tint ours_changed, theirs_changed;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tours_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry);\n\ttheirs_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry);\n\n\tours_changed = (conflict->our_status != GIT_DELTA_UNMODIFIED);\n\ttheirs_changed = (conflict->their_status != GIT_DELTA_UNMODIFIED);\n\n\t/* Removed in both */\n\tif (ours_changed && ours_empty && theirs_empty)\n\t\t*resolved = 1;\n\t/* Removed in ours */\n\telse if (ours_empty && !theirs_changed)\n\t\t*resolved = 1;\n\t/* Removed in theirs */\n\telse if (!ours_changed && theirs_empty)\n\t\t*resolved = 1;\n\n\tif (*resolved)\n\t\tgit_vector_insert(&diff_list->resolved, (git_merge_diff *)conflict);\n\n\treturn error;\n}"
  },
  {
    "function_name": "merge_conflict_resolve_trivial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "631-713",
    "snippet": "static int merge_conflict_resolve_trivial(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_empty, theirs_empty;\n\tint ours_changed, theirs_changed, ours_theirs_differ;\n\tgit_index_entry const *result = NULL;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tif (conflict->our_status == GIT_DELTA_RENAMED ||\n\t\tconflict->their_status == GIT_DELTA_RENAMED)\n\t\treturn 0;\n\n\tours_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry);\n\ttheirs_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry);\n\n\tours_changed = (conflict->our_status != GIT_DELTA_UNMODIFIED);\n\ttheirs_changed = (conflict->their_status != GIT_DELTA_UNMODIFIED);\n\tours_theirs_differ = ours_changed && theirs_changed &&\n\t\tindex_entry_cmp(&conflict->our_entry, &conflict->their_entry);\n\n\t/*\n\t * Note: with only one ancestor, some cases are not distinct:\n\t *\n\t * 16: ancest:anc1/anc2, head:anc1, remote:anc2 = result:no merge\n\t * 3: ancest:(empty)^, head:head, remote:(empty) = result:no merge\n\t * 2: ancest:(empty)^, head:(empty), remote:remote = result:no merge\n\t *\n\t * Note that the two cases that take D/F conflicts into account\n\t * specifically do not need to be explicitly tested, as D/F conflicts\n\t * would fail the *empty* test:\n\t *\n\t * 3ALT: ancest:(empty)+, head:head, remote:*empty* = result:head\n\t * 2ALT: ancest:(empty)+, head:*empty*, remote:remote = result:remote\n\t *\n\t * Note that many of these cases need not be explicitly tested, as\n\t * they simply degrade to \"all different\" cases (eg, 11):\n\t *\n\t * 4: ancest:(empty)^, head:head, remote:remote = result:no merge\n\t * 7: ancest:ancest+, head:(empty), remote:remote = result:no merge\n\t * 9: ancest:ancest+, head:head, remote:(empty) = result:no merge\n\t * 11: ancest:ancest+, head:head, remote:remote = result:no merge\n\t */\n\n\t/* 5ALT: ancest:*, head:head, remote:head = result:head */\n\tif (ours_changed && !ours_empty && !ours_theirs_differ)\n\t\tresult = &conflict->our_entry;\n\t/* 6: ancest:ancest+, head:(empty), remote:(empty) = result:no merge */\n\telse if (ours_changed && ours_empty && theirs_empty)\n\t\t*resolved = 0;\n\t/* 8: ancest:ancest^, head:(empty), remote:ancest = result:no merge */\n\telse if (ours_empty && !theirs_changed)\n\t\t*resolved = 0;\n\t/* 10: ancest:ancest^, head:ancest, remote:(empty) = result:no merge */\n\telse if (!ours_changed && theirs_empty)\n\t\t*resolved = 0;\n\t/* 13: ancest:ancest+, head:head, remote:ancest = result:head */\n\telse if (ours_changed && !theirs_changed)\n\t\tresult = &conflict->our_entry;\n\t/* 14: ancest:ancest+, head:ancest, remote:remote = result:remote */\n\telse if (!ours_changed && theirs_changed)\n\t\tresult = &conflict->their_entry;\n\telse\n\t\t*resolved = 0;\n\n\tif (result != NULL &&\n\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(*result) &&\n\t\t(error = git_vector_insert(&diff_list->staged, (void *)result)) >= 0)\n\t\t*resolved = 1;\n\n\t/* Note: trivial resolution does not update the REUC. */\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&diff_list->staged",
            "(void *)result"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "*result"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_entry_cmp",
          "args": [
            "&conflict->our_entry",
            "&conflict->their_entry"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "615-627",
          "snippet": "GIT_INLINE(int) index_entry_cmp(const git_index_entry *a, const git_index_entry *b)\n{\n\tint value = 0;\n\n\tif (a->path == NULL)\n\t\treturn (b->path == NULL) ? 0 : 1;\n\n\tif ((value = a->mode - b->mode) == 0 &&\n\t\t(value = git_oid__cmp(&a->id, &b->id)) == 0)\n\t\tvalue = strcmp(a->path, b->path);\n\n\treturn value;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) index_entry_cmp(const git_index_entry *a, const git_index_entry *b)\n{\n\tint value = 0;\n\n\tif (a->path == NULL)\n\t\treturn (b->path == NULL) ? 0 : 1;\n\n\tif ((value = a->mode - b->mode) == 0 &&\n\t\t(value = git_oid__cmp(&a->id, &b->id)) == 0)\n\t\tvalue = strcmp(a->path, b->path);\n\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->their_entry"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MERGE_INDEX_ENTRY_EXISTS",
          "args": [
            "conflict->our_entry"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "resolved && diff_list && conflict"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_conflict_resolve_trivial(\n\tint *resolved,\n\tgit_merge_diff_list *diff_list,\n\tconst git_merge_diff *conflict)\n{\n\tint ours_empty, theirs_empty;\n\tint ours_changed, theirs_changed, ours_theirs_differ;\n\tgit_index_entry const *result = NULL;\n\tint error = 0;\n\n\tassert(resolved && diff_list && conflict);\n\n\t*resolved = 0;\n\n\tif (conflict->type == GIT_MERGE_DIFF_DIRECTORY_FILE ||\n\t\tconflict->type == GIT_MERGE_DIFF_RENAMED_ADDED)\n\t\treturn 0;\n\n\tif (conflict->our_status == GIT_DELTA_RENAMED ||\n\t\tconflict->their_status == GIT_DELTA_RENAMED)\n\t\treturn 0;\n\n\tours_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->our_entry);\n\ttheirs_empty = !GIT_MERGE_INDEX_ENTRY_EXISTS(conflict->their_entry);\n\n\tours_changed = (conflict->our_status != GIT_DELTA_UNMODIFIED);\n\ttheirs_changed = (conflict->their_status != GIT_DELTA_UNMODIFIED);\n\tours_theirs_differ = ours_changed && theirs_changed &&\n\t\tindex_entry_cmp(&conflict->our_entry, &conflict->their_entry);\n\n\t/*\n\t * Note: with only one ancestor, some cases are not distinct:\n\t *\n\t * 16: ancest:anc1/anc2, head:anc1, remote:anc2 = result:no merge\n\t * 3: ancest:(empty)^, head:head, remote:(empty) = result:no merge\n\t * 2: ancest:(empty)^, head:(empty), remote:remote = result:no merge\n\t *\n\t * Note that the two cases that take D/F conflicts into account\n\t * specifically do not need to be explicitly tested, as D/F conflicts\n\t * would fail the *empty* test:\n\t *\n\t * 3ALT: ancest:(empty)+, head:head, remote:*empty* = result:head\n\t * 2ALT: ancest:(empty)+, head:*empty*, remote:remote = result:remote\n\t *\n\t * Note that many of these cases need not be explicitly tested, as\n\t * they simply degrade to \"all different\" cases (eg, 11):\n\t *\n\t * 4: ancest:(empty)^, head:head, remote:remote = result:no merge\n\t * 7: ancest:ancest+, head:(empty), remote:remote = result:no merge\n\t * 9: ancest:ancest+, head:head, remote:(empty) = result:no merge\n\t * 11: ancest:ancest+, head:head, remote:remote = result:no merge\n\t */\n\n\t/* 5ALT: ancest:*, head:head, remote:head = result:head */\n\tif (ours_changed && !ours_empty && !ours_theirs_differ)\n\t\tresult = &conflict->our_entry;\n\t/* 6: ancest:ancest+, head:(empty), remote:(empty) = result:no merge */\n\telse if (ours_changed && ours_empty && theirs_empty)\n\t\t*resolved = 0;\n\t/* 8: ancest:ancest^, head:(empty), remote:ancest = result:no merge */\n\telse if (ours_empty && !theirs_changed)\n\t\t*resolved = 0;\n\t/* 10: ancest:ancest^, head:ancest, remote:(empty) = result:no merge */\n\telse if (!ours_changed && theirs_empty)\n\t\t*resolved = 0;\n\t/* 13: ancest:ancest+, head:head, remote:ancest = result:head */\n\telse if (ours_changed && !theirs_changed)\n\t\tresult = &conflict->our_entry;\n\t/* 14: ancest:ancest+, head:ancest, remote:remote = result:remote */\n\telse if (!ours_changed && theirs_changed)\n\t\tresult = &conflict->their_entry;\n\telse\n\t\t*resolved = 0;\n\n\tif (result != NULL &&\n\t\tGIT_MERGE_INDEX_ENTRY_EXISTS(*result) &&\n\t\t(error = git_vector_insert(&diff_list->staged, (void *)result)) >= 0)\n\t\t*resolved = 1;\n\n\t/* Note: trivial resolution does not update the REUC. */\n\n\treturn error;\n}"
  },
  {
    "function_name": "index_entry_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "615-627",
    "snippet": "GIT_INLINE(int) index_entry_cmp(const git_index_entry *a, const git_index_entry *b)\n{\n\tint value = 0;\n\n\tif (a->path == NULL)\n\t\treturn (b->path == NULL) ? 0 : 1;\n\n\tif ((value = a->mode - b->mode) == 0 &&\n\t\t(value = git_oid__cmp(&a->id, &b->id)) == 0)\n\t\tvalue = strcmp(a->path, b->path);\n\n\treturn value;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->path",
            "b->path"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&a->id",
            "&b->id"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) index_entry_cmp(const git_index_entry *a, const git_index_entry *b)\n{\n\tint value = 0;\n\n\tif (a->path == NULL)\n\t\treturn (b->path == NULL) ? 0 : 1;\n\n\tif ((value = a->mode - b->mode) == 0 &&\n\t\t(value = git_oid__cmp(&a->id, &b->id)) == 0)\n\t\tvalue = strcmp(a->path, b->path);\n\n\treturn value;\n}"
  },
  {
    "function_name": "git_repository_mergehead_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "561-613",
    "snippet": "int git_repository_mergehead_foreach(\n\tgit_repository *repo,\n\tgit_repository_mergehead_foreach_cb cb,\n\tvoid *payload)\n{\n\tgit_buf merge_head_path = GIT_BUF_INIT, merge_head_file = GIT_BUF_INIT;\n\tchar *buffer, *line;\n\tsize_t line_num = 1;\n\tgit_oid oid;\n\tint error = 0;\n\n\tassert(repo && cb);\n\n\tif ((error = git_buf_joinpath(&merge_head_path, repo->path_repository,\n\t\tGIT_MERGE_HEAD_FILE)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_readbuffer(&merge_head_file,\n\t\tgit_buf_cstr(&merge_head_path))) < 0)\n\t\tgoto cleanup;\n\n\tbuffer = merge_head_file.ptr;\n\n\twhile ((line = git__strsep(&buffer, \"\\n\")) != NULL) {\n\t\tif (strlen(line) != GIT_OID_HEXSZ) {\n\t\t\tgiterr_set(GITERR_INVALID, \"Unable to parse OID - invalid length\");\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ((error = git_oid_fromstr(&oid, line)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = cb(&oid, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t++line_num;\n\t}\n\n\tif (*buffer) {\n\t\tgiterr_set(GITERR_MERGE, \"No EOL at line %d\", line_num);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&merge_head_path);\n\tgit_buf_free(&merge_head_file);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&merge_head_file"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_MERGE",
            "\"No EOL at line %d\"",
            "line_num"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "&oid",
            "payload"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_load__cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "193-226",
          "snippet": "static int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_load__cb(void *_data, git_buf *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_load__cb(void *_data, git_buf *path);\n\nstatic int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromstr",
          "args": [
            "&oid",
            "line"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "54-57",
          "snippet": "int git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Unable to parse OID - invalid length\""
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strsep",
          "args": [
            "&buffer",
            "\"\\n\""
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "git__strsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "307-322",
          "snippet": "char *git__strsep(char **end, const char *sep)\n{\n\tchar *start = *end, *ptr = *end;\n\n\twhile (*ptr && !strchr(sep, *ptr))\n\t\t++ptr;\n\n\tif (*ptr) {\n\t\t*end = ptr + 1;\n\t\t*ptr = '\\0';\n\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nchar *git__strsep(char **end, const char *sep)\n{\n\tchar *start = *end, *ptr = *end;\n\n\twhile (*ptr && !strchr(sep, *ptr))\n\t\t++ptr;\n\n\tif (*ptr) {\n\t\t*end = ptr + 1;\n\t\t*ptr = '\\0';\n\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "&merge_head_file",
            "git_buf_cstr(&merge_head_path)"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&merge_head_path"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&merge_head_path",
            "repo->path_repository",
            "GIT_MERGE_HEAD_FILE"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && cb"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_repository_mergehead_foreach(\n\tgit_repository *repo,\n\tgit_repository_mergehead_foreach_cb cb,\n\tvoid *payload)\n{\n\tgit_buf merge_head_path = GIT_BUF_INIT, merge_head_file = GIT_BUF_INIT;\n\tchar *buffer, *line;\n\tsize_t line_num = 1;\n\tgit_oid oid;\n\tint error = 0;\n\n\tassert(repo && cb);\n\n\tif ((error = git_buf_joinpath(&merge_head_path, repo->path_repository,\n\t\tGIT_MERGE_HEAD_FILE)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_readbuffer(&merge_head_file,\n\t\tgit_buf_cstr(&merge_head_path))) < 0)\n\t\tgoto cleanup;\n\n\tbuffer = merge_head_file.ptr;\n\n\twhile ((line = git__strsep(&buffer, \"\\n\")) != NULL) {\n\t\tif (strlen(line) != GIT_OID_HEXSZ) {\n\t\t\tgiterr_set(GITERR_INVALID, \"Unable to parse OID - invalid length\");\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ((error = git_oid_fromstr(&oid, line)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = cb(&oid, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t++line_num;\n\t}\n\n\tif (*buffer) {\n\t\tgiterr_set(GITERR_MERGE, \"No EOL at line %d\", line_num);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&merge_head_path);\n\tgit_buf_free(&merge_head_file);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_merge__bases_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "494-559",
    "snippet": "int git_merge__bases_many(git_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tint error;\n\tunsigned int i;\n\tgit_commit_list_node *two;\n\tgit_commit_list *result = NULL, *tmp = NULL;\n\n\t/* If there's only the one commit, there can be no merge bases */\n\tif (twos->length == 0) {\n\t\t*out = NULL;\n\t\treturn 0;\n\t}\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (one == two)\n\t\t\treturn git_commit_list_insert(one, out) ? 0 : -1;\n\t}\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\treturn -1;\n\n\terror = paint_down_to_common(&result, walk, one, twos);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* filter out any stale commits in the results */\n\ttmp = result;\n\tresult = NULL;\n\n\twhile (tmp) {\n\t\tgit_commit_list_node *c = git_commit_list_pop(&tmp);\n\t\tif (!(c->flags & STALE))\n\t\t\tif (git_commit_list_insert_by_date(c, &result) == NULL)\n\t\t\t\treturn -1;\n\t}\n\n\t/*\n\t * more than one merge base -- see if there are redundant merge\n\t * bases and remove them\n\t */\n\tif (result && result->next) {\n\t\tgit_vector redundant = GIT_VECTOR_INIT;\n\n\t\twhile (result)\n\t\t\tgit_vector_insert(&redundant, git_commit_list_pop(&result));\n\n\t\tclear_commit_marks(one, ALL_FLAGS);\n\t\tclear_commit_marks_many(twos, ALL_FLAGS);\n\n\t\tif ((error = remove_redundant(walk, &redundant)) < 0) {\n\t\t\tgit_vector_free(&redundant);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_vector_foreach(&redundant, i, two) {\n\t\t\tif (two != NULL)\n\t\t\t\tgit_commit_list_insert_by_date(two, &result);\n\t\t}\n\n\t\tgit_vector_free(&redundant);\n\t}\n\n\t*out = result;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&redundant"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_insert_by_date",
          "args": [
            "two",
            "&result"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_insert_by_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "33-46",
          "snippet": "git_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\ngit_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&redundant",
            "i",
            "two"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_redundant",
          "args": [
            "walk",
            "&redundant"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "remove_redundant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "427-492",
          "snippet": "static int remove_redundant(git_revwalk *walk, git_vector *commits)\n{\n\tgit_vector work = GIT_VECTOR_INIT;\n\tunsigned char *redundant;\n\tunsigned int *filled_index;\n\tunsigned int i, j;\n\tint error = 0;\n\n\tredundant = git__calloc(commits->length, 1);\n\tGITERR_CHECK_ALLOC(redundant);\n\tfilled_index = git__calloc((commits->length - 1), sizeof(unsigned int));\n\tGITERR_CHECK_ALLOC(filled_index);\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tif ((error = git_commit_list_parse(walk, commits->contents[i])) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tgit_commit_list *common = NULL;\n\t\tgit_commit_list_node *commit = commits->contents[i];\n\n\t\tif (redundant[i])\n\t\t\tcontinue;\n\n\t\tgit_vector_clear(&work);\n\n\t\tfor (j = 0; j < commits->length; j++) {\n\t\t\tif (i == j || redundant[j])\n\t\t\t\tcontinue;\n\n\t\t\tfilled_index[work.length] = j;\n\t\t\tif ((error = git_vector_insert(&work, commits->contents[j])) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\terror = paint_down_to_common(&common, walk, commit, &work);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t\tif (commit->flags & PARENT2)\n\t\t\tredundant[i] = 1;\n\n\t\tfor (j = 0; j < work.length; j++) {\n\t\t\tgit_commit_list_node *w = work.contents[j];\n\t\t\tif (w->flags & PARENT1)\n\t\t\t\tredundant[filled_index[j]] = 1;\n\t\t}\n\n\t\tclear_commit_marks(commit, ALL_FLAGS);\n\t\tclear_commit_marks_many(&work, ALL_FLAGS);\n\n\t\tgit_commit_list_free(&common);\n\t}\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tif (redundant[i])\n\t\t\tcommits->contents[i] = NULL;\n\t}\n\ndone:\n\tgit__free(redundant);\n\tgit__free(filled_index);\n\tgit_vector_free(&work);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int remove_redundant(git_revwalk *walk, git_vector *commits)\n{\n\tgit_vector work = GIT_VECTOR_INIT;\n\tunsigned char *redundant;\n\tunsigned int *filled_index;\n\tunsigned int i, j;\n\tint error = 0;\n\n\tredundant = git__calloc(commits->length, 1);\n\tGITERR_CHECK_ALLOC(redundant);\n\tfilled_index = git__calloc((commits->length - 1), sizeof(unsigned int));\n\tGITERR_CHECK_ALLOC(filled_index);\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tif ((error = git_commit_list_parse(walk, commits->contents[i])) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tgit_commit_list *common = NULL;\n\t\tgit_commit_list_node *commit = commits->contents[i];\n\n\t\tif (redundant[i])\n\t\t\tcontinue;\n\n\t\tgit_vector_clear(&work);\n\n\t\tfor (j = 0; j < commits->length; j++) {\n\t\t\tif (i == j || redundant[j])\n\t\t\t\tcontinue;\n\n\t\t\tfilled_index[work.length] = j;\n\t\t\tif ((error = git_vector_insert(&work, commits->contents[j])) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\terror = paint_down_to_common(&common, walk, commit, &work);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t\tif (commit->flags & PARENT2)\n\t\t\tredundant[i] = 1;\n\n\t\tfor (j = 0; j < work.length; j++) {\n\t\t\tgit_commit_list_node *w = work.contents[j];\n\t\t\tif (w->flags & PARENT1)\n\t\t\t\tredundant[filled_index[j]] = 1;\n\t\t}\n\n\t\tclear_commit_marks(commit, ALL_FLAGS);\n\t\tclear_commit_marks_many(&work, ALL_FLAGS);\n\n\t\tgit_commit_list_free(&common);\n\t}\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tif (redundant[i])\n\t\t\tcommits->contents[i] = NULL;\n\t}\n\ndone:\n\tgit__free(redundant);\n\tgit__free(filled_index);\n\tgit_vector_free(&work);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_commit_marks_many",
          "args": [
            "twos",
            "ALL_FLAGS"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "clear_commit_marks_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "340-352",
          "snippet": "static void clear_commit_marks_many(git_vector *commits, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_node *c;\n\tunsigned int i;\n\n\tgit_vector_foreach(commits, i, c) {\n\t\tgit_commit_list_insert(c, &list);\n\t}\n\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void clear_commit_marks_many(git_vector *commits, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_node *c;\n\tunsigned int i;\n\n\tgit_vector_foreach(commits, i, c) {\n\t\tgit_commit_list_insert(c, &list);\n\t}\n\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_commit_marks",
          "args": [
            "one",
            "ALL_FLAGS"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "clear_commit_marks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "354-360",
          "snippet": "static void clear_commit_marks(git_commit_list_node *commit, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_insert(commit, &list);\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void clear_commit_marks(git_commit_list_node *commit, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_insert(commit, &list);\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&redundant",
            "git_commit_list_pop(&result)"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_pop",
          "args": [
            "&result"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "91-101",
          "snippet": "git_commit_list_node *git_commit_list_pop(git_commit_list **stack)\n{\n\tgit_commit_list *top = *stack;\n\tgit_commit_list_node *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tgit__free(top);\n\t}\n\treturn item;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\ngit_commit_list_node *git_commit_list_pop(git_commit_list **stack)\n{\n\tgit_commit_list *top = *stack;\n\tgit_commit_list_node *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tgit__free(top);\n\t}\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "paint_down_to_common",
          "args": [
            "&result",
            "walk",
            "one",
            "twos"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "paint_down_to_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "362-425",
          "snippet": "static int paint_down_to_common(\n\tgit_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tgit_pqueue list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *two;\n\n\tint error;\n\tunsigned int i;\n\n\tif (git_pqueue_init(&list, 0, twos->length * 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (git_commit_list_parse(walk, two) < 0)\n\t\t\treturn -1;\n\n\t\ttwo->flags |= PARENT2;\n\n\t\tif (git_pqueue_insert(&list, two) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT)) {\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t\tif (git_commit_list_insert(commit, &result) == NULL)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_commit_list_parse(walk, p)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_pqueue_free(&list);\n\t*out = result;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int paint_down_to_common(\n\tgit_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tgit_pqueue list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *two;\n\n\tint error;\n\tunsigned int i;\n\n\tif (git_pqueue_init(&list, 0, twos->length * 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (git_commit_list_parse(walk, two) < 0)\n\t\t\treturn -1;\n\n\t\ttwo->flags |= PARENT2;\n\n\t\tif (git_pqueue_insert(&list, two) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT)) {\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t\tif (git_commit_list_insert(commit, &result) == NULL)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_commit_list_parse(walk, p)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_pqueue_free(&list);\n\t*out = result;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_parse",
          "args": [
            "walk",
            "one"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "177-199",
          "snippet": "int git_commit_list_parse(git_revwalk *walk, git_commit_list_node *commit)\n{\n\tgit_odb_object *obj;\n\tint error;\n\n\tif (commit->parsed)\n\t\treturn 0;\n\n\tif ((error = git_odb_read(&obj, walk->odb, &commit->oid)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"Object is no commit object\");\n\t\terror = -1;\n\t} else\n\t\terror = commit_quick_parse(\n\t\t\twalk, commit,\n\t\t\t(const uint8_t *)git_odb_object_data(obj),\n\t\t\tgit_odb_object_size(obj));\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nint git_commit_list_parse(git_revwalk *walk, git_commit_list_node *commit)\n{\n\tgit_odb_object *obj;\n\tint error;\n\n\tif (commit->parsed)\n\t\treturn 0;\n\n\tif ((error = git_odb_read(&obj, walk->odb, &commit->oid)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"Object is no commit object\");\n\t\terror = -1;\n\t} else\n\t\terror = commit_quick_parse(\n\t\t\twalk, commit,\n\t\t\t(const uint8_t *)git_odb_object_data(obj),\n\t\t\tgit_odb_object_size(obj));\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "twos",
            "i",
            "two"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge__bases_many(git_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tint error;\n\tunsigned int i;\n\tgit_commit_list_node *two;\n\tgit_commit_list *result = NULL, *tmp = NULL;\n\n\t/* If there's only the one commit, there can be no merge bases */\n\tif (twos->length == 0) {\n\t\t*out = NULL;\n\t\treturn 0;\n\t}\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (one == two)\n\t\t\treturn git_commit_list_insert(one, out) ? 0 : -1;\n\t}\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\treturn -1;\n\n\terror = paint_down_to_common(&result, walk, one, twos);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* filter out any stale commits in the results */\n\ttmp = result;\n\tresult = NULL;\n\n\twhile (tmp) {\n\t\tgit_commit_list_node *c = git_commit_list_pop(&tmp);\n\t\tif (!(c->flags & STALE))\n\t\t\tif (git_commit_list_insert_by_date(c, &result) == NULL)\n\t\t\t\treturn -1;\n\t}\n\n\t/*\n\t * more than one merge base -- see if there are redundant merge\n\t * bases and remove them\n\t */\n\tif (result && result->next) {\n\t\tgit_vector redundant = GIT_VECTOR_INIT;\n\n\t\twhile (result)\n\t\t\tgit_vector_insert(&redundant, git_commit_list_pop(&result));\n\n\t\tclear_commit_marks(one, ALL_FLAGS);\n\t\tclear_commit_marks_many(twos, ALL_FLAGS);\n\n\t\tif ((error = remove_redundant(walk, &redundant)) < 0) {\n\t\t\tgit_vector_free(&redundant);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_vector_foreach(&redundant, i, two) {\n\t\t\tif (two != NULL)\n\t\t\t\tgit_commit_list_insert_by_date(two, &result);\n\t\t}\n\n\t\tgit_vector_free(&redundant);\n\t}\n\n\t*out = result;\n\treturn 0;\n}"
  },
  {
    "function_name": "remove_redundant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "427-492",
    "snippet": "static int remove_redundant(git_revwalk *walk, git_vector *commits)\n{\n\tgit_vector work = GIT_VECTOR_INIT;\n\tunsigned char *redundant;\n\tunsigned int *filled_index;\n\tunsigned int i, j;\n\tint error = 0;\n\n\tredundant = git__calloc(commits->length, 1);\n\tGITERR_CHECK_ALLOC(redundant);\n\tfilled_index = git__calloc((commits->length - 1), sizeof(unsigned int));\n\tGITERR_CHECK_ALLOC(filled_index);\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tif ((error = git_commit_list_parse(walk, commits->contents[i])) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tgit_commit_list *common = NULL;\n\t\tgit_commit_list_node *commit = commits->contents[i];\n\n\t\tif (redundant[i])\n\t\t\tcontinue;\n\n\t\tgit_vector_clear(&work);\n\n\t\tfor (j = 0; j < commits->length; j++) {\n\t\t\tif (i == j || redundant[j])\n\t\t\t\tcontinue;\n\n\t\t\tfilled_index[work.length] = j;\n\t\t\tif ((error = git_vector_insert(&work, commits->contents[j])) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\terror = paint_down_to_common(&common, walk, commit, &work);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t\tif (commit->flags & PARENT2)\n\t\t\tredundant[i] = 1;\n\n\t\tfor (j = 0; j < work.length; j++) {\n\t\t\tgit_commit_list_node *w = work.contents[j];\n\t\t\tif (w->flags & PARENT1)\n\t\t\t\tredundant[filled_index[j]] = 1;\n\t\t}\n\n\t\tclear_commit_marks(commit, ALL_FLAGS);\n\t\tclear_commit_marks_many(&work, ALL_FLAGS);\n\n\t\tgit_commit_list_free(&common);\n\t}\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tif (redundant[i])\n\t\t\tcommits->contents[i] = NULL;\n\t}\n\ndone:\n\tgit__free(redundant);\n\tgit__free(filled_index);\n\tgit_vector_free(&work);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&work"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "filled_index"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_free",
          "args": [
            "&common"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "75-89",
          "snippet": "void git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nvoid git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_commit_marks_many",
          "args": [
            "&work",
            "ALL_FLAGS"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "clear_commit_marks_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "340-352",
          "snippet": "static void clear_commit_marks_many(git_vector *commits, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_node *c;\n\tunsigned int i;\n\n\tgit_vector_foreach(commits, i, c) {\n\t\tgit_commit_list_insert(c, &list);\n\t}\n\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void clear_commit_marks_many(git_vector *commits, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_node *c;\n\tunsigned int i;\n\n\tgit_vector_foreach(commits, i, c) {\n\t\tgit_commit_list_insert(c, &list);\n\t}\n\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_commit_marks",
          "args": [
            "commit",
            "ALL_FLAGS"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "clear_commit_marks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "354-360",
          "snippet": "static void clear_commit_marks(git_commit_list_node *commit, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_insert(commit, &list);\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void clear_commit_marks(git_commit_list_node *commit, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_insert(commit, &list);\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "paint_down_to_common",
          "args": [
            "&common",
            "walk",
            "commit",
            "&work"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "paint_down_to_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "362-425",
          "snippet": "static int paint_down_to_common(\n\tgit_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tgit_pqueue list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *two;\n\n\tint error;\n\tunsigned int i;\n\n\tif (git_pqueue_init(&list, 0, twos->length * 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (git_commit_list_parse(walk, two) < 0)\n\t\t\treturn -1;\n\n\t\ttwo->flags |= PARENT2;\n\n\t\tif (git_pqueue_insert(&list, two) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT)) {\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t\tif (git_commit_list_insert(commit, &result) == NULL)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_commit_list_parse(walk, p)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_pqueue_free(&list);\n\t*out = result;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int paint_down_to_common(\n\tgit_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tgit_pqueue list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *two;\n\n\tint error;\n\tunsigned int i;\n\n\tif (git_pqueue_init(&list, 0, twos->length * 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (git_commit_list_parse(walk, two) < 0)\n\t\t\treturn -1;\n\n\t\ttwo->flags |= PARENT2;\n\n\t\tif (git_pqueue_insert(&list, two) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT)) {\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t\tif (git_commit_list_insert(commit, &result) == NULL)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_commit_list_parse(walk, p)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_pqueue_free(&list);\n\t*out = result;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&work",
            "commits->contents[j]"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&work"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_parse",
          "args": [
            "walk",
            "commits->contents[i]"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "177-199",
          "snippet": "int git_commit_list_parse(git_revwalk *walk, git_commit_list_node *commit)\n{\n\tgit_odb_object *obj;\n\tint error;\n\n\tif (commit->parsed)\n\t\treturn 0;\n\n\tif ((error = git_odb_read(&obj, walk->odb, &commit->oid)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"Object is no commit object\");\n\t\terror = -1;\n\t} else\n\t\terror = commit_quick_parse(\n\t\t\twalk, commit,\n\t\t\t(const uint8_t *)git_odb_object_data(obj),\n\t\t\tgit_odb_object_size(obj));\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nint git_commit_list_parse(git_revwalk *walk, git_commit_list_node *commit)\n{\n\tgit_odb_object *obj;\n\tint error;\n\n\tif (commit->parsed)\n\t\treturn 0;\n\n\tif ((error = git_odb_read(&obj, walk->odb, &commit->oid)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"Object is no commit object\");\n\t\terror = -1;\n\t} else\n\t\terror = commit_quick_parse(\n\t\t\twalk, commit,\n\t\t\t(const uint8_t *)git_odb_object_data(obj),\n\t\t\tgit_odb_object_size(obj));\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "filled_index"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "(commits->length - 1)",
            "sizeof(unsigned int)"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "redundant"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int remove_redundant(git_revwalk *walk, git_vector *commits)\n{\n\tgit_vector work = GIT_VECTOR_INIT;\n\tunsigned char *redundant;\n\tunsigned int *filled_index;\n\tunsigned int i, j;\n\tint error = 0;\n\n\tredundant = git__calloc(commits->length, 1);\n\tGITERR_CHECK_ALLOC(redundant);\n\tfilled_index = git__calloc((commits->length - 1), sizeof(unsigned int));\n\tGITERR_CHECK_ALLOC(filled_index);\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tif ((error = git_commit_list_parse(walk, commits->contents[i])) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tgit_commit_list *common = NULL;\n\t\tgit_commit_list_node *commit = commits->contents[i];\n\n\t\tif (redundant[i])\n\t\t\tcontinue;\n\n\t\tgit_vector_clear(&work);\n\n\t\tfor (j = 0; j < commits->length; j++) {\n\t\t\tif (i == j || redundant[j])\n\t\t\t\tcontinue;\n\n\t\t\tfilled_index[work.length] = j;\n\t\t\tif ((error = git_vector_insert(&work, commits->contents[j])) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\terror = paint_down_to_common(&common, walk, commit, &work);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t\tif (commit->flags & PARENT2)\n\t\t\tredundant[i] = 1;\n\n\t\tfor (j = 0; j < work.length; j++) {\n\t\t\tgit_commit_list_node *w = work.contents[j];\n\t\t\tif (w->flags & PARENT1)\n\t\t\t\tredundant[filled_index[j]] = 1;\n\t\t}\n\n\t\tclear_commit_marks(commit, ALL_FLAGS);\n\t\tclear_commit_marks_many(&work, ALL_FLAGS);\n\n\t\tgit_commit_list_free(&common);\n\t}\n\n\tfor (i = 0; i < commits->length; ++i) {\n\t\tif (redundant[i])\n\t\t\tcommits->contents[i] = NULL;\n\t}\n\ndone:\n\tgit__free(redundant);\n\tgit__free(filled_index);\n\tgit_vector_free(&work);\n\treturn error;\n}"
  },
  {
    "function_name": "paint_down_to_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "362-425",
    "snippet": "static int paint_down_to_common(\n\tgit_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tgit_pqueue list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *two;\n\n\tint error;\n\tunsigned int i;\n\n\tif (git_pqueue_init(&list, 0, twos->length * 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (git_commit_list_parse(walk, two) < 0)\n\t\t\treturn -1;\n\n\t\ttwo->flags |= PARENT2;\n\n\t\tif (git_pqueue_insert(&list, two) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT)) {\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t\tif (git_commit_list_insert(commit, &result) == NULL)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_commit_list_parse(walk, p)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_pqueue_free(&list);\n\t*out = result;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pqueue_free",
          "args": [
            "&list"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pqueue_insert",
          "args": [
            "&list",
            "p"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "81-100",
          "snippet": "int git_pqueue_insert(git_pqueue *pq, void *item)\n{\n\tint error = 0;\n\n\t/* if heap is full, pop the top element if new one should replace it */\n\tif ((pq->flags & GIT_PQUEUE_FIXED_SIZE) != 0 &&\n\t\tpq->length >= pq->_alloc_size)\n\t{\n\t\t/* skip this item if below min item in heap */\n\t\tif (pq->_cmp(item, git_vector_get(pq, 0)) <= 0)\n\t\t\treturn 0;\n\t\t/* otherwise remove the min item before inserting new */\n\t\t(void)git_pqueue_pop(pq);\n\t}\n\n\tif (!(error = git_vector_insert(pq, item)))\n\t\tpqueue_up(pq, pq->length - 1);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nint git_pqueue_insert(git_pqueue *pq, void *item)\n{\n\tint error = 0;\n\n\t/* if heap is full, pop the top element if new one should replace it */\n\tif ((pq->flags & GIT_PQUEUE_FIXED_SIZE) != 0 &&\n\t\tpq->length >= pq->_alloc_size)\n\t{\n\t\t/* skip this item if below min item in heap */\n\t\tif (pq->_cmp(item, git_vector_get(pq, 0)) <= 0)\n\t\t\treturn 0;\n\t\t/* otherwise remove the min item before inserting new */\n\t\t(void)git_pqueue_pop(pq);\n\t}\n\n\tif (!(error = git_vector_insert(pq, item)))\n\t\tpqueue_up(pq, pq->length - 1);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_parse",
          "args": [
            "walk",
            "p"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "177-199",
          "snippet": "int git_commit_list_parse(git_revwalk *walk, git_commit_list_node *commit)\n{\n\tgit_odb_object *obj;\n\tint error;\n\n\tif (commit->parsed)\n\t\treturn 0;\n\n\tif ((error = git_odb_read(&obj, walk->odb, &commit->oid)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"Object is no commit object\");\n\t\terror = -1;\n\t} else\n\t\terror = commit_quick_parse(\n\t\t\twalk, commit,\n\t\t\t(const uint8_t *)git_odb_object_data(obj),\n\t\t\tgit_odb_object_size(obj));\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nint git_commit_list_parse(git_revwalk *walk, git_commit_list_node *commit)\n{\n\tgit_odb_object *obj;\n\tint error;\n\n\tif (commit->parsed)\n\t\treturn 0;\n\n\tif ((error = git_odb_read(&obj, walk->odb, &commit->oid)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"Object is no commit object\");\n\t\terror = -1;\n\t} else\n\t\terror = commit_quick_parse(\n\t\t\twalk, commit,\n\t\t\t(const uint8_t *)git_odb_object_data(obj),\n\t\t\tgit_odb_object_size(obj));\n\n\tgit_odb_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_insert",
          "args": [
            "commit",
            "&result"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_insert_by_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "33-46",
          "snippet": "git_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\ngit_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pqueue_pop",
          "args": [
            "&list"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "102-117",
          "snippet": "void *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nvoid *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "interesting",
          "args": [
            "&list"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "interesting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "307-318",
          "snippet": "static int interesting(git_pqueue *list)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < git_pqueue_size(list); i++) {\n\t\tgit_commit_list_node *commit = git_pqueue_get(list, i);\n\t\tif ((commit->flags & STALE) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int interesting(git_pqueue *list)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < git_pqueue_size(list); i++) {\n\t\tgit_commit_list_node *commit = git_pqueue_get(list, i);\n\t\tif ((commit->flags & STALE) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "twos",
            "i",
            "two"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pqueue_init",
          "args": [
            "&list",
            "0",
            "twos->length * 2",
            "git_commit_list_time_cmp"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "15-33",
          "snippet": "int git_pqueue_init(\n\tgit_pqueue *pq,\n\tuint32_t flags,\n\tsize_t init_size,\n\tgit_vector_cmp cmp)\n{\n\tint error = git_vector_init(pq, init_size, cmp);\n\n\tif (!error) {\n\t\t/* mix in our flags */\n\t\tpq->flags |= flags;\n\n\t\t/* if fixed size heap, pretend vector is exactly init_size elements */\n\t\tif ((flags & GIT_PQUEUE_FIXED_SIZE) && init_size > 0)\n\t\t\tpq->_alloc_size = init_size;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nint git_pqueue_init(\n\tgit_pqueue *pq,\n\tuint32_t flags,\n\tsize_t init_size,\n\tgit_vector_cmp cmp)\n{\n\tint error = git_vector_init(pq, init_size, cmp);\n\n\tif (!error) {\n\t\t/* mix in our flags */\n\t\tpq->flags |= flags;\n\n\t\t/* if fixed size heap, pretend vector is exactly init_size elements */\n\t\tif ((flags & GIT_PQUEUE_FIXED_SIZE) && init_size > 0)\n\t\t\tpq->_alloc_size = init_size;\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int paint_down_to_common(\n\tgit_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tgit_pqueue list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *two;\n\n\tint error;\n\tunsigned int i;\n\n\tif (git_pqueue_init(&list, 0, twos->length * 2, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tone->flags |= PARENT1;\n\tif (git_pqueue_insert(&list, one) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (git_commit_list_parse(walk, two) < 0)\n\t\t\treturn -1;\n\n\t\ttwo->flags |= PARENT2;\n\n\t\tif (git_pqueue_insert(&list, two) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* as long as there are non-STALE commits */\n\twhile (interesting(&list)) {\n\t\tgit_commit_list_node *commit = git_pqueue_pop(&list);\n\t\tint flags;\n\n\t\tif (commit == NULL)\n\t\t\tbreak;\n\n\t\tflags = commit->flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->flags & RESULT)) {\n\t\t\t\tcommit->flags |= RESULT;\n\t\t\t\tif (git_commit_list_insert(commit, &result) == NULL)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* we mark the parents of a merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\n\t\tfor (i = 0; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tif ((p->flags & flags) == flags)\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_commit_list_parse(walk, p)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tp->flags |= flags;\n\t\t\tif (git_pqueue_insert(&list, p) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_pqueue_free(&list);\n\t*out = result;\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_commit_marks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "354-360",
    "snippet": "static void clear_commit_marks(git_commit_list_node *commit, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_insert(commit, &list);\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_commit_marks_1",
          "args": [
            "&list",
            "git_commit_list_pop(&list)",
            "mark"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "clear_commit_marks_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "320-338",
          "snippet": "static void clear_commit_marks_1(git_commit_list **plist,\n\t\tgit_commit_list_node *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tunsigned int i;\n\n\t\tif (!(mark & commit->flags))\n\t\t\treturn;\n\n\t\tcommit->flags &= ~mark;\n\n\t\tfor (i = 1; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tgit_commit_list_insert(p, plist);\n\t\t}\n\n\t\tcommit = commit->out_degree ? commit->parents[0] : NULL;\n\t}\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void clear_commit_marks_1(git_commit_list **plist,\n\t\tgit_commit_list_node *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tunsigned int i;\n\n\t\tif (!(mark & commit->flags))\n\t\t\treturn;\n\n\t\tcommit->flags &= ~mark;\n\n\t\tfor (i = 1; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tgit_commit_list_insert(p, plist);\n\t\t}\n\n\t\tcommit = commit->out_degree ? commit->parents[0] : NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_pop",
          "args": [
            "&list"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "91-101",
          "snippet": "git_commit_list_node *git_commit_list_pop(git_commit_list **stack)\n{\n\tgit_commit_list *top = *stack;\n\tgit_commit_list_node *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tgit__free(top);\n\t}\n\treturn item;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\ngit_commit_list_node *git_commit_list_pop(git_commit_list **stack)\n{\n\tgit_commit_list *top = *stack;\n\tgit_commit_list_node *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tgit__free(top);\n\t}\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_insert",
          "args": [
            "commit",
            "&list"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_insert_by_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "33-46",
          "snippet": "git_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\ngit_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void clear_commit_marks(git_commit_list_node *commit, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_insert(commit, &list);\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}"
  },
  {
    "function_name": "clear_commit_marks_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "340-352",
    "snippet": "static void clear_commit_marks_many(git_vector *commits, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_node *c;\n\tunsigned int i;\n\n\tgit_vector_foreach(commits, i, c) {\n\t\tgit_commit_list_insert(c, &list);\n\t}\n\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_commit_marks_1",
          "args": [
            "&list",
            "git_commit_list_pop(&list)",
            "mark"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "clear_commit_marks_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "320-338",
          "snippet": "static void clear_commit_marks_1(git_commit_list **plist,\n\t\tgit_commit_list_node *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tunsigned int i;\n\n\t\tif (!(mark & commit->flags))\n\t\t\treturn;\n\n\t\tcommit->flags &= ~mark;\n\n\t\tfor (i = 1; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tgit_commit_list_insert(p, plist);\n\t\t}\n\n\t\tcommit = commit->out_degree ? commit->parents[0] : NULL;\n\t}\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void clear_commit_marks_1(git_commit_list **plist,\n\t\tgit_commit_list_node *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tunsigned int i;\n\n\t\tif (!(mark & commit->flags))\n\t\t\treturn;\n\n\t\tcommit->flags &= ~mark;\n\n\t\tfor (i = 1; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tgit_commit_list_insert(p, plist);\n\t\t}\n\n\t\tcommit = commit->out_degree ? commit->parents[0] : NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_pop",
          "args": [
            "&list"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "91-101",
          "snippet": "git_commit_list_node *git_commit_list_pop(git_commit_list **stack)\n{\n\tgit_commit_list *top = *stack;\n\tgit_commit_list_node *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tgit__free(top);\n\t}\n\treturn item;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\ngit_commit_list_node *git_commit_list_pop(git_commit_list **stack)\n{\n\tgit_commit_list *top = *stack;\n\tgit_commit_list_node *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tgit__free(top);\n\t}\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_insert",
          "args": [
            "c",
            "&list"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_insert_by_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "33-46",
          "snippet": "git_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\ngit_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "commits",
            "i",
            "c"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void clear_commit_marks_many(git_vector *commits, unsigned int mark)\n{\n\tgit_commit_list *list = NULL;\n\tgit_commit_list_node *c;\n\tunsigned int i;\n\n\tgit_vector_foreach(commits, i, c) {\n\t\tgit_commit_list_insert(c, &list);\n\t}\n\n\twhile (list)\n\t\tclear_commit_marks_1(&list, git_commit_list_pop(&list), mark);\n}"
  },
  {
    "function_name": "clear_commit_marks_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "320-338",
    "snippet": "static void clear_commit_marks_1(git_commit_list **plist,\n\t\tgit_commit_list_node *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tunsigned int i;\n\n\t\tif (!(mark & commit->flags))\n\t\t\treturn;\n\n\t\tcommit->flags &= ~mark;\n\n\t\tfor (i = 1; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tgit_commit_list_insert(p, plist);\n\t\t}\n\n\t\tcommit = commit->out_degree ? commit->parents[0] : NULL;\n\t}\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit_list_insert",
          "args": [
            "p",
            "plist"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_insert_by_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "33-46",
          "snippet": "git_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\ngit_commit_list *git_commit_list_insert_by_date(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list **pp = list_p;\n\tgit_commit_list *p;\n\n\twhile ((p = *pp) != NULL) {\n\t\tif (git_commit_list_time_cmp(p->item, item) > 0)\n\t\t\tbreak;\n\n\t\tpp = &p->next;\n\t}\n\n\treturn git_commit_list_insert(item, pp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic void clear_commit_marks_1(git_commit_list **plist,\n\t\tgit_commit_list_node *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tunsigned int i;\n\n\t\tif (!(mark & commit->flags))\n\t\t\treturn;\n\n\t\tcommit->flags &= ~mark;\n\n\t\tfor (i = 1; i < commit->out_degree; i++) {\n\t\t\tgit_commit_list_node *p = commit->parents[i];\n\t\t\tgit_commit_list_insert(p, plist);\n\t\t}\n\n\t\tcommit = commit->out_degree ? commit->parents[0] : NULL;\n\t}\n}"
  },
  {
    "function_name": "interesting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "307-318",
    "snippet": "static int interesting(git_pqueue *list)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < git_pqueue_size(list); i++) {\n\t\tgit_commit_list_node *commit = git_pqueue_get(list, i);\n\t\tif ((commit->flags & STALE) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pqueue_get",
          "args": [
            "list",
            "i"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pqueue_size",
          "args": [
            "list"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int interesting(git_pqueue *list)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < git_pqueue_size(list); i++) {\n\t\tgit_commit_list_node *commit = git_pqueue_get(list, i);\n\t\tif ((commit->flags & STALE) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_merge_bases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "273-305",
    "snippet": "int git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n        git_revwalk *walk;\n\tgit_commit_list *result, *list;\n\tgit_array_oid_t array;\n\n\tgit_array_init(array);\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_free",
          "args": [
            "&result"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "75-89",
          "snippet": "void git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nvoid git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oidarray__from_array",
          "args": [
            "out",
            "&array"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "git_oidarray__from_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oidarray.c",
          "lines": "17-21",
          "snippet": "void git_oidarray__from_array(git_oidarray *arr, git_array_oid_t *array)\n{\n\tarr->count = array->size;\n\tarr->ids = array->ptr;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"oidarray.h\"",
            "#include \"git2/oidarray.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"oidarray.h\"\n#include \"git2/oidarray.h\"\n\nvoid git_oidarray__from_array(git_oidarray *arr, git_array_oid_t *array)\n{\n\tarr->count = array->size;\n\tarr->ids = array->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "id",
            "&list->item->oid"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_alloc",
          "args": [
            "array"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_bases",
          "args": [
            "&result",
            "&walk",
            "repo",
            "one",
            "two"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "merge_bases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "212-255",
          "snippet": "static int merge_bases(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tgit_revwalk *walk;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tvoid *contents[1];\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\treturn -1;\n\n\tcommit = git_revwalk__commit_lookup(walk, two);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\t/* This is just one value, so we can do it on the stack */\n\tmemset(&list, 0x0, sizeof(git_vector));\n\tcontents[0] = commit;\n\tlist.length = 1;\n\tlist.contents = contents;\n\n\tcommit = git_revwalk__commit_lookup(walk, one);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgit_revwalk_free(walk);\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\treturn -1;\n\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_bases(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tgit_revwalk *walk;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tvoid *contents[1];\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\treturn -1;\n\n\tcommit = git_revwalk__commit_lookup(walk, two);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\t/* This is just one value, so we can do it on the stack */\n\tmemset(&list, 0x0, sizeof(git_vector));\n\tcontents[0] = commit;\n\tlist.length = 1;\n\tlist.contents = contents;\n\n\tcommit = git_revwalk__commit_lookup(walk, one);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgit_revwalk_free(walk);\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\treturn -1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_init",
          "args": [
            "array"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n        git_revwalk *walk;\n\tgit_commit_list *result, *list;\n\tgit_array_oid_t array;\n\n\tgit_array_init(array);\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_merge_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "257-271",
    "snippet": "int git_merge_base(git_oid *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n\tgit_revwalk *walk;\n\tgit_commit_list *result;\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, &result->item->oid);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_free",
          "args": [
            "&result"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "75-89",
          "snippet": "void git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nvoid git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "out",
            "&result->item->oid"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_bases",
          "args": [
            "&result",
            "&walk",
            "repo",
            "one",
            "two"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "merge_bases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "212-255",
          "snippet": "static int merge_bases(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tgit_revwalk *walk;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tvoid *contents[1];\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\treturn -1;\n\n\tcommit = git_revwalk__commit_lookup(walk, two);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\t/* This is just one value, so we can do it on the stack */\n\tmemset(&list, 0x0, sizeof(git_vector));\n\tcontents[0] = commit;\n\tlist.length = 1;\n\tlist.contents = contents;\n\n\tcommit = git_revwalk__commit_lookup(walk, one);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgit_revwalk_free(walk);\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\treturn -1;\n\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_bases(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tgit_revwalk *walk;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tvoid *contents[1];\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\treturn -1;\n\n\tcommit = git_revwalk__commit_lookup(walk, two);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\t/* This is just one value, so we can do it on the stack */\n\tmemset(&list, 0x0, sizeof(git_vector));\n\tcontents[0] = commit;\n\tlist.length = 1;\n\tlist.contents = contents;\n\n\tcommit = git_revwalk__commit_lookup(walk, one);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgit_revwalk_free(walk);\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\treturn -1;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_base(git_oid *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n\tgit_revwalk *walk;\n\tgit_commit_list *result;\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, &result->item->oid);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "merge_bases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "212-255",
    "snippet": "static int merge_bases(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tgit_revwalk *walk;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tvoid *contents[1];\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\treturn -1;\n\n\tcommit = git_revwalk__commit_lookup(walk, two);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\t/* This is just one value, so we can do it on the stack */\n\tmemset(&list, 0x0, sizeof(git_vector));\n\tcontents[0] = commit;\n\tlist.length = 1;\n\tlist.contents = contents;\n\n\tcommit = git_revwalk__commit_lookup(walk, one);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgit_revwalk_free(walk);\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\treturn -1;\n\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_MERGE",
            "\"No merge base found\""
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__bases_many",
          "args": [
            "&result",
            "walk",
            "commit",
            "&list"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__bases_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "494-559",
          "snippet": "int git_merge__bases_many(git_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tint error;\n\tunsigned int i;\n\tgit_commit_list_node *two;\n\tgit_commit_list *result = NULL, *tmp = NULL;\n\n\t/* If there's only the one commit, there can be no merge bases */\n\tif (twos->length == 0) {\n\t\t*out = NULL;\n\t\treturn 0;\n\t}\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (one == two)\n\t\t\treturn git_commit_list_insert(one, out) ? 0 : -1;\n\t}\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\treturn -1;\n\n\terror = paint_down_to_common(&result, walk, one, twos);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* filter out any stale commits in the results */\n\ttmp = result;\n\tresult = NULL;\n\n\twhile (tmp) {\n\t\tgit_commit_list_node *c = git_commit_list_pop(&tmp);\n\t\tif (!(c->flags & STALE))\n\t\t\tif (git_commit_list_insert_by_date(c, &result) == NULL)\n\t\t\t\treturn -1;\n\t}\n\n\t/*\n\t * more than one merge base -- see if there are redundant merge\n\t * bases and remove them\n\t */\n\tif (result && result->next) {\n\t\tgit_vector redundant = GIT_VECTOR_INIT;\n\n\t\twhile (result)\n\t\t\tgit_vector_insert(&redundant, git_commit_list_pop(&result));\n\n\t\tclear_commit_marks(one, ALL_FLAGS);\n\t\tclear_commit_marks_many(twos, ALL_FLAGS);\n\n\t\tif ((error = remove_redundant(walk, &redundant)) < 0) {\n\t\t\tgit_vector_free(&redundant);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_vector_foreach(&redundant, i, two) {\n\t\t\tif (two != NULL)\n\t\t\t\tgit_commit_list_insert_by_date(two, &result);\n\t\t}\n\n\t\tgit_vector_free(&redundant);\n\t}\n\n\t*out = result;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge__bases_many(git_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tint error;\n\tunsigned int i;\n\tgit_commit_list_node *two;\n\tgit_commit_list *result = NULL, *tmp = NULL;\n\n\t/* If there's only the one commit, there can be no merge bases */\n\tif (twos->length == 0) {\n\t\t*out = NULL;\n\t\treturn 0;\n\t}\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (one == two)\n\t\t\treturn git_commit_list_insert(one, out) ? 0 : -1;\n\t}\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\treturn -1;\n\n\terror = paint_down_to_common(&result, walk, one, twos);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* filter out any stale commits in the results */\n\ttmp = result;\n\tresult = NULL;\n\n\twhile (tmp) {\n\t\tgit_commit_list_node *c = git_commit_list_pop(&tmp);\n\t\tif (!(c->flags & STALE))\n\t\t\tif (git_commit_list_insert_by_date(c, &result) == NULL)\n\t\t\t\treturn -1;\n\t}\n\n\t/*\n\t * more than one merge base -- see if there are redundant merge\n\t * bases and remove them\n\t */\n\tif (result && result->next) {\n\t\tgit_vector redundant = GIT_VECTOR_INIT;\n\n\t\twhile (result)\n\t\t\tgit_vector_insert(&redundant, git_commit_list_pop(&result));\n\n\t\tclear_commit_marks(one, ALL_FLAGS);\n\t\tclear_commit_marks_many(twos, ALL_FLAGS);\n\n\t\tif ((error = remove_redundant(walk, &redundant)) < 0) {\n\t\t\tgit_vector_free(&redundant);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_vector_foreach(&redundant, i, two) {\n\t\t\tif (two != NULL)\n\t\t\t\tgit_commit_list_insert_by_date(two, &result);\n\t\t}\n\n\t\tgit_vector_free(&redundant);\n\t}\n\n\t*out = result;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk__commit_lookup",
          "args": [
            "walk",
            "one"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk__commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "17-42",
          "snippet": "GIT__USE_OIDMAP\n\ngit_commit_list_node *git_revwalk__commit_lookup(\n\tgit_revwalk *walk, const git_oid *oid)\n{\n\tgit_commit_list_node *commit;\n\tkhiter_t pos;\n\tint ret;\n\n\t/* lookup and reserve space if not already present */\n\tpos = kh_get(oid, walk->commits, oid);\n\tif (pos != kh_end(walk->commits))\n\t\treturn kh_value(walk->commits, pos);\n\n\tcommit = git_commit_list_alloc_node(walk);\n\tif (commit == NULL)\n\t\treturn NULL;\n\n\tgit_oid_cpy(&commit->oid, oid);\n\n\tpos = kh_put(oid, walk->commits, &commit->oid, &ret);\n\tassert(ret != 0);\n\tkh_value(walk->commits, pos) = commit;\n\n\treturn commit;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nGIT__USE_OIDMAP\n\ngit_commit_list_node *git_revwalk__commit_lookup(\n\tgit_revwalk *walk, const git_oid *oid)\n{\n\tgit_commit_list_node *commit;\n\tkhiter_t pos;\n\tint ret;\n\n\t/* lookup and reserve space if not already present */\n\tpos = kh_get(oid, walk->commits, oid);\n\tif (pos != kh_end(walk->commits))\n\t\treturn kh_value(walk->commits, pos);\n\n\tcommit = git_commit_list_alloc_node(walk);\n\tif (commit == NULL)\n\t\treturn NULL;\n\n\tgit_oid_cpy(&commit->oid, oid);\n\n\tpos = kh_put(oid, walk->commits, &commit->oid, &ret);\n\tassert(ret != 0);\n\tkh_value(walk->commits, pos) = commit;\n\n\treturn commit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&list",
            "0x0",
            "sizeof(git_vector)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_revwalk_new",
          "args": [
            "&walk",
            "repo"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "529-553",
          "snippet": "int git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_bases(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tgit_revwalk *walk;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tvoid *contents[1];\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\treturn -1;\n\n\tcommit = git_revwalk__commit_lookup(walk, two);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\t/* This is just one value, so we can do it on the stack */\n\tmemset(&list, 0x0, sizeof(git_vector));\n\tcontents[0] = commit;\n\tlist.length = 1;\n\tlist.contents = contents;\n\n\tcommit = git_revwalk__commit_lookup(walk, one);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgit_revwalk_free(walk);\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\treturn -1;\n\n}"
  },
  {
    "function_name": "git_merge_base_octopus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "187-210",
    "snippet": "int git_merge_base_octopus(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_oid result;\n\tunsigned int i;\n\tint error = -1;\n\n\tassert(out && repo && input_array);\n\n\tif (length < 2) {\n\t\tgiterr_set(GITERR_INVALID, \"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\", length);\n\t\treturn -1;\n\t}\n\n\tresult = input_array[0];\n\tfor (i = 1; i < length; i++) {\n\t\terror = git_merge_base(&result, repo, &result, &input_array[i]);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\t*out = result;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_merge_base",
          "args": [
            "&result",
            "repo",
            "&result",
            "&input_array[i]"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_bases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "273-305",
          "snippet": "int git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n        git_revwalk *walk;\n\tgit_commit_list *result, *list;\n\tgit_array_oid_t array;\n\n\tgit_array_init(array);\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n        git_revwalk *walk;\n\tgit_commit_list *result, *list;\n\tgit_array_oid_t array;\n\n\tgit_array_init(array);\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\"",
            "length"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && input_array"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_base_octopus(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_oid result;\n\tunsigned int i;\n\tint error = -1;\n\n\tassert(out && repo && input_array);\n\n\tif (length < 2) {\n\t\tgiterr_set(GITERR_INVALID, \"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\", length);\n\t\treturn -1;\n\t}\n\n\tresult = input_array[0];\n\tfor (i = 1; i < length; i++) {\n\t\terror = git_merge_base(&result, repo, &result, &input_array[i]);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\t*out = result;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_merge_bases_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "152-185",
    "snippet": "int git_merge_bases_many(git_oidarray *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk;\n\tgit_commit_list *list, *result = NULL;\n\tint error = 0;\n\tgit_array_oid_t array;\n\n\tassert(out && repo && input_array);\n\n\tif ((error = merge_bases_many(&result, &walk, repo, length, input_array)) < 0)\n\t\treturn error;\n\n\tgit_array_init(array);\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL) {\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\ncleanup:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_free",
          "args": [
            "&result"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "75-89",
          "snippet": "void git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nvoid git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oidarray__from_array",
          "args": [
            "out",
            "&array"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "git_oidarray__from_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oidarray.c",
          "lines": "17-21",
          "snippet": "void git_oidarray__from_array(git_oidarray *arr, git_array_oid_t *array)\n{\n\tarr->count = array->size;\n\tarr->ids = array->ptr;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"oidarray.h\"",
            "#include \"git2/oidarray.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"oidarray.h\"\n#include \"git2/oidarray.h\"\n\nvoid git_oidarray__from_array(git_oidarray *arr, git_array_oid_t *array)\n{\n\tarr->count = array->size;\n\tarr->ids = array->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "id",
            "&list->item->oid"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_alloc",
          "args": [
            "array"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_init",
          "args": [
            "array"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_bases_many",
          "args": [
            "&result",
            "&walk",
            "repo",
            "length",
            "input_array"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "merge_bases_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "80-131",
          "snippet": "int merge_bases_many(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk = NULL;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tint error = -1;\n\tunsigned int i;\n\n\tif (length < 2) {\n\t\tgiterr_set(GITERR_INVALID, \"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\", length);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&list, length - 1, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\tgoto on_error;\n\n\tfor (i = 1; i < length; i++) {\n\t\tcommit = git_revwalk__commit_lookup(walk, &input_array[i]);\n\t\tif (commit == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_insert(&list, commit);\n\t}\n\n\tcommit = git_revwalk__commit_lookup(walk, &input_array[0]);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto on_error;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\tgit_vector_free(&list);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&list);\n\tgit_revwalk_free(walk);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint merge_bases_many(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk = NULL;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tint error = -1;\n\tunsigned int i;\n\n\tif (length < 2) {\n\t\tgiterr_set(GITERR_INVALID, \"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\", length);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&list, length - 1, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\tgoto on_error;\n\n\tfor (i = 1; i < length; i++) {\n\t\tcommit = git_revwalk__commit_lookup(walk, &input_array[i]);\n\t\tif (commit == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_insert(&list, commit);\n\t}\n\n\tcommit = git_revwalk__commit_lookup(walk, &input_array[0]);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto on_error;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\tgit_vector_free(&list);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&list);\n\tgit_revwalk_free(walk);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && input_array"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_bases_many(git_oidarray *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk;\n\tgit_commit_list *list, *result = NULL;\n\tint error = 0;\n\tgit_array_oid_t array;\n\n\tassert(out && repo && input_array);\n\n\tif ((error = merge_bases_many(&result, &walk, repo, length, input_array)) < 0)\n\t\treturn error;\n\n\tgit_array_init(array);\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL) {\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\ncleanup:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_merge_base_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "133-150",
    "snippet": "int git_merge_base_many(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk;\n\tgit_commit_list *result = NULL;\n\tint error = 0;\n\n\tassert(out && repo && input_array);\n\n\tif ((error = merge_bases_many(&result, &walk, repo, length, input_array)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, &result->item->oid);\n\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_list_free",
          "args": [
            "&result"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit_list.c",
          "lines": "75-89",
          "snippet": "void git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"revwalk.h\"",
            "#include \"common.h\"",
            "#include \"commit_list.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"revwalk.h\"\n#include \"common.h\"\n#include \"commit_list.h\"\n\nvoid git_commit_list_free(git_commit_list **list_p)\n{\n\tgit_commit_list *list = *list_p;\n\n\tif (list == NULL)\n\t\treturn;\n\n\twhile (list) {\n\t\tgit_commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tgit__free(temp);\n\t}\n\n\t*list_p = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "out",
            "&result->item->oid"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_bases_many",
          "args": [
            "&result",
            "&walk",
            "repo",
            "length",
            "input_array"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "merge_bases_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "80-131",
          "snippet": "int merge_bases_many(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk = NULL;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tint error = -1;\n\tunsigned int i;\n\n\tif (length < 2) {\n\t\tgiterr_set(GITERR_INVALID, \"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\", length);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&list, length - 1, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\tgoto on_error;\n\n\tfor (i = 1; i < length; i++) {\n\t\tcommit = git_revwalk__commit_lookup(walk, &input_array[i]);\n\t\tif (commit == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_insert(&list, commit);\n\t}\n\n\tcommit = git_revwalk__commit_lookup(walk, &input_array[0]);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto on_error;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\tgit_vector_free(&list);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&list);\n\tgit_revwalk_free(walk);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint merge_bases_many(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk = NULL;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tint error = -1;\n\tunsigned int i;\n\n\tif (length < 2) {\n\t\tgiterr_set(GITERR_INVALID, \"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\", length);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&list, length - 1, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\tgoto on_error;\n\n\tfor (i = 1; i < length; i++) {\n\t\tcommit = git_revwalk__commit_lookup(walk, &input_array[i]);\n\t\tif (commit == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_insert(&list, commit);\n\t}\n\n\tcommit = git_revwalk__commit_lookup(walk, &input_array[0]);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto on_error;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\tgit_vector_free(&list);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&list);\n\tgit_revwalk_free(walk);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && input_array"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_base_many(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk;\n\tgit_commit_list *result = NULL;\n\tint error = 0;\n\n\tassert(out && repo && input_array);\n\n\tif ((error = merge_bases_many(&result, &walk, repo, length, input_array)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, &result->item->oid);\n\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "merge_bases_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
    "lines": "80-131",
    "snippet": "int merge_bases_many(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk = NULL;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tint error = -1;\n\tunsigned int i;\n\n\tif (length < 2) {\n\t\tgiterr_set(GITERR_INVALID, \"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\", length);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&list, length - 1, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\tgoto on_error;\n\n\tfor (i = 1; i < length; i++) {\n\t\tcommit = git_revwalk__commit_lookup(walk, &input_array[i]);\n\t\tif (commit == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_insert(&list, commit);\n\t}\n\n\tcommit = git_revwalk__commit_lookup(walk, &input_array[0]);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto on_error;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\tgit_vector_free(&list);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&list);\n\tgit_revwalk_free(walk);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/sys/index.h\"",
      "#include \"git2/annotated_commit.h\"",
      "#include \"git2/oidarray.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/reset.h\"",
      "#include \"git2/refs.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/types.h\"",
      "#include \"oidarray.h\"",
      "#include \"commit.h\"",
      "#include \"annotated_commit.h\"",
      "#include \"oidarray.h\"",
      "#include \"config.h\"",
      "#include \"filebuf.h\"",
      "#include \"index.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"checkout.h\"",
      "#include \"diff.h\"",
      "#include \"refs.h\"",
      "#include \"iterator.h\"",
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"path.h\"",
      "#include \"merge.h\"",
      "#include \"commit_list.h\"",
      "#include \"revwalk.h\"",
      "#include \"repository.h\"",
      "#include \"buffer.h\"",
      "#include \"posix.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&list"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_MERGE",
            "\"No merge base found\""
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__bases_many",
          "args": [
            "&result",
            "walk",
            "commit",
            "&list"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__bases_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "494-559",
          "snippet": "int git_merge__bases_many(git_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tint error;\n\tunsigned int i;\n\tgit_commit_list_node *two;\n\tgit_commit_list *result = NULL, *tmp = NULL;\n\n\t/* If there's only the one commit, there can be no merge bases */\n\tif (twos->length == 0) {\n\t\t*out = NULL;\n\t\treturn 0;\n\t}\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (one == two)\n\t\t\treturn git_commit_list_insert(one, out) ? 0 : -1;\n\t}\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\treturn -1;\n\n\terror = paint_down_to_common(&result, walk, one, twos);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* filter out any stale commits in the results */\n\ttmp = result;\n\tresult = NULL;\n\n\twhile (tmp) {\n\t\tgit_commit_list_node *c = git_commit_list_pop(&tmp);\n\t\tif (!(c->flags & STALE))\n\t\t\tif (git_commit_list_insert_by_date(c, &result) == NULL)\n\t\t\t\treturn -1;\n\t}\n\n\t/*\n\t * more than one merge base -- see if there are redundant merge\n\t * bases and remove them\n\t */\n\tif (result && result->next) {\n\t\tgit_vector redundant = GIT_VECTOR_INIT;\n\n\t\twhile (result)\n\t\t\tgit_vector_insert(&redundant, git_commit_list_pop(&result));\n\n\t\tclear_commit_marks(one, ALL_FLAGS);\n\t\tclear_commit_marks_many(twos, ALL_FLAGS);\n\n\t\tif ((error = remove_redundant(walk, &redundant)) < 0) {\n\t\t\tgit_vector_free(&redundant);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_vector_foreach(&redundant, i, two) {\n\t\t\tif (two != NULL)\n\t\t\t\tgit_commit_list_insert_by_date(two, &result);\n\t\t}\n\n\t\tgit_vector_free(&redundant);\n\t}\n\n\t*out = result;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge__bases_many(git_commit_list **out, git_revwalk *walk, git_commit_list_node *one, git_vector *twos)\n{\n\tint error;\n\tunsigned int i;\n\tgit_commit_list_node *two;\n\tgit_commit_list *result = NULL, *tmp = NULL;\n\n\t/* If there's only the one commit, there can be no merge bases */\n\tif (twos->length == 0) {\n\t\t*out = NULL;\n\t\treturn 0;\n\t}\n\n\t/* if the commit is repeated, we have a our merge base already */\n\tgit_vector_foreach(twos, i, two) {\n\t\tif (one == two)\n\t\t\treturn git_commit_list_insert(one, out) ? 0 : -1;\n\t}\n\n\tif (git_commit_list_parse(walk, one) < 0)\n\t\treturn -1;\n\n\terror = paint_down_to_common(&result, walk, one, twos);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* filter out any stale commits in the results */\n\ttmp = result;\n\tresult = NULL;\n\n\twhile (tmp) {\n\t\tgit_commit_list_node *c = git_commit_list_pop(&tmp);\n\t\tif (!(c->flags & STALE))\n\t\t\tif (git_commit_list_insert_by_date(c, &result) == NULL)\n\t\t\t\treturn -1;\n\t}\n\n\t/*\n\t * more than one merge base -- see if there are redundant merge\n\t * bases and remove them\n\t */\n\tif (result && result->next) {\n\t\tgit_vector redundant = GIT_VECTOR_INIT;\n\n\t\twhile (result)\n\t\t\tgit_vector_insert(&redundant, git_commit_list_pop(&result));\n\n\t\tclear_commit_marks(one, ALL_FLAGS);\n\t\tclear_commit_marks_many(twos, ALL_FLAGS);\n\n\t\tif ((error = remove_redundant(walk, &redundant)) < 0) {\n\t\t\tgit_vector_free(&redundant);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_vector_foreach(&redundant, i, two) {\n\t\t\tif (two != NULL)\n\t\t\t\tgit_commit_list_insert_by_date(two, &result);\n\t\t}\n\n\t\tgit_vector_free(&redundant);\n\t}\n\n\t*out = result;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk__commit_lookup",
          "args": [
            "walk",
            "&input_array[0]"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk__commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "17-42",
          "snippet": "GIT__USE_OIDMAP\n\ngit_commit_list_node *git_revwalk__commit_lookup(\n\tgit_revwalk *walk, const git_oid *oid)\n{\n\tgit_commit_list_node *commit;\n\tkhiter_t pos;\n\tint ret;\n\n\t/* lookup and reserve space if not already present */\n\tpos = kh_get(oid, walk->commits, oid);\n\tif (pos != kh_end(walk->commits))\n\t\treturn kh_value(walk->commits, pos);\n\n\tcommit = git_commit_list_alloc_node(walk);\n\tif (commit == NULL)\n\t\treturn NULL;\n\n\tgit_oid_cpy(&commit->oid, oid);\n\n\tpos = kh_put(oid, walk->commits, &commit->oid, &ret);\n\tassert(ret != 0);\n\tkh_value(walk->commits, pos) = commit;\n\n\treturn commit;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nGIT__USE_OIDMAP\n\ngit_commit_list_node *git_revwalk__commit_lookup(\n\tgit_revwalk *walk, const git_oid *oid)\n{\n\tgit_commit_list_node *commit;\n\tkhiter_t pos;\n\tint ret;\n\n\t/* lookup and reserve space if not already present */\n\tpos = kh_get(oid, walk->commits, oid);\n\tif (pos != kh_end(walk->commits))\n\t\treturn kh_value(walk->commits, pos);\n\n\tcommit = git_commit_list_alloc_node(walk);\n\tif (commit == NULL)\n\t\treturn NULL;\n\n\tgit_oid_cpy(&commit->oid, oid);\n\n\tpos = kh_put(oid, walk->commits, &commit->oid, &ret);\n\tassert(ret != 0);\n\tkh_value(walk->commits, pos) = commit;\n\n\treturn commit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&list",
            "commit"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_new",
          "args": [
            "&walk",
            "repo"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "529-553",
          "snippet": "int git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&list",
            "length - 1",
            "NULL"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\"",
            "length"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint merge_bases_many(git_commit_list **out, git_revwalk **walk_out, git_repository *repo, size_t length, const git_oid input_array[])\n{\n\tgit_revwalk *walk = NULL;\n\tgit_vector list;\n\tgit_commit_list *result = NULL;\n\tgit_commit_list_node *commit;\n\tint error = -1;\n\tunsigned int i;\n\n\tif (length < 2) {\n\t\tgiterr_set(GITERR_INVALID, \"At least two commits are required to find an ancestor. Provided 'length' was %\" PRIuZ \".\", length);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&list, length - 1, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_revwalk_new(&walk, repo) < 0)\n\t\tgoto on_error;\n\n\tfor (i = 1; i < length; i++) {\n\t\tcommit = git_revwalk__commit_lookup(walk, &input_array[i]);\n\t\tif (commit == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_insert(&list, commit);\n\t}\n\n\tcommit = git_revwalk__commit_lookup(walk, &input_array[0]);\n\tif (commit == NULL)\n\t\tgoto on_error;\n\n\tif (git_merge__bases_many(&result, walk, commit, &list) < 0)\n\t\tgoto on_error;\n\n\tif (!result) {\n\t\tgiterr_set(GITERR_MERGE, \"No merge base found\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto on_error;\n\t}\n\n\t*out = result;\n\t*walk_out = walk;\n\n\tgit_vector_free(&list);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&list);\n\tgit_revwalk_free(walk);\n\treturn error;\n}"
  }
]