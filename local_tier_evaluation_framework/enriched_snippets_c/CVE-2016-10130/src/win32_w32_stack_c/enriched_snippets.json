[
  {
    "function_name": "git_win32__stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
    "lines": "177-190",
    "snippet": "int git_win32__stack(\n\tchar * pbuf, int buf_len,\n\tint skip,\n\tconst char *prefix, const char *suffix)\n{\n\tgit_win32__stack__raw_data data;\n\tint error;\n\n\tif ((error = git_win32__stack_capture(&data, skip)) < 0)\n\t\treturn error;\n\tif ((error = git_win32__stack_format(pbuf, buf_len, &data, prefix, suffix)) < 0)\n\t\treturn error;\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"w32_stack.h\"",
      "#include \"win32/posix.h\"",
      "#include \"Dbghelp.h\"",
      "#include \"Windows.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_win32__stack_format",
          "args": [
            "pbuf",
            "buf_len",
            "&data",
            "prefix",
            "suffix"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__stack_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
          "lines": "82-175",
          "snippet": "int git_win32__stack_format(\n\tchar *pbuf, int buf_len,\n\tconst git_win32__stack__raw_data *pdata,\n\tconst char *prefix, const char *suffix)\n{\n#define MY_MAX_FILENAME 255\n\n\t/* SYMBOL_INFO has char FileName[1] at the end.  The docs say to\n\t * to malloc it with extra space for your desired max filename.\n\t */\n\tstruct {\n\t\tSYMBOL_INFO symbol;\n\t\tchar extra[MY_MAX_FILENAME + 1];\n\t} s;\n\n\tIMAGEHLP_LINE64 line;\n\tint buf_used = 0;\n\tunsigned int k;\n\tchar detail[MY_MAX_FILENAME * 2]; /* filename plus space for function name and formatting */\n\tint detail_len;\n\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (!prefix)\n\t\tprefix = \"\\t\";\n\tif (!suffix)\n\t\tsuffix = \"\\n\";\n\n\tmemset(pbuf, 0, buf_len);\n\n\tmemset(&s, 0, sizeof(s));\n\ts.symbol.MaxNameLen = MY_MAX_FILENAME;\n\ts.symbol.SizeOfStruct = sizeof(SYMBOL_INFO);\n\n\tmemset(&line, 0, sizeof(line));\n\tline.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n\n\tfor (k=0; k < pdata->nr_frames; k++) {\n\t\tDWORD64 frame_k = (DWORD64)pdata->frames[k];\n\t\tDWORD dwUnused;\n\n\t\tif (SymFromAddr(g_win32_stack_process, frame_k, 0, &s.symbol) &&\n\t\t\tSymGetLineFromAddr64(g_win32_stack_process, frame_k, &dwUnused, &line)) {\n\t\t\tconst char *pslash;\n\t\t\tconst char *pfile;\n\n\t\t\tpslash = strrchr(line.FileName, '\\\\');\n\t\t\tpfile = ((pslash) ? (pslash+1) : line.FileName);\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s%s:%d> %s%s\",\n\t\t\t\t\t   prefix, pfile, line.LineNumber, s.symbol.Name, suffix);\n\t\t} else {\n\t\t\t/* This happens when we cross into another module.\n\t\t\t * For example, in CLAR tests, this is typically\n\t\t\t * the CRT startup code.  Just print an unknown\n\t\t\t * frame and continue.\n\t\t\t */\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s??%s\", prefix, suffix);\n\t\t}\n\t\tdetail_len = strlen(detail);\n\n\t\tif (buf_len < (buf_used + detail_len + 1)) {\n\t\t\t/* we don't have room for this frame in the buffer, so just stop. */\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\tbuf_used += detail_len;\n\t}\n\n\t/* \"aux_id\" 0 is reserved to mean no aux data. This is needed to handle\n\t * allocs that occur before the aux callbacks were registered.\n\t */\n\tif (pdata->aux_id > 0) {\n\t\tp_snprintf(detail, sizeof(detail), \"%saux_id: %d%s\",\n\t\t\t\t   prefix, pdata->aux_id, suffix);\n\t\tdetail_len = strlen(detail);\n\t\tif ((buf_used + detail_len + 1) < buf_len) {\n\t\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\t\tbuf_used += detail_len;\n\t\t}\n\n\t\t/* If an \"aux\" data provider is still registered, ask it to append its detailed\n\t\t * data to the end of ours using the \"aux_id\" it gave us when this de-duped\n\t\t * item was created.\n\t\t */\n\t\tif (g_aux_cb_lookup)\n\t\t\t(g_aux_cb_lookup)(pdata->aux_id, &pbuf[buf_used], (buf_len - buf_used - 1));\n\t}\n\n\treturn GIT_OK;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"w32_stack.h\"",
            "#include \"win32/posix.h\"",
            "#include \"Dbghelp.h\"",
            "#include \"Windows.h\""
          ],
          "macros_used": [
            "#define MY_MAX_FILENAME 255"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\n#define MY_MAX_FILENAME 255\n\nint git_win32__stack_format(\n\tchar *pbuf, int buf_len,\n\tconst git_win32__stack__raw_data *pdata,\n\tconst char *prefix, const char *suffix)\n{\n#define MY_MAX_FILENAME 255\n\n\t/* SYMBOL_INFO has char FileName[1] at the end.  The docs say to\n\t * to malloc it with extra space for your desired max filename.\n\t */\n\tstruct {\n\t\tSYMBOL_INFO symbol;\n\t\tchar extra[MY_MAX_FILENAME + 1];\n\t} s;\n\n\tIMAGEHLP_LINE64 line;\n\tint buf_used = 0;\n\tunsigned int k;\n\tchar detail[MY_MAX_FILENAME * 2]; /* filename plus space for function name and formatting */\n\tint detail_len;\n\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (!prefix)\n\t\tprefix = \"\\t\";\n\tif (!suffix)\n\t\tsuffix = \"\\n\";\n\n\tmemset(pbuf, 0, buf_len);\n\n\tmemset(&s, 0, sizeof(s));\n\ts.symbol.MaxNameLen = MY_MAX_FILENAME;\n\ts.symbol.SizeOfStruct = sizeof(SYMBOL_INFO);\n\n\tmemset(&line, 0, sizeof(line));\n\tline.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n\n\tfor (k=0; k < pdata->nr_frames; k++) {\n\t\tDWORD64 frame_k = (DWORD64)pdata->frames[k];\n\t\tDWORD dwUnused;\n\n\t\tif (SymFromAddr(g_win32_stack_process, frame_k, 0, &s.symbol) &&\n\t\t\tSymGetLineFromAddr64(g_win32_stack_process, frame_k, &dwUnused, &line)) {\n\t\t\tconst char *pslash;\n\t\t\tconst char *pfile;\n\n\t\t\tpslash = strrchr(line.FileName, '\\\\');\n\t\t\tpfile = ((pslash) ? (pslash+1) : line.FileName);\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s%s:%d> %s%s\",\n\t\t\t\t\t   prefix, pfile, line.LineNumber, s.symbol.Name, suffix);\n\t\t} else {\n\t\t\t/* This happens when we cross into another module.\n\t\t\t * For example, in CLAR tests, this is typically\n\t\t\t * the CRT startup code.  Just print an unknown\n\t\t\t * frame and continue.\n\t\t\t */\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s??%s\", prefix, suffix);\n\t\t}\n\t\tdetail_len = strlen(detail);\n\n\t\tif (buf_len < (buf_used + detail_len + 1)) {\n\t\t\t/* we don't have room for this frame in the buffer, so just stop. */\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\tbuf_used += detail_len;\n\t}\n\n\t/* \"aux_id\" 0 is reserved to mean no aux data. This is needed to handle\n\t * allocs that occur before the aux callbacks were registered.\n\t */\n\tif (pdata->aux_id > 0) {\n\t\tp_snprintf(detail, sizeof(detail), \"%saux_id: %d%s\",\n\t\t\t\t   prefix, pdata->aux_id, suffix);\n\t\tdetail_len = strlen(detail);\n\t\tif ((buf_used + detail_len + 1) < buf_len) {\n\t\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\t\tbuf_used += detail_len;\n\t\t}\n\n\t\t/* If an \"aux\" data provider is still registered, ask it to append its detailed\n\t\t * data to the end of ours using the \"aux_id\" it gave us when this de-duped\n\t\t * item was created.\n\t\t */\n\t\tif (g_aux_cb_lookup)\n\t\t\t(g_aux_cb_lookup)(pdata->aux_id, &pbuf[buf_used], (buf_len - buf_used - 1));\n\t}\n\n\treturn GIT_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32__stack_capture",
          "args": [
            "&data",
            "skip"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__stack_capture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
          "lines": "54-73",
          "snippet": "int git_win32__stack_capture(git_win32__stack__raw_data *pdata, int skip)\n{\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tmemset(pdata, 0, sizeof(*pdata));\n\tpdata->nr_frames = RtlCaptureStackBackTrace(\n\t\tskip+1, GIT_WIN32__STACK__MAX_FRAMES, pdata->frames, NULL);\n\n\t/* If an \"aux\" data provider was registered, ask it to capture\n\t * whatever data it needs and give us an \"aux_id\" to it so that\n\t * we can refer to it later when reporting.\n\t */\n\tif (g_aux_cb_alloc)\n\t\t(g_aux_cb_alloc)(&pdata->aux_id);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"w32_stack.h\"",
            "#include \"win32/posix.h\"",
            "#include \"Dbghelp.h\"",
            "#include \"Windows.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\nint git_win32__stack_capture(git_win32__stack__raw_data *pdata, int skip)\n{\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tmemset(pdata, 0, sizeof(*pdata));\n\tpdata->nr_frames = RtlCaptureStackBackTrace(\n\t\tskip+1, GIT_WIN32__STACK__MAX_FRAMES, pdata->frames, NULL);\n\n\t/* If an \"aux\" data provider was registered, ask it to capture\n\t * whatever data it needs and give us an \"aux_id\" to it so that\n\t * we can refer to it later when reporting.\n\t */\n\tif (g_aux_cb_alloc)\n\t\t(g_aux_cb_alloc)(&pdata->aux_id);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\nint git_win32__stack(\n\tchar * pbuf, int buf_len,\n\tint skip,\n\tconst char *prefix, const char *suffix)\n{\n\tgit_win32__stack__raw_data data;\n\tint error;\n\n\tif ((error = git_win32__stack_capture(&data, skip)) < 0)\n\t\treturn error;\n\tif ((error = git_win32__stack_format(pbuf, buf_len, &data, prefix, suffix)) < 0)\n\t\treturn error;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_win32__stack_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
    "lines": "82-175",
    "snippet": "int git_win32__stack_format(\n\tchar *pbuf, int buf_len,\n\tconst git_win32__stack__raw_data *pdata,\n\tconst char *prefix, const char *suffix)\n{\n#define MY_MAX_FILENAME 255\n\n\t/* SYMBOL_INFO has char FileName[1] at the end.  The docs say to\n\t * to malloc it with extra space for your desired max filename.\n\t */\n\tstruct {\n\t\tSYMBOL_INFO symbol;\n\t\tchar extra[MY_MAX_FILENAME + 1];\n\t} s;\n\n\tIMAGEHLP_LINE64 line;\n\tint buf_used = 0;\n\tunsigned int k;\n\tchar detail[MY_MAX_FILENAME * 2]; /* filename plus space for function name and formatting */\n\tint detail_len;\n\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (!prefix)\n\t\tprefix = \"\\t\";\n\tif (!suffix)\n\t\tsuffix = \"\\n\";\n\n\tmemset(pbuf, 0, buf_len);\n\n\tmemset(&s, 0, sizeof(s));\n\ts.symbol.MaxNameLen = MY_MAX_FILENAME;\n\ts.symbol.SizeOfStruct = sizeof(SYMBOL_INFO);\n\n\tmemset(&line, 0, sizeof(line));\n\tline.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n\n\tfor (k=0; k < pdata->nr_frames; k++) {\n\t\tDWORD64 frame_k = (DWORD64)pdata->frames[k];\n\t\tDWORD dwUnused;\n\n\t\tif (SymFromAddr(g_win32_stack_process, frame_k, 0, &s.symbol) &&\n\t\t\tSymGetLineFromAddr64(g_win32_stack_process, frame_k, &dwUnused, &line)) {\n\t\t\tconst char *pslash;\n\t\t\tconst char *pfile;\n\n\t\t\tpslash = strrchr(line.FileName, '\\\\');\n\t\t\tpfile = ((pslash) ? (pslash+1) : line.FileName);\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s%s:%d> %s%s\",\n\t\t\t\t\t   prefix, pfile, line.LineNumber, s.symbol.Name, suffix);\n\t\t} else {\n\t\t\t/* This happens when we cross into another module.\n\t\t\t * For example, in CLAR tests, this is typically\n\t\t\t * the CRT startup code.  Just print an unknown\n\t\t\t * frame and continue.\n\t\t\t */\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s??%s\", prefix, suffix);\n\t\t}\n\t\tdetail_len = strlen(detail);\n\n\t\tif (buf_len < (buf_used + detail_len + 1)) {\n\t\t\t/* we don't have room for this frame in the buffer, so just stop. */\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\tbuf_used += detail_len;\n\t}\n\n\t/* \"aux_id\" 0 is reserved to mean no aux data. This is needed to handle\n\t * allocs that occur before the aux callbacks were registered.\n\t */\n\tif (pdata->aux_id > 0) {\n\t\tp_snprintf(detail, sizeof(detail), \"%saux_id: %d%s\",\n\t\t\t\t   prefix, pdata->aux_id, suffix);\n\t\tdetail_len = strlen(detail);\n\t\tif ((buf_used + detail_len + 1) < buf_len) {\n\t\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\t\tbuf_used += detail_len;\n\t\t}\n\n\t\t/* If an \"aux\" data provider is still registered, ask it to append its detailed\n\t\t * data to the end of ours using the \"aux_id\" it gave us when this de-duped\n\t\t * item was created.\n\t\t */\n\t\tif (g_aux_cb_lookup)\n\t\t\t(g_aux_cb_lookup)(pdata->aux_id, &pbuf[buf_used], (buf_len - buf_used - 1));\n\t}\n\n\treturn GIT_OK;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"w32_stack.h\"",
      "#include \"win32/posix.h\"",
      "#include \"Dbghelp.h\"",
      "#include \"Windows.h\""
    ],
    "macros_used": [
      "#define MY_MAX_FILENAME 255"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "pdata->aux_id",
            "&pbuf[buf_used]",
            "(buf_len - buf_used - 1)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&pbuf[buf_used]",
            "detail",
            "detail_len"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "detail"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_snprintf",
          "args": [
            "detail",
            "sizeof(detail)",
            "\"%saux_id: %d%s\"",
            "prefix",
            "pdata->aux_id",
            "suffix"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "p_snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "548-558",
          "snippet": "int p_snprintf(char *buffer, size_t count, const char *format, ...)\n{\n\tva_list va;\n\tint r;\n\n\tva_start(va, format);\n\tr = p_vsnprintf(buffer, count, format, va);\n\tva_end(va);\n\n\treturn r;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_snprintf(char *buffer, size_t count, const char *format, ...)\n{\n\tva_list va;\n\tint r;\n\n\tva_start(va, format);\n\tr = p_vsnprintf(buffer, count, format, va);\n\tva_end(va);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&pbuf[buf_used]",
            "detail",
            "detail_len"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "detail"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line.FileName",
            "'\\\\'"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SymGetLineFromAddr64",
          "args": [
            "g_win32_stack_process",
            "frame_k",
            "&dwUnused",
            "&line"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SymFromAddr",
          "args": [
            "g_win32_stack_process",
            "frame_k",
            "0",
            "&s.symbol"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&line",
            "0",
            "sizeof(line)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&s",
            "0",
            "sizeof(s)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pbuf",
            "0",
            "buf_len"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"git_win32_stack not initialized.\""
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\n#define MY_MAX_FILENAME 255\n\nint git_win32__stack_format(\n\tchar *pbuf, int buf_len,\n\tconst git_win32__stack__raw_data *pdata,\n\tconst char *prefix, const char *suffix)\n{\n#define MY_MAX_FILENAME 255\n\n\t/* SYMBOL_INFO has char FileName[1] at the end.  The docs say to\n\t * to malloc it with extra space for your desired max filename.\n\t */\n\tstruct {\n\t\tSYMBOL_INFO symbol;\n\t\tchar extra[MY_MAX_FILENAME + 1];\n\t} s;\n\n\tIMAGEHLP_LINE64 line;\n\tint buf_used = 0;\n\tunsigned int k;\n\tchar detail[MY_MAX_FILENAME * 2]; /* filename plus space for function name and formatting */\n\tint detail_len;\n\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (!prefix)\n\t\tprefix = \"\\t\";\n\tif (!suffix)\n\t\tsuffix = \"\\n\";\n\n\tmemset(pbuf, 0, buf_len);\n\n\tmemset(&s, 0, sizeof(s));\n\ts.symbol.MaxNameLen = MY_MAX_FILENAME;\n\ts.symbol.SizeOfStruct = sizeof(SYMBOL_INFO);\n\n\tmemset(&line, 0, sizeof(line));\n\tline.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n\n\tfor (k=0; k < pdata->nr_frames; k++) {\n\t\tDWORD64 frame_k = (DWORD64)pdata->frames[k];\n\t\tDWORD dwUnused;\n\n\t\tif (SymFromAddr(g_win32_stack_process, frame_k, 0, &s.symbol) &&\n\t\t\tSymGetLineFromAddr64(g_win32_stack_process, frame_k, &dwUnused, &line)) {\n\t\t\tconst char *pslash;\n\t\t\tconst char *pfile;\n\n\t\t\tpslash = strrchr(line.FileName, '\\\\');\n\t\t\tpfile = ((pslash) ? (pslash+1) : line.FileName);\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s%s:%d> %s%s\",\n\t\t\t\t\t   prefix, pfile, line.LineNumber, s.symbol.Name, suffix);\n\t\t} else {\n\t\t\t/* This happens when we cross into another module.\n\t\t\t * For example, in CLAR tests, this is typically\n\t\t\t * the CRT startup code.  Just print an unknown\n\t\t\t * frame and continue.\n\t\t\t */\n\t\t\tp_snprintf(detail, sizeof(detail), \"%s??%s\", prefix, suffix);\n\t\t}\n\t\tdetail_len = strlen(detail);\n\n\t\tif (buf_len < (buf_used + detail_len + 1)) {\n\t\t\t/* we don't have room for this frame in the buffer, so just stop. */\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\tbuf_used += detail_len;\n\t}\n\n\t/* \"aux_id\" 0 is reserved to mean no aux data. This is needed to handle\n\t * allocs that occur before the aux callbacks were registered.\n\t */\n\tif (pdata->aux_id > 0) {\n\t\tp_snprintf(detail, sizeof(detail), \"%saux_id: %d%s\",\n\t\t\t\t   prefix, pdata->aux_id, suffix);\n\t\tdetail_len = strlen(detail);\n\t\tif ((buf_used + detail_len + 1) < buf_len) {\n\t\t\tmemcpy(&pbuf[buf_used], detail, detail_len);\n\t\t\tbuf_used += detail_len;\n\t\t}\n\n\t\t/* If an \"aux\" data provider is still registered, ask it to append its detailed\n\t\t * data to the end of ours using the \"aux_id\" it gave us when this de-duped\n\t\t * item was created.\n\t\t */\n\t\tif (g_aux_cb_lookup)\n\t\t\t(g_aux_cb_lookup)(pdata->aux_id, &pbuf[buf_used], (buf_len - buf_used - 1));\n\t}\n\n\treturn GIT_OK;\n}"
  },
  {
    "function_name": "git_win32__stack_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
    "lines": "75-80",
    "snippet": "int git_win32__stack_compare(\n\tgit_win32__stack__raw_data *d1,\n\tgit_win32__stack__raw_data *d2)\n{\n\treturn memcmp(d1, d2, sizeof(*d1));\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"w32_stack.h\"",
      "#include \"win32/posix.h\"",
      "#include \"Dbghelp.h\"",
      "#include \"Windows.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "d1",
            "d2",
            "sizeof(*d1)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\nint git_win32__stack_compare(\n\tgit_win32__stack__raw_data *d1,\n\tgit_win32__stack__raw_data *d2)\n{\n\treturn memcmp(d1, d2, sizeof(*d1));\n}"
  },
  {
    "function_name": "git_win32__stack_capture",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
    "lines": "54-73",
    "snippet": "int git_win32__stack_capture(git_win32__stack__raw_data *pdata, int skip)\n{\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tmemset(pdata, 0, sizeof(*pdata));\n\tpdata->nr_frames = RtlCaptureStackBackTrace(\n\t\tskip+1, GIT_WIN32__STACK__MAX_FRAMES, pdata->frames, NULL);\n\n\t/* If an \"aux\" data provider was registered, ask it to capture\n\t * whatever data it needs and give us an \"aux_id\" to it so that\n\t * we can refer to it later when reporting.\n\t */\n\tif (g_aux_cb_alloc)\n\t\t(g_aux_cb_alloc)(&pdata->aux_id);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"w32_stack.h\"",
      "#include \"win32/posix.h\"",
      "#include \"Dbghelp.h\"",
      "#include \"Windows.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "&pdata->aux_id"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RtlCaptureStackBackTrace",
          "args": [
            "skip+1",
            "GIT_WIN32__STACK__MAX_FRAMES",
            "pdata->frames",
            "NULL"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pdata",
            "0",
            "sizeof(*pdata)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"git_win32_stack not initialized.\""
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\nint git_win32__stack_capture(git_win32__stack__raw_data *pdata, int skip)\n{\n\tif (!g_win32_stack_initialized) {\n\t\tgiterr_set(GITERR_INVALID, \"git_win32_stack not initialized.\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tmemset(pdata, 0, sizeof(*pdata));\n\tpdata->nr_frames = RtlCaptureStackBackTrace(\n\t\tskip+1, GIT_WIN32__STACK__MAX_FRAMES, pdata->frames, NULL);\n\n\t/* If an \"aux\" data provider was registered, ask it to capture\n\t * whatever data it needs and give us an \"aux_id\" to it so that\n\t * we can refer to it later when reporting.\n\t */\n\tif (g_aux_cb_alloc)\n\t\t(g_aux_cb_alloc)(&pdata->aux_id);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_win32__stack_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
    "lines": "45-52",
    "snippet": "void git_win32__stack_cleanup(void)\n{\n\tif (g_win32_stack_initialized) {\n\t\tSymCleanup(g_win32_stack_process);\n\t\tg_win32_stack_process = INVALID_HANDLE_VALUE;\n\t\tg_win32_stack_initialized = false;\n\t}\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"w32_stack.h\"",
      "#include \"win32/posix.h\"",
      "#include \"Dbghelp.h\"",
      "#include \"Windows.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SymCleanup",
          "args": [
            "g_win32_stack_process"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\nvoid git_win32__stack_cleanup(void)\n{\n\tif (g_win32_stack_initialized) {\n\t\tSymCleanup(g_win32_stack_process);\n\t\tg_win32_stack_process = INVALID_HANDLE_VALUE;\n\t\tg_win32_stack_initialized = false;\n\t}\n}"
  },
  {
    "function_name": "git_win32__stack_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
    "lines": "35-43",
    "snippet": "void git_win32__stack_init(void)\n{\n\tif (!g_win32_stack_initialized) {\n\t\tg_win32_stack_process = GetCurrentProcess();\n\t\tSymSetOptions(SYMOPT_LOAD_LINES);\n\t\tSymInitialize(g_win32_stack_process, NULL, TRUE);\n\t\tg_win32_stack_initialized = true;\n\t}\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"w32_stack.h\"",
      "#include \"win32/posix.h\"",
      "#include \"Dbghelp.h\"",
      "#include \"Windows.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SymInitialize",
          "args": [
            "g_win32_stack_process",
            "NULL",
            "TRUE"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SymSetOptions",
          "args": [
            "SYMOPT_LOAD_LINES"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentProcess",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\nvoid git_win32__stack_init(void)\n{\n\tif (!g_win32_stack_initialized) {\n\t\tg_win32_stack_process = GetCurrentProcess();\n\t\tSymSetOptions(SYMOPT_LOAD_LINES);\n\t\tSymInitialize(g_win32_stack_process, NULL, TRUE);\n\t\tg_win32_stack_initialized = true;\n\t}\n}"
  },
  {
    "function_name": "git_win32__stack__set_aux_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_stack.c",
    "lines": "25-33",
    "snippet": "int git_win32__stack__set_aux_cb(\n\tgit_win32__stack__aux_cb_alloc cb_alloc,\n\tgit_win32__stack__aux_cb_lookup cb_lookup)\n{\n\tg_aux_cb_alloc = cb_alloc;\n\tg_aux_cb_lookup = cb_lookup;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"w32_stack.h\"",
      "#include \"win32/posix.h\"",
      "#include \"Dbghelp.h\"",
      "#include \"Windows.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hash.h\"\n#include \"w32_stack.h\"\n#include \"win32/posix.h\"\n#include \"Dbghelp.h\"\n#include \"Windows.h\"\n\nint git_win32__stack__set_aux_cb(\n\tgit_win32__stack__aux_cb_alloc cb_alloc,\n\tgit_win32__stack__aux_cb_lookup cb_lookup)\n{\n\tg_aux_cb_alloc = cb_alloc;\n\tg_aux_cb_lookup = cb_lookup;\n\n\treturn 0;\n}"
  }
]