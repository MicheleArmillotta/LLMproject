[
  {
    "function_name": "config_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1876-1948",
    "snippet": "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
      "static char *escape_value(const char *ptr);",
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&reader->buffer"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&file"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "&file",
            "git_buf_cstr(&buf)",
            "git_buf_len(&buf)"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&buf"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_attach",
          "args": [
            "&cfg->locked_content",
            "git_buf_detach(&buf)",
            "len"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_attach_notowned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "505-517",
          "snippet": "void git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&buf"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "section"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_parse",
          "args": [
            "reader",
            "write_on_section",
            "write_on_variable",
            "write_on_comment",
            "write_on_eof",
            "&write_data"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "config_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1470-1530",
          "snippet": "static int config_parse(\n\tstruct reader *reader,\n\tint (*on_section)(struct reader **reader, const char *current_section, const char *line, size_t line_len, void *data),\n\tint (*on_variable)(struct reader **reader, const char *current_section, char *var_name, char *var_value, const char *line, size_t line_len, void *data),\n\tint (*on_comment)(struct reader **reader, const char *line, size_t line_len, void *data),\n\tint (*on_eof)(struct reader **reader, const char *current_section, void *data),\n\tvoid *data)\n{\n\tchar *current_section = NULL, *var_name, *var_value, *line_start;\n\tchar c;\n\tsize_t line_len;\n\tint result = 0;\n\n\tskip_bom(reader);\n\n\twhile (result == 0 && !reader->eof) {\n\t\tline_start = reader->read_ptr;\n\n\t\tc = reader_peek(reader, SKIP_WHITESPACE);\n\n\t\tswitch (c) {\n\t\tcase '\\0': /* EOF when peeking, set EOF in the reader to exit the loop */\n\t\t\treader->eof = 1;\n\t\t\tbreak;\n\n\t\tcase '[': /* section header, new section begins */\n\t\t\tgit__free(current_section);\n\t\t\tcurrent_section = NULL;\n\n\t\t\tif ((result = parse_section_header(reader, &current_section)) == 0 && on_section) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_section(&reader, current_section, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\n': /* comment or whitespace-only */\n\t\tcase ';':\n\t\tcase '#':\n\t\t\treader_consume_line(reader);\n\n\t\t\tif (on_comment) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_comment(&reader, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: /* assume variable declaration */\n\t\t\tif ((result = parse_variable(reader, &var_name, &var_value)) == 0 && on_variable) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_variable(&reader, current_section, var_name, var_value, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (on_eof)\n\t\tresult = on_eof(&reader, current_section, data);\n\n\tgit__free(current_section);\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define SKIP_WHITESPACE (1 << 1)"
          ],
          "globals_used": [
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\n#define SKIP_WHITESPACE (1 << 1)\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_parse(\n\tstruct reader *reader,\n\tint (*on_section)(struct reader **reader, const char *current_section, const char *line, size_t line_len, void *data),\n\tint (*on_variable)(struct reader **reader, const char *current_section, char *var_name, char *var_value, const char *line, size_t line_len, void *data),\n\tint (*on_comment)(struct reader **reader, const char *line, size_t line_len, void *data),\n\tint (*on_eof)(struct reader **reader, const char *current_section, void *data),\n\tvoid *data)\n{\n\tchar *current_section = NULL, *var_name, *var_value, *line_start;\n\tchar c;\n\tsize_t line_len;\n\tint result = 0;\n\n\tskip_bom(reader);\n\n\twhile (result == 0 && !reader->eof) {\n\t\tline_start = reader->read_ptr;\n\n\t\tc = reader_peek(reader, SKIP_WHITESPACE);\n\n\t\tswitch (c) {\n\t\tcase '\\0': /* EOF when peeking, set EOF in the reader to exit the loop */\n\t\t\treader->eof = 1;\n\t\t\tbreak;\n\n\t\tcase '[': /* section header, new section begins */\n\t\t\tgit__free(current_section);\n\t\t\tcurrent_section = NULL;\n\n\t\t\tif ((result = parse_section_header(reader, &current_section)) == 0 && on_section) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_section(&reader, current_section, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\n': /* comment or whitespace-only */\n\t\tcase ';':\n\t\tcase '#':\n\t\t\treader_consume_line(reader);\n\n\t\t\tif (on_comment) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_comment(&reader, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: /* assume variable declaration */\n\t\t\tif ((result = parse_variable(reader, &var_name, &var_value)) == 0 && on_variable) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_variable(&reader, current_section, var_name, var_value, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (on_eof)\n\t\tresult = on_eof(&reader, current_section, data);\n\n\tgit__free(current_section);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "&write_data.buffered_comment",
            "0"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "key",
            "ldot - key"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "key",
            "'.'"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&reader->buffer"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "&reader->buffer",
            "cfg->file_path"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&file",
            "cfg->file_path",
            "GIT_FILEBUF_HASH_CONTENTS",
            "GIT_CONFIG_FILE_MODE"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&reader->buffer",
            "git_buf_cstr(&cfg->locked_content)"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "cfg->readers",
            "0"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}"
  },
  {
    "function_name": "write_on_eof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1842-1871",
    "snippet": "static int write_on_eof(\n\tstruct reader **reader, const char *current_section, void *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tint result = 0;\n\n\tGIT_UNUSED(reader);\n\n\t/*\n\t * If we've buffered comments when reaching EOF, make sure to dump them.\n\t */\n\tif ((result = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size)) < 0)\n\t\treturn result;\n\n\t/* If we are at the EOF and have not written our value (again, for a\n\t * simple name/value set, not a multivar) then we have never seen the\n\t * section in question and should create a new section and write the\n\t * value.\n\t */\n\tif ((!write_data->preg || !write_data->preg_replaced) && write_data->value) {\n\t\t/* write the section header unless we're already in it */\n\t\tif (!current_section || strcmp(current_section, write_data->section))\n\t\t\tresult = write_section(write_data->buf, write_data->section);\n\n\t\tif (!result)\n\t\t\tresult = write_value(write_data);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
      "static char *escape_value(const char *ptr);",
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_value",
          "args": [
            "write_data"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "write_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1726-1743",
          "snippet": "static int write_value(struct write_data *write_data)\n{\n\tconst char *q;\n\tint result;\n\n\tq = quotes_for_value(write_data->value);\n\tresult = git_buf_printf(write_data->buf,\n\t\t\"\\t%s = %s%s%s\\n\", write_data->name, q, write_data->value, q);\n\n\t/* If we are updating a single name/value, we're done.  Setting `value`\n\t * to `NULL` will prevent us from trying to write it again later (in\n\t * `write_on_section`) if we see the same section repeated.\n\t */\n\tif (!write_data->preg)\n\t\twrite_data->value = NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int write_value(struct write_data *write_data)\n{\n\tconst char *q;\n\tint result;\n\n\tq = quotes_for_value(write_data->value);\n\tresult = git_buf_printf(write_data->buf,\n\t\t\"\\t%s = %s%s%s\\n\", write_data->name, q, write_data->value, q);\n\n\t/* If we are updating a single name/value, we're done.  Setting `value`\n\t * to `NULL` will prevent us from trying to write it again later (in\n\t * `write_on_section`) if we see the same section repeated.\n\t */\n\tif (!write_data->preg)\n\t\twrite_data->value = NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_section",
          "args": [
            "write_data->buf",
            "write_data->section"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "write_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1652-1680",
          "snippet": "static int write_section(git_buf *fbuf, const char *key)\n{\n\tint result;\n\tconst char *dot;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* All of this just for [section \"subsection\"] */\n\tdot = strchr(key, '.');\n\tgit_buf_putc(&buf, '[');\n\tif (dot == NULL) {\n\t\tgit_buf_puts(&buf, key);\n\t} else {\n\t\tchar *escaped;\n\t\tgit_buf_put(&buf, key, dot - key);\n\t\tescaped = escape_value(dot + 1);\n\t\tGITERR_CHECK_ALLOC(escaped);\n\t\tgit_buf_printf(&buf, \" \\\"%s\\\"\", escaped);\n\t\tgit__free(escaped);\n\t}\n\tgit_buf_puts(&buf, \"]\\n\");\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tresult = git_buf_put(fbuf, git_buf_cstr(&buf), buf.size);\n\tgit_buf_free(&buf);\n\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
            "static const char *escaped = \"\\n\\t\\b\\\"\\\\\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nstatic const char *escaped = \"\\n\\t\\b\\\"\\\\\";\n\nstatic int write_section(git_buf *fbuf, const char *key)\n{\n\tint result;\n\tconst char *dot;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* All of this just for [section \"subsection\"] */\n\tdot = strchr(key, '.');\n\tgit_buf_putc(&buf, '[');\n\tif (dot == NULL) {\n\t\tgit_buf_puts(&buf, key);\n\t} else {\n\t\tchar *escaped;\n\t\tgit_buf_put(&buf, key, dot - key);\n\t\tescaped = escape_value(dot + 1);\n\t\tGITERR_CHECK_ALLOC(escaped);\n\t\tgit_buf_printf(&buf, \" \\\"%s\\\"\", escaped);\n\t\tgit__free(escaped);\n\t}\n\tgit_buf_puts(&buf, \"]\\n\");\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tresult = git_buf_put(fbuf, git_buf_cstr(&buf), buf.size);\n\tgit_buf_free(&buf);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "current_section",
            "write_data->section"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "write_data->buf",
            "write_data->buffered_comment.ptr",
            "write_data->buffered_comment.size"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "reader"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int write_on_eof(\n\tstruct reader **reader, const char *current_section, void *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tint result = 0;\n\n\tGIT_UNUSED(reader);\n\n\t/*\n\t * If we've buffered comments when reaching EOF, make sure to dump them.\n\t */\n\tif ((result = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size)) < 0)\n\t\treturn result;\n\n\t/* If we are at the EOF and have not written our value (again, for a\n\t * simple name/value set, not a multivar) then we have never seen the\n\t * section in question and should create a new section and write the\n\t * value.\n\t */\n\tif ((!write_data->preg || !write_data->preg_replaced) && write_data->value) {\n\t\t/* write the section header unless we're already in it */\n\t\tif (!current_section || strcmp(current_section, write_data->section))\n\t\t\tresult = write_section(write_data->buf, write_data->section);\n\n\t\tif (!result)\n\t\t\tresult = write_value(write_data);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "write_on_comment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1832-1840",
    "snippet": "static int write_on_comment(struct reader **reader, const char *line, size_t line_len, void *data)\n{\n\tstruct write_data *write_data;\n\n\tGIT_UNUSED(reader);\n\n\twrite_data = (struct write_data *)data;\n\treturn write_line_to(&write_data->buffered_comment, line, line_len);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line_to",
          "args": [
            "&write_data->buffered_comment",
            "line",
            "line_len"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "write_line_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1711-1719",
          "snippet": "static int write_line_to(git_buf *buf, const char *line, size_t line_len)\n{\n\tint result = git_buf_put(buf, line, line_len);\n\n\tif (!result && line_len && line[line_len-1] != '\\n')\n\t\tresult = git_buf_printf(buf, \"\\n\");\n\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int write_line_to(git_buf *buf, const char *line, size_t line_len)\n{\n\tint result = git_buf_put(buf, line, line_len);\n\n\tif (!result && line_len && line[line_len-1] != '\\n')\n\t\tresult = git_buf_printf(buf, \"\\n\");\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "reader"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int write_on_comment(struct reader **reader, const char *line, size_t line_len, void *data)\n{\n\tstruct write_data *write_data;\n\n\tGIT_UNUSED(reader);\n\n\twrite_data = (struct write_data *)data;\n\treturn write_line_to(&write_data->buffered_comment, line, line_len);\n}"
  },
  {
    "function_name": "write_on_variable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1781-1830",
    "snippet": "static int write_on_variable(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tchar *var_name,\n\tchar *var_value,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tbool has_matched = false;\n\tint error;\n\n\tGIT_UNUSED(reader);\n\tGIT_UNUSED(current_section);\n\n\t/*\n\t * If there were comments just before this variable, let's dump them as well.\n\t */\n\tif ((error = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size)) < 0)\n\t\treturn error;\n\n\tgit_buf_clear(&write_data->buffered_comment);\n\n\t/* See if we are to update this name/value pair; first examine name */\n\tif (write_data->in_section &&\n\t\tstrcasecmp(write_data->name, var_name) == 0)\n\t\thas_matched = true;\n\n\t/* If we have a regex to match the value, see if it matches */\n\tif (has_matched && write_data->preg != NULL)\n\t\thas_matched = (regexec(write_data->preg, var_value, 0, NULL, 0) == 0);\n\n\tgit__free(var_name);\n\tgit__free(var_value);\n\n\t/* If this isn't the name/value we're looking for, simply dump the\n\t * existing data back out and continue on.\n\t */\n\tif (!has_matched)\n\t\treturn write_line(write_data, line, line_len);\n\n\twrite_data->preg_replaced = 1;\n\n\t/* If value is NULL, we are deleting this value; write nothing. */\n\tif (!write_data->value)\n\t\treturn 0;\n\n\treturn write_value(write_data);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
      "static char *escape_value(const char *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_value",
          "args": [
            "write_data"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "write_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1726-1743",
          "snippet": "static int write_value(struct write_data *write_data)\n{\n\tconst char *q;\n\tint result;\n\n\tq = quotes_for_value(write_data->value);\n\tresult = git_buf_printf(write_data->buf,\n\t\t\"\\t%s = %s%s%s\\n\", write_data->name, q, write_data->value, q);\n\n\t/* If we are updating a single name/value, we're done.  Setting `value`\n\t * to `NULL` will prevent us from trying to write it again later (in\n\t * `write_on_section`) if we see the same section repeated.\n\t */\n\tif (!write_data->preg)\n\t\twrite_data->value = NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int write_value(struct write_data *write_data)\n{\n\tconst char *q;\n\tint result;\n\n\tq = quotes_for_value(write_data->value);\n\tresult = git_buf_printf(write_data->buf,\n\t\t\"\\t%s = %s%s%s\\n\", write_data->name, q, write_data->value, q);\n\n\t/* If we are updating a single name/value, we're done.  Setting `value`\n\t * to `NULL` will prevent us from trying to write it again later (in\n\t * `write_on_section`) if we see the same section repeated.\n\t */\n\tif (!write_data->preg)\n\t\twrite_data->value = NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "write_data",
            "line",
            "line_len"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1721-1724",
          "snippet": "static int write_line(struct write_data *write_data, const char *line, size_t line_len)\n{\n\treturn write_line_to(write_data->buf, line, line_len);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int write_line(struct write_data *write_data, const char *line, size_t line_len)\n{\n\treturn write_line_to(write_data->buf, line, line_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "var_value"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "regexec",
          "args": [
            "write_data->preg",
            "var_value",
            "0",
            "NULL",
            "0"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "write_data->name",
            "var_name"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&write_data->buffered_comment"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "write_data->buf",
            "write_data->buffered_comment.ptr",
            "write_data->buffered_comment.size"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "current_section"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "reader"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\n\nstatic int write_on_variable(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tchar *var_name,\n\tchar *var_value,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tbool has_matched = false;\n\tint error;\n\n\tGIT_UNUSED(reader);\n\tGIT_UNUSED(current_section);\n\n\t/*\n\t * If there were comments just before this variable, let's dump them as well.\n\t */\n\tif ((error = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size)) < 0)\n\t\treturn error;\n\n\tgit_buf_clear(&write_data->buffered_comment);\n\n\t/* See if we are to update this name/value pair; first examine name */\n\tif (write_data->in_section &&\n\t\tstrcasecmp(write_data->name, var_name) == 0)\n\t\thas_matched = true;\n\n\t/* If we have a regex to match the value, see if it matches */\n\tif (has_matched && write_data->preg != NULL)\n\t\thas_matched = (regexec(write_data->preg, var_value, 0, NULL, 0) == 0);\n\n\tgit__free(var_name);\n\tgit__free(var_value);\n\n\t/* If this isn't the name/value we're looking for, simply dump the\n\t * existing data back out and continue on.\n\t */\n\tif (!has_matched)\n\t\treturn write_line(write_data, line, line_len);\n\n\twrite_data->preg_replaced = 1;\n\n\t/* If value is NULL, we are deleting this value; write nothing. */\n\tif (!write_data->value)\n\t\treturn 0;\n\n\treturn write_value(write_data);\n}"
  },
  {
    "function_name": "write_on_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1745-1779",
    "snippet": "static int write_on_section(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tint result = 0;\n\n\tGIT_UNUSED(reader);\n\n\t/* If we were previously in the correct section (but aren't anymore)\n\t * and haven't written our value (for a simple name/value set, not\n\t * a multivar), then append it to the end of the section before writing\n\t * the new one.\n\t */\n\tif (write_data->in_section && !write_data->preg && write_data->value)\n\t\tresult = write_value(write_data);\n\n\twrite_data->in_section = strcmp(current_section, write_data->section) == 0;\n\n\t/*\n\t * If there were comments just before this section, dump them as well.\n\t */\n\tif (!result) {\n\t\tresult = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size);\n\t\tgit_buf_clear(&write_data->buffered_comment);\n\t}\n\n\tif (!result)\n\t\tresult = write_line(write_data, line, line_len);\n\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
      "static char *escape_value(const char *ptr);",
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "write_data",
            "line",
            "line_len"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1721-1724",
          "snippet": "static int write_line(struct write_data *write_data, const char *line, size_t line_len)\n{\n\treturn write_line_to(write_data->buf, line, line_len);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int write_line(struct write_data *write_data, const char *line, size_t line_len)\n{\n\treturn write_line_to(write_data->buf, line, line_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&write_data->buffered_comment"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "write_data->buf",
            "write_data->buffered_comment.ptr",
            "write_data->buffered_comment.size"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "current_section",
            "write_data->section"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_value",
          "args": [
            "write_data"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "write_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1726-1743",
          "snippet": "static int write_value(struct write_data *write_data)\n{\n\tconst char *q;\n\tint result;\n\n\tq = quotes_for_value(write_data->value);\n\tresult = git_buf_printf(write_data->buf,\n\t\t\"\\t%s = %s%s%s\\n\", write_data->name, q, write_data->value, q);\n\n\t/* If we are updating a single name/value, we're done.  Setting `value`\n\t * to `NULL` will prevent us from trying to write it again later (in\n\t * `write_on_section`) if we see the same section repeated.\n\t */\n\tif (!write_data->preg)\n\t\twrite_data->value = NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int write_value(struct write_data *write_data)\n{\n\tconst char *q;\n\tint result;\n\n\tq = quotes_for_value(write_data->value);\n\tresult = git_buf_printf(write_data->buf,\n\t\t\"\\t%s = %s%s%s\\n\", write_data->name, q, write_data->value, q);\n\n\t/* If we are updating a single name/value, we're done.  Setting `value`\n\t * to `NULL` will prevent us from trying to write it again later (in\n\t * `write_on_section`) if we see the same section repeated.\n\t */\n\tif (!write_data->preg)\n\t\twrite_data->value = NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "reader"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int write_on_section(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tint result = 0;\n\n\tGIT_UNUSED(reader);\n\n\t/* If we were previously in the correct section (but aren't anymore)\n\t * and haven't written our value (for a simple name/value set, not\n\t * a multivar), then append it to the end of the section before writing\n\t * the new one.\n\t */\n\tif (write_data->in_section && !write_data->preg && write_data->value)\n\t\tresult = write_value(write_data);\n\n\twrite_data->in_section = strcmp(current_section, write_data->section) == 0;\n\n\t/*\n\t * If there were comments just before this section, dump them as well.\n\t */\n\tif (!result) {\n\t\tresult = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size);\n\t\tgit_buf_clear(&write_data->buffered_comment);\n\t}\n\n\tif (!result)\n\t\tresult = write_line(write_data, line, line_len);\n\n\treturn result;\n}"
  },
  {
    "function_name": "write_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1726-1743",
    "snippet": "static int write_value(struct write_data *write_data)\n{\n\tconst char *q;\n\tint result;\n\n\tq = quotes_for_value(write_data->value);\n\tresult = git_buf_printf(write_data->buf,\n\t\t\"\\t%s = %s%s%s\\n\", write_data->name, q, write_data->value, q);\n\n\t/* If we are updating a single name/value, we're done.  Setting `value`\n\t * to `NULL` will prevent us from trying to write it again later (in\n\t * `write_on_section`) if we see the same section repeated.\n\t */\n\tif (!write_data->preg)\n\t\twrite_data->value = NULL;\n\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "write_data->buf",
            "\"\\t%s = %s%s%s\\n\"",
            "write_data->name",
            "q",
            "write_data->value",
            "q"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quotes_for_value",
          "args": [
            "write_data->value"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "quotes_for_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1682-1698",
          "snippet": "static const char *quotes_for_value(const char *value)\n{\n\tconst char *ptr;\n\n\tif (value[0] == ' ' || value[0] == '\\0')\n\t\treturn \"\\\"\";\n\n\tfor (ptr = value; *ptr; ++ptr) {\n\t\tif (*ptr == ';' || *ptr == '#')\n\t\t\treturn \"\\\"\";\n\t}\n\n\tif (ptr[-1] == ' ')\n\t\treturn \"\\\"\";\n\n\treturn \"\";\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "static char *escape_value(const char *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\n\nstatic const char *quotes_for_value(const char *value)\n{\n\tconst char *ptr;\n\n\tif (value[0] == ' ' || value[0] == '\\0')\n\t\treturn \"\\\"\";\n\n\tfor (ptr = value; *ptr; ++ptr) {\n\t\tif (*ptr == ';' || *ptr == '#')\n\t\t\treturn \"\\\"\";\n\t}\n\n\tif (ptr[-1] == ' ')\n\t\treturn \"\\\"\";\n\n\treturn \"\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int write_value(struct write_data *write_data)\n{\n\tconst char *q;\n\tint result;\n\n\tq = quotes_for_value(write_data->value);\n\tresult = git_buf_printf(write_data->buf,\n\t\t\"\\t%s = %s%s%s\\n\", write_data->name, q, write_data->value, q);\n\n\t/* If we are updating a single name/value, we're done.  Setting `value`\n\t * to `NULL` will prevent us from trying to write it again later (in\n\t * `write_on_section`) if we see the same section repeated.\n\t */\n\tif (!write_data->preg)\n\t\twrite_data->value = NULL;\n\n\treturn result;\n}"
  },
  {
    "function_name": "write_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1721-1724",
    "snippet": "static int write_line(struct write_data *write_data, const char *line, size_t line_len)\n{\n\treturn write_line_to(write_data->buf, line, line_len);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line_to",
          "args": [
            "write_data->buf",
            "line",
            "line_len"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "write_line_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1711-1719",
          "snippet": "static int write_line_to(git_buf *buf, const char *line, size_t line_len)\n{\n\tint result = git_buf_put(buf, line, line_len);\n\n\tif (!result && line_len && line[line_len-1] != '\\n')\n\t\tresult = git_buf_printf(buf, \"\\n\");\n\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int write_line_to(git_buf *buf, const char *line, size_t line_len)\n{\n\tint result = git_buf_put(buf, line, line_len);\n\n\tif (!result && line_len && line[line_len-1] != '\\n')\n\t\tresult = git_buf_printf(buf, \"\\n\");\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int write_line(struct write_data *write_data, const char *line, size_t line_len)\n{\n\treturn write_line_to(write_data->buf, line, line_len);\n}"
  },
  {
    "function_name": "write_line_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1711-1719",
    "snippet": "static int write_line_to(git_buf *buf, const char *line, size_t line_len)\n{\n\tint result = git_buf_put(buf, line, line_len);\n\n\tif (!result && line_len && line[line_len-1] != '\\n')\n\t\tresult = git_buf_printf(buf, \"\\n\");\n\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "buf",
            "\"\\n\""
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "buf",
            "line",
            "line_len"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int write_line_to(git_buf *buf, const char *line, size_t line_len)\n{\n\tint result = git_buf_put(buf, line, line_len);\n\n\tif (!result && line_len && line[line_len-1] != '\\n')\n\t\tresult = git_buf_printf(buf, \"\\n\");\n\n\treturn result;\n}"
  },
  {
    "function_name": "quotes_for_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1682-1698",
    "snippet": "static const char *quotes_for_value(const char *value)\n{\n\tconst char *ptr;\n\n\tif (value[0] == ' ' || value[0] == '\\0')\n\t\treturn \"\\\"\";\n\n\tfor (ptr = value; *ptr; ++ptr) {\n\t\tif (*ptr == ';' || *ptr == '#')\n\t\t\treturn \"\\\"\";\n\t}\n\n\tif (ptr[-1] == ' ')\n\t\treturn \"\\\"\";\n\n\treturn \"\";\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
      "static char *escape_value(const char *ptr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\n\nstatic const char *quotes_for_value(const char *value)\n{\n\tconst char *ptr;\n\n\tif (value[0] == ' ' || value[0] == '\\0')\n\t\treturn \"\\\"\";\n\n\tfor (ptr = value; *ptr; ++ptr) {\n\t\tif (*ptr == ';' || *ptr == '#')\n\t\t\treturn \"\\\"\";\n\t}\n\n\tif (ptr[-1] == ' ')\n\t\treturn \"\\\"\";\n\n\treturn \"\";\n}"
  },
  {
    "function_name": "write_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1652-1680",
    "snippet": "static int write_section(git_buf *fbuf, const char *key)\n{\n\tint result;\n\tconst char *dot;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* All of this just for [section \"subsection\"] */\n\tdot = strchr(key, '.');\n\tgit_buf_putc(&buf, '[');\n\tif (dot == NULL) {\n\t\tgit_buf_puts(&buf, key);\n\t} else {\n\t\tchar *escaped;\n\t\tgit_buf_put(&buf, key, dot - key);\n\t\tescaped = escape_value(dot + 1);\n\t\tGITERR_CHECK_ALLOC(escaped);\n\t\tgit_buf_printf(&buf, \" \\\"%s\\\"\", escaped);\n\t\tgit__free(escaped);\n\t}\n\tgit_buf_puts(&buf, \"]\\n\");\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tresult = git_buf_put(fbuf, git_buf_cstr(&buf), buf.size);\n\tgit_buf_free(&buf);\n\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
      "static const char *escaped = \"\\n\\t\\b\\\"\\\\\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "fbuf",
            "git_buf_cstr(&buf)",
            "buf.size"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&buf"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&buf",
            "\"]\\n\""
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "escaped"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\" \\\"%s\\\"\"",
            "escaped"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "escaped"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_value",
          "args": [
            "dot + 1"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "escape_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1252-1282",
          "snippet": "static char *escape_value(const char *ptr)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t len;\n\tconst char *esc;\n\n\tassert(ptr);\n\n\tlen = strlen(ptr);\n\tif (!len)\n\t\treturn git__calloc(1, sizeof(char));\n\n\tgit_buf_grow(&buf, len);\n\n\twhile (*ptr != '\\0') {\n\t\tif ((esc = strchr(escaped, *ptr)) != NULL) {\n\t\t\tgit_buf_putc(&buf, '\\\\');\n\t\t\tgit_buf_putc(&buf, escapes[esc - escaped]);\n\t\t} else {\n\t\t\tgit_buf_putc(&buf, *ptr);\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (git_buf_oom(&buf)) {\n\t\tgit_buf_free(&buf);\n\t\treturn NULL;\n\t}\n\n\treturn git_buf_detach(&buf);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *escape_value(const char *ptr);",
            "static const char *escapes = \"ntb\\\"\\\\\";",
            "static const char *escaped = \"\\n\\t\\b\\\"\\\\\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\nstatic const char *escapes = \"ntb\\\"\\\\\";\nstatic const char *escaped = \"\\n\\t\\b\\\"\\\\\";\n\nstatic char *escape_value(const char *ptr)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t len;\n\tconst char *esc;\n\n\tassert(ptr);\n\n\tlen = strlen(ptr);\n\tif (!len)\n\t\treturn git__calloc(1, sizeof(char));\n\n\tgit_buf_grow(&buf, len);\n\n\twhile (*ptr != '\\0') {\n\t\tif ((esc = strchr(escaped, *ptr)) != NULL) {\n\t\t\tgit_buf_putc(&buf, '\\\\');\n\t\t\tgit_buf_putc(&buf, escapes[esc - escaped]);\n\t\t} else {\n\t\t\tgit_buf_putc(&buf, *ptr);\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (git_buf_oom(&buf)) {\n\t\tgit_buf_free(&buf);\n\t\treturn NULL;\n\t}\n\n\treturn git_buf_detach(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "&buf",
            "'['"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "'.'"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nstatic const char *escaped = \"\\n\\t\\b\\\"\\\\\";\n\nstatic int write_section(git_buf *fbuf, const char *key)\n{\n\tint result;\n\tconst char *dot;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* All of this just for [section \"subsection\"] */\n\tdot = strchr(key, '.');\n\tgit_buf_putc(&buf, '[');\n\tif (dot == NULL) {\n\t\tgit_buf_puts(&buf, key);\n\t} else {\n\t\tchar *escaped;\n\t\tgit_buf_put(&buf, key, dot - key);\n\t\tescaped = escape_value(dot + 1);\n\t\tGITERR_CHECK_ALLOC(escaped);\n\t\tgit_buf_printf(&buf, \" \\\"%s\\\"\", escaped);\n\t\tgit__free(escaped);\n\t}\n\tgit_buf_puts(&buf, \"]\\n\");\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tresult = git_buf_put(fbuf, git_buf_cstr(&buf), buf.size);\n\tgit_buf_free(&buf);\n\n\treturn result;\n}"
  },
  {
    "function_name": "config_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1626-1650",
    "snippet": "static int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth)\n{\n\tstruct parse_data parse_data;\n\n\tif (depth >= MAX_INCLUDE_DEPTH) {\n\t\tgiterr_set(GITERR_CONFIG, \"Maximum config include depth reached\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the reading position */\n\treader->read_ptr = reader->buffer.ptr;\n\treader->eof = 0;\n\n\t/* If the file is empty, there's nothing for us to do */\n\tif (*reader->read_ptr == '\\0')\n\t\treturn 0;\n\n\tparse_data.values = values;\n\tparse_data.cfg_file = cfg_file;\n\tparse_data.reader_idx = git_array_size(cfg_file->readers) - 1;\n\tparse_data.level = level;\n\tparse_data.depth = depth;\n\n\treturn config_parse(reader, NULL, read_on_variable, NULL, NULL, &parse_data);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define MAX_INCLUDE_DEPTH 10"
    ],
    "globals_used": [
      "static int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);",
      "static char *escape_value(const char *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_parse",
          "args": [
            "reader",
            "NULL",
            "read_on_variable",
            "NULL",
            "NULL",
            "&parse_data"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "config_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1470-1530",
          "snippet": "static int config_parse(\n\tstruct reader *reader,\n\tint (*on_section)(struct reader **reader, const char *current_section, const char *line, size_t line_len, void *data),\n\tint (*on_variable)(struct reader **reader, const char *current_section, char *var_name, char *var_value, const char *line, size_t line_len, void *data),\n\tint (*on_comment)(struct reader **reader, const char *line, size_t line_len, void *data),\n\tint (*on_eof)(struct reader **reader, const char *current_section, void *data),\n\tvoid *data)\n{\n\tchar *current_section = NULL, *var_name, *var_value, *line_start;\n\tchar c;\n\tsize_t line_len;\n\tint result = 0;\n\n\tskip_bom(reader);\n\n\twhile (result == 0 && !reader->eof) {\n\t\tline_start = reader->read_ptr;\n\n\t\tc = reader_peek(reader, SKIP_WHITESPACE);\n\n\t\tswitch (c) {\n\t\tcase '\\0': /* EOF when peeking, set EOF in the reader to exit the loop */\n\t\t\treader->eof = 1;\n\t\t\tbreak;\n\n\t\tcase '[': /* section header, new section begins */\n\t\t\tgit__free(current_section);\n\t\t\tcurrent_section = NULL;\n\n\t\t\tif ((result = parse_section_header(reader, &current_section)) == 0 && on_section) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_section(&reader, current_section, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\n': /* comment or whitespace-only */\n\t\tcase ';':\n\t\tcase '#':\n\t\t\treader_consume_line(reader);\n\n\t\t\tif (on_comment) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_comment(&reader, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: /* assume variable declaration */\n\t\t\tif ((result = parse_variable(reader, &var_name, &var_value)) == 0 && on_variable) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_variable(&reader, current_section, var_name, var_value, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (on_eof)\n\t\tresult = on_eof(&reader, current_section, data);\n\n\tgit__free(current_section);\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define SKIP_WHITESPACE (1 << 1)"
          ],
          "globals_used": [
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\n#define SKIP_WHITESPACE (1 << 1)\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_parse(\n\tstruct reader *reader,\n\tint (*on_section)(struct reader **reader, const char *current_section, const char *line, size_t line_len, void *data),\n\tint (*on_variable)(struct reader **reader, const char *current_section, char *var_name, char *var_value, const char *line, size_t line_len, void *data),\n\tint (*on_comment)(struct reader **reader, const char *line, size_t line_len, void *data),\n\tint (*on_eof)(struct reader **reader, const char *current_section, void *data),\n\tvoid *data)\n{\n\tchar *current_section = NULL, *var_name, *var_value, *line_start;\n\tchar c;\n\tsize_t line_len;\n\tint result = 0;\n\n\tskip_bom(reader);\n\n\twhile (result == 0 && !reader->eof) {\n\t\tline_start = reader->read_ptr;\n\n\t\tc = reader_peek(reader, SKIP_WHITESPACE);\n\n\t\tswitch (c) {\n\t\tcase '\\0': /* EOF when peeking, set EOF in the reader to exit the loop */\n\t\t\treader->eof = 1;\n\t\t\tbreak;\n\n\t\tcase '[': /* section header, new section begins */\n\t\t\tgit__free(current_section);\n\t\t\tcurrent_section = NULL;\n\n\t\t\tif ((result = parse_section_header(reader, &current_section)) == 0 && on_section) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_section(&reader, current_section, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\n': /* comment or whitespace-only */\n\t\tcase ';':\n\t\tcase '#':\n\t\t\treader_consume_line(reader);\n\n\t\t\tif (on_comment) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_comment(&reader, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: /* assume variable declaration */\n\t\t\tif ((result = parse_variable(reader, &var_name, &var_value)) == 0 && on_variable) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_variable(&reader, current_section, var_name, var_value, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (on_eof)\n\t\tresult = on_eof(&reader, current_section, data);\n\n\tgit__free(current_section);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_size",
          "args": [
            "cfg_file->readers"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"Maximum config include depth reached\""
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\n#define MAX_INCLUDE_DEPTH 10\n\nstatic int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);\nstatic char *escape_value(const char *ptr);\n\nstatic int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth)\n{\n\tstruct parse_data parse_data;\n\n\tif (depth >= MAX_INCLUDE_DEPTH) {\n\t\tgiterr_set(GITERR_CONFIG, \"Maximum config include depth reached\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the reading position */\n\treader->read_ptr = reader->buffer.ptr;\n\treader->eof = 0;\n\n\t/* If the file is empty, there's nothing for us to do */\n\tif (*reader->read_ptr == '\\0')\n\t\treturn 0;\n\n\tparse_data.values = values;\n\tparse_data.cfg_file = cfg_file;\n\tparse_data.reader_idx = git_array_size(cfg_file->readers) - 1;\n\tparse_data.level = level;\n\tparse_data.depth = depth;\n\n\treturn config_parse(reader, NULL, read_on_variable, NULL, NULL, &parse_data);\n}"
  },
  {
    "function_name": "read_on_variable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1540-1624",
    "snippet": "static int read_on_variable(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tchar *var_name,\n\tchar *var_value,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct parse_data *parse_data = (struct parse_data *)data;\n\tgit_buf buf = GIT_BUF_INIT;\n\tcvar_t *var;\n\tint result = 0;\n\n\tGIT_UNUSED(line);\n\tGIT_UNUSED(line_len);\n\n\tgit__strtolower(var_name);\n\tgit_buf_printf(&buf, \"%s.%s\", current_section, var_name);\n\tgit__free(var_name);\n\n\tif (git_buf_oom(&buf)) {\n\t\tgit__free(var_value);\n\t\treturn -1;\n\t}\n\n\tvar = git__calloc(1, sizeof(cvar_t));\n\tGITERR_CHECK_ALLOC(var);\n\tvar->entry = git__calloc(1, sizeof(git_config_entry));\n\tGITERR_CHECK_ALLOC(var->entry);\n\n\tvar->entry->name = git_buf_detach(&buf);\n\tvar->entry->value = var_value;\n\tvar->entry->level = parse_data->level;\n\tvar->included = !!parse_data->depth;\n\n\tif ((result = append_entry(parse_data->values, var)) < 0)\n\t\treturn result;\n\n\tresult = 0;\n\n\t/* Add or append the new config option */\n\tif (!git__strcmp(var->entry->name, \"include.path\")) {\n\t\tstruct reader *r;\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tchar *dir;\n\t\tuint32_t index;\n\n\t\tr = git_array_alloc(parse_data->cfg_file->readers);\n\t\t/* The reader may have been reallocated */\n\t\t*reader = git_array_get(parse_data->cfg_file->readers, parse_data->reader_idx);\n\t\tmemset(r, 0, sizeof(struct reader));\n\n\t\tif ((result = git_path_dirname_r(&path, (*reader)->file_path)) < 0)\n\t\t\treturn result;\n\n\t\t/* We need to know our index in the array, as the next config_parse call may realloc */\n\t\tindex = git_array_size(parse_data->cfg_file->readers) - 1;\n\t\tdir = git_buf_detach(&path);\n\t\tresult = included_path(&path, dir, var->entry->value);\n\t\tgit__free(dir);\n\n\t\tif (result < 0)\n\t\t\treturn result;\n\n\t\tr->file_path = git_buf_detach(&path);\n\t\tgit_buf_init(&r->buffer, 0);\n\n\t\tresult = git_futils_readbuffer_updated(\n\t\t\t&r->buffer, r->file_path, &r->checksum, NULL);\n\n\t\tif (result == 0) {\n\t\t\tresult = config_read(parse_data->values, parse_data->cfg_file, r, parse_data->level, parse_data->depth+1);\n\t\t\tr = git_array_get(parse_data->cfg_file->readers, index);\n\t\t\t*reader = git_array_get(parse_data->cfg_file->readers, parse_data->reader_idx);\n\t\t} else if (result == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\tresult = 0;\n\t\t}\n\n\t\tgit_buf_free(&r->buffer);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);",
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&r->buffer"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "parse_data->cfg_file->readers",
            "parse_data->reader_idx"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "parse_data->cfg_file->readers",
            "index"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_read",
          "args": [
            "parse_data->values",
            "parse_data->cfg_file",
            "r",
            "parse_data->level",
            "parse_data->depth+1"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "config_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1626-1650",
          "snippet": "static int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth)\n{\n\tstruct parse_data parse_data;\n\n\tif (depth >= MAX_INCLUDE_DEPTH) {\n\t\tgiterr_set(GITERR_CONFIG, \"Maximum config include depth reached\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the reading position */\n\treader->read_ptr = reader->buffer.ptr;\n\treader->eof = 0;\n\n\t/* If the file is empty, there's nothing for us to do */\n\tif (*reader->read_ptr == '\\0')\n\t\treturn 0;\n\n\tparse_data.values = values;\n\tparse_data.cfg_file = cfg_file;\n\tparse_data.reader_idx = git_array_size(cfg_file->readers) - 1;\n\tparse_data.level = level;\n\tparse_data.depth = depth;\n\n\treturn config_parse(reader, NULL, read_on_variable, NULL, NULL, &parse_data);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MAX_INCLUDE_DEPTH 10"
          ],
          "globals_used": [
            "static int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);",
            "static char *escape_value(const char *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\n#define MAX_INCLUDE_DEPTH 10\n\nstatic int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);\nstatic char *escape_value(const char *ptr);\n\nstatic int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth)\n{\n\tstruct parse_data parse_data;\n\n\tif (depth >= MAX_INCLUDE_DEPTH) {\n\t\tgiterr_set(GITERR_CONFIG, \"Maximum config include depth reached\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the reading position */\n\treader->read_ptr = reader->buffer.ptr;\n\treader->eof = 0;\n\n\t/* If the file is empty, there's nothing for us to do */\n\tif (*reader->read_ptr == '\\0')\n\t\treturn 0;\n\n\tparse_data.values = values;\n\tparse_data.cfg_file = cfg_file;\n\tparse_data.reader_idx = git_array_size(cfg_file->readers) - 1;\n\tparse_data.level = level;\n\tparse_data.depth = depth;\n\n\treturn config_parse(reader, NULL, read_on_variable, NULL, NULL, &parse_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer_updated",
          "args": [
            "&r->buffer",
            "r->file_path",
            "&r->checksum",
            "NULL"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer_updated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "155-222",
          "snippet": "int git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "&r->buffer",
            "0"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&path"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "dir"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "included_path",
          "args": [
            "&path",
            "dir",
            "var->entry->value"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "included_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1239-1246",
          "snippet": "static int included_path(git_buf *out, const char *dir, const char *path)\n{\n\t/* From the user's home */\n\tif (path[0] == '~' && path[1] == '/')\n\t\treturn git_sysdir_find_global_file(out, &path[1]);\n\n\treturn git_path_join_unrooted(out, path, dir, NULL);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int included_path(git_buf *out, const char *dir, const char *path)\n{\n\t/* From the user's home */\n\tif (path[0] == '~' && path[1] == '/')\n\t\treturn git_sysdir_find_global_file(out, &path[1]);\n\n\treturn git_path_join_unrooted(out, path, dir, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_size",
          "args": [
            "parse_data->cfg_file->readers"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_dirname_r",
          "args": [
            "&path",
            "(*reader)->file_path"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_dirname_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "117-178",
          "snippet": "int git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "r",
            "0",
            "sizeof(struct reader)"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "parse_data->cfg_file->readers",
            "parse_data->reader_idx"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_alloc",
          "args": [
            "parse_data->cfg_file->readers"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strcmp",
          "args": [
            "var->entry->name",
            "\"include.path\""
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_entry",
          "args": [
            "parse_data->values",
            "var"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "append_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "174-195",
          "snippet": "static int append_entry(git_strmap *values, cvar_t *var)\n{\n\tgit_strmap_iter pos;\n\tcvar_t *existing;\n\tint error = 0;\n\n\tpos = git_strmap_lookup_index(values, var->entry->name);\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\tgit_strmap_insert(values, var->entry->name, var, error);\n\t} else {\n\t\texisting = git_strmap_value_at(values, pos);\n\t\twhile (existing->next != NULL) {\n\t\t\texisting = existing->next;\n\t\t}\n\t\texisting->next = var;\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int append_entry(git_strmap *values, cvar_t *var)\n{\n\tgit_strmap_iter pos;\n\tcvar_t *existing;\n\tint error = 0;\n\n\tpos = git_strmap_lookup_index(values, var->entry->name);\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\tgit_strmap_insert(values, var->entry->name, var, error);\n\t} else {\n\t\texisting = git_strmap_value_at(values, pos);\n\t\twhile (existing->next != NULL) {\n\t\t\texisting = existing->next;\n\t\t}\n\t\texisting->next = var;\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "var->entry"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_config_entry)"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "var"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&buf"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"%s.%s\"",
            "current_section",
            "var_name"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strtolower",
          "args": [
            "var_name"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "git__strtolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "236-239",
          "snippet": "void git__strtolower(char *str)\n{\n\tgit__strntolower(str, strlen(str));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nvoid git__strtolower(char *str)\n{\n\tgit__strntolower(str, strlen(str));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "line_len"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "line"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int read_on_variable(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tchar *var_name,\n\tchar *var_value,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct parse_data *parse_data = (struct parse_data *)data;\n\tgit_buf buf = GIT_BUF_INIT;\n\tcvar_t *var;\n\tint result = 0;\n\n\tGIT_UNUSED(line);\n\tGIT_UNUSED(line_len);\n\n\tgit__strtolower(var_name);\n\tgit_buf_printf(&buf, \"%s.%s\", current_section, var_name);\n\tgit__free(var_name);\n\n\tif (git_buf_oom(&buf)) {\n\t\tgit__free(var_value);\n\t\treturn -1;\n\t}\n\n\tvar = git__calloc(1, sizeof(cvar_t));\n\tGITERR_CHECK_ALLOC(var);\n\tvar->entry = git__calloc(1, sizeof(git_config_entry));\n\tGITERR_CHECK_ALLOC(var->entry);\n\n\tvar->entry->name = git_buf_detach(&buf);\n\tvar->entry->value = var_value;\n\tvar->entry->level = parse_data->level;\n\tvar->included = !!parse_data->depth;\n\n\tif ((result = append_entry(parse_data->values, var)) < 0)\n\t\treturn result;\n\n\tresult = 0;\n\n\t/* Add or append the new config option */\n\tif (!git__strcmp(var->entry->name, \"include.path\")) {\n\t\tstruct reader *r;\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tchar *dir;\n\t\tuint32_t index;\n\n\t\tr = git_array_alloc(parse_data->cfg_file->readers);\n\t\t/* The reader may have been reallocated */\n\t\t*reader = git_array_get(parse_data->cfg_file->readers, parse_data->reader_idx);\n\t\tmemset(r, 0, sizeof(struct reader));\n\n\t\tif ((result = git_path_dirname_r(&path, (*reader)->file_path)) < 0)\n\t\t\treturn result;\n\n\t\t/* We need to know our index in the array, as the next config_parse call may realloc */\n\t\tindex = git_array_size(parse_data->cfg_file->readers) - 1;\n\t\tdir = git_buf_detach(&path);\n\t\tresult = included_path(&path, dir, var->entry->value);\n\t\tgit__free(dir);\n\n\t\tif (result < 0)\n\t\t\treturn result;\n\n\t\tr->file_path = git_buf_detach(&path);\n\t\tgit_buf_init(&r->buffer, 0);\n\n\t\tresult = git_futils_readbuffer_updated(\n\t\t\t&r->buffer, r->file_path, &r->checksum, NULL);\n\n\t\tif (result == 0) {\n\t\t\tresult = config_read(parse_data->values, parse_data->cfg_file, r, parse_data->level, parse_data->depth+1);\n\t\t\tr = git_array_get(parse_data->cfg_file->readers, index);\n\t\t\t*reader = git_array_get(parse_data->cfg_file->readers, parse_data->reader_idx);\n\t\t} else if (result == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\tresult = 0;\n\t\t}\n\n\t\tgit_buf_free(&r->buffer);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "config_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1470-1530",
    "snippet": "static int config_parse(\n\tstruct reader *reader,\n\tint (*on_section)(struct reader **reader, const char *current_section, const char *line, size_t line_len, void *data),\n\tint (*on_variable)(struct reader **reader, const char *current_section, char *var_name, char *var_value, const char *line, size_t line_len, void *data),\n\tint (*on_comment)(struct reader **reader, const char *line, size_t line_len, void *data),\n\tint (*on_eof)(struct reader **reader, const char *current_section, void *data),\n\tvoid *data)\n{\n\tchar *current_section = NULL, *var_name, *var_value, *line_start;\n\tchar c;\n\tsize_t line_len;\n\tint result = 0;\n\n\tskip_bom(reader);\n\n\twhile (result == 0 && !reader->eof) {\n\t\tline_start = reader->read_ptr;\n\n\t\tc = reader_peek(reader, SKIP_WHITESPACE);\n\n\t\tswitch (c) {\n\t\tcase '\\0': /* EOF when peeking, set EOF in the reader to exit the loop */\n\t\t\treader->eof = 1;\n\t\t\tbreak;\n\n\t\tcase '[': /* section header, new section begins */\n\t\t\tgit__free(current_section);\n\t\t\tcurrent_section = NULL;\n\n\t\t\tif ((result = parse_section_header(reader, &current_section)) == 0 && on_section) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_section(&reader, current_section, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\n': /* comment or whitespace-only */\n\t\tcase ';':\n\t\tcase '#':\n\t\t\treader_consume_line(reader);\n\n\t\t\tif (on_comment) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_comment(&reader, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: /* assume variable declaration */\n\t\t\tif ((result = parse_variable(reader, &var_name, &var_value)) == 0 && on_variable) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_variable(&reader, current_section, var_name, var_value, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (on_eof)\n\t\tresult = on_eof(&reader, current_section, data);\n\n\tgit__free(current_section);\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define SKIP_WHITESPACE (1 << 1)"
    ],
    "globals_used": [
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "current_section"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_eof",
          "args": [
            "&reader",
            "current_section",
            "data"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "write_on_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1842-1871",
          "snippet": "static int write_on_eof(\n\tstruct reader **reader, const char *current_section, void *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tint result = 0;\n\n\tGIT_UNUSED(reader);\n\n\t/*\n\t * If we've buffered comments when reaching EOF, make sure to dump them.\n\t */\n\tif ((result = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size)) < 0)\n\t\treturn result;\n\n\t/* If we are at the EOF and have not written our value (again, for a\n\t * simple name/value set, not a multivar) then we have never seen the\n\t * section in question and should create a new section and write the\n\t * value.\n\t */\n\tif ((!write_data->preg || !write_data->preg_replaced) && write_data->value) {\n\t\t/* write the section header unless we're already in it */\n\t\tif (!current_section || strcmp(current_section, write_data->section))\n\t\t\tresult = write_section(write_data->buf, write_data->section);\n\n\t\tif (!result)\n\t\t\tresult = write_value(write_data);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "static char *escape_value(const char *ptr);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int write_on_eof(\n\tstruct reader **reader, const char *current_section, void *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tint result = 0;\n\n\tGIT_UNUSED(reader);\n\n\t/*\n\t * If we've buffered comments when reaching EOF, make sure to dump them.\n\t */\n\tif ((result = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size)) < 0)\n\t\treturn result;\n\n\t/* If we are at the EOF and have not written our value (again, for a\n\t * simple name/value set, not a multivar) then we have never seen the\n\t * section in question and should create a new section and write the\n\t * value.\n\t */\n\tif ((!write_data->preg || !write_data->preg_replaced) && write_data->value) {\n\t\t/* write the section header unless we're already in it */\n\t\tif (!current_section || strcmp(current_section, write_data->section))\n\t\t\tresult = write_section(write_data->buf, write_data->section);\n\n\t\tif (!result)\n\t\t\tresult = write_value(write_data);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_variable",
          "args": [
            "&reader",
            "current_section",
            "var_name",
            "var_value",
            "line_start",
            "line_len",
            "data"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "write_on_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1781-1830",
          "snippet": "static int write_on_variable(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tchar *var_name,\n\tchar *var_value,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tbool has_matched = false;\n\tint error;\n\n\tGIT_UNUSED(reader);\n\tGIT_UNUSED(current_section);\n\n\t/*\n\t * If there were comments just before this variable, let's dump them as well.\n\t */\n\tif ((error = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size)) < 0)\n\t\treturn error;\n\n\tgit_buf_clear(&write_data->buffered_comment);\n\n\t/* See if we are to update this name/value pair; first examine name */\n\tif (write_data->in_section &&\n\t\tstrcasecmp(write_data->name, var_name) == 0)\n\t\thas_matched = true;\n\n\t/* If we have a regex to match the value, see if it matches */\n\tif (has_matched && write_data->preg != NULL)\n\t\thas_matched = (regexec(write_data->preg, var_value, 0, NULL, 0) == 0);\n\n\tgit__free(var_name);\n\tgit__free(var_value);\n\n\t/* If this isn't the name/value we're looking for, simply dump the\n\t * existing data back out and continue on.\n\t */\n\tif (!has_matched)\n\t\treturn write_line(write_data, line, line_len);\n\n\twrite_data->preg_replaced = 1;\n\n\t/* If value is NULL, we are deleting this value; write nothing. */\n\tif (!write_data->value)\n\t\treturn 0;\n\n\treturn write_value(write_data);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "static char *escape_value(const char *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\n\nstatic int write_on_variable(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tchar *var_name,\n\tchar *var_value,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tbool has_matched = false;\n\tint error;\n\n\tGIT_UNUSED(reader);\n\tGIT_UNUSED(current_section);\n\n\t/*\n\t * If there were comments just before this variable, let's dump them as well.\n\t */\n\tif ((error = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size)) < 0)\n\t\treturn error;\n\n\tgit_buf_clear(&write_data->buffered_comment);\n\n\t/* See if we are to update this name/value pair; first examine name */\n\tif (write_data->in_section &&\n\t\tstrcasecmp(write_data->name, var_name) == 0)\n\t\thas_matched = true;\n\n\t/* If we have a regex to match the value, see if it matches */\n\tif (has_matched && write_data->preg != NULL)\n\t\thas_matched = (regexec(write_data->preg, var_value, 0, NULL, 0) == 0);\n\n\tgit__free(var_name);\n\tgit__free(var_value);\n\n\t/* If this isn't the name/value we're looking for, simply dump the\n\t * existing data back out and continue on.\n\t */\n\tif (!has_matched)\n\t\treturn write_line(write_data, line, line_len);\n\n\twrite_data->preg_replaced = 1;\n\n\t/* If value is NULL, we are deleting this value; write nothing. */\n\tif (!write_data->value)\n\t\treturn 0;\n\n\treturn write_value(write_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_variable",
          "args": [
            "reader",
            "&var_name",
            "&var_value"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "parse_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1418-1468",
          "snippet": "static int parse_variable(struct reader *reader, char **var_name, char **var_value)\n{\n\tconst char *value_start = NULL;\n\tchar *line;\n\tint quote_count;\n\tbool multiline;\n\n\tline = reader_readline(reader, true);\n\tif (line == NULL)\n\t\treturn -1;\n\n\tquote_count = strip_comments(line, 0);\n\n\t/* If there is no value, boolean true is assumed */\n\t*var_value = NULL;\n\n\tif (parse_name(var_name, &value_start, reader, line) < 0)\n\t\tgoto on_error;\n\n\t/*\n\t * Now, let's try to parse the value\n\t */\n\tif (value_start != NULL) {\n\t\twhile (git__isspace(value_start[0]))\n\t\t\tvalue_start++;\n\n\t\tif (unescape_line(var_value, &multiline, value_start, 0) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (multiline) {\n\t\t\tgit_buf multi_value = GIT_BUF_INIT;\n\t\t\tgit_buf_attach(&multi_value, *var_value, 0);\n\n\t\t\tif (parse_multiline_variable(reader, &multi_value, quote_count) < 0 ||\n\t\t\t\tgit_buf_oom(&multi_value)) {\n\t\t\t\tgit_buf_free(&multi_value);\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\t*var_value = git_buf_detach(&multi_value);\n\t\t}\n\t}\n\n\tgit__free(line);\n\treturn 0;\n\non_error:\n\tgit__free(*var_name);\n\tgit__free(line);\n\treturn -1;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\n\nstatic int parse_variable(struct reader *reader, char **var_name, char **var_value)\n{\n\tconst char *value_start = NULL;\n\tchar *line;\n\tint quote_count;\n\tbool multiline;\n\n\tline = reader_readline(reader, true);\n\tif (line == NULL)\n\t\treturn -1;\n\n\tquote_count = strip_comments(line, 0);\n\n\t/* If there is no value, boolean true is assumed */\n\t*var_value = NULL;\n\n\tif (parse_name(var_name, &value_start, reader, line) < 0)\n\t\tgoto on_error;\n\n\t/*\n\t * Now, let's try to parse the value\n\t */\n\tif (value_start != NULL) {\n\t\twhile (git__isspace(value_start[0]))\n\t\t\tvalue_start++;\n\n\t\tif (unescape_line(var_value, &multiline, value_start, 0) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (multiline) {\n\t\t\tgit_buf multi_value = GIT_BUF_INIT;\n\t\t\tgit_buf_attach(&multi_value, *var_value, 0);\n\n\t\t\tif (parse_multiline_variable(reader, &multi_value, quote_count) < 0 ||\n\t\t\t\tgit_buf_oom(&multi_value)) {\n\t\t\t\tgit_buf_free(&multi_value);\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\t*var_value = git_buf_detach(&multi_value);\n\t\t}\n\t}\n\n\tgit__free(line);\n\treturn 0;\n\non_error:\n\tgit__free(*var_name);\n\tgit__free(line);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_comment",
          "args": [
            "&reader",
            "line_start",
            "line_len",
            "data"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "write_on_comment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1832-1840",
          "snippet": "static int write_on_comment(struct reader **reader, const char *line, size_t line_len, void *data)\n{\n\tstruct write_data *write_data;\n\n\tGIT_UNUSED(reader);\n\n\twrite_data = (struct write_data *)data;\n\treturn write_line_to(&write_data->buffered_comment, line, line_len);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int write_on_comment(struct reader **reader, const char *line, size_t line_len, void *data)\n{\n\tstruct write_data *write_data;\n\n\tGIT_UNUSED(reader);\n\n\twrite_data = (struct write_data *)data;\n\treturn write_line_to(&write_data->buffered_comment, line, line_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader_consume_line",
          "args": [
            "reader"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "reader_consume_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "979-998",
          "snippet": "static void reader_consume_line(struct reader *reader)\n{\n\tchar *line_start, *line_end;\n\n\tline_start = reader->read_ptr;\n\tline_end = strchr(line_start, '\\n');\n\t/* No newline at EOF */\n\tif(line_end == NULL){\n\t\tline_end = strchr(line_start, '\\0');\n\t}\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void reader_consume_line(struct reader *reader)\n{\n\tchar *line_start, *line_end;\n\n\tline_start = reader->read_ptr;\n\tline_end = strchr(line_start, '\\n');\n\t/* No newline at EOF */\n\tif(line_end == NULL){\n\t\tline_end = strchr(line_start, '\\0');\n\t}\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_section",
          "args": [
            "&reader",
            "current_section",
            "line_start",
            "line_len",
            "data"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "write_on_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1745-1779",
          "snippet": "static int write_on_section(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tint result = 0;\n\n\tGIT_UNUSED(reader);\n\n\t/* If we were previously in the correct section (but aren't anymore)\n\t * and haven't written our value (for a simple name/value set, not\n\t * a multivar), then append it to the end of the section before writing\n\t * the new one.\n\t */\n\tif (write_data->in_section && !write_data->preg && write_data->value)\n\t\tresult = write_value(write_data);\n\n\twrite_data->in_section = strcmp(current_section, write_data->section) == 0;\n\n\t/*\n\t * If there were comments just before this section, dump them as well.\n\t */\n\tif (!result) {\n\t\tresult = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size);\n\t\tgit_buf_clear(&write_data->buffered_comment);\n\t}\n\n\tif (!result)\n\t\tresult = write_line(write_data, line, line_len);\n\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "static char *escape_value(const char *ptr);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int write_on_section(\n\tstruct reader **reader,\n\tconst char *current_section,\n\tconst char *line,\n\tsize_t line_len,\n\tvoid *data)\n{\n\tstruct write_data *write_data = (struct write_data *)data;\n\tint result = 0;\n\n\tGIT_UNUSED(reader);\n\n\t/* If we were previously in the correct section (but aren't anymore)\n\t * and haven't written our value (for a simple name/value set, not\n\t * a multivar), then append it to the end of the section before writing\n\t * the new one.\n\t */\n\tif (write_data->in_section && !write_data->preg && write_data->value)\n\t\tresult = write_value(write_data);\n\n\twrite_data->in_section = strcmp(current_section, write_data->section) == 0;\n\n\t/*\n\t * If there were comments just before this section, dump them as well.\n\t */\n\tif (!result) {\n\t\tresult = git_buf_put(write_data->buf, write_data->buffered_comment.ptr, write_data->buffered_comment.size);\n\t\tgit_buf_clear(&write_data->buffered_comment);\n\t}\n\n\tif (!result)\n\t\tresult = write_line(write_data, line, line_len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_section_header",
          "args": [
            "reader",
            "&current_section"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "parse_section_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1086-1153",
          "snippet": "static int parse_section_header(struct reader *reader, char **section_out)\n{\n\tchar *name, *name_end;\n\tint name_length, c, pos;\n\tint result;\n\tchar *line;\n\tsize_t line_len;\n\n\tline = reader_readline(reader, true);\n\tif (line == NULL)\n\t\treturn -1;\n\n\t/* find the end of the variable's name */\n\tname_end = strrchr(line, ']');\n\tif (name_end == NULL) {\n\t\tgit__free(line);\n\t\tset_parse_error(reader, 0, \"Missing ']' in section header\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&line_len, (size_t)(name_end - line), 1);\n\tname = git__malloc(line_len);\n\tGITERR_CHECK_ALLOC(name);\n\n\tname_length = 0;\n\tpos = 0;\n\n\t/* Make sure we were given a section header */\n\tc = line[pos++];\n\tassert(c == '[');\n\n\tc = line[pos++];\n\n\tdo {\n\t\tif (git__isspace(c)){\n\t\t\tname[name_length] = '\\0';\n\t\t\tresult = parse_section_header_ext(reader, line, name, section_out);\n\t\t\tgit__free(line);\n\t\t\tgit__free(name);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (!config_keychar(c) && c != '.') {\n\t\t\tset_parse_error(reader, pos, \"Unexpected character in header\");\n\t\t\tgoto fail_parse;\n\t\t}\n\n\t\tname[name_length++] = (char)git__tolower(c);\n\n\t} while ((c = line[pos++]) != ']');\n\n\tif (line[pos - 1] != ']') {\n\t\tset_parse_error(reader, pos, \"Unexpected end of file\");\n\t\tgoto fail_parse;\n\t}\n\n\tgit__free(line);\n\n\tname[name_length] = 0;\n\t*section_out = name;\n\n\treturn 0;\n\nfail_parse:\n\tgit__free(line);\n\tgit__free(name);\n\treturn -1;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int parse_section_header(struct reader *reader, char **section_out)\n{\n\tchar *name, *name_end;\n\tint name_length, c, pos;\n\tint result;\n\tchar *line;\n\tsize_t line_len;\n\n\tline = reader_readline(reader, true);\n\tif (line == NULL)\n\t\treturn -1;\n\n\t/* find the end of the variable's name */\n\tname_end = strrchr(line, ']');\n\tif (name_end == NULL) {\n\t\tgit__free(line);\n\t\tset_parse_error(reader, 0, \"Missing ']' in section header\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&line_len, (size_t)(name_end - line), 1);\n\tname = git__malloc(line_len);\n\tGITERR_CHECK_ALLOC(name);\n\n\tname_length = 0;\n\tpos = 0;\n\n\t/* Make sure we were given a section header */\n\tc = line[pos++];\n\tassert(c == '[');\n\n\tc = line[pos++];\n\n\tdo {\n\t\tif (git__isspace(c)){\n\t\t\tname[name_length] = '\\0';\n\t\t\tresult = parse_section_header_ext(reader, line, name, section_out);\n\t\t\tgit__free(line);\n\t\t\tgit__free(name);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (!config_keychar(c) && c != '.') {\n\t\t\tset_parse_error(reader, pos, \"Unexpected character in header\");\n\t\t\tgoto fail_parse;\n\t\t}\n\n\t\tname[name_length++] = (char)git__tolower(c);\n\n\t} while ((c = line[pos++]) != ']');\n\n\tif (line[pos - 1] != ']') {\n\t\tset_parse_error(reader, pos, \"Unexpected end of file\");\n\t\tgoto fail_parse;\n\t}\n\n\tgit__free(line);\n\n\tname[name_length] = 0;\n\t*section_out = name;\n\n\treturn 0;\n\nfail_parse:\n\tgit__free(line);\n\tgit__free(name);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader_peek",
          "args": [
            "reader",
            "SKIP_WHITESPACE"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "reader_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "908-927",
          "snippet": "static int reader_peek(struct reader *reader, int flags)\n{\n\tvoid *old_read_ptr;\n\tint old_lineno, old_eof;\n\tint ret;\n\n\tassert(reader->read_ptr);\n\n\told_read_ptr = reader->read_ptr;\n\told_lineno = reader->line_number;\n\told_eof = reader->eof;\n\n\tret = reader_getchar(reader, flags);\n\n\treader->read_ptr = old_read_ptr;\n\treader->line_number = old_lineno;\n\treader->eof = old_eof;\n\n\treturn ret;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int reader_peek(struct reader *reader, int flags)\n{\n\tvoid *old_read_ptr;\n\tint old_lineno, old_eof;\n\tint ret;\n\n\tassert(reader->read_ptr);\n\n\told_read_ptr = reader->read_ptr;\n\told_lineno = reader->line_number;\n\told_eof = reader->eof;\n\n\tret = reader_getchar(reader, flags);\n\n\treader->read_ptr = old_read_ptr;\n\treader->line_number = old_lineno;\n\treader->eof = old_eof;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_bom",
          "args": [
            "reader"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "skip_bom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1155-1167",
          "snippet": "static int skip_bom(struct reader *reader)\n{\n\tgit_bom_t bom;\n\tint bom_offset = git_buf_text_detect_bom(&bom,\n\t\t&reader->buffer, reader->read_ptr - reader->buffer.ptr);\n\n\tif (bom == GIT_BOM_UTF8)\n\t\treader->read_ptr += bom_offset;\n\n\t/* TODO: reference implementation is pretty stupid with BoM */\n\n\treturn 0;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *escape_value(const char *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\n\nstatic int skip_bom(struct reader *reader)\n{\n\tgit_bom_t bom;\n\tint bom_offset = git_buf_text_detect_bom(&bom,\n\t\t&reader->buffer, reader->read_ptr - reader->buffer.ptr);\n\n\tif (bom == GIT_BOM_UTF8)\n\t\treader->read_ptr += bom_offset;\n\n\t/* TODO: reference implementation is pretty stupid with BoM */\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\n#define SKIP_WHITESPACE (1 << 1)\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_parse(\n\tstruct reader *reader,\n\tint (*on_section)(struct reader **reader, const char *current_section, const char *line, size_t line_len, void *data),\n\tint (*on_variable)(struct reader **reader, const char *current_section, char *var_name, char *var_value, const char *line, size_t line_len, void *data),\n\tint (*on_comment)(struct reader **reader, const char *line, size_t line_len, void *data),\n\tint (*on_eof)(struct reader **reader, const char *current_section, void *data),\n\tvoid *data)\n{\n\tchar *current_section = NULL, *var_name, *var_value, *line_start;\n\tchar c;\n\tsize_t line_len;\n\tint result = 0;\n\n\tskip_bom(reader);\n\n\twhile (result == 0 && !reader->eof) {\n\t\tline_start = reader->read_ptr;\n\n\t\tc = reader_peek(reader, SKIP_WHITESPACE);\n\n\t\tswitch (c) {\n\t\tcase '\\0': /* EOF when peeking, set EOF in the reader to exit the loop */\n\t\t\treader->eof = 1;\n\t\t\tbreak;\n\n\t\tcase '[': /* section header, new section begins */\n\t\t\tgit__free(current_section);\n\t\t\tcurrent_section = NULL;\n\n\t\t\tif ((result = parse_section_header(reader, &current_section)) == 0 && on_section) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_section(&reader, current_section, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\n': /* comment or whitespace-only */\n\t\tcase ';':\n\t\tcase '#':\n\t\t\treader_consume_line(reader);\n\n\t\t\tif (on_comment) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_comment(&reader, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: /* assume variable declaration */\n\t\t\tif ((result = parse_variable(reader, &var_name, &var_value)) == 0 && on_variable) {\n\t\t\t\tline_len = reader->read_ptr - line_start;\n\t\t\t\tresult = on_variable(&reader, current_section, var_name, var_value, line_start, line_len, data);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (on_eof)\n\t\tresult = on_eof(&reader, current_section, data);\n\n\tgit__free(current_section);\n\treturn result;\n}"
  },
  {
    "function_name": "parse_variable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1418-1468",
    "snippet": "static int parse_variable(struct reader *reader, char **var_name, char **var_value)\n{\n\tconst char *value_start = NULL;\n\tchar *line;\n\tint quote_count;\n\tbool multiline;\n\n\tline = reader_readline(reader, true);\n\tif (line == NULL)\n\t\treturn -1;\n\n\tquote_count = strip_comments(line, 0);\n\n\t/* If there is no value, boolean true is assumed */\n\t*var_value = NULL;\n\n\tif (parse_name(var_name, &value_start, reader, line) < 0)\n\t\tgoto on_error;\n\n\t/*\n\t * Now, let's try to parse the value\n\t */\n\tif (value_start != NULL) {\n\t\twhile (git__isspace(value_start[0]))\n\t\t\tvalue_start++;\n\n\t\tif (unescape_line(var_value, &multiline, value_start, 0) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (multiline) {\n\t\t\tgit_buf multi_value = GIT_BUF_INIT;\n\t\t\tgit_buf_attach(&multi_value, *var_value, 0);\n\n\t\t\tif (parse_multiline_variable(reader, &multi_value, quote_count) < 0 ||\n\t\t\t\tgit_buf_oom(&multi_value)) {\n\t\t\t\tgit_buf_free(&multi_value);\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\t*var_value = git_buf_detach(&multi_value);\n\t\t}\n\t}\n\n\tgit__free(line);\n\treturn 0;\n\non_error:\n\tgit__free(*var_name);\n\tgit__free(line);\n\treturn -1;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "line"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&multi_value"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&multi_value"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&multi_value"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_multiline_variable",
          "args": [
            "reader",
            "&multi_value",
            "quote_count"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "parse_multiline_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1331-1377",
          "snippet": "static int parse_multiline_variable(struct reader *reader, git_buf *value, int in_quotes)\n{\n\tchar *line = NULL, *proc_line = NULL;\n\tint quote_count;\n\tbool multiline;\n\n\t/* Check that the next line exists */\n\tline = reader_readline(reader, false);\n\tif (line == NULL)\n\t\treturn -1;\n\n\t/* We've reached the end of the file, there is no continuation.\n\t * (this is not an error).\n\t */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn 0;\n\t}\n\n\tquote_count = strip_comments(line, !!in_quotes);\n\n\t/* If it was just a comment, pretend it didn't exist */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\t\t/* TODO: unbounded recursion. This **could** be exploitable */\n\t}\n\n\tif (unescape_line(&proc_line, &multiline, line, in_quotes) < 0) {\n\t\tgit__free(line);\n\t\treturn -1;\n\t}\n\t/* add this line to the multiline var */\n\n\tgit_buf_puts(value, proc_line);\n\tgit__free(line);\n\tgit__free(proc_line);\n\n\t/*\n\t * If we need to continue reading the next line, let's just\n\t * keep putting stuff in the buffer\n\t */\n\tif (multiline)\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\n\treturn 0;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int parse_multiline_variable(struct reader *reader, git_buf *value, int in_quotes)\n{\n\tchar *line = NULL, *proc_line = NULL;\n\tint quote_count;\n\tbool multiline;\n\n\t/* Check that the next line exists */\n\tline = reader_readline(reader, false);\n\tif (line == NULL)\n\t\treturn -1;\n\n\t/* We've reached the end of the file, there is no continuation.\n\t * (this is not an error).\n\t */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn 0;\n\t}\n\n\tquote_count = strip_comments(line, !!in_quotes);\n\n\t/* If it was just a comment, pretend it didn't exist */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\t\t/* TODO: unbounded recursion. This **could** be exploitable */\n\t}\n\n\tif (unescape_line(&proc_line, &multiline, line, in_quotes) < 0) {\n\t\tgit__free(line);\n\t\treturn -1;\n\t}\n\t/* add this line to the multiline var */\n\n\tgit_buf_puts(value, proc_line);\n\tgit__free(line);\n\tgit__free(proc_line);\n\n\t/*\n\t * If we need to continue reading the next line, let's just\n\t * keep putting stuff in the buffer\n\t */\n\tif (multiline)\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_attach",
          "args": [
            "&multi_value",
            "*var_value",
            "0"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_attach_notowned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "505-517",
          "snippet": "void git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unescape_line",
          "args": [
            "var_value",
            "&multiline",
            "value_start",
            "0"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "unescape_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1285-1329",
          "snippet": "static int unescape_line(\n\tchar **out, bool *is_multi, const char *ptr, int quote_count)\n{\n\tchar *str, *fixed, *esc;\n\tsize_t ptr_len = strlen(ptr), alloc_len;\n\n\t*is_multi = false;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, ptr_len, 1) ||\n\t\t(str = git__malloc(alloc_len)) == NULL) {\n\t\treturn -1;\n\t}\n\n\tfixed = str;\n\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == '\"') {\n\t\t\tquote_count++;\n\t\t} else if (*ptr != '\\\\') {\n\t\t\t*fixed++ = *ptr;\n\t\t} else {\n\t\t\t/* backslash, check the next char */\n\t\t\tptr++;\n\t\t\t/* if we're at the end, it's a multiline, so keep the backslash */\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\t*is_multi = true;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((esc = strchr(escapes, *ptr)) != NULL) {\n\t\t\t\t*fixed++ = escaped[esc - escapes];\n\t\t\t} else {\n\t\t\t\tgit__free(str);\n\t\t\t\tgiterr_set(GITERR_CONFIG, \"Invalid escape at %s\", ptr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\ndone:\n\t*fixed = '\\0';\n\t*out = str;\n\n\treturn 0;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *escape_value(const char *ptr);",
            "static const char *escapes = \"ntb\\\"\\\\\";",
            "static const char *escaped = \"\\n\\t\\b\\\"\\\\\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\nstatic const char *escapes = \"ntb\\\"\\\\\";\nstatic const char *escaped = \"\\n\\t\\b\\\"\\\\\";\n\nstatic int unescape_line(\n\tchar **out, bool *is_multi, const char *ptr, int quote_count)\n{\n\tchar *str, *fixed, *esc;\n\tsize_t ptr_len = strlen(ptr), alloc_len;\n\n\t*is_multi = false;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, ptr_len, 1) ||\n\t\t(str = git__malloc(alloc_len)) == NULL) {\n\t\treturn -1;\n\t}\n\n\tfixed = str;\n\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == '\"') {\n\t\t\tquote_count++;\n\t\t} else if (*ptr != '\\\\') {\n\t\t\t*fixed++ = *ptr;\n\t\t} else {\n\t\t\t/* backslash, check the next char */\n\t\t\tptr++;\n\t\t\t/* if we're at the end, it's a multiline, so keep the backslash */\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\t*is_multi = true;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((esc = strchr(escapes, *ptr)) != NULL) {\n\t\t\t\t*fixed++ = escaped[esc - escapes];\n\t\t\t} else {\n\t\t\t\tgit__free(str);\n\t\t\t\tgiterr_set(GITERR_CONFIG, \"Invalid escape at %s\", ptr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\ndone:\n\t*fixed = '\\0';\n\t*out = str;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "value_start[0]"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_name",
          "args": [
            "var_name",
            "&value_start",
            "reader",
            "line"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "parse_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1384-1416",
          "snippet": "static int parse_name(\n\tchar **name, const char **value, struct reader *reader, const char *line)\n{\n\tconst char *name_end = line, *value_start;\n\n\t*name = NULL;\n\t*value = NULL;\n\n\twhile (*name_end && is_namechar(*name_end))\n\t\tname_end++;\n\n\tif (line == name_end) {\n\t\tset_parse_error(reader, 0, \"Invalid configuration key\");\n\t\treturn -1;\n\t}\n\n\tvalue_start = name_end;\n\n\twhile (*value_start && git__isspace(*value_start))\n\t\tvalue_start++;\n\n\tif (*value_start == '=') {\n\t\t*value = value_start + 1;\n\t} else if (*value_start) {\n\t\tset_parse_error(reader, 0, \"Invalid configuration key\");\n\t\treturn -1;\n\t}\n\n\tif ((*name = git__strndup(line, name_end - line)) == NULL)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\n\nstatic int parse_name(\n\tchar **name, const char **value, struct reader *reader, const char *line)\n{\n\tconst char *name_end = line, *value_start;\n\n\t*name = NULL;\n\t*value = NULL;\n\n\twhile (*name_end && is_namechar(*name_end))\n\t\tname_end++;\n\n\tif (line == name_end) {\n\t\tset_parse_error(reader, 0, \"Invalid configuration key\");\n\t\treturn -1;\n\t}\n\n\tvalue_start = name_end;\n\n\twhile (*value_start && git__isspace(*value_start))\n\t\tvalue_start++;\n\n\tif (*value_start == '=') {\n\t\t*value = value_start + 1;\n\t} else if (*value_start) {\n\t\tset_parse_error(reader, 0, \"Invalid configuration key\");\n\t\treturn -1;\n\t}\n\n\tif ((*name = git__strndup(line, name_end - line)) == NULL)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strip_comments",
          "args": [
            "line",
            "0"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "strip_comments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1208-1237",
          "snippet": "static int strip_comments(char *line, int in_quotes)\n{\n\tint quote_count = in_quotes, backslash_count = 0;\n\tchar *ptr;\n\n\tfor (ptr = line; *ptr; ++ptr) {\n\t\tif (ptr[0] == '\"' && ptr > line && ptr[-1] != '\\\\')\n\t\t\tquote_count++;\n\n\t\tif ((ptr[0] == ';' || ptr[0] == '#') &&\n\t\t\t(quote_count % 2) == 0 &&\n\t\t\t(backslash_count % 2) == 0) {\n\t\t\tptr[0] = '\\0';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ptr[0] == '\\\\')\n\t\t\tbackslash_count++;\n\t\telse\n\t\t\tbackslash_count = 0;\n\t}\n\n\t/* skip any space at the end */\n\twhile (ptr > line && git__isspace(ptr[-1])) {\n\t\tptr--;\n\t}\n\tptr[0] = '\\0';\n\n\treturn quote_count;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *escape_value(const char *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\n\nstatic int strip_comments(char *line, int in_quotes)\n{\n\tint quote_count = in_quotes, backslash_count = 0;\n\tchar *ptr;\n\n\tfor (ptr = line; *ptr; ++ptr) {\n\t\tif (ptr[0] == '\"' && ptr > line && ptr[-1] != '\\\\')\n\t\t\tquote_count++;\n\n\t\tif ((ptr[0] == ';' || ptr[0] == '#') &&\n\t\t\t(quote_count % 2) == 0 &&\n\t\t\t(backslash_count % 2) == 0) {\n\t\t\tptr[0] = '\\0';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ptr[0] == '\\\\')\n\t\t\tbackslash_count++;\n\t\telse\n\t\t\tbackslash_count = 0;\n\t}\n\n\t/* skip any space at the end */\n\twhile (ptr > line && git__isspace(ptr[-1])) {\n\t\tptr--;\n\t}\n\tptr[0] = '\\0';\n\n\treturn quote_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader_readline",
          "args": [
            "reader",
            "true"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "reader_readline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "932-974",
          "snippet": "static char *reader_readline(struct reader *reader, bool skip_whitespace)\n{\n\tchar *line = NULL;\n\tchar *line_src, *line_end;\n\tsize_t line_len, alloc_len;\n\n\tline_src = reader->read_ptr;\n\n\tif (skip_whitespace) {\n\t\t/* Skip empty empty lines */\n\t\twhile (git__isspace(*line_src))\n\t\t\t++line_src;\n\t}\n\n\tline_end = strchr(line_src, '\\n');\n\n\t/* no newline at EOF */\n\tif (line_end == NULL)\n\t\tline_end = strchr(line_src, 0);\n\n\tline_len = line_end - line_src;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, line_len, 1) ||\n\t\t(line = git__malloc(alloc_len)) == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemcpy(line, line_src, line_len);\n\n\tdo line[line_len] = '\\0';\n\twhile (line_len-- > 0 && git__isspace(line[line_len]));\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n\n\treturn line;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *reader_readline(struct reader *reader, bool skip_whitespace)\n{\n\tchar *line = NULL;\n\tchar *line_src, *line_end;\n\tsize_t line_len, alloc_len;\n\n\tline_src = reader->read_ptr;\n\n\tif (skip_whitespace) {\n\t\t/* Skip empty empty lines */\n\t\twhile (git__isspace(*line_src))\n\t\t\t++line_src;\n\t}\n\n\tline_end = strchr(line_src, '\\n');\n\n\t/* no newline at EOF */\n\tif (line_end == NULL)\n\t\tline_end = strchr(line_src, 0);\n\n\tline_len = line_end - line_src;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, line_len, 1) ||\n\t\t(line = git__malloc(alloc_len)) == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemcpy(line, line_src, line_len);\n\n\tdo line[line_len] = '\\0';\n\twhile (line_len-- > 0 && git__isspace(line[line_len]));\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n\n\treturn line;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\n\nstatic int parse_variable(struct reader *reader, char **var_name, char **var_value)\n{\n\tconst char *value_start = NULL;\n\tchar *line;\n\tint quote_count;\n\tbool multiline;\n\n\tline = reader_readline(reader, true);\n\tif (line == NULL)\n\t\treturn -1;\n\n\tquote_count = strip_comments(line, 0);\n\n\t/* If there is no value, boolean true is assumed */\n\t*var_value = NULL;\n\n\tif (parse_name(var_name, &value_start, reader, line) < 0)\n\t\tgoto on_error;\n\n\t/*\n\t * Now, let's try to parse the value\n\t */\n\tif (value_start != NULL) {\n\t\twhile (git__isspace(value_start[0]))\n\t\t\tvalue_start++;\n\n\t\tif (unescape_line(var_value, &multiline, value_start, 0) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (multiline) {\n\t\t\tgit_buf multi_value = GIT_BUF_INIT;\n\t\t\tgit_buf_attach(&multi_value, *var_value, 0);\n\n\t\t\tif (parse_multiline_variable(reader, &multi_value, quote_count) < 0 ||\n\t\t\t\tgit_buf_oom(&multi_value)) {\n\t\t\t\tgit_buf_free(&multi_value);\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\t*var_value = git_buf_detach(&multi_value);\n\t\t}\n\t}\n\n\tgit__free(line);\n\treturn 0;\n\non_error:\n\tgit__free(*var_name);\n\tgit__free(line);\n\treturn -1;\n}"
  },
  {
    "function_name": "parse_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1384-1416",
    "snippet": "static int parse_name(\n\tchar **name, const char **value, struct reader *reader, const char *line)\n{\n\tconst char *name_end = line, *value_start;\n\n\t*name = NULL;\n\t*value = NULL;\n\n\twhile (*name_end && is_namechar(*name_end))\n\t\tname_end++;\n\n\tif (line == name_end) {\n\t\tset_parse_error(reader, 0, \"Invalid configuration key\");\n\t\treturn -1;\n\t}\n\n\tvalue_start = name_end;\n\n\twhile (*value_start && git__isspace(*value_start))\n\t\tvalue_start++;\n\n\tif (*value_start == '=') {\n\t\t*value = value_start + 1;\n\t} else if (*value_start) {\n\t\tset_parse_error(reader, 0, \"Invalid configuration key\");\n\t\treturn -1;\n\t}\n\n\tif ((*name = git__strndup(line, name_end - line)) == NULL)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "line",
            "name_end - line"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_parse_error",
          "args": [
            "reader",
            "0",
            "\"Invalid configuration key\""
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "set_parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "127-131",
          "snippet": "static void set_parse_error(struct reader *reader, int col, const char *error_str)\n{\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse config file: %s (in %s:%d, column %d)\",\n\t\terror_str, reader->file_path, reader->line_number, col);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic void set_parse_error(struct reader *reader, int col, const char *error_str)\n{\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse config file: %s (in %s:%d, column %d)\",\n\t\terror_str, reader->file_path, reader->line_number, col);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "*value_start"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_namechar",
          "args": [
            "*name_end"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "is_namechar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1379-1382",
          "snippet": "GIT_INLINE(bool) is_namechar(char c)\n{\n\treturn isalnum(c) || c == '-';\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) is_namechar(char c)\n{\n\treturn isalnum(c) || c == '-';\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\n\nstatic int parse_name(\n\tchar **name, const char **value, struct reader *reader, const char *line)\n{\n\tconst char *name_end = line, *value_start;\n\n\t*name = NULL;\n\t*value = NULL;\n\n\twhile (*name_end && is_namechar(*name_end))\n\t\tname_end++;\n\n\tif (line == name_end) {\n\t\tset_parse_error(reader, 0, \"Invalid configuration key\");\n\t\treturn -1;\n\t}\n\n\tvalue_start = name_end;\n\n\twhile (*value_start && git__isspace(*value_start))\n\t\tvalue_start++;\n\n\tif (*value_start == '=') {\n\t\t*value = value_start + 1;\n\t} else if (*value_start) {\n\t\tset_parse_error(reader, 0, \"Invalid configuration key\");\n\t\treturn -1;\n\t}\n\n\tif ((*name = git__strndup(line, name_end - line)) == NULL)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_namechar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1379-1382",
    "snippet": "GIT_INLINE(bool) is_namechar(char c)\n{\n\treturn isalnum(c) || c == '-';\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "c"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) is_namechar(char c)\n{\n\treturn isalnum(c) || c == '-';\n}"
  },
  {
    "function_name": "parse_multiline_variable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1331-1377",
    "snippet": "static int parse_multiline_variable(struct reader *reader, git_buf *value, int in_quotes)\n{\n\tchar *line = NULL, *proc_line = NULL;\n\tint quote_count;\n\tbool multiline;\n\n\t/* Check that the next line exists */\n\tline = reader_readline(reader, false);\n\tif (line == NULL)\n\t\treturn -1;\n\n\t/* We've reached the end of the file, there is no continuation.\n\t * (this is not an error).\n\t */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn 0;\n\t}\n\n\tquote_count = strip_comments(line, !!in_quotes);\n\n\t/* If it was just a comment, pretend it didn't exist */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\t\t/* TODO: unbounded recursion. This **could** be exploitable */\n\t}\n\n\tif (unescape_line(&proc_line, &multiline, line, in_quotes) < 0) {\n\t\tgit__free(line);\n\t\treturn -1;\n\t}\n\t/* add this line to the multiline var */\n\n\tgit_buf_puts(value, proc_line);\n\tgit__free(line);\n\tgit__free(proc_line);\n\n\t/*\n\t * If we need to continue reading the next line, let's just\n\t * keep putting stuff in the buffer\n\t */\n\tif (multiline)\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_multiline_variable",
          "args": [
            "reader",
            "value",
            "quote_count"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "parse_multiline_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1331-1377",
          "snippet": "static int parse_multiline_variable(struct reader *reader, git_buf *value, int in_quotes)\n{\n\tchar *line = NULL, *proc_line = NULL;\n\tint quote_count;\n\tbool multiline;\n\n\t/* Check that the next line exists */\n\tline = reader_readline(reader, false);\n\tif (line == NULL)\n\t\treturn -1;\n\n\t/* We've reached the end of the file, there is no continuation.\n\t * (this is not an error).\n\t */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn 0;\n\t}\n\n\tquote_count = strip_comments(line, !!in_quotes);\n\n\t/* If it was just a comment, pretend it didn't exist */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\t\t/* TODO: unbounded recursion. This **could** be exploitable */\n\t}\n\n\tif (unescape_line(&proc_line, &multiline, line, in_quotes) < 0) {\n\t\tgit__free(line);\n\t\treturn -1;\n\t}\n\t/* add this line to the multiline var */\n\n\tgit_buf_puts(value, proc_line);\n\tgit__free(line);\n\tgit__free(proc_line);\n\n\t/*\n\t * If we need to continue reading the next line, let's just\n\t * keep putting stuff in the buffer\n\t */\n\tif (multiline)\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "proc_line"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "value",
            "proc_line"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unescape_line",
          "args": [
            "&proc_line",
            "&multiline",
            "line",
            "in_quotes"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "unescape_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1285-1329",
          "snippet": "static int unescape_line(\n\tchar **out, bool *is_multi, const char *ptr, int quote_count)\n{\n\tchar *str, *fixed, *esc;\n\tsize_t ptr_len = strlen(ptr), alloc_len;\n\n\t*is_multi = false;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, ptr_len, 1) ||\n\t\t(str = git__malloc(alloc_len)) == NULL) {\n\t\treturn -1;\n\t}\n\n\tfixed = str;\n\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == '\"') {\n\t\t\tquote_count++;\n\t\t} else if (*ptr != '\\\\') {\n\t\t\t*fixed++ = *ptr;\n\t\t} else {\n\t\t\t/* backslash, check the next char */\n\t\t\tptr++;\n\t\t\t/* if we're at the end, it's a multiline, so keep the backslash */\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\t*is_multi = true;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((esc = strchr(escapes, *ptr)) != NULL) {\n\t\t\t\t*fixed++ = escaped[esc - escapes];\n\t\t\t} else {\n\t\t\t\tgit__free(str);\n\t\t\t\tgiterr_set(GITERR_CONFIG, \"Invalid escape at %s\", ptr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\ndone:\n\t*fixed = '\\0';\n\t*out = str;\n\n\treturn 0;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *escape_value(const char *ptr);",
            "static const char *escapes = \"ntb\\\"\\\\\";",
            "static const char *escaped = \"\\n\\t\\b\\\"\\\\\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\nstatic const char *escapes = \"ntb\\\"\\\\\";\nstatic const char *escaped = \"\\n\\t\\b\\\"\\\\\";\n\nstatic int unescape_line(\n\tchar **out, bool *is_multi, const char *ptr, int quote_count)\n{\n\tchar *str, *fixed, *esc;\n\tsize_t ptr_len = strlen(ptr), alloc_len;\n\n\t*is_multi = false;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, ptr_len, 1) ||\n\t\t(str = git__malloc(alloc_len)) == NULL) {\n\t\treturn -1;\n\t}\n\n\tfixed = str;\n\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == '\"') {\n\t\t\tquote_count++;\n\t\t} else if (*ptr != '\\\\') {\n\t\t\t*fixed++ = *ptr;\n\t\t} else {\n\t\t\t/* backslash, check the next char */\n\t\t\tptr++;\n\t\t\t/* if we're at the end, it's a multiline, so keep the backslash */\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\t*is_multi = true;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((esc = strchr(escapes, *ptr)) != NULL) {\n\t\t\t\t*fixed++ = escaped[esc - escapes];\n\t\t\t} else {\n\t\t\t\tgit__free(str);\n\t\t\t\tgiterr_set(GITERR_CONFIG, \"Invalid escape at %s\", ptr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\ndone:\n\t*fixed = '\\0';\n\t*out = str;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strip_comments",
          "args": [
            "line",
            "!!in_quotes"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "strip_comments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1208-1237",
          "snippet": "static int strip_comments(char *line, int in_quotes)\n{\n\tint quote_count = in_quotes, backslash_count = 0;\n\tchar *ptr;\n\n\tfor (ptr = line; *ptr; ++ptr) {\n\t\tif (ptr[0] == '\"' && ptr > line && ptr[-1] != '\\\\')\n\t\t\tquote_count++;\n\n\t\tif ((ptr[0] == ';' || ptr[0] == '#') &&\n\t\t\t(quote_count % 2) == 0 &&\n\t\t\t(backslash_count % 2) == 0) {\n\t\t\tptr[0] = '\\0';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ptr[0] == '\\\\')\n\t\t\tbackslash_count++;\n\t\telse\n\t\t\tbackslash_count = 0;\n\t}\n\n\t/* skip any space at the end */\n\twhile (ptr > line && git__isspace(ptr[-1])) {\n\t\tptr--;\n\t}\n\tptr[0] = '\\0';\n\n\treturn quote_count;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *escape_value(const char *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\n\nstatic int strip_comments(char *line, int in_quotes)\n{\n\tint quote_count = in_quotes, backslash_count = 0;\n\tchar *ptr;\n\n\tfor (ptr = line; *ptr; ++ptr) {\n\t\tif (ptr[0] == '\"' && ptr > line && ptr[-1] != '\\\\')\n\t\t\tquote_count++;\n\n\t\tif ((ptr[0] == ';' || ptr[0] == '#') &&\n\t\t\t(quote_count % 2) == 0 &&\n\t\t\t(backslash_count % 2) == 0) {\n\t\t\tptr[0] = '\\0';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ptr[0] == '\\\\')\n\t\t\tbackslash_count++;\n\t\telse\n\t\t\tbackslash_count = 0;\n\t}\n\n\t/* skip any space at the end */\n\twhile (ptr > line && git__isspace(ptr[-1])) {\n\t\tptr--;\n\t}\n\tptr[0] = '\\0';\n\n\treturn quote_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader_readline",
          "args": [
            "reader",
            "false"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "reader_readline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "932-974",
          "snippet": "static char *reader_readline(struct reader *reader, bool skip_whitespace)\n{\n\tchar *line = NULL;\n\tchar *line_src, *line_end;\n\tsize_t line_len, alloc_len;\n\n\tline_src = reader->read_ptr;\n\n\tif (skip_whitespace) {\n\t\t/* Skip empty empty lines */\n\t\twhile (git__isspace(*line_src))\n\t\t\t++line_src;\n\t}\n\n\tline_end = strchr(line_src, '\\n');\n\n\t/* no newline at EOF */\n\tif (line_end == NULL)\n\t\tline_end = strchr(line_src, 0);\n\n\tline_len = line_end - line_src;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, line_len, 1) ||\n\t\t(line = git__malloc(alloc_len)) == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemcpy(line, line_src, line_len);\n\n\tdo line[line_len] = '\\0';\n\twhile (line_len-- > 0 && git__isspace(line[line_len]));\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n\n\treturn line;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *reader_readline(struct reader *reader, bool skip_whitespace)\n{\n\tchar *line = NULL;\n\tchar *line_src, *line_end;\n\tsize_t line_len, alloc_len;\n\n\tline_src = reader->read_ptr;\n\n\tif (skip_whitespace) {\n\t\t/* Skip empty empty lines */\n\t\twhile (git__isspace(*line_src))\n\t\t\t++line_src;\n\t}\n\n\tline_end = strchr(line_src, '\\n');\n\n\t/* no newline at EOF */\n\tif (line_end == NULL)\n\t\tline_end = strchr(line_src, 0);\n\n\tline_len = line_end - line_src;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, line_len, 1) ||\n\t\t(line = git__malloc(alloc_len)) == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemcpy(line, line_src, line_len);\n\n\tdo line[line_len] = '\\0';\n\twhile (line_len-- > 0 && git__isspace(line[line_len]));\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n\n\treturn line;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int parse_multiline_variable(struct reader *reader, git_buf *value, int in_quotes)\n{\n\tchar *line = NULL, *proc_line = NULL;\n\tint quote_count;\n\tbool multiline;\n\n\t/* Check that the next line exists */\n\tline = reader_readline(reader, false);\n\tif (line == NULL)\n\t\treturn -1;\n\n\t/* We've reached the end of the file, there is no continuation.\n\t * (this is not an error).\n\t */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn 0;\n\t}\n\n\tquote_count = strip_comments(line, !!in_quotes);\n\n\t/* If it was just a comment, pretend it didn't exist */\n\tif (line[0] == '\\0') {\n\t\tgit__free(line);\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\t\t/* TODO: unbounded recursion. This **could** be exploitable */\n\t}\n\n\tif (unescape_line(&proc_line, &multiline, line, in_quotes) < 0) {\n\t\tgit__free(line);\n\t\treturn -1;\n\t}\n\t/* add this line to the multiline var */\n\n\tgit_buf_puts(value, proc_line);\n\tgit__free(line);\n\tgit__free(proc_line);\n\n\t/*\n\t * If we need to continue reading the next line, let's just\n\t * keep putting stuff in the buffer\n\t */\n\tif (multiline)\n\t\treturn parse_multiline_variable(reader, value, quote_count);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "unescape_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1285-1329",
    "snippet": "static int unescape_line(\n\tchar **out, bool *is_multi, const char *ptr, int quote_count)\n{\n\tchar *str, *fixed, *esc;\n\tsize_t ptr_len = strlen(ptr), alloc_len;\n\n\t*is_multi = false;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, ptr_len, 1) ||\n\t\t(str = git__malloc(alloc_len)) == NULL) {\n\t\treturn -1;\n\t}\n\n\tfixed = str;\n\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == '\"') {\n\t\t\tquote_count++;\n\t\t} else if (*ptr != '\\\\') {\n\t\t\t*fixed++ = *ptr;\n\t\t} else {\n\t\t\t/* backslash, check the next char */\n\t\t\tptr++;\n\t\t\t/* if we're at the end, it's a multiline, so keep the backslash */\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\t*is_multi = true;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((esc = strchr(escapes, *ptr)) != NULL) {\n\t\t\t\t*fixed++ = escaped[esc - escapes];\n\t\t\t} else {\n\t\t\t\tgit__free(str);\n\t\t\t\tgiterr_set(GITERR_CONFIG, \"Invalid escape at %s\", ptr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\ndone:\n\t*fixed = '\\0';\n\t*out = str;\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *escape_value(const char *ptr);",
      "static const char *escapes = \"ntb\\\"\\\\\";",
      "static const char *escaped = \"\\n\\t\\b\\\"\\\\\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"Invalid escape at %s\"",
            "ptr"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "str"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "escapes",
            "*ptr"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloc_len"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloc_len",
            "ptr_len",
            "1"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\nstatic const char *escapes = \"ntb\\\"\\\\\";\nstatic const char *escaped = \"\\n\\t\\b\\\"\\\\\";\n\nstatic int unescape_line(\n\tchar **out, bool *is_multi, const char *ptr, int quote_count)\n{\n\tchar *str, *fixed, *esc;\n\tsize_t ptr_len = strlen(ptr), alloc_len;\n\n\t*is_multi = false;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, ptr_len, 1) ||\n\t\t(str = git__malloc(alloc_len)) == NULL) {\n\t\treturn -1;\n\t}\n\n\tfixed = str;\n\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == '\"') {\n\t\t\tquote_count++;\n\t\t} else if (*ptr != '\\\\') {\n\t\t\t*fixed++ = *ptr;\n\t\t} else {\n\t\t\t/* backslash, check the next char */\n\t\t\tptr++;\n\t\t\t/* if we're at the end, it's a multiline, so keep the backslash */\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\t*is_multi = true;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((esc = strchr(escapes, *ptr)) != NULL) {\n\t\t\t\t*fixed++ = escaped[esc - escapes];\n\t\t\t} else {\n\t\t\t\tgit__free(str);\n\t\t\t\tgiterr_set(GITERR_CONFIG, \"Invalid escape at %s\", ptr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\ndone:\n\t*fixed = '\\0';\n\t*out = str;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "escape_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1252-1282",
    "snippet": "static char *escape_value(const char *ptr)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t len;\n\tconst char *esc;\n\n\tassert(ptr);\n\n\tlen = strlen(ptr);\n\tif (!len)\n\t\treturn git__calloc(1, sizeof(char));\n\n\tgit_buf_grow(&buf, len);\n\n\twhile (*ptr != '\\0') {\n\t\tif ((esc = strchr(escaped, *ptr)) != NULL) {\n\t\t\tgit_buf_putc(&buf, '\\\\');\n\t\t\tgit_buf_putc(&buf, escapes[esc - escaped]);\n\t\t} else {\n\t\t\tgit_buf_putc(&buf, *ptr);\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (git_buf_oom(&buf)) {\n\t\tgit_buf_free(&buf);\n\t\treturn NULL;\n\t}\n\n\treturn git_buf_detach(&buf);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *escape_value(const char *ptr);",
      "static const char *escapes = \"ntb\\\"\\\\\";",
      "static const char *escaped = \"\\n\\t\\b\\\"\\\\\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&buf"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&buf"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "&buf",
            "*ptr"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "escaped",
            "*ptr"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "&buf",
            "len"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(char)"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ptr"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\nstatic const char *escapes = \"ntb\\\"\\\\\";\nstatic const char *escaped = \"\\n\\t\\b\\\"\\\\\";\n\nstatic char *escape_value(const char *ptr)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t len;\n\tconst char *esc;\n\n\tassert(ptr);\n\n\tlen = strlen(ptr);\n\tif (!len)\n\t\treturn git__calloc(1, sizeof(char));\n\n\tgit_buf_grow(&buf, len);\n\n\twhile (*ptr != '\\0') {\n\t\tif ((esc = strchr(escaped, *ptr)) != NULL) {\n\t\t\tgit_buf_putc(&buf, '\\\\');\n\t\t\tgit_buf_putc(&buf, escapes[esc - escaped]);\n\t\t} else {\n\t\t\tgit_buf_putc(&buf, *ptr);\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (git_buf_oom(&buf)) {\n\t\tgit_buf_free(&buf);\n\t\treturn NULL;\n\t}\n\n\treturn git_buf_detach(&buf);\n}"
  },
  {
    "function_name": "included_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1239-1246",
    "snippet": "static int included_path(git_buf *out, const char *dir, const char *path)\n{\n\t/* From the user's home */\n\tif (path[0] == '~' && path[1] == '/')\n\t\treturn git_sysdir_find_global_file(out, &path[1]);\n\n\treturn git_path_join_unrooted(out, path, dir, NULL);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_join_unrooted",
          "args": [
            "out",
            "path",
            "dir",
            "NULL"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_join_unrooted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "279-307",
          "snippet": "int git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sysdir_find_global_file",
          "args": [
            "out",
            "&path[1]"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "git_sysdir_find_global_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sysdir.c",
          "lines": "254-258",
          "snippet": "int git_sysdir_find_global_file(git_buf *path, const char *filename)\n{\n\treturn git_sysdir_find_in_dirlist(\n\t\tpath, filename, GIT_SYSDIR_GLOBAL, \"global\");\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"path.h\"",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"path.h\"\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_sysdir_find_global_file(git_buf *path, const char *filename)\n{\n\treturn git_sysdir_find_in_dirlist(\n\t\tpath, filename, GIT_SYSDIR_GLOBAL, \"global\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int included_path(git_buf *out, const char *dir, const char *path)\n{\n\t/* From the user's home */\n\tif (path[0] == '~' && path[1] == '/')\n\t\treturn git_sysdir_find_global_file(out, &path[1]);\n\n\treturn git_path_join_unrooted(out, path, dir, NULL);\n}"
  },
  {
    "function_name": "strip_comments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1208-1237",
    "snippet": "static int strip_comments(char *line, int in_quotes)\n{\n\tint quote_count = in_quotes, backslash_count = 0;\n\tchar *ptr;\n\n\tfor (ptr = line; *ptr; ++ptr) {\n\t\tif (ptr[0] == '\"' && ptr > line && ptr[-1] != '\\\\')\n\t\t\tquote_count++;\n\n\t\tif ((ptr[0] == ';' || ptr[0] == '#') &&\n\t\t\t(quote_count % 2) == 0 &&\n\t\t\t(backslash_count % 2) == 0) {\n\t\t\tptr[0] = '\\0';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ptr[0] == '\\\\')\n\t\t\tbackslash_count++;\n\t\telse\n\t\t\tbackslash_count = 0;\n\t}\n\n\t/* skip any space at the end */\n\twhile (ptr > line && git__isspace(ptr[-1])) {\n\t\tptr--;\n\t}\n\tptr[0] = '\\0';\n\n\treturn quote_count;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *escape_value(const char *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "ptr[-1]"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\n\nstatic int strip_comments(char *line, int in_quotes)\n{\n\tint quote_count = in_quotes, backslash_count = 0;\n\tchar *ptr;\n\n\tfor (ptr = line; *ptr; ++ptr) {\n\t\tif (ptr[0] == '\"' && ptr > line && ptr[-1] != '\\\\')\n\t\t\tquote_count++;\n\n\t\tif ((ptr[0] == ';' || ptr[0] == '#') &&\n\t\t\t(quote_count % 2) == 0 &&\n\t\t\t(backslash_count % 2) == 0) {\n\t\t\tptr[0] = '\\0';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ptr[0] == '\\\\')\n\t\t\tbackslash_count++;\n\t\telse\n\t\t\tbackslash_count = 0;\n\t}\n\n\t/* skip any space at the end */\n\twhile (ptr > line && git__isspace(ptr[-1])) {\n\t\tptr--;\n\t}\n\tptr[0] = '\\0';\n\n\treturn quote_count;\n}"
  },
  {
    "function_name": "skip_bom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1155-1167",
    "snippet": "static int skip_bom(struct reader *reader)\n{\n\tgit_bom_t bom;\n\tint bom_offset = git_buf_text_detect_bom(&bom,\n\t\t&reader->buffer, reader->read_ptr - reader->buffer.ptr);\n\n\tif (bom == GIT_BOM_UTF8)\n\t\treader->read_ptr += bom_offset;\n\n\t/* TODO: reference implementation is pretty stupid with BoM */\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *escape_value(const char *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_text_detect_bom",
          "args": [
            "&bom",
            "&reader->buffer",
            "reader->read_ptr - reader->buffer.ptr"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_detect_bom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "218-266",
          "snippet": "int git_buf_text_detect_bom(git_bom_t *bom, const git_buf *buf, size_t offset)\n{\n\tconst char *ptr;\n\tsize_t len;\n\n\t*bom = GIT_BOM_NONE;\n\t/* need at least 2 bytes after offset to look for any BOM */\n\tif (buf->size < offset + 2)\n\t\treturn 0;\n\n\tptr = buf->ptr + offset;\n\tlen = buf->size - offset;\n\n\tswitch (*ptr++) {\n\tcase 0:\n\t\tif (len >= 4 && ptr[0] == 0 && ptr[1] == '\\xFE' && ptr[2] == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF32_BE;\n\t\t\treturn 4;\n\t\t}\n\t\tbreak;\n\tcase '\\xEF':\n\t\tif (len >= 3 && ptr[0] == '\\xBB' && ptr[1] == '\\xBF') {\n\t\t\t*bom = GIT_BOM_UTF8;\n\t\t\treturn 3;\n\t\t}\n\t\tbreak;\n\tcase '\\xFE':\n\t\tif (*ptr == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF16_BE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tcase '\\xFF':\n\t\tif (*ptr != '\\xFE')\n\t\t\tbreak;\n\t\tif (len >= 4 && ptr[1] == 0 && ptr[2] == 0) {\n\t\t\t*bom = GIT_BOM_UTF32_LE;\n\t\t\treturn 4;\n\t\t} else {\n\t\t\t*bom = GIT_BOM_UTF16_LE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_detect_bom(git_bom_t *bom, const git_buf *buf, size_t offset)\n{\n\tconst char *ptr;\n\tsize_t len;\n\n\t*bom = GIT_BOM_NONE;\n\t/* need at least 2 bytes after offset to look for any BOM */\n\tif (buf->size < offset + 2)\n\t\treturn 0;\n\n\tptr = buf->ptr + offset;\n\tlen = buf->size - offset;\n\n\tswitch (*ptr++) {\n\tcase 0:\n\t\tif (len >= 4 && ptr[0] == 0 && ptr[1] == '\\xFE' && ptr[2] == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF32_BE;\n\t\t\treturn 4;\n\t\t}\n\t\tbreak;\n\tcase '\\xEF':\n\t\tif (len >= 3 && ptr[0] == '\\xBB' && ptr[1] == '\\xBF') {\n\t\t\t*bom = GIT_BOM_UTF8;\n\t\t\treturn 3;\n\t\t}\n\t\tbreak;\n\tcase '\\xFE':\n\t\tif (*ptr == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF16_BE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tcase '\\xFF':\n\t\tif (*ptr != '\\xFE')\n\t\t\tbreak;\n\t\tif (len >= 4 && ptr[1] == 0 && ptr[2] == 0) {\n\t\t\t*bom = GIT_BOM_UTF32_LE;\n\t\t\treturn 4;\n\t\t} else {\n\t\t\t*bom = GIT_BOM_UTF16_LE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\n\nstatic int skip_bom(struct reader *reader)\n{\n\tgit_bom_t bom;\n\tint bom_offset = git_buf_text_detect_bom(&bom,\n\t\t&reader->buffer, reader->read_ptr - reader->buffer.ptr);\n\n\tif (bom == GIT_BOM_UTF8)\n\t\treader->read_ptr += bom_offset;\n\n\t/* TODO: reference implementation is pretty stupid with BoM */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_section_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1086-1153",
    "snippet": "static int parse_section_header(struct reader *reader, char **section_out)\n{\n\tchar *name, *name_end;\n\tint name_length, c, pos;\n\tint result;\n\tchar *line;\n\tsize_t line_len;\n\n\tline = reader_readline(reader, true);\n\tif (line == NULL)\n\t\treturn -1;\n\n\t/* find the end of the variable's name */\n\tname_end = strrchr(line, ']');\n\tif (name_end == NULL) {\n\t\tgit__free(line);\n\t\tset_parse_error(reader, 0, \"Missing ']' in section header\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&line_len, (size_t)(name_end - line), 1);\n\tname = git__malloc(line_len);\n\tGITERR_CHECK_ALLOC(name);\n\n\tname_length = 0;\n\tpos = 0;\n\n\t/* Make sure we were given a section header */\n\tc = line[pos++];\n\tassert(c == '[');\n\n\tc = line[pos++];\n\n\tdo {\n\t\tif (git__isspace(c)){\n\t\t\tname[name_length] = '\\0';\n\t\t\tresult = parse_section_header_ext(reader, line, name, section_out);\n\t\t\tgit__free(line);\n\t\t\tgit__free(name);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (!config_keychar(c) && c != '.') {\n\t\t\tset_parse_error(reader, pos, \"Unexpected character in header\");\n\t\t\tgoto fail_parse;\n\t\t}\n\n\t\tname[name_length++] = (char)git__tolower(c);\n\n\t} while ((c = line[pos++]) != ']');\n\n\tif (line[pos - 1] != ']') {\n\t\tset_parse_error(reader, pos, \"Unexpected end of file\");\n\t\tgoto fail_parse;\n\t}\n\n\tgit__free(line);\n\n\tname[name_length] = 0;\n\t*section_out = name;\n\n\treturn 0;\n\nfail_parse:\n\tgit__free(line);\n\tgit__free(name);\n\treturn -1;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "name"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_parse_error",
          "args": [
            "reader",
            "pos",
            "\"Unexpected end of file\""
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "set_parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "127-131",
          "snippet": "static void set_parse_error(struct reader *reader, int col, const char *error_str)\n{\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse config file: %s (in %s:%d, column %d)\",\n\t\terror_str, reader->file_path, reader->line_number, col);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic void set_parse_error(struct reader *reader, int col, const char *error_str)\n{\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse config file: %s (in %s:%d, column %d)\",\n\t\terror_str, reader->file_path, reader->line_number, col);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__tolower",
          "args": [
            "c"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "git__tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "285-288",
          "snippet": "GIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_keychar",
          "args": [
            "c"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "config_keychar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1000-1003",
          "snippet": "GIT_INLINE(int) config_keychar(int c)\n{\n\treturn isalnum(c) || c == '-';\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) config_keychar(int c)\n{\n\treturn isalnum(c) || c == '-';\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_section_header_ext",
          "args": [
            "reader",
            "line",
            "name",
            "section_out"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "parse_section_header_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1005-1084",
          "snippet": "static int parse_section_header_ext(struct reader *reader, const char *line, const char *base_name, char **section_name)\n{\n\tint c, rpos;\n\tchar *first_quote, *last_quote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t quoted_len, alloc_len, base_name_len = strlen(base_name);\n\n\t/*\n\t * base_name is what came before the space. We should be at the\n\t * first quotation mark, except for now, line isn't being kept in\n\t * sync so we only really use it to calculate the length.\n\t */\n\n\tfirst_quote = strchr(line, '\"');\n\tif (first_quote == NULL) {\n\t\tset_parse_error(reader, 0, \"Missing quotation marks in section header\");\n\t\treturn -1;\n\t}\n\n\tlast_quote = strrchr(line, '\"');\n\tquoted_len = last_quote - first_quote;\n\n\tif (quoted_len == 0) {\n\t\tset_parse_error(reader, 0, \"Missing closing quotation mark in section header\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, base_name_len, quoted_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_grow(&buf, alloc_len);\n\tgit_buf_printf(&buf, \"%s.\", base_name);\n\n\trpos = 0;\n\n\tline = first_quote;\n\tc = line[++rpos];\n\n\t/*\n\t * At the end of each iteration, whatever is stored in c will be\n\t * added to the string. In case of error, jump to out\n\t */\n\tdo {\n\n\t\tswitch (c) {\n\t\tcase 0:\n\t\t\tset_parse_error(reader, 0, \"Unexpected end-of-line in section header\");\n\t\t\tgit_buf_free(&buf);\n\t\t\treturn -1;\n\n\t\tcase '\"':\n\t\t\tgoto end_parse;\n\n\t\tcase '\\\\':\n\t\t\tc = line[++rpos];\n\n\t\t\tif (c == 0) {\n\t\t\t\tset_parse_error(reader, rpos, \"Unexpected end-of-line in section header\");\n\t\t\t\tgit_buf_free(&buf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tgit_buf_putc(&buf, (char)c);\n\t\tc = line[++rpos];\n\t} while (line + rpos < last_quote);\n\nend_parse:\n\tif (line[rpos] != '\"' || line[rpos + 1] != ']') {\n\t\tset_parse_error(reader, rpos, \"Unexpected text after closing quotes\");\n\t\tgit_buf_free(&buf);\n\t\treturn -1;\n\t}\n\n\t*section_name = git_buf_detach(&buf);\n\treturn 0;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int parse_section_header_ext(struct reader *reader, const char *line, const char *base_name, char **section_name)\n{\n\tint c, rpos;\n\tchar *first_quote, *last_quote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t quoted_len, alloc_len, base_name_len = strlen(base_name);\n\n\t/*\n\t * base_name is what came before the space. We should be at the\n\t * first quotation mark, except for now, line isn't being kept in\n\t * sync so we only really use it to calculate the length.\n\t */\n\n\tfirst_quote = strchr(line, '\"');\n\tif (first_quote == NULL) {\n\t\tset_parse_error(reader, 0, \"Missing quotation marks in section header\");\n\t\treturn -1;\n\t}\n\n\tlast_quote = strrchr(line, '\"');\n\tquoted_len = last_quote - first_quote;\n\n\tif (quoted_len == 0) {\n\t\tset_parse_error(reader, 0, \"Missing closing quotation mark in section header\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, base_name_len, quoted_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_grow(&buf, alloc_len);\n\tgit_buf_printf(&buf, \"%s.\", base_name);\n\n\trpos = 0;\n\n\tline = first_quote;\n\tc = line[++rpos];\n\n\t/*\n\t * At the end of each iteration, whatever is stored in c will be\n\t * added to the string. In case of error, jump to out\n\t */\n\tdo {\n\n\t\tswitch (c) {\n\t\tcase 0:\n\t\t\tset_parse_error(reader, 0, \"Unexpected end-of-line in section header\");\n\t\t\tgit_buf_free(&buf);\n\t\t\treturn -1;\n\n\t\tcase '\"':\n\t\t\tgoto end_parse;\n\n\t\tcase '\\\\':\n\t\t\tc = line[++rpos];\n\n\t\t\tif (c == 0) {\n\t\t\t\tset_parse_error(reader, rpos, \"Unexpected end-of-line in section header\");\n\t\t\t\tgit_buf_free(&buf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tgit_buf_putc(&buf, (char)c);\n\t\tc = line[++rpos];\n\t} while (line + rpos < last_quote);\n\nend_parse:\n\tif (line[rpos] != '\"' || line[rpos + 1] != ']') {\n\t\tset_parse_error(reader, rpos, \"Unexpected text after closing quotes\");\n\t\tgit_buf_free(&buf);\n\t\treturn -1;\n\t}\n\n\t*section_name = git_buf_detach(&buf);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "c"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "c == '['"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "name"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "line_len"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&line_len",
            "(size_t)(name_end - line)",
            "1"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "']'"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader_readline",
          "args": [
            "reader",
            "true"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "reader_readline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "932-974",
          "snippet": "static char *reader_readline(struct reader *reader, bool skip_whitespace)\n{\n\tchar *line = NULL;\n\tchar *line_src, *line_end;\n\tsize_t line_len, alloc_len;\n\n\tline_src = reader->read_ptr;\n\n\tif (skip_whitespace) {\n\t\t/* Skip empty empty lines */\n\t\twhile (git__isspace(*line_src))\n\t\t\t++line_src;\n\t}\n\n\tline_end = strchr(line_src, '\\n');\n\n\t/* no newline at EOF */\n\tif (line_end == NULL)\n\t\tline_end = strchr(line_src, 0);\n\n\tline_len = line_end - line_src;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, line_len, 1) ||\n\t\t(line = git__malloc(alloc_len)) == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemcpy(line, line_src, line_len);\n\n\tdo line[line_len] = '\\0';\n\twhile (line_len-- > 0 && git__isspace(line[line_len]));\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n\n\treturn line;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *reader_readline(struct reader *reader, bool skip_whitespace)\n{\n\tchar *line = NULL;\n\tchar *line_src, *line_end;\n\tsize_t line_len, alloc_len;\n\n\tline_src = reader->read_ptr;\n\n\tif (skip_whitespace) {\n\t\t/* Skip empty empty lines */\n\t\twhile (git__isspace(*line_src))\n\t\t\t++line_src;\n\t}\n\n\tline_end = strchr(line_src, '\\n');\n\n\t/* no newline at EOF */\n\tif (line_end == NULL)\n\t\tline_end = strchr(line_src, 0);\n\n\tline_len = line_end - line_src;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, line_len, 1) ||\n\t\t(line = git__malloc(alloc_len)) == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemcpy(line, line_src, line_len);\n\n\tdo line[line_len] = '\\0';\n\twhile (line_len-- > 0 && git__isspace(line[line_len]));\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n\n\treturn line;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int parse_section_header(struct reader *reader, char **section_out)\n{\n\tchar *name, *name_end;\n\tint name_length, c, pos;\n\tint result;\n\tchar *line;\n\tsize_t line_len;\n\n\tline = reader_readline(reader, true);\n\tif (line == NULL)\n\t\treturn -1;\n\n\t/* find the end of the variable's name */\n\tname_end = strrchr(line, ']');\n\tif (name_end == NULL) {\n\t\tgit__free(line);\n\t\tset_parse_error(reader, 0, \"Missing ']' in section header\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&line_len, (size_t)(name_end - line), 1);\n\tname = git__malloc(line_len);\n\tGITERR_CHECK_ALLOC(name);\n\n\tname_length = 0;\n\tpos = 0;\n\n\t/* Make sure we were given a section header */\n\tc = line[pos++];\n\tassert(c == '[');\n\n\tc = line[pos++];\n\n\tdo {\n\t\tif (git__isspace(c)){\n\t\t\tname[name_length] = '\\0';\n\t\t\tresult = parse_section_header_ext(reader, line, name, section_out);\n\t\t\tgit__free(line);\n\t\t\tgit__free(name);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (!config_keychar(c) && c != '.') {\n\t\t\tset_parse_error(reader, pos, \"Unexpected character in header\");\n\t\t\tgoto fail_parse;\n\t\t}\n\n\t\tname[name_length++] = (char)git__tolower(c);\n\n\t} while ((c = line[pos++]) != ']');\n\n\tif (line[pos - 1] != ']') {\n\t\tset_parse_error(reader, pos, \"Unexpected end of file\");\n\t\tgoto fail_parse;\n\t}\n\n\tgit__free(line);\n\n\tname[name_length] = 0;\n\t*section_out = name;\n\n\treturn 0;\n\nfail_parse:\n\tgit__free(line);\n\tgit__free(name);\n\treturn -1;\n}"
  },
  {
    "function_name": "parse_section_header_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1005-1084",
    "snippet": "static int parse_section_header_ext(struct reader *reader, const char *line, const char *base_name, char **section_name)\n{\n\tint c, rpos;\n\tchar *first_quote, *last_quote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t quoted_len, alloc_len, base_name_len = strlen(base_name);\n\n\t/*\n\t * base_name is what came before the space. We should be at the\n\t * first quotation mark, except for now, line isn't being kept in\n\t * sync so we only really use it to calculate the length.\n\t */\n\n\tfirst_quote = strchr(line, '\"');\n\tif (first_quote == NULL) {\n\t\tset_parse_error(reader, 0, \"Missing quotation marks in section header\");\n\t\treturn -1;\n\t}\n\n\tlast_quote = strrchr(line, '\"');\n\tquoted_len = last_quote - first_quote;\n\n\tif (quoted_len == 0) {\n\t\tset_parse_error(reader, 0, \"Missing closing quotation mark in section header\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, base_name_len, quoted_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_grow(&buf, alloc_len);\n\tgit_buf_printf(&buf, \"%s.\", base_name);\n\n\trpos = 0;\n\n\tline = first_quote;\n\tc = line[++rpos];\n\n\t/*\n\t * At the end of each iteration, whatever is stored in c will be\n\t * added to the string. In case of error, jump to out\n\t */\n\tdo {\n\n\t\tswitch (c) {\n\t\tcase 0:\n\t\t\tset_parse_error(reader, 0, \"Unexpected end-of-line in section header\");\n\t\t\tgit_buf_free(&buf);\n\t\t\treturn -1;\n\n\t\tcase '\"':\n\t\t\tgoto end_parse;\n\n\t\tcase '\\\\':\n\t\t\tc = line[++rpos];\n\n\t\t\tif (c == 0) {\n\t\t\t\tset_parse_error(reader, rpos, \"Unexpected end-of-line in section header\");\n\t\t\t\tgit_buf_free(&buf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tgit_buf_putc(&buf, (char)c);\n\t\tc = line[++rpos];\n\t} while (line + rpos < last_quote);\n\nend_parse:\n\tif (line[rpos] != '\"' || line[rpos + 1] != ']') {\n\t\tset_parse_error(reader, rpos, \"Unexpected text after closing quotes\");\n\t\tgit_buf_free(&buf);\n\t\treturn -1;\n\t}\n\n\t*section_name = git_buf_detach(&buf);\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;",
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&buf"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_parse_error",
          "args": [
            "reader",
            "rpos",
            "\"Unexpected text after closing quotes\""
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "set_parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "127-131",
          "snippet": "static void set_parse_error(struct reader *reader, int col, const char *error_str)\n{\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse config file: %s (in %s:%d, column %d)\",\n\t\terror_str, reader->file_path, reader->line_number, col);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic void set_parse_error(struct reader *reader, int col, const char *error_str)\n{\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse config file: %s (in %s:%d, column %d)\",\n\t\terror_str, reader->file_path, reader->line_number, col);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "&buf",
            "(char)c"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"%s.\"",
            "base_name"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "&buf",
            "alloc_len"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "alloc_len",
            "2"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "base_name_len",
            "quoted_len"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "'\"'"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'\"'"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "base_name"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstruct cvar_t {\n\tstruct cvar_t *next;\n\tgit_config_entry *entry;\n\tbool included; /* whether this is part of [include] */\n} cvar_t;\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int parse_section_header_ext(struct reader *reader, const char *line, const char *base_name, char **section_name)\n{\n\tint c, rpos;\n\tchar *first_quote, *last_quote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t quoted_len, alloc_len, base_name_len = strlen(base_name);\n\n\t/*\n\t * base_name is what came before the space. We should be at the\n\t * first quotation mark, except for now, line isn't being kept in\n\t * sync so we only really use it to calculate the length.\n\t */\n\n\tfirst_quote = strchr(line, '\"');\n\tif (first_quote == NULL) {\n\t\tset_parse_error(reader, 0, \"Missing quotation marks in section header\");\n\t\treturn -1;\n\t}\n\n\tlast_quote = strrchr(line, '\"');\n\tquoted_len = last_quote - first_quote;\n\n\tif (quoted_len == 0) {\n\t\tset_parse_error(reader, 0, \"Missing closing quotation mark in section header\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, base_name_len, quoted_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tgit_buf_grow(&buf, alloc_len);\n\tgit_buf_printf(&buf, \"%s.\", base_name);\n\n\trpos = 0;\n\n\tline = first_quote;\n\tc = line[++rpos];\n\n\t/*\n\t * At the end of each iteration, whatever is stored in c will be\n\t * added to the string. In case of error, jump to out\n\t */\n\tdo {\n\n\t\tswitch (c) {\n\t\tcase 0:\n\t\t\tset_parse_error(reader, 0, \"Unexpected end-of-line in section header\");\n\t\t\tgit_buf_free(&buf);\n\t\t\treturn -1;\n\n\t\tcase '\"':\n\t\t\tgoto end_parse;\n\n\t\tcase '\\\\':\n\t\t\tc = line[++rpos];\n\n\t\t\tif (c == 0) {\n\t\t\t\tset_parse_error(reader, rpos, \"Unexpected end-of-line in section header\");\n\t\t\t\tgit_buf_free(&buf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tgit_buf_putc(&buf, (char)c);\n\t\tc = line[++rpos];\n\t} while (line + rpos < last_quote);\n\nend_parse:\n\tif (line[rpos] != '\"' || line[rpos + 1] != ']') {\n\t\tset_parse_error(reader, rpos, \"Unexpected text after closing quotes\");\n\t\tgit_buf_free(&buf);\n\t\treturn -1;\n\t}\n\n\t*section_name = git_buf_detach(&buf);\n\treturn 0;\n}"
  },
  {
    "function_name": "config_keychar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "1000-1003",
    "snippet": "GIT_INLINE(int) config_keychar(int c)\n{\n\treturn isalnum(c) || c == '-';\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "c"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) config_keychar(int c)\n{\n\treturn isalnum(c) || c == '-';\n}"
  },
  {
    "function_name": "reader_consume_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "979-998",
    "snippet": "static void reader_consume_line(struct reader *reader)\n{\n\tchar *line_start, *line_end;\n\n\tline_start = reader->read_ptr;\n\tline_end = strchr(line_start, '\\n');\n\t/* No newline at EOF */\n\tif(line_end == NULL){\n\t\tline_end = strchr(line_start, '\\0');\n\t}\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line_start",
            "'\\0'"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line_start",
            "'\\n'"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void reader_consume_line(struct reader *reader)\n{\n\tchar *line_start, *line_end;\n\n\tline_start = reader->read_ptr;\n\tline_end = strchr(line_start, '\\n');\n\t/* No newline at EOF */\n\tif(line_end == NULL){\n\t\tline_end = strchr(line_start, '\\0');\n\t}\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n}"
  },
  {
    "function_name": "reader_readline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "932-974",
    "snippet": "static char *reader_readline(struct reader *reader, bool skip_whitespace)\n{\n\tchar *line = NULL;\n\tchar *line_src, *line_end;\n\tsize_t line_len, alloc_len;\n\n\tline_src = reader->read_ptr;\n\n\tif (skip_whitespace) {\n\t\t/* Skip empty empty lines */\n\t\twhile (git__isspace(*line_src))\n\t\t\t++line_src;\n\t}\n\n\tline_end = strchr(line_src, '\\n');\n\n\t/* no newline at EOF */\n\tif (line_end == NULL)\n\t\tline_end = strchr(line_src, 0);\n\n\tline_len = line_end - line_src;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, line_len, 1) ||\n\t\t(line = git__malloc(alloc_len)) == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemcpy(line, line_src, line_len);\n\n\tdo line[line_len] = '\\0';\n\twhile (line_len-- > 0 && git__isspace(line[line_len]));\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n\n\treturn line;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "line[line_len]"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "line",
            "line_src",
            "line_len"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloc_len"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloc_len",
            "line_len",
            "1"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line_src",
            "0"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line_src",
            "'\\n'"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *reader_readline(struct reader *reader, bool skip_whitespace)\n{\n\tchar *line = NULL;\n\tchar *line_src, *line_end;\n\tsize_t line_len, alloc_len;\n\n\tline_src = reader->read_ptr;\n\n\tif (skip_whitespace) {\n\t\t/* Skip empty empty lines */\n\t\twhile (git__isspace(*line_src))\n\t\t\t++line_src;\n\t}\n\n\tline_end = strchr(line_src, '\\n');\n\n\t/* no newline at EOF */\n\tif (line_end == NULL)\n\t\tline_end = strchr(line_src, 0);\n\n\tline_len = line_end - line_src;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloc_len, line_len, 1) ||\n\t\t(line = git__malloc(alloc_len)) == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemcpy(line, line_src, line_len);\n\n\tdo line[line_len] = '\\0';\n\twhile (line_len-- > 0 && git__isspace(line[line_len]));\n\n\tif (*line_end == '\\n')\n\t\tline_end++;\n\n\tif (*line_end == '\\0')\n\t\treader->eof = 1;\n\n\treader->line_number++;\n\treader->read_ptr = line_end;\n\n\treturn line;\n}"
  },
  {
    "function_name": "reader_peek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "908-927",
    "snippet": "static int reader_peek(struct reader *reader, int flags)\n{\n\tvoid *old_read_ptr;\n\tint old_lineno, old_eof;\n\tint ret;\n\n\tassert(reader->read_ptr);\n\n\told_read_ptr = reader->read_ptr;\n\told_lineno = reader->line_number;\n\told_eof = reader->eof;\n\n\tret = reader_getchar(reader, flags);\n\n\treader->read_ptr = old_read_ptr;\n\treader->line_number = old_lineno;\n\treader->eof = old_eof;\n\n\treturn ret;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reader_getchar",
          "args": [
            "reader",
            "flags"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "reader_getchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "884-903",
          "snippet": "static int reader_getchar(struct reader *reader, int flags)\n{\n\tconst int skip_whitespace = (flags & SKIP_WHITESPACE);\n\tconst int skip_comments = (flags & SKIP_COMMENTS);\n\tint c;\n\n\tassert(reader->read_ptr);\n\n\tdo {\n\t\tc = reader_getchar_raw(reader);\n\t} while (c != '\\n' && c != '\\0' && skip_whitespace && git__isspace(c));\n\n\tif (skip_comments && (c == '#' || c == ';')) {\n\t\tdo {\n\t\t\tc = reader_getchar_raw(reader);\n\t\t} while (c != '\\n' && c != '\\0');\n\t}\n\n\treturn c;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define SKIP_COMMENTS (1 << 2)",
            "#define SKIP_WHITESPACE (1 << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\n#define SKIP_COMMENTS (1 << 2)\n#define SKIP_WHITESPACE (1 << 1)\n\nstatic int reader_getchar(struct reader *reader, int flags)\n{\n\tconst int skip_whitespace = (flags & SKIP_WHITESPACE);\n\tconst int skip_comments = (flags & SKIP_COMMENTS);\n\tint c;\n\n\tassert(reader->read_ptr);\n\n\tdo {\n\t\tc = reader_getchar_raw(reader);\n\t} while (c != '\\n' && c != '\\0' && skip_whitespace && git__isspace(c));\n\n\tif (skip_comments && (c == '#' || c == ';')) {\n\t\tdo {\n\t\t\tc = reader_getchar_raw(reader);\n\t\t} while (c != '\\n' && c != '\\0');\n\t}\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "reader->read_ptr"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int reader_peek(struct reader *reader, int flags)\n{\n\tvoid *old_read_ptr;\n\tint old_lineno, old_eof;\n\tint ret;\n\n\tassert(reader->read_ptr);\n\n\told_read_ptr = reader->read_ptr;\n\told_lineno = reader->line_number;\n\told_eof = reader->eof;\n\n\tret = reader_getchar(reader, flags);\n\n\treader->read_ptr = old_read_ptr;\n\treader->line_number = old_lineno;\n\treader->eof = old_eof;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "reader_getchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "884-903",
    "snippet": "static int reader_getchar(struct reader *reader, int flags)\n{\n\tconst int skip_whitespace = (flags & SKIP_WHITESPACE);\n\tconst int skip_comments = (flags & SKIP_COMMENTS);\n\tint c;\n\n\tassert(reader->read_ptr);\n\n\tdo {\n\t\tc = reader_getchar_raw(reader);\n\t} while (c != '\\n' && c != '\\0' && skip_whitespace && git__isspace(c));\n\n\tif (skip_comments && (c == '#' || c == ';')) {\n\t\tdo {\n\t\t\tc = reader_getchar_raw(reader);\n\t\t} while (c != '\\n' && c != '\\0');\n\t}\n\n\treturn c;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define SKIP_COMMENTS (1 << 2)",
      "#define SKIP_WHITESPACE (1 << 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reader_getchar_raw",
          "args": [
            "reader"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "reader_getchar_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "855-879",
          "snippet": "static int reader_getchar_raw(struct reader *reader)\n{\n\tint c;\n\n\tc = *reader->read_ptr++;\n\n\t/*\n\tWin 32 line breaks: if we find a \\r\\n sequence,\n\treturn only the \\n as a newline\n\t*/\n\tif (c == '\\r' && *reader->read_ptr == '\\n') {\n\t\treader->read_ptr++;\n\t\tc = '\\n';\n\t}\n\n\tif (c == '\\n')\n\t\treader->line_number++;\n\n\tif (c == 0) {\n\t\treader->eof = 1;\n\t\tc = '\\0';\n\t}\n\n\treturn c;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int reader_getchar_raw(struct reader *reader)\n{\n\tint c;\n\n\tc = *reader->read_ptr++;\n\n\t/*\n\tWin 32 line breaks: if we find a \\r\\n sequence,\n\treturn only the \\n as a newline\n\t*/\n\tif (c == '\\r' && *reader->read_ptr == '\\n') {\n\t\treader->read_ptr++;\n\t\tc = '\\n';\n\t}\n\n\tif (c == '\\n')\n\t\treader->line_number++;\n\n\tif (c == 0) {\n\t\treader->eof = 1;\n\t\tc = '\\0';\n\t}\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "c"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "reader->read_ptr"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\n#define SKIP_COMMENTS (1 << 2)\n#define SKIP_WHITESPACE (1 << 1)\n\nstatic int reader_getchar(struct reader *reader, int flags)\n{\n\tconst int skip_whitespace = (flags & SKIP_WHITESPACE);\n\tconst int skip_comments = (flags & SKIP_COMMENTS);\n\tint c;\n\n\tassert(reader->read_ptr);\n\n\tdo {\n\t\tc = reader_getchar_raw(reader);\n\t} while (c != '\\n' && c != '\\0' && skip_whitespace && git__isspace(c));\n\n\tif (skip_comments && (c == '#' || c == ';')) {\n\t\tdo {\n\t\t\tc = reader_getchar_raw(reader);\n\t\t} while (c != '\\n' && c != '\\0');\n\t}\n\n\treturn c;\n}"
  },
  {
    "function_name": "reader_getchar_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "855-879",
    "snippet": "static int reader_getchar_raw(struct reader *reader)\n{\n\tint c;\n\n\tc = *reader->read_ptr++;\n\n\t/*\n\tWin 32 line breaks: if we find a \\r\\n sequence,\n\treturn only the \\n as a newline\n\t*/\n\tif (c == '\\r' && *reader->read_ptr == '\\n') {\n\t\treader->read_ptr++;\n\t\tc = '\\n';\n\t}\n\n\tif (c == '\\n')\n\t\treader->line_number++;\n\n\tif (c == 0) {\n\t\treader->eof = 1;\n\t\tc = '\\0';\n\t}\n\n\treturn c;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int reader_getchar_raw(struct reader *reader)\n{\n\tint c;\n\n\tc = *reader->read_ptr++;\n\n\t/*\n\tWin 32 line breaks: if we find a \\r\\n sequence,\n\treturn only the \\n as a newline\n\t*/\n\tif (c == '\\r' && *reader->read_ptr == '\\n') {\n\t\treader->read_ptr++;\n\t\tc = '\\n';\n\t}\n\n\tif (c == '\\n')\n\t\treader->line_number++;\n\n\tif (c == 0) {\n\t\treader->eof = 1;\n\t\tc = '\\0';\n\t}\n\n\treturn c;\n}"
  },
  {
    "function_name": "git_config_file__snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "825-853",
    "snippet": "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in)\n{\n\tdiskfile_readonly_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(diskfile_readonly_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tgit_mutex_init(&backend->header.values_mutex);\n\n\tbackend->snapshot_from = in;\n\n\tbackend->header.parent.readonly = 1;\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tbackend->header.parent.open = config_readonly_open;\n\tbackend->header.parent.get = config_get;\n\tbackend->header.parent.set = config_set_readonly;\n\tbackend->header.parent.set_multivar = config_set_multivar_readonly;\n\tbackend->header.parent.del = config_delete_readonly;\n\tbackend->header.parent.del_multivar = config_delete_multivar_readonly;\n\tbackend->header.parent.iterator = config_iterator_new;\n\tbackend->header.parent.lock = config_lock_readonly;\n\tbackend->header.parent.unlock = config_unlock_readonly;\n\tbackend->header.parent.free = backend_readonly_free;\n\n\t*out = (git_config_backend *)backend;\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_init",
          "args": [
            "&backend->header.values_mutex"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "140-141",
          "snippet": "GIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "backend"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(diskfile_readonly_backend)"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in)\n{\n\tdiskfile_readonly_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(diskfile_readonly_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tgit_mutex_init(&backend->header.values_mutex);\n\n\tbackend->snapshot_from = in;\n\n\tbackend->header.parent.readonly = 1;\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tbackend->header.parent.open = config_readonly_open;\n\tbackend->header.parent.get = config_get;\n\tbackend->header.parent.set = config_set_readonly;\n\tbackend->header.parent.set_multivar = config_set_multivar_readonly;\n\tbackend->header.parent.del = config_delete_readonly;\n\tbackend->header.parent.del_multivar = config_delete_multivar_readonly;\n\tbackend->header.parent.iterator = config_iterator_new;\n\tbackend->header.parent.lock = config_lock_readonly;\n\tbackend->header.parent.unlock = config_unlock_readonly;\n\tbackend->header.parent.free = backend_readonly_free;\n\n\t*out = (git_config_backend *)backend;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "config_readonly_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "805-823",
    "snippet": "static int config_readonly_open(git_config_backend *cfg, git_config_level_t level)\n{\n\tdiskfile_readonly_backend *b = (diskfile_readonly_backend *) cfg;\n\tdiskfile_backend *src = b->snapshot_from;\n\tdiskfile_header *src_header = &src->header;\n\trefcounted_strmap *src_map;\n\tint error;\n\n\tif (!src_header->parent.readonly && (error = config_refresh(&src_header->parent)) < 0)\n\t\treturn error;\n\n\t/* We're just copying data, don't care about the level */\n\tGIT_UNUSED(level);\n\n\tsrc_map = refcounted_strmap_take(src_header);\n\tb->header.values = src_map;\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcounted_strmap_take",
          "args": [
            "src_header"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_take",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "231-243",
          "snippet": "static refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "level"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_refresh",
          "args": [
            "&src_header->parent"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "config_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "336-360",
          "snippet": "static int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_readonly_open(git_config_backend *cfg, git_config_level_t level)\n{\n\tdiskfile_readonly_backend *b = (diskfile_readonly_backend *) cfg;\n\tdiskfile_backend *src = b->snapshot_from;\n\tdiskfile_header *src_header = &src->header;\n\trefcounted_strmap *src_map;\n\tint error;\n\n\tif (!src_header->parent.readonly && (error = config_refresh(&src_header->parent)) < 0)\n\t\treturn error;\n\n\t/* We're just copying data, don't care about the level */\n\tGIT_UNUSED(level);\n\n\tsrc_map = refcounted_strmap_take(src_header);\n\tb->header.values = src_map;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "backend_readonly_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "793-803",
    "snippet": "static void backend_readonly_free(git_config_backend *_backend)\n{\n\tdiskfile_backend *backend = (diskfile_backend *)_backend;\n\n\tif (backend == NULL)\n\t\treturn;\n\n\trefcounted_strmap_free(backend->header.values);\n\tgit_mutex_free(&backend->header.values_mutex);\n\tgit__free(backend);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "backend"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_free",
          "args": [
            "&backend->header.values_mutex"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "104-108",
          "snippet": "int git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_free",
          "args": [
            "backend->header.values"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "214-224",
          "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void backend_readonly_free(git_config_backend *_backend)\n{\n\tdiskfile_backend *backend = (diskfile_backend *)_backend;\n\n\tif (backend == NULL)\n\t\treturn;\n\n\trefcounted_strmap_free(backend->header.values);\n\tgit_mutex_free(&backend->header.values_mutex);\n\tgit__free(backend);\n}"
  },
  {
    "function_name": "config_unlock_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "785-791",
    "snippet": "static int config_unlock_readonly(git_config_backend *_cfg, int success)\n{\n\tGIT_UNUSED(_cfg);\n\tGIT_UNUSED(success);\n\n\treturn config_error_readonly();\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_error_readonly",
          "args": [],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "config_error_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "133-137",
          "snippet": "static int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "success"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "_cfg"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_unlock_readonly(git_config_backend *_cfg, int success)\n{\n\tGIT_UNUSED(_cfg);\n\tGIT_UNUSED(success);\n\n\treturn config_error_readonly();\n}"
  },
  {
    "function_name": "config_lock_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "778-783",
    "snippet": "static int config_lock_readonly(git_config_backend *_cfg)\n{\n\tGIT_UNUSED(_cfg);\n\n\treturn config_error_readonly();\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_error_readonly",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "config_error_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "133-137",
          "snippet": "static int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "_cfg"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_lock_readonly(git_config_backend *_cfg)\n{\n\tGIT_UNUSED(_cfg);\n\n\treturn config_error_readonly();\n}"
  },
  {
    "function_name": "config_delete_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "770-776",
    "snippet": "static int config_delete_readonly(git_config_backend *cfg, const char *name)\n{\n\tGIT_UNUSED(cfg);\n\tGIT_UNUSED(name);\n\n\treturn config_error_readonly();\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_error_readonly",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "config_error_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "133-137",
          "snippet": "static int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "name"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "cfg"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_delete_readonly(git_config_backend *cfg, const char *name)\n{\n\tGIT_UNUSED(cfg);\n\tGIT_UNUSED(name);\n\n\treturn config_error_readonly();\n}"
  },
  {
    "function_name": "config_delete_multivar_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "761-768",
    "snippet": "static int config_delete_multivar_readonly(git_config_backend *cfg, const char *name, const char *regexp)\n{\n\tGIT_UNUSED(cfg);\n\tGIT_UNUSED(name);\n\tGIT_UNUSED(regexp);\n\n\treturn config_error_readonly();\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_error_readonly",
          "args": [],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "config_error_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "133-137",
          "snippet": "static int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "regexp"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "name"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "cfg"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_delete_multivar_readonly(git_config_backend *cfg, const char *name, const char *regexp)\n{\n\tGIT_UNUSED(cfg);\n\tGIT_UNUSED(name);\n\tGIT_UNUSED(regexp);\n\n\treturn config_error_readonly();\n}"
  },
  {
    "function_name": "config_set_multivar_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "750-759",
    "snippet": "static int config_set_multivar_readonly(\n\tgit_config_backend *cfg, const char *name, const char *regexp, const char *value)\n{\n\tGIT_UNUSED(cfg);\n\tGIT_UNUSED(name);\n\tGIT_UNUSED(regexp);\n\tGIT_UNUSED(value);\n\n\treturn config_error_readonly();\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_error_readonly",
          "args": [],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "config_error_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "133-137",
          "snippet": "static int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "value"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "regexp"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "name"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "cfg"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\n\nstatic int config_set_multivar_readonly(\n\tgit_config_backend *cfg, const char *name, const char *regexp, const char *value)\n{\n\tGIT_UNUSED(cfg);\n\tGIT_UNUSED(name);\n\tGIT_UNUSED(regexp);\n\tGIT_UNUSED(value);\n\n\treturn config_error_readonly();\n}"
  },
  {
    "function_name": "config_set_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "741-748",
    "snippet": "static int config_set_readonly(git_config_backend *cfg, const char *name, const char *value)\n{\n\tGIT_UNUSED(cfg);\n\tGIT_UNUSED(name);\n\tGIT_UNUSED(value);\n\n\treturn config_error_readonly();\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_error_readonly",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "config_error_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "133-137",
          "snippet": "static int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "value"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "name"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "cfg"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\n\nstatic int config_set_readonly(git_config_backend *cfg, const char *name, const char *value)\n{\n\tGIT_UNUSED(cfg);\n\tGIT_UNUSED(name);\n\tGIT_UNUSED(value);\n\n\treturn config_error_readonly();\n}"
  },
  {
    "function_name": "git_config_file__ondisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "711-739",
    "snippet": "int git_config_file__ondisk(git_config_backend **out, const char *path)\n{\n\tdiskfile_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(diskfile_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tgit_mutex_init(&backend->header.values_mutex);\n\n\tbackend->file_path = git__strdup(path);\n\tGITERR_CHECK_ALLOC(backend->file_path);\n\n\tbackend->header.parent.open = config_open;\n\tbackend->header.parent.get = config_get;\n\tbackend->header.parent.set = config_set;\n\tbackend->header.parent.set_multivar = config_set_multivar;\n\tbackend->header.parent.del = config_delete;\n\tbackend->header.parent.del_multivar = config_delete_multivar;\n\tbackend->header.parent.iterator = config_iterator_new;\n\tbackend->header.parent.snapshot = config_snapshot;\n\tbackend->header.parent.lock = config_lock;\n\tbackend->header.parent.unlock = config_unlock;\n\tbackend->header.parent.free = backend_free;\n\n\t*out = (git_config_backend *)backend;\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "backend->file_path"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "path"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_init",
          "args": [
            "&backend->header.values_mutex"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "140-141",
          "snippet": "GIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "backend"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(diskfile_backend)"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__ondisk(git_config_backend **out, const char *path)\n{\n\tdiskfile_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(diskfile_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tgit_mutex_init(&backend->header.values_mutex);\n\n\tbackend->file_path = git__strdup(path);\n\tGITERR_CHECK_ALLOC(backend->file_path);\n\n\tbackend->header.parent.open = config_open;\n\tbackend->header.parent.get = config_get;\n\tbackend->header.parent.set = config_set;\n\tbackend->header.parent.set_multivar = config_set_multivar;\n\tbackend->header.parent.del = config_delete;\n\tbackend->header.parent.del_multivar = config_delete_multivar;\n\tbackend->header.parent.iterator = config_iterator_new;\n\tbackend->header.parent.snapshot = config_snapshot;\n\tbackend->header.parent.lock = config_lock;\n\tbackend->header.parent.unlock = config_unlock;\n\tbackend->header.parent.free = backend_free;\n\n\t*out = (git_config_backend *)backend;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "config_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "694-709",
    "snippet": "static int config_unlock(git_config_backend *_cfg, int success)\n{\n\tdiskfile_backend *cfg = (diskfile_backend *) _cfg;\n\tint error = 0;\n\n\tif (success) {\n\t\tgit_filebuf_write(&cfg->locked_buf, cfg->locked_content.ptr, cfg->locked_content.size);\n\t\terror = git_filebuf_commit(&cfg->locked_buf);\n\t}\n\n\tgit_filebuf_cleanup(&cfg->locked_buf);\n\tgit_buf_free(&cfg->locked_content);\n\tcfg->locked = false;\n\n\treturn error;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *escape_value(const char *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&cfg->locked_content"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&cfg->locked_buf"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&cfg->locked_buf"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "&cfg->locked_buf",
            "cfg->locked_content.ptr",
            "cfg->locked_content.size"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\n\nstatic int config_unlock(git_config_backend *_cfg, int success)\n{\n\tdiskfile_backend *cfg = (diskfile_backend *) _cfg;\n\tint error = 0;\n\n\tif (success) {\n\t\tgit_filebuf_write(&cfg->locked_buf, cfg->locked_content.ptr, cfg->locked_content.size);\n\t\terror = git_filebuf_commit(&cfg->locked_buf);\n\t}\n\n\tgit_filebuf_cleanup(&cfg->locked_buf);\n\tgit_buf_free(&cfg->locked_content);\n\tcfg->locked = false;\n\n\treturn error;\n}"
  },
  {
    "function_name": "config_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "675-692",
    "snippet": "static int config_lock(git_config_backend *_cfg)\n{\n\tdiskfile_backend *cfg = (diskfile_backend *) _cfg;\n\tint error;\n\n\tif ((error = git_filebuf_open(&cfg->locked_buf, cfg->file_path, 0, GIT_CONFIG_FILE_MODE)) < 0)\n\t\treturn error;\n\n\terror = git_futils_readbuffer(&cfg->locked_content, cfg->file_path);\n\tif (error < 0 && error != GIT_ENOTFOUND) {\n\t\tgit_filebuf_cleanup(&cfg->locked_buf);\n\t\treturn error;\n\t}\n\n\tcfg->locked = true;\n\treturn 0;\n\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&cfg->locked_buf"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "&cfg->locked_content",
            "cfg->file_path"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&cfg->locked_buf",
            "cfg->file_path",
            "0",
            "GIT_CONFIG_FILE_MODE"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_lock(git_config_backend *_cfg)\n{\n\tdiskfile_backend *cfg = (diskfile_backend *) _cfg;\n\tint error;\n\n\tif ((error = git_filebuf_open(&cfg->locked_buf, cfg->file_path, 0, GIT_CONFIG_FILE_MODE)) < 0)\n\t\treturn error;\n\n\terror = git_futils_readbuffer(&cfg->locked_content, cfg->file_path);\n\tif (error < 0 && error != GIT_ENOTFOUND) {\n\t\tgit_filebuf_cleanup(&cfg->locked_buf);\n\t\treturn error;\n\t}\n\n\tcfg->locked = true;\n\treturn 0;\n\n}"
  },
  {
    "function_name": "config_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "668-673",
    "snippet": "static int config_snapshot(git_config_backend **out, git_config_backend *in)\n{\n\tdiskfile_backend *b = (diskfile_backend *) in;\n\n\treturn git_config_file__snapshot(out, b);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_file__snapshot",
          "args": [
            "out",
            "b"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file__snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "825-853",
          "snippet": "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in)\n{\n\tdiskfile_readonly_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(diskfile_readonly_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tgit_mutex_init(&backend->header.values_mutex);\n\n\tbackend->snapshot_from = in;\n\n\tbackend->header.parent.readonly = 1;\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tbackend->header.parent.open = config_readonly_open;\n\tbackend->header.parent.get = config_get;\n\tbackend->header.parent.set = config_set_readonly;\n\tbackend->header.parent.set_multivar = config_set_multivar_readonly;\n\tbackend->header.parent.del = config_delete_readonly;\n\tbackend->header.parent.del_multivar = config_delete_multivar_readonly;\n\tbackend->header.parent.iterator = config_iterator_new;\n\tbackend->header.parent.lock = config_lock_readonly;\n\tbackend->header.parent.unlock = config_unlock_readonly;\n\tbackend->header.parent.free = backend_readonly_free;\n\n\t*out = (git_config_backend *)backend;\n\n\treturn 0;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in)\n{\n\tdiskfile_readonly_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(diskfile_readonly_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tgit_mutex_init(&backend->header.values_mutex);\n\n\tbackend->snapshot_from = in;\n\n\tbackend->header.parent.readonly = 1;\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tbackend->header.parent.open = config_readonly_open;\n\tbackend->header.parent.get = config_get;\n\tbackend->header.parent.set = config_set_readonly;\n\tbackend->header.parent.set_multivar = config_set_multivar_readonly;\n\tbackend->header.parent.del = config_delete_readonly;\n\tbackend->header.parent.del_multivar = config_delete_multivar_readonly;\n\tbackend->header.parent.iterator = config_iterator_new;\n\tbackend->header.parent.lock = config_lock_readonly;\n\tbackend->header.parent.unlock = config_unlock_readonly;\n\tbackend->header.parent.free = backend_readonly_free;\n\n\t*out = (git_config_backend *)backend;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in)\n{\n\tdiskfile_backend *b = (diskfile_backend *) in;\n\n\treturn git_config_file__snapshot(out, b);\n}"
  },
  {
    "function_name": "config_delete_multivar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "623-666",
    "snippet": "static int config_delete_multivar(git_config_backend *cfg, const char *name, const char *regexp)\n{\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\trefcounted_strmap *map;\n\tgit_strmap *values;\n\tchar *key;\n\tregex_t preg;\n\tint result;\n\tkhiter_t pos;\n\n\tif ((result = git_config__normalize_name(name, &key)) < 0)\n\t\treturn result;\n\n\tmap = refcounted_strmap_take(&b->header);\n\tvalues = b->header.values->values;\n\n\tpos = git_strmap_lookup_index(values, key);\n\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\trefcounted_strmap_free(map);\n\t\tgit__free(key);\n\t\tgiterr_set(GITERR_CONFIG, \"Could not find key '%s' to delete\", name);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\trefcounted_strmap_free(map);\n\n\tresult = regcomp(&preg, regexp, REG_EXTENDED);\n\tif (result != 0) {\n\t\tgiterr_set_regex(&preg, result);\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\n\tif ((result = config_write(b, key, &preg, NULL)) < 0)\n\t\tgoto out;\n\n\tresult = config_refresh(cfg);\n\nout:\n\tgit__free(key);\n\tregfree(&preg);\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "regfree",
          "args": [
            "&preg"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "key"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_refresh",
          "args": [
            "cfg"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "config_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "336-360",
          "snippet": "static int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_write",
          "args": [
            "b",
            "key",
            "&preg",
            "NULL"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "config_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1876-1948",
          "snippet": "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "static char *escape_value(const char *ptr);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_regex",
          "args": [
            "&preg",
            "result"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "106-119",
          "snippet": "int giterr_set_regex(const regex_t *regex, int error_code)\n{\n\tchar error_buf[1024];\n\n\tassert(error_code);\n\n\tregerror(error_code, regex, error_buf, sizeof(error_buf));\n\tgiterr_set_str(GITERR_REGEX, error_buf);\n\n\tif (error_code == REG_NOMATCH)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nint giterr_set_regex(const regex_t *regex, int error_code)\n{\n\tchar error_buf[1024];\n\n\tassert(error_code);\n\n\tregerror(error_code, regex, error_buf, sizeof(error_buf));\n\tgiterr_set_str(GITERR_REGEX, error_buf);\n\n\tif (error_code == REG_NOMATCH)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regcomp",
          "args": [
            "&preg",
            "regexp",
            "REG_EXTENDED"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_free",
          "args": [
            "map"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "214-224",
          "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"Could not find key '%s' to delete\"",
            "name"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "values",
            "pos"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "values",
            "key"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_take",
          "args": [
            "&b->header"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_take",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "231-243",
          "snippet": "static refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__normalize_name",
          "args": [
            "name",
            "&key"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__normalize_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1371-1403",
          "snippet": "int git_config__normalize_name(const char *in, char **out)\n{\n\tchar *name, *fdot, *ldot;\n\n\tassert(in && out);\n\n\tname = git__strdup(in);\n\tGITERR_CHECK_ALLOC(name);\n\n\tfdot = strchr(name, '.');\n\tldot = strrchr(name, '.');\n\n\tif (fdot == NULL || fdot == name || ldot == NULL || !ldot[1])\n\t\tgoto invalid;\n\n\t/* Validate and downcase up to first dot and after last dot */\n\tif (git_config_file_normalize_section(name, fdot) < 0 ||\n\t\tgit_config_file_normalize_section(ldot + 1, NULL) < 0)\n\t\tgoto invalid;\n\n\t/* If there is a middle range, make sure it doesn't have newlines */\n\twhile (fdot < ldot)\n\t\tif (*fdot++ == '\\n')\n\t\t\tgoto invalid;\n\n\t*out = name;\n\treturn 0;\n\ninvalid:\n\tgit__free(name);\n\tgiterr_set(GITERR_CONFIG, \"Invalid config item name '%s'\", in);\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__normalize_name(const char *in, char **out)\n{\n\tchar *name, *fdot, *ldot;\n\n\tassert(in && out);\n\n\tname = git__strdup(in);\n\tGITERR_CHECK_ALLOC(name);\n\n\tfdot = strchr(name, '.');\n\tldot = strrchr(name, '.');\n\n\tif (fdot == NULL || fdot == name || ldot == NULL || !ldot[1])\n\t\tgoto invalid;\n\n\t/* Validate and downcase up to first dot and after last dot */\n\tif (git_config_file_normalize_section(name, fdot) < 0 ||\n\t\tgit_config_file_normalize_section(ldot + 1, NULL) < 0)\n\t\tgoto invalid;\n\n\t/* If there is a middle range, make sure it doesn't have newlines */\n\twhile (fdot < ldot)\n\t\tif (*fdot++ == '\\n')\n\t\t\tgoto invalid;\n\n\t*out = name;\n\treturn 0;\n\ninvalid:\n\tgit__free(name);\n\tgiterr_set(GITERR_CONFIG, \"Invalid config item name '%s'\", in);\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_delete_multivar(git_config_backend *cfg, const char *name, const char *regexp)\n{\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\trefcounted_strmap *map;\n\tgit_strmap *values;\n\tchar *key;\n\tregex_t preg;\n\tint result;\n\tkhiter_t pos;\n\n\tif ((result = git_config__normalize_name(name, &key)) < 0)\n\t\treturn result;\n\n\tmap = refcounted_strmap_take(&b->header);\n\tvalues = b->header.values->values;\n\n\tpos = git_strmap_lookup_index(values, key);\n\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\trefcounted_strmap_free(map);\n\t\tgit__free(key);\n\t\tgiterr_set(GITERR_CONFIG, \"Could not find key '%s' to delete\", name);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\trefcounted_strmap_free(map);\n\n\tresult = regcomp(&preg, regexp, REG_EXTENDED);\n\tif (result != 0) {\n\t\tgiterr_set_regex(&preg, result);\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\n\tif ((result = config_write(b, key, &preg, NULL)) < 0)\n\t\tgoto out;\n\n\tresult = config_refresh(cfg);\n\nout:\n\tgit__free(key);\n\tregfree(&preg);\n\treturn result;\n}"
  },
  {
    "function_name": "config_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "585-621",
    "snippet": "static int config_delete(git_config_backend *cfg, const char *name)\n{\n\tcvar_t *var;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\trefcounted_strmap *map;\tgit_strmap *values;\n\tchar *key;\n\tint result;\n\tkhiter_t pos;\n\n\tif ((result = git_config__normalize_name(name, &key)) < 0)\n\t\treturn result;\n\n\tmap = refcounted_strmap_take(&b->header);\n\tvalues = b->header.values->values;\n\n\tpos = git_strmap_lookup_index(values, key);\n\tgit__free(key);\n\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\trefcounted_strmap_free(map);\n\t\tgiterr_set(GITERR_CONFIG, \"Could not find key '%s' to delete\", name);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tvar = git_strmap_value_at(values, pos);\n\trefcounted_strmap_free(map);\n\n\tif (var->next != NULL) {\n\t\tgiterr_set(GITERR_CONFIG, \"Cannot delete multivar with a single delete\");\n\t\treturn -1;\n\t}\n\n\tif ((result = config_write(b, var->entry->name, NULL, NULL)) < 0)\n\t\treturn result;\n\n\treturn config_refresh(cfg);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_refresh",
          "args": [
            "cfg"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "config_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "336-360",
          "snippet": "static int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_write",
          "args": [
            "b",
            "var->entry->name",
            "NULL",
            "NULL"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "config_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1876-1948",
          "snippet": "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "static char *escape_value(const char *ptr);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"Cannot delete multivar with a single delete\""
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_free",
          "args": [
            "map"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "214-224",
          "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "values",
            "pos"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"Could not find key '%s' to delete\"",
            "name"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "values",
            "pos"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "key"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "values",
            "key"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_take",
          "args": [
            "&b->header"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_take",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "231-243",
          "snippet": "static refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__normalize_name",
          "args": [
            "name",
            "&key"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__normalize_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1371-1403",
          "snippet": "int git_config__normalize_name(const char *in, char **out)\n{\n\tchar *name, *fdot, *ldot;\n\n\tassert(in && out);\n\n\tname = git__strdup(in);\n\tGITERR_CHECK_ALLOC(name);\n\n\tfdot = strchr(name, '.');\n\tldot = strrchr(name, '.');\n\n\tif (fdot == NULL || fdot == name || ldot == NULL || !ldot[1])\n\t\tgoto invalid;\n\n\t/* Validate and downcase up to first dot and after last dot */\n\tif (git_config_file_normalize_section(name, fdot) < 0 ||\n\t\tgit_config_file_normalize_section(ldot + 1, NULL) < 0)\n\t\tgoto invalid;\n\n\t/* If there is a middle range, make sure it doesn't have newlines */\n\twhile (fdot < ldot)\n\t\tif (*fdot++ == '\\n')\n\t\t\tgoto invalid;\n\n\t*out = name;\n\treturn 0;\n\ninvalid:\n\tgit__free(name);\n\tgiterr_set(GITERR_CONFIG, \"Invalid config item name '%s'\", in);\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__normalize_name(const char *in, char **out)\n{\n\tchar *name, *fdot, *ldot;\n\n\tassert(in && out);\n\n\tname = git__strdup(in);\n\tGITERR_CHECK_ALLOC(name);\n\n\tfdot = strchr(name, '.');\n\tldot = strrchr(name, '.');\n\n\tif (fdot == NULL || fdot == name || ldot == NULL || !ldot[1])\n\t\tgoto invalid;\n\n\t/* Validate and downcase up to first dot and after last dot */\n\tif (git_config_file_normalize_section(name, fdot) < 0 ||\n\t\tgit_config_file_normalize_section(ldot + 1, NULL) < 0)\n\t\tgoto invalid;\n\n\t/* If there is a middle range, make sure it doesn't have newlines */\n\twhile (fdot < ldot)\n\t\tif (*fdot++ == '\\n')\n\t\t\tgoto invalid;\n\n\t*out = name;\n\treturn 0;\n\ninvalid:\n\tgit__free(name);\n\tgiterr_set(GITERR_CONFIG, \"Invalid config item name '%s'\", in);\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_delete(git_config_backend *cfg, const char *name)\n{\n\tcvar_t *var;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\trefcounted_strmap *map;\tgit_strmap *values;\n\tchar *key;\n\tint result;\n\tkhiter_t pos;\n\n\tif ((result = git_config__normalize_name(name, &key)) < 0)\n\t\treturn result;\n\n\tmap = refcounted_strmap_take(&b->header);\n\tvalues = b->header.values->values;\n\n\tpos = git_strmap_lookup_index(values, key);\n\tgit__free(key);\n\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\trefcounted_strmap_free(map);\n\t\tgiterr_set(GITERR_CONFIG, \"Could not find key '%s' to delete\", name);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tvar = git_strmap_value_at(values, pos);\n\trefcounted_strmap_free(map);\n\n\tif (var->next != NULL) {\n\t\tgiterr_set(GITERR_CONFIG, \"Cannot delete multivar with a single delete\");\n\t\treturn -1;\n\t}\n\n\tif ((result = config_write(b, var->entry->name, NULL, NULL)) < 0)\n\t\treturn result;\n\n\treturn config_refresh(cfg);\n}"
  },
  {
    "function_name": "config_set_multivar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "552-583",
    "snippet": "static int config_set_multivar(\n\tgit_config_backend *cfg, const char *name, const char *regexp, const char *value)\n{\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tchar *key;\n\tregex_t preg;\n\tint result;\n\n\tassert(regexp);\n\n\tif ((result = git_config__normalize_name(name, &key)) < 0)\n\t\treturn result;\n\n\tresult = regcomp(&preg, regexp, REG_EXTENDED);\n\tif (result != 0) {\n\t\tgiterr_set_regex(&preg, result);\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\n\t/* If we do have it, set call config_write() and reload */\n\tif ((result = config_write(b, key, &preg, value)) < 0)\n\t\tgoto out;\n\n\tresult = config_refresh(cfg);\n\nout:\n\tgit__free(key);\n\tregfree(&preg);\n\n\treturn result;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "regfree",
          "args": [
            "&preg"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "key"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_refresh",
          "args": [
            "cfg"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "config_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "336-360",
          "snippet": "static int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_write",
          "args": [
            "b",
            "key",
            "&preg",
            "value"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "config_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1876-1948",
          "snippet": "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "static char *escape_value(const char *ptr);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_regex",
          "args": [
            "&preg",
            "result"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "106-119",
          "snippet": "int giterr_set_regex(const regex_t *regex, int error_code)\n{\n\tchar error_buf[1024];\n\n\tassert(error_code);\n\n\tregerror(error_code, regex, error_buf, sizeof(error_buf));\n\tgiterr_set_str(GITERR_REGEX, error_buf);\n\n\tif (error_code == REG_NOMATCH)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nint giterr_set_regex(const regex_t *regex, int error_code)\n{\n\tchar error_buf[1024];\n\n\tassert(error_code);\n\n\tregerror(error_code, regex, error_buf, sizeof(error_buf));\n\tgiterr_set_str(GITERR_REGEX, error_buf);\n\n\tif (error_code == REG_NOMATCH)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regcomp",
          "args": [
            "&preg",
            "regexp",
            "REG_EXTENDED"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_config__normalize_name",
          "args": [
            "name",
            "&key"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__normalize_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1371-1403",
          "snippet": "int git_config__normalize_name(const char *in, char **out)\n{\n\tchar *name, *fdot, *ldot;\n\n\tassert(in && out);\n\n\tname = git__strdup(in);\n\tGITERR_CHECK_ALLOC(name);\n\n\tfdot = strchr(name, '.');\n\tldot = strrchr(name, '.');\n\n\tif (fdot == NULL || fdot == name || ldot == NULL || !ldot[1])\n\t\tgoto invalid;\n\n\t/* Validate and downcase up to first dot and after last dot */\n\tif (git_config_file_normalize_section(name, fdot) < 0 ||\n\t\tgit_config_file_normalize_section(ldot + 1, NULL) < 0)\n\t\tgoto invalid;\n\n\t/* If there is a middle range, make sure it doesn't have newlines */\n\twhile (fdot < ldot)\n\t\tif (*fdot++ == '\\n')\n\t\t\tgoto invalid;\n\n\t*out = name;\n\treturn 0;\n\ninvalid:\n\tgit__free(name);\n\tgiterr_set(GITERR_CONFIG, \"Invalid config item name '%s'\", in);\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__normalize_name(const char *in, char **out)\n{\n\tchar *name, *fdot, *ldot;\n\n\tassert(in && out);\n\n\tname = git__strdup(in);\n\tGITERR_CHECK_ALLOC(name);\n\n\tfdot = strchr(name, '.');\n\tldot = strrchr(name, '.');\n\n\tif (fdot == NULL || fdot == name || ldot == NULL || !ldot[1])\n\t\tgoto invalid;\n\n\t/* Validate and downcase up to first dot and after last dot */\n\tif (git_config_file_normalize_section(name, fdot) < 0 ||\n\t\tgit_config_file_normalize_section(ldot + 1, NULL) < 0)\n\t\tgoto invalid;\n\n\t/* If there is a middle range, make sure it doesn't have newlines */\n\twhile (fdot < ldot)\n\t\tif (*fdot++ == '\\n')\n\t\t\tgoto invalid;\n\n\t*out = name;\n\treturn 0;\n\ninvalid:\n\tgit__free(name);\n\tgiterr_set(GITERR_CONFIG, \"Invalid config item name '%s'\", in);\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "regexp"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\n\nstatic int config_set_multivar(\n\tgit_config_backend *cfg, const char *name, const char *regexp, const char *value)\n{\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tchar *key;\n\tregex_t preg;\n\tint result;\n\n\tassert(regexp);\n\n\tif ((result = git_config__normalize_name(name, &key)) < 0)\n\t\treturn result;\n\n\tresult = regcomp(&preg, regexp, REG_EXTENDED);\n\tif (result != 0) {\n\t\tgiterr_set_regex(&preg, result);\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\n\t/* If we do have it, set call config_write() and reload */\n\tif ((result = config_write(b, key, &preg, value)) < 0)\n\t\tgoto out;\n\n\tresult = config_refresh(cfg);\n\nout:\n\tgit__free(key);\n\tregfree(&preg);\n\n\treturn result;\n}"
  },
  {
    "function_name": "config_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "518-550",
    "snippet": "static int config_get(git_config_backend *cfg, const char *key, git_config_entry **out)\n{\n\tdiskfile_header *h = (diskfile_header *)cfg;\n\trefcounted_strmap *map;\n\tgit_strmap *values;\n\tkhiter_t pos;\n\tcvar_t *var;\n\tint error = 0;\n\n\tif (!h->parent.readonly && ((error = config_refresh(cfg)) < 0))\n\t\treturn error;\n\n\tmap = refcounted_strmap_take(h);\n\tvalues = map->values;\n\n\tpos = git_strmap_lookup_index(values, key);\n\n\t/* no error message; the config system will write one */\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\trefcounted_strmap_free(map);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tvar = git_strmap_value_at(values, pos);\n\twhile (var->next)\n\t\tvar = var->next;\n\n\t*out = var->entry;\n\t(*out)->free = release_map;\n\t(*out)->payload = map;\n\n\treturn error;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "values",
            "pos"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_free",
          "args": [
            "map"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "214-224",
          "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "values",
            "pos"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "values",
            "key"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_take",
          "args": [
            "h"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_take",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "231-243",
          "snippet": "static refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_refresh",
          "args": [
            "cfg"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "config_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "336-360",
          "snippet": "static int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_get(git_config_backend *cfg, const char *key, git_config_entry **out)\n{\n\tdiskfile_header *h = (diskfile_header *)cfg;\n\trefcounted_strmap *map;\n\tgit_strmap *values;\n\tkhiter_t pos;\n\tcvar_t *var;\n\tint error = 0;\n\n\tif (!h->parent.readonly && ((error = config_refresh(cfg)) < 0))\n\t\treturn error;\n\n\tmap = refcounted_strmap_take(h);\n\tvalues = map->values;\n\n\tpos = git_strmap_lookup_index(values, key);\n\n\t/* no error message; the config system will write one */\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\trefcounted_strmap_free(map);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tvar = git_strmap_value_at(values, pos);\n\twhile (var->next)\n\t\tvar = var->next;\n\n\t*out = var->entry;\n\t(*out)->free = release_map;\n\t(*out)->payload = map;\n\n\treturn error;\n}"
  },
  {
    "function_name": "release_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "509-513",
    "snippet": "static void release_map(git_config_entry *entry)\n{\n\trefcounted_strmap *map = (refcounted_strmap *) entry->payload;\n\trefcounted_strmap_free(map);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcounted_strmap_free",
          "args": [
            "map"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "214-224",
          "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void release_map(git_config_entry *entry)\n{\n\trefcounted_strmap *map = (refcounted_strmap *) entry->payload;\n\trefcounted_strmap_free(map);\n}"
  },
  {
    "function_name": "config_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "451-506",
    "snippet": "static int config_set(git_config_backend *cfg, const char *name, const char *value)\n{\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\trefcounted_strmap *map;\n\tgit_strmap *values;\n\tchar *key, *esc_value = NULL;\n\tkhiter_t pos;\n\tint rval, ret;\n\n\tif ((rval = git_config__normalize_name(name, &key)) < 0)\n\t\treturn rval;\n\n\tmap = refcounted_strmap_take(&b->header);\n\tvalues = map->values;\n\n\t/*\n\t * Try to find it in the existing values and update it if it\n\t * only has one value.\n\t */\n\tpos = git_strmap_lookup_index(values, key);\n\tif (git_strmap_valid_index(values, pos)) {\n\t\tcvar_t *existing = git_strmap_value_at(values, pos);\n\n\t\tif (existing->next != NULL) {\n\t\t\tgiterr_set(GITERR_CONFIG, \"Multivar incompatible with simple set\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* don't update if old and new values already match */\n\t\tif ((!existing->entry->value && !value) ||\n\t\t\t(existing->entry->value && value &&\n\t\t\t !strcmp(existing->entry->value, value))) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* No early returns due to sanity checks, let's write it out and refresh */\n\n\tif (value) {\n\t\tesc_value = escape_value(value);\n\t\tGITERR_CHECK_ALLOC(esc_value);\n\t}\n\n\tif ((ret = config_write(b, key, NULL, esc_value)) < 0)\n\t\tgoto out;\n\n\tret = config_refresh(cfg);\n\nout:\n\trefcounted_strmap_free(map);\n\tgit__free(esc_value);\n\tgit__free(key);\n\treturn ret;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "key"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_free",
          "args": [
            "map"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "214-224",
          "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_refresh",
          "args": [
            "cfg"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "config_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "336-360",
          "snippet": "static int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_write",
          "args": [
            "b",
            "key",
            "NULL",
            "esc_value"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "config_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1876-1948",
          "snippet": "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);",
            "static char *escape_value(const char *ptr);",
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nstatic char *escape_value(const char *ptr);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char* value)\n{\n\tint result;\n\tchar *section, *name, *ldot;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tstruct reader *reader = git_array_get(cfg->readers, 0);\n\tstruct write_data write_data;\n\n\tif (cfg->locked) {\n\t\tresult = git_buf_puts(&reader->buffer, git_buf_cstr(&cfg->locked_content));\n\t} else {\n\t\t/* Lock the file */\n\t\tif ((result = git_filebuf_open(\n\t\t\t     &file, cfg->file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_CONFIG_FILE_MODE)) < 0) {\n\t\t\tgit_buf_free(&reader->buffer);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* We need to read in our own config file */\n\t\tresult = git_futils_readbuffer(&reader->buffer, cfg->file_path);\n\t}\n\n\t/* Initialise the reading position */\n\tif (result == GIT_ENOTFOUND) {\n\t\treader->read_ptr = NULL;\n\t\treader->eof = 1;\n\t\tgit_buf_clear(&reader->buffer);\n\t} else if (result == 0) {\n\t\treader->read_ptr = reader->buffer.ptr;\n\t\treader->eof = 0;\n\t} else {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn -1; /* OS error when reading the file */\n\t}\n\n\tldot = strrchr(key, '.');\n\tname = ldot + 1;\n\tsection = git__strndup(key, ldot - key);\n\n\twrite_data.buf = &buf;\n\tgit_buf_init(&write_data.buffered_comment, 0);\n\twrite_data.section = section;\n\twrite_data.in_section = 0;\n\twrite_data.preg_replaced = 0;\n\twrite_data.name = name;\n\twrite_data.preg = preg;\n\twrite_data.value = value;\n\n\tresult = config_parse(reader, write_on_section, write_on_variable, write_on_comment, write_on_eof, &write_data);\n\tgit__free(section);\n\tgit_buf_free(&write_data.buffered_comment);\n\n\tif (result < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\tgoto done;\n\t}\n\n\tif (cfg->locked) {\n\t\tsize_t len = buf.asize;\n\t\t/* Update our copy with the modified contents */\n\t\tgit_buf_free(&cfg->locked_content);\n\t\tgit_buf_attach(&cfg->locked_content, git_buf_detach(&buf), len);\n\t} else {\n\t\tgit_filebuf_write(&file, git_buf_cstr(&buf), git_buf_len(&buf));\n\t\tresult = git_filebuf_commit(&file);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&reader->buffer);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "esc_value"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_value",
          "args": [
            "value"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "escape_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1252-1282",
          "snippet": "static char *escape_value(const char *ptr)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t len;\n\tconst char *esc;\n\n\tassert(ptr);\n\n\tlen = strlen(ptr);\n\tif (!len)\n\t\treturn git__calloc(1, sizeof(char));\n\n\tgit_buf_grow(&buf, len);\n\n\twhile (*ptr != '\\0') {\n\t\tif ((esc = strchr(escaped, *ptr)) != NULL) {\n\t\t\tgit_buf_putc(&buf, '\\\\');\n\t\t\tgit_buf_putc(&buf, escapes[esc - escaped]);\n\t\t} else {\n\t\t\tgit_buf_putc(&buf, *ptr);\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (git_buf_oom(&buf)) {\n\t\tgit_buf_free(&buf);\n\t\treturn NULL;\n\t}\n\n\treturn git_buf_detach(&buf);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *escape_value(const char *ptr);",
            "static const char *escapes = \"ntb\\\"\\\\\";",
            "static const char *escaped = \"\\n\\t\\b\\\"\\\\\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic char *escape_value(const char *ptr);\nstatic const char *escapes = \"ntb\\\"\\\\\";\nstatic const char *escaped = \"\\n\\t\\b\\\"\\\\\";\n\nstatic char *escape_value(const char *ptr)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t len;\n\tconst char *esc;\n\n\tassert(ptr);\n\n\tlen = strlen(ptr);\n\tif (!len)\n\t\treturn git__calloc(1, sizeof(char));\n\n\tgit_buf_grow(&buf, len);\n\n\twhile (*ptr != '\\0') {\n\t\tif ((esc = strchr(escaped, *ptr)) != NULL) {\n\t\t\tgit_buf_putc(&buf, '\\\\');\n\t\t\tgit_buf_putc(&buf, escapes[esc - escaped]);\n\t\t} else {\n\t\t\tgit_buf_putc(&buf, *ptr);\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (git_buf_oom(&buf)) {\n\t\tgit_buf_free(&buf);\n\t\treturn NULL;\n\t}\n\n\treturn git_buf_detach(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "existing->entry->value",
            "value"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"Multivar incompatible with simple set\""
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "values",
            "pos"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "values",
            "pos"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "values",
            "key"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_take",
          "args": [
            "&b->header"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_take",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "231-243",
          "snippet": "static refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__normalize_name",
          "args": [
            "name",
            "&key"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__normalize_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1371-1403",
          "snippet": "int git_config__normalize_name(const char *in, char **out)\n{\n\tchar *name, *fdot, *ldot;\n\n\tassert(in && out);\n\n\tname = git__strdup(in);\n\tGITERR_CHECK_ALLOC(name);\n\n\tfdot = strchr(name, '.');\n\tldot = strrchr(name, '.');\n\n\tif (fdot == NULL || fdot == name || ldot == NULL || !ldot[1])\n\t\tgoto invalid;\n\n\t/* Validate and downcase up to first dot and after last dot */\n\tif (git_config_file_normalize_section(name, fdot) < 0 ||\n\t\tgit_config_file_normalize_section(ldot + 1, NULL) < 0)\n\t\tgoto invalid;\n\n\t/* If there is a middle range, make sure it doesn't have newlines */\n\twhile (fdot < ldot)\n\t\tif (*fdot++ == '\\n')\n\t\t\tgoto invalid;\n\n\t*out = name;\n\treturn 0;\n\ninvalid:\n\tgit__free(name);\n\tgiterr_set(GITERR_CONFIG, \"Invalid config item name '%s'\", in);\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__normalize_name(const char *in, char **out)\n{\n\tchar *name, *fdot, *ldot;\n\n\tassert(in && out);\n\n\tname = git__strdup(in);\n\tGITERR_CHECK_ALLOC(name);\n\n\tfdot = strchr(name, '.');\n\tldot = strrchr(name, '.');\n\n\tif (fdot == NULL || fdot == name || ldot == NULL || !ldot[1])\n\t\tgoto invalid;\n\n\t/* Validate and downcase up to first dot and after last dot */\n\tif (git_config_file_normalize_section(name, fdot) < 0 ||\n\t\tgit_config_file_normalize_section(ldot + 1, NULL) < 0)\n\t\tgoto invalid;\n\n\t/* If there is a middle range, make sure it doesn't have newlines */\n\twhile (fdot < ldot)\n\t\tif (*fdot++ == '\\n')\n\t\t\tgoto invalid;\n\n\t*out = name;\n\treturn 0;\n\ninvalid:\n\tgit__free(name);\n\tgiterr_set(GITERR_CONFIG, \"Invalid config item name '%s'\", in);\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_set(git_config_backend *cfg, const char *name, const char *value)\n{\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\trefcounted_strmap *map;\n\tgit_strmap *values;\n\tchar *key, *esc_value = NULL;\n\tkhiter_t pos;\n\tint rval, ret;\n\n\tif ((rval = git_config__normalize_name(name, &key)) < 0)\n\t\treturn rval;\n\n\tmap = refcounted_strmap_take(&b->header);\n\tvalues = map->values;\n\n\t/*\n\t * Try to find it in the existing values and update it if it\n\t * only has one value.\n\t */\n\tpos = git_strmap_lookup_index(values, key);\n\tif (git_strmap_valid_index(values, pos)) {\n\t\tcvar_t *existing = git_strmap_value_at(values, pos);\n\n\t\tif (existing->next != NULL) {\n\t\t\tgiterr_set(GITERR_CONFIG, \"Multivar incompatible with simple set\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* don't update if old and new values already match */\n\t\tif ((!existing->entry->value && !value) ||\n\t\t\t(existing->entry->value && value &&\n\t\t\t !strcmp(existing->entry->value, value))) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* No early returns due to sanity checks, let's write it out and refresh */\n\n\tif (value) {\n\t\tesc_value = escape_value(value);\n\t\tGITERR_CHECK_ALLOC(esc_value);\n\t}\n\n\tif ((ret = config_write(b, key, NULL, esc_value)) < 0)\n\t\tgoto out;\n\n\tret = config_refresh(cfg);\n\nout:\n\trefcounted_strmap_free(map);\n\tgit__free(esc_value);\n\tgit__free(key);\n\treturn ret;\n}"
  },
  {
    "function_name": "config_iterator_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "416-449",
    "snippet": "static int config_iterator_new(\n\tgit_config_iterator **iter,\n\tstruct git_config_backend* backend)\n{\n\tdiskfile_header *h;\n\tgit_config_file_iter *it;\n\tgit_config_backend *snapshot;\n\tdiskfile_backend *b = (diskfile_backend *) backend;\n\tint error;\n\n\tif ((error = config_snapshot(&snapshot, backend)) < 0)\n\t\treturn error;\n\n\tif ((error = snapshot->open(snapshot, b->level)) < 0)\n\t\treturn error;\n\n\tit = git__calloc(1, sizeof(git_config_file_iter));\n\tGITERR_CHECK_ALLOC(it);\n\n\th = (diskfile_header *)snapshot;\n\n\t/* strmap_begin() is currently a macro returning 0 */\n\tGIT_UNUSED(h);\n\n\tit->parent.backend = snapshot;\n\tit->iter = git_strmap_begin(h->values);\n\tit->next_var = NULL;\n\n\tit->parent.next = config_iterator_next;\n\tit->parent.free = config_iterator_free;\n\t*iter = (git_config_iterator *) it;\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_begin",
          "args": [
            "h->values"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "h"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "it"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_config_file_iter)"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot->open",
          "args": [
            "snapshot",
            "b->level"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_snapshot",
          "args": [
            "&snapshot",
            "backend"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "668-673",
          "snippet": "static int config_snapshot(git_config_backend **out, git_config_backend *in)\n{\n\tdiskfile_backend *b = (diskfile_backend *) in;\n\n\treturn git_config_file__snapshot(out, b);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
            "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in)\n{\n\tdiskfile_backend *b = (diskfile_backend *) in;\n\n\treturn git_config_file__snapshot(out, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_iterator_new(\n\tgit_config_iterator **iter,\n\tstruct git_config_backend* backend)\n{\n\tdiskfile_header *h;\n\tgit_config_file_iter *it;\n\tgit_config_backend *snapshot;\n\tdiskfile_backend *b = (diskfile_backend *) backend;\n\tint error;\n\n\tif ((error = config_snapshot(&snapshot, backend)) < 0)\n\t\treturn error;\n\n\tif ((error = snapshot->open(snapshot, b->level)) < 0)\n\t\treturn error;\n\n\tit = git__calloc(1, sizeof(git_config_file_iter));\n\tGITERR_CHECK_ALLOC(it);\n\n\th = (diskfile_header *)snapshot;\n\n\t/* strmap_begin() is currently a macro returning 0 */\n\tGIT_UNUSED(h);\n\n\tit->parent.backend = snapshot;\n\tit->iter = git_strmap_begin(h->values);\n\tit->next_var = NULL;\n\n\tit->parent.next = config_iterator_next;\n\tit->parent.free = config_iterator_free;\n\t*iter = (git_config_iterator *) it;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "config_iterator_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "389-414",
    "snippet": "static int config_iterator_next(\n\tgit_config_entry **entry,\n\tgit_config_iterator *iter)\n{\n\tgit_config_file_iter *it = (git_config_file_iter *) iter;\n\tdiskfile_header *h = (diskfile_header *) it->parent.backend;\n\tgit_strmap *values = h->values->values;\n\tint err = 0;\n\tcvar_t * var;\n\n\tif (it->next_var == NULL) {\n\t\terr = git_strmap_next((void**) &var, &(it->iter), values);\n\t} else {\n\t\tvar = it->next_var;\n\t}\n\n\tif (err < 0) {\n\t\tit->next_var = NULL;\n\t\treturn err;\n\t}\n\n\t*entry = var->entry;\n\tit->next_var = CVAR_LIST_NEXT(var);\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CVAR_LIST_NEXT",
          "args": [
            "var"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_next",
          "args": [
            "(void**) &var",
            "&(it->iter)",
            "values"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "git_strmap_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/strmap.c",
          "lines": "10-32",
          "snippet": "int git_strmap_next(\n\tvoid **data,\n\tgit_strmap_iter* iter,\n\tgit_strmap *map)\n{\n\tif (!map)\n\t\treturn GIT_ERROR;\n\n\twhile (*iter != git_strmap_end(map)) {\n\t\tif (!(git_strmap_has_data(map, *iter))) {\n\t\t\t++(*iter);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*data = git_strmap_value_at(map, *iter);\n\n\t\t++(*iter);\n\n\t\treturn GIT_OK;\n\t}\n\n\treturn GIT_ITEROVER;\n}",
          "includes": [
            "#include \"strmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strmap.h\"\n\nint git_strmap_next(\n\tvoid **data,\n\tgit_strmap_iter* iter,\n\tgit_strmap *map)\n{\n\tif (!map)\n\t\treturn GIT_ERROR;\n\n\twhile (*iter != git_strmap_end(map)) {\n\t\tif (!(git_strmap_has_data(map, *iter))) {\n\t\t\t++(*iter);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*data = git_strmap_value_at(map, *iter);\n\n\t\t++(*iter);\n\n\t\treturn GIT_OK;\n\t}\n\n\treturn GIT_ITEROVER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_iterator_next(\n\tgit_config_entry **entry,\n\tgit_config_iterator *iter)\n{\n\tgit_config_file_iter *it = (git_config_file_iter *) iter;\n\tdiskfile_header *h = (diskfile_header *) it->parent.backend;\n\tgit_strmap *values = h->values->values;\n\tint err = 0;\n\tcvar_t * var;\n\n\tif (it->next_var == NULL) {\n\t\terr = git_strmap_next((void**) &var, &(it->iter), values);\n\t} else {\n\t\tvar = it->next_var;\n\t}\n\n\tif (err < 0) {\n\t\tit->next_var = NULL;\n\t\treturn err;\n\t}\n\n\t*entry = var->entry;\n\tit->next_var = CVAR_LIST_NEXT(var);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "config_iterator_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "382-387",
    "snippet": "static void config_iterator_free(\n\tgit_config_iterator* iter)\n{\n\titer->backend->free(iter->backend);\n\tgit__free(iter);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "iter"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->backend->free",
          "args": [
            "iter->backend"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void config_iterator_free(\n\tgit_config_iterator* iter)\n{\n\titer->backend->free(iter->backend);\n\tgit__free(iter);\n}"
  },
  {
    "function_name": "backend_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "362-380",
    "snippet": "static void backend_free(git_config_backend *_backend)\n{\n\tdiskfile_backend *backend = (diskfile_backend *)_backend;\n\tuint32_t i;\n\n\tif (backend == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(backend->readers); i++) {\n\t\tstruct reader *r = git_array_get(backend->readers, i);\n\t\tgit__free(r->file_path);\n\t}\n\tgit_array_clear(backend->readers);\n\n\tgit__free(backend->file_path);\n\trefcounted_strmap_free(backend->header.values);\n\tgit_mutex_free(&backend->header.values_mutex);\n\tgit__free(backend);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "backend"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_free",
          "args": [
            "&backend->header.values_mutex"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "104-108",
          "snippet": "int git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_free",
          "args": [
            "backend->header.values"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "214-224",
          "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_clear",
          "args": [
            "backend->readers"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "backend->readers",
            "i"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_size",
          "args": [
            "backend->readers"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void backend_free(git_config_backend *_backend)\n{\n\tdiskfile_backend *backend = (diskfile_backend *)_backend;\n\tuint32_t i;\n\n\tif (backend == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(backend->readers); i++) {\n\t\tstruct reader *r = git_array_get(backend->readers, i);\n\t\tgit__free(r->file_path);\n\t}\n\tgit_array_clear(backend->readers);\n\n\tgit__free(backend->file_path);\n\trefcounted_strmap_free(backend->header.values);\n\tgit_mutex_free(&backend->header.values_mutex);\n\tgit__free(backend);\n}"
  },
  {
    "function_name": "config_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "336-360",
    "snippet": "static int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config__refresh",
          "args": [
            "cfg"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "config__refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "305-334",
          "snippet": "static int config__refresh(git_config_backend *cfg)\n{\n\trefcounted_strmap *values = NULL, *tmp;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tint error = 0;\n\n\tif ((error = refcounted_strmap_alloc(&values)) < 0)\n\t\tgoto out;\n\n\treader = git_array_get(b->readers, git_array_size(b->readers) - 1);\n\tGITERR_CHECK_ALLOC(reader);\n\n\tif ((error = config_read(values->values, b, reader, b->level, 0)) < 0)\n\t\tgoto out;\n\n\tgit_mutex_lock(&b->header.values_mutex);\n\n\ttmp = b->header.values;\n\tb->header.values = values;\n\tvalues = tmp;\n\n\tgit_mutex_unlock(&b->header.values_mutex);\n\nout:\n\trefcounted_strmap_free(values);\n\tif (reader)\n\t\tgit_buf_free(&reader->buffer);\n\treturn error;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config__refresh(git_config_backend *cfg)\n{\n\trefcounted_strmap *values = NULL, *tmp;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tint error = 0;\n\n\tif ((error = refcounted_strmap_alloc(&values)) < 0)\n\t\tgoto out;\n\n\treader = git_array_get(b->readers, git_array_size(b->readers) - 1);\n\tGITERR_CHECK_ALLOC(reader);\n\n\tif ((error = config_read(values->values, b, reader, b->level, 0)) < 0)\n\t\tgoto out;\n\n\tgit_mutex_lock(&b->header.values_mutex);\n\n\ttmp = b->header.values;\n\tb->header.values = values;\n\tvalues = tmp;\n\n\tgit_mutex_unlock(&b->header.values_mutex);\n\nout:\n\trefcounted_strmap_free(values);\n\tif (reader)\n\t\tgit_buf_free(&reader->buffer);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer_updated",
          "args": [
            "&reader->buffer",
            "reader->file_path",
            "&reader->checksum",
            "&updated"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer_updated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "155-222",
          "snippet": "int git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "b->readers",
            "i"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_size",
          "args": [
            "b->readers"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_refresh(git_config_backend *cfg)\n{\n\tint error = 0, updated = 0, any_updated = 0;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tuint32_t i;\n\n\tfor (i = 0; i < git_array_size(b->readers); i++) {\n\t\treader = git_array_get(b->readers, i);\n\t\terror = git_futils_readbuffer_updated(\n\t\t\t&reader->buffer, reader->file_path,\n\t\t\t&reader->checksum, &updated);\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\n\t\tif (updated)\n\t\t\tany_updated = 1;\n\t}\n\n\tif (!any_updated)\n\t\treturn (error == GIT_ENOTFOUND) ? 0 : error;\n\n\treturn config__refresh(cfg);\n}"
  },
  {
    "function_name": "config__refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "305-334",
    "snippet": "static int config__refresh(git_config_backend *cfg)\n{\n\trefcounted_strmap *values = NULL, *tmp;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tint error = 0;\n\n\tif ((error = refcounted_strmap_alloc(&values)) < 0)\n\t\tgoto out;\n\n\treader = git_array_get(b->readers, git_array_size(b->readers) - 1);\n\tGITERR_CHECK_ALLOC(reader);\n\n\tif ((error = config_read(values->values, b, reader, b->level, 0)) < 0)\n\t\tgoto out;\n\n\tgit_mutex_lock(&b->header.values_mutex);\n\n\ttmp = b->header.values;\n\tb->header.values = values;\n\tvalues = tmp;\n\n\tgit_mutex_unlock(&b->header.values_mutex);\n\nout:\n\trefcounted_strmap_free(values);\n\tif (reader)\n\t\tgit_buf_free(&reader->buffer);\n\treturn error;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&reader->buffer"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_free",
          "args": [
            "values"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "214-224",
          "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&b->header.values_mutex"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&b->header.values_mutex"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "config_read",
          "args": [
            "values->values",
            "b",
            "reader",
            "b->level",
            "0"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "config_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1626-1650",
          "snippet": "static int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth)\n{\n\tstruct parse_data parse_data;\n\n\tif (depth >= MAX_INCLUDE_DEPTH) {\n\t\tgiterr_set(GITERR_CONFIG, \"Maximum config include depth reached\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the reading position */\n\treader->read_ptr = reader->buffer.ptr;\n\treader->eof = 0;\n\n\t/* If the file is empty, there's nothing for us to do */\n\tif (*reader->read_ptr == '\\0')\n\t\treturn 0;\n\n\tparse_data.values = values;\n\tparse_data.cfg_file = cfg_file;\n\tparse_data.reader_idx = git_array_size(cfg_file->readers) - 1;\n\tparse_data.level = level;\n\tparse_data.depth = depth;\n\n\treturn config_parse(reader, NULL, read_on_variable, NULL, NULL, &parse_data);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MAX_INCLUDE_DEPTH 10"
          ],
          "globals_used": [
            "static int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);",
            "static char *escape_value(const char *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\n#define MAX_INCLUDE_DEPTH 10\n\nstatic int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);\nstatic char *escape_value(const char *ptr);\n\nstatic int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth)\n{\n\tstruct parse_data parse_data;\n\n\tif (depth >= MAX_INCLUDE_DEPTH) {\n\t\tgiterr_set(GITERR_CONFIG, \"Maximum config include depth reached\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the reading position */\n\treader->read_ptr = reader->buffer.ptr;\n\treader->eof = 0;\n\n\t/* If the file is empty, there's nothing for us to do */\n\tif (*reader->read_ptr == '\\0')\n\t\treturn 0;\n\n\tparse_data.values = values;\n\tparse_data.cfg_file = cfg_file;\n\tparse_data.reader_idx = git_array_size(cfg_file->readers) - 1;\n\tparse_data.level = level;\n\tparse_data.depth = depth;\n\n\treturn config_parse(reader, NULL, read_on_variable, NULL, NULL, &parse_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "reader"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "b->readers",
            "git_array_size(b->readers) - 1"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_size",
          "args": [
            "b->readers"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_alloc",
          "args": [
            "&values"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "245-261",
          "snippet": "static int refcounted_strmap_alloc(refcounted_strmap **out)\n{\n\trefcounted_strmap *map;\n\tint error;\n\n\tmap = git__calloc(1, sizeof(refcounted_strmap));\n\tGITERR_CHECK_ALLOC(map);\n\n\tgit_atomic_set(&map->refcount, 1);\n\n\tif ((error = git_strmap_alloc(&map->values)) < 0)\n\t\tgit__free(map);\n\telse\n\t\t*out = map;\n\n\treturn error;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int refcounted_strmap_alloc(refcounted_strmap **out)\n{\n\trefcounted_strmap *map;\n\tint error;\n\n\tmap = git__calloc(1, sizeof(refcounted_strmap));\n\tGITERR_CHECK_ALLOC(map);\n\n\tgit_atomic_set(&map->refcount, 1);\n\n\tif ((error = git_strmap_alloc(&map->values)) < 0)\n\t\tgit__free(map);\n\telse\n\t\t*out = map;\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config__refresh(git_config_backend *cfg)\n{\n\trefcounted_strmap *values = NULL, *tmp;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\tstruct reader *reader = NULL;\n\tint error = 0;\n\n\tif ((error = refcounted_strmap_alloc(&values)) < 0)\n\t\tgoto out;\n\n\treader = git_array_get(b->readers, git_array_size(b->readers) - 1);\n\tGITERR_CHECK_ALLOC(reader);\n\n\tif ((error = config_read(values->values, b, reader, b->level, 0)) < 0)\n\t\tgoto out;\n\n\tgit_mutex_lock(&b->header.values_mutex);\n\n\ttmp = b->header.values;\n\tb->header.values = values;\n\tvalues = tmp;\n\n\tgit_mutex_unlock(&b->header.values_mutex);\n\nout:\n\trefcounted_strmap_free(values);\n\tif (reader)\n\t\tgit_buf_free(&reader->buffer);\n\treturn error;\n}"
  },
  {
    "function_name": "config_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "263-302",
    "snippet": "static int config_open(git_config_backend *cfg, git_config_level_t level)\n{\n\tint res;\n\tstruct reader *reader;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\n\tb->level = level;\n\n\tif ((res = refcounted_strmap_alloc(&b->header.values)) < 0)\n\t\treturn res;\n\n\tgit_array_init(b->readers);\n\treader = git_array_alloc(b->readers);\n\tif (!reader) {\n\t\trefcounted_strmap_free(b->header.values);\n\t\treturn -1;\n\t}\n\tmemset(reader, 0, sizeof(struct reader));\n\n\treader->file_path = git__strdup(b->file_path);\n\tGITERR_CHECK_ALLOC(reader->file_path);\n\n\tgit_buf_init(&reader->buffer, 0);\n\tres = git_futils_readbuffer_updated(\n\t\t&reader->buffer, b->file_path, &reader->checksum, NULL);\n\n\t/* It's fine if the file doesn't exist */\n\tif (res == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (res < 0 || (res = config_read(b->header.values->values, b, reader, level, 0)) < 0) {\n\t\trefcounted_strmap_free(b->header.values);\n\t\tb->header.values = NULL;\n\t}\n\n\treader = git_array_get(b->readers, 0);\n\tgit_buf_free(&reader->buffer);\n\n\treturn res;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&reader->buffer"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "b->readers",
            "0"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_free",
          "args": [
            "b->header.values"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "214-224",
          "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_read",
          "args": [
            "b->header.values->values",
            "b",
            "reader",
            "level",
            "0"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "config_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "1626-1650",
          "snippet": "static int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth)\n{\n\tstruct parse_data parse_data;\n\n\tif (depth >= MAX_INCLUDE_DEPTH) {\n\t\tgiterr_set(GITERR_CONFIG, \"Maximum config include depth reached\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the reading position */\n\treader->read_ptr = reader->buffer.ptr;\n\treader->eof = 0;\n\n\t/* If the file is empty, there's nothing for us to do */\n\tif (*reader->read_ptr == '\\0')\n\t\treturn 0;\n\n\tparse_data.values = values;\n\tparse_data.cfg_file = cfg_file;\n\tparse_data.reader_idx = git_array_size(cfg_file->readers) - 1;\n\tparse_data.level = level;\n\tparse_data.depth = depth;\n\n\treturn config_parse(reader, NULL, read_on_variable, NULL, NULL, &parse_data);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MAX_INCLUDE_DEPTH 10"
          ],
          "globals_used": [
            "static int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);",
            "static char *escape_value(const char *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\n#define MAX_INCLUDE_DEPTH 10\n\nstatic int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth);\nstatic char *escape_value(const char *ptr);\n\nstatic int config_read(git_strmap *values, diskfile_backend *cfg_file, struct reader *reader, git_config_level_t level, int depth)\n{\n\tstruct parse_data parse_data;\n\n\tif (depth >= MAX_INCLUDE_DEPTH) {\n\t\tgiterr_set(GITERR_CONFIG, \"Maximum config include depth reached\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the reading position */\n\treader->read_ptr = reader->buffer.ptr;\n\treader->eof = 0;\n\n\t/* If the file is empty, there's nothing for us to do */\n\tif (*reader->read_ptr == '\\0')\n\t\treturn 0;\n\n\tparse_data.values = values;\n\tparse_data.cfg_file = cfg_file;\n\tparse_data.reader_idx = git_array_size(cfg_file->readers) - 1;\n\tparse_data.level = level;\n\tparse_data.depth = depth;\n\n\treturn config_parse(reader, NULL, read_on_variable, NULL, NULL, &parse_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer_updated",
          "args": [
            "&reader->buffer",
            "b->file_path",
            "&reader->checksum",
            "NULL"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer_updated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "155-222",
          "snippet": "int git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "&reader->buffer",
            "0"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "reader->file_path"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "b->file_path"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "reader",
            "0",
            "sizeof(struct reader)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_alloc",
          "args": [
            "b->readers"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_init",
          "args": [
            "b->readers"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcounted_strmap_alloc",
          "args": [
            "&b->header.values"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted_strmap_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "245-261",
          "snippet": "static int refcounted_strmap_alloc(refcounted_strmap **out)\n{\n\trefcounted_strmap *map;\n\tint error;\n\n\tmap = git__calloc(1, sizeof(refcounted_strmap));\n\tGITERR_CHECK_ALLOC(map);\n\n\tgit_atomic_set(&map->refcount, 1);\n\n\tif ((error = git_strmap_alloc(&map->values)) < 0)\n\t\tgit__free(map);\n\telse\n\t\t*out = map;\n\n\treturn error;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int refcounted_strmap_alloc(refcounted_strmap **out)\n{\n\trefcounted_strmap *map;\n\tint error;\n\n\tmap = git__calloc(1, sizeof(refcounted_strmap));\n\tGITERR_CHECK_ALLOC(map);\n\n\tgit_atomic_set(&map->refcount, 1);\n\n\tif ((error = git_strmap_alloc(&map->values)) < 0)\n\t\tgit__free(map);\n\telse\n\t\t*out = map;\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_open(git_config_backend *cfg, git_config_level_t level)\n{\n\tint res;\n\tstruct reader *reader;\n\tdiskfile_backend *b = (diskfile_backend *)cfg;\n\n\tb->level = level;\n\n\tif ((res = refcounted_strmap_alloc(&b->header.values)) < 0)\n\t\treturn res;\n\n\tgit_array_init(b->readers);\n\treader = git_array_alloc(b->readers);\n\tif (!reader) {\n\t\trefcounted_strmap_free(b->header.values);\n\t\treturn -1;\n\t}\n\tmemset(reader, 0, sizeof(struct reader));\n\n\treader->file_path = git__strdup(b->file_path);\n\tGITERR_CHECK_ALLOC(reader->file_path);\n\n\tgit_buf_init(&reader->buffer, 0);\n\tres = git_futils_readbuffer_updated(\n\t\t&reader->buffer, b->file_path, &reader->checksum, NULL);\n\n\t/* It's fine if the file doesn't exist */\n\tif (res == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (res < 0 || (res = config_read(b->header.values->values, b, reader, level, 0)) < 0) {\n\t\trefcounted_strmap_free(b->header.values);\n\t\tb->header.values = NULL;\n\t}\n\n\treader = git_array_get(b->readers, 0);\n\tgit_buf_free(&reader->buffer);\n\n\treturn res;\n}"
  },
  {
    "function_name": "refcounted_strmap_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "245-261",
    "snippet": "static int refcounted_strmap_alloc(refcounted_strmap **out)\n{\n\trefcounted_strmap *map;\n\tint error;\n\n\tmap = git__calloc(1, sizeof(refcounted_strmap));\n\tGITERR_CHECK_ALLOC(map);\n\n\tgit_atomic_set(&map->refcount, 1);\n\n\tif ((error = git_strmap_alloc(&map->values)) < 0)\n\t\tgit__free(map);\n\telse\n\t\t*out = map;\n\n\treturn error;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "map"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_alloc",
          "args": [
            "&map->values"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_atomic_set",
          "args": [
            "&map->refcount",
            "1"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "166-169",
          "snippet": "GIT_INLINE(void) git_atomic_set(git_atomic *a, int val)\n{\n\ta->val = val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(void) git_atomic_set(git_atomic *a, int val)\n{\n\ta->val = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "map"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(refcounted_strmap)"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int refcounted_strmap_alloc(refcounted_strmap **out)\n{\n\trefcounted_strmap *map;\n\tint error;\n\n\tmap = git__calloc(1, sizeof(refcounted_strmap));\n\tGITERR_CHECK_ALLOC(map);\n\n\tgit_atomic_set(&map->refcount, 1);\n\n\tif ((error = git_strmap_alloc(&map->values)) < 0)\n\t\tgit__free(map);\n\telse\n\t\t*out = map;\n\n\treturn error;\n}"
  },
  {
    "function_name": "refcounted_strmap_take",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "231-243",
    "snippet": "static refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&h->values_mutex"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_atomic_inc",
          "args": [
            "&map->refcount"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "171-174",
          "snippet": "GIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&h->values_mutex"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic refcounted_strmap *refcounted_strmap_take(diskfile_header *h)\n{\n\trefcounted_strmap *map;\n\n\tgit_mutex_lock(&h->values_mutex);\n\n\tmap = h->values;\n\tgit_atomic_inc(&map->refcount);\n\n\tgit_mutex_unlock(&h->values_mutex);\n\n\treturn map;\n}"
  },
  {
    "function_name": "refcounted_strmap_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "214-224",
    "snippet": "static void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "map"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_vars",
          "args": [
            "map->values"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "free_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "197-212",
          "snippet": "static void free_vars(git_strmap *values)\n{\n\tcvar_t *var = NULL;\n\n\tif (values == NULL)\n\t\treturn;\n\n\tgit_strmap_foreach_value(values, var,\n\t\twhile (var != NULL) {\n\t\t\tcvar_t *next = CVAR_LIST_NEXT(var);\n\t\t\tcvar_free(var);\n\t\t\tvar = next;\n\t\t});\n\n\tgit_strmap_free(values);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void free_vars(git_strmap *values)\n{\n\tcvar_t *var = NULL;\n\n\tif (values == NULL)\n\t\treturn;\n\n\tgit_strmap_foreach_value(values, var,\n\t\twhile (var != NULL) {\n\t\t\tcvar_t *next = CVAR_LIST_NEXT(var);\n\t\t\tcvar_free(var);\n\t\t\tvar = next;\n\t\t});\n\n\tgit_strmap_free(values);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_atomic_dec",
          "args": [
            "&map->refcount"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "182-185",
          "snippet": "GIT_INLINE(int) git_atomic_dec(git_atomic *a)\n{\n\treturn --a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_dec(git_atomic *a)\n{\n\treturn --a->val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void refcounted_strmap_free(refcounted_strmap *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (git_atomic_dec(&map->refcount) != 0)\n\t\treturn;\n\n\tfree_vars(map->values);\n\tgit__free(map);\n}"
  },
  {
    "function_name": "free_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "197-212",
    "snippet": "static void free_vars(git_strmap *values)\n{\n\tcvar_t *var = NULL;\n\n\tif (values == NULL)\n\t\treturn;\n\n\tgit_strmap_foreach_value(values, var,\n\t\twhile (var != NULL) {\n\t\t\tcvar_t *next = CVAR_LIST_NEXT(var);\n\t\t\tcvar_free(var);\n\t\t\tvar = next;\n\t\t});\n\n\tgit_strmap_free(values);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_free",
          "args": [
            "values"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_foreach_value",
          "args": [
            "values",
            "var",
            "while (var != NULL){\n\t\t\tcvar_t *next = CVAR_LIST_NEXT(var);\n\t\t\tcvar_free(var);\n\t\t\tvar = next;\n\t\t}"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cvar_free",
          "args": [
            "var"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "cvar_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "139-148",
          "snippet": "static void cvar_free(cvar_t *var)\n{\n\tif (var == NULL)\n\t\treturn;\n\n\tgit__free((char*)var->entry->name);\n\tgit__free((char *)var->entry->value);\n\tgit__free(var->entry);\n\tgit__free(var);\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\n\nstatic void cvar_free(cvar_t *var)\n{\n\tif (var == NULL)\n\t\treturn;\n\n\tgit__free((char*)var->entry->name);\n\tgit__free((char *)var->entry->value);\n\tgit__free(var->entry);\n\tgit__free(var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CVAR_LIST_NEXT",
          "args": [
            "var"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while",
          "args": [
            "var != NULL"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "wait_while_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "306-330",
          "snippet": "static int wait_while_ack(gitno_buffer *buf)\n{\n\tint error;\n\tgit_pkt_ack *pkt = NULL;\n\n\twhile (1) {\n\t\tgit__free(pkt);\n\n\t\tif ((error = recv_pkt((git_pkt **)&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_NAK)\n\t\t\tbreak;\n\n\t\tif (pkt->type == GIT_PKT_ACK &&\n\t\t    (pkt->status != GIT_ACK_CONTINUE &&\n\t\t     pkt->status != GIT_ACK_COMMON)) {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgit__free(pkt);\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int wait_while_ack(gitno_buffer *buf)\n{\n\tint error;\n\tgit_pkt_ack *pkt = NULL;\n\n\twhile (1) {\n\t\tgit__free(pkt);\n\n\t\tif ((error = recv_pkt((git_pkt **)&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_NAK)\n\t\t\tbreak;\n\n\t\tif (pkt->type == GIT_PKT_ACK &&\n\t\t    (pkt->status != GIT_ACK_CONTINUE &&\n\t\t     pkt->status != GIT_ACK_COMMON)) {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgit__free(pkt);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic void free_vars(git_strmap *values)\n{\n\tcvar_t *var = NULL;\n\n\tif (values == NULL)\n\t\treturn;\n\n\tgit_strmap_foreach_value(values, var,\n\t\twhile (var != NULL) {\n\t\t\tcvar_t *next = CVAR_LIST_NEXT(var);\n\t\t\tcvar_free(var);\n\t\t\tvar = next;\n\t\t});\n\n\tgit_strmap_free(values);\n}"
  },
  {
    "function_name": "append_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "174-195",
    "snippet": "static int append_entry(git_strmap *values, cvar_t *var)\n{\n\tgit_strmap_iter pos;\n\tcvar_t *existing;\n\tint error = 0;\n\n\tpos = git_strmap_lookup_index(values, var->entry->name);\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\tgit_strmap_insert(values, var->entry->name, var, error);\n\t} else {\n\t\texisting = git_strmap_value_at(values, pos);\n\t\twhile (existing->next != NULL) {\n\t\t\texisting = existing->next;\n\t\t}\n\t\texisting->next = var;\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\n\treturn error;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "values",
            "pos"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_insert",
          "args": [
            "values",
            "var->entry->name",
            "var",
            "error"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "values",
            "pos"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "values",
            "var->entry->name"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int append_entry(git_strmap *values, cvar_t *var)\n{\n\tgit_strmap_iter pos;\n\tcvar_t *existing;\n\tint error = 0;\n\n\tpos = git_strmap_lookup_index(values, var->entry->name);\n\tif (!git_strmap_valid_index(values, pos)) {\n\t\tgit_strmap_insert(values, var->entry->name, var, error);\n\t} else {\n\t\texisting = git_strmap_value_at(values, pos);\n\t\twhile (existing->next != NULL) {\n\t\t\texisting = existing->next;\n\t\t}\n\t\texisting->next = var;\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_config_file_normalize_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "150-171",
    "snippet": "int git_config_file_normalize_section(char *start, char *end)\n{\n\tchar *scan;\n\n\tif (start == end)\n\t\treturn GIT_EINVALIDSPEC;\n\n\t/* Validate and downcase range */\n\tfor (scan = start; *scan; ++scan) {\n\t\tif (end && scan >= end)\n\t\t\tbreak;\n\t\tif (isalnum(*scan))\n\t\t\t*scan = (char)git__tolower(*scan);\n\t\telse if (*scan != '-' || scan == start)\n\t\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif (scan == start)\n\t\treturn GIT_EINVALIDSPEC;\n\n\treturn 0;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__tolower",
          "args": [
            "*scan"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "git__tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "285-288",
          "snippet": "GIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*scan"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file_normalize_section(char *start, char *end)\n{\n\tchar *scan;\n\n\tif (start == end)\n\t\treturn GIT_EINVALIDSPEC;\n\n\t/* Validate and downcase range */\n\tfor (scan = start; *scan; ++scan) {\n\t\tif (end && scan >= end)\n\t\t\tbreak;\n\t\tif (isalnum(*scan))\n\t\t\t*scan = (char)git__tolower(*scan);\n\t\telse if (*scan != '-' || scan == start)\n\t\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif (scan == start)\n\t\treturn GIT_EINVALIDSPEC;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cvar_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "139-148",
    "snippet": "static void cvar_free(cvar_t *var)\n{\n\tif (var == NULL)\n\t\treturn;\n\n\tgit__free((char*)var->entry->name);\n\tgit__free((char *)var->entry->value);\n\tgit__free(var->entry);\n\tgit__free(var);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "var"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_write(diskfile_backend *cfg, const char *key, const regex_t *preg, const char *value);\n\nstatic void cvar_free(cvar_t *var)\n{\n\tif (var == NULL)\n\t\treturn;\n\n\tgit__free((char*)var->entry->name);\n\tgit__free((char *)var->entry->value);\n\tgit__free(var->entry);\n\tgit__free(var);\n}"
  },
  {
    "function_name": "config_error_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "133-137",
    "snippet": "static int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"this backend is read-only\""
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nstatic int config_error_readonly(void)\n{\n\tgiterr_set(GITERR_CONFIG, \"this backend is read-only\");\n\treturn -1;\n}"
  },
  {
    "function_name": "set_parse_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
    "lines": "127-131",
    "snippet": "static void set_parse_error(struct reader *reader, int col, const char *error_str)\n{\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse config file: %s (in %s:%d, column %d)\",\n\t\terror_str, reader->file_path, reader->line_number, col);\n}",
    "includes": [
      "#include <regex.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"array.h\"",
      "#include \"strmap.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"sysdir.h\"",
      "#include \"filebuf.h\"",
      "#include \"config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);",
      "static int config_snapshot(git_config_backend **out, git_config_backend *in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"Failed to parse config file: %s (in %s:%d, column %d)\"",
            "error_str",
            "reader->file_path",
            "reader->line_number",
            "col"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__snapshot(git_config_backend **out, diskfile_backend *in);\nstatic int config_snapshot(git_config_backend **out, git_config_backend *in);\n\nstatic void set_parse_error(struct reader *reader, int col, const char *error_str)\n{\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse config file: %s (in %s:%d, column %d)\",\n\t\terror_str, reader->file_path, reader->line_number, col);\n}"
  }
]