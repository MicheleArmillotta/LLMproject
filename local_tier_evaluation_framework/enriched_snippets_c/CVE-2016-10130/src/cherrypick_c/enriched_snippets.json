[
  {
    "function_name": "git_cherrypick_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
    "lines": "223-229",
    "snippet": "int git_cherrypick_init_options(\n\tgit_cherrypick_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_cherrypick_options, GIT_CHERRYPICK_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/cherrypick.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/types.h\"",
      "#include \"index.h\"",
      "#include \"vector.h\"",
      "#include \"merge.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_cherrypick_options",
            "GIT_CHERRYPICK_OPTIONS_INIT"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_cherrypick_init_options(\n\tgit_cherrypick_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_cherrypick_options, GIT_CHERRYPICK_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_cherrypick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
    "lines": "164-221",
    "snippet": "int git_cherrypick(\n\tgit_repository *repo,\n\tgit_commit *commit,\n\tconst git_cherrypick_options *given_opts)\n{\n\tgit_cherrypick_options opts;\n\tgit_reference *our_ref = NULL;\n\tgit_commit *our_commit = NULL;\n\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\tconst char *commit_msg, *commit_summary;\n\tgit_buf their_label = GIT_BUF_INIT;\n\tgit_index *index = NULL;\n\tgit_indexwriter indexwriter = GIT_INDEXWRITER_INIT;\n\tint error = 0;\n\n\tassert(repo && commit);\n\n\tGITERR_CHECK_VERSION(given_opts, GIT_CHERRYPICK_OPTIONS_VERSION, \"git_cherrypick_options\");\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"cherry-pick\")) < 0)\n\t\treturn error;\n\n\tif ((commit_msg = git_commit_message(commit)) == NULL ||\n\t\t(commit_summary = git_commit_summary(commit)) == NULL) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tgit_oid_nfmt(commit_oidstr, sizeof(commit_oidstr), git_commit_id(commit));\n\n\tif ((error = write_merge_msg(repo, commit_msg)) < 0 ||\n\t\t(error = git_buf_printf(&their_label, \"%.7s... %s\", commit_oidstr, commit_summary)) < 0 ||\n\t\t(error = cherrypick_normalize_opts(repo, &opts, given_opts, git_buf_cstr(&their_label))) < 0 ||\n\t\t(error = git_indexwriter_init_for_operation(&indexwriter, repo, &opts.checkout_opts.checkout_strategy)) < 0 ||\n\t\t(error = write_cherrypick_head(repo, commit_oidstr)) < 0 ||\n\t\t(error = git_repository_head(&our_ref, repo)) < 0 ||\n\t\t(error = git_reference_peel((git_object **)&our_commit, our_ref, GIT_OBJ_COMMIT)) < 0 ||\n\t\t(error = git_cherrypick_commit(&index, repo, commit, our_commit, opts.mainline, &opts.merge_opts)) < 0 ||\n\t\t(error = git_merge__check_result(repo, index)) < 0 ||\n\t\t(error = git_merge__append_conflicts_to_merge_msg(repo, index)) < 0 ||\n\t\t(error = git_checkout_index(repo, index, &opts.checkout_opts)) < 0 ||\n\t\t(error = git_indexwriter_commit(&indexwriter)) < 0)\n\t\tgoto on_error;\n\n\tgoto done;\n\non_error:\n\tcherrypick_state_cleanup(repo);\n\ndone:\n\tgit_indexwriter_cleanup(&indexwriter);\n\tgit_index_free(index);\n\tgit_commit_free(our_commit);\n\tgit_reference_free(our_ref);\n\tgit_buf_free(&their_label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/cherrypick.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/types.h\"",
      "#include \"index.h\"",
      "#include \"vector.h\"",
      "#include \"merge.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&their_label"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "our_ref"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "our_commit"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexwriter_cleanup",
          "args": [
            "&indexwriter"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3433-3439",
          "snippet": "void git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nvoid git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cherrypick_state_cleanup",
          "args": [
            "repo"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "cherrypick_state_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
          "lines": "99-104",
          "snippet": "static int cherrypick_state_cleanup(git_repository *repo)\n{\n\tconst char *state_files[] = { GIT_CHERRYPICK_HEAD_FILE, GIT_MERGE_MSG_FILE };\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}",
          "includes": [
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/cherrypick.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/types.h\"",
            "#include \"index.h\"",
            "#include \"vector.h\"",
            "#include \"merge.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int cherrypick_state_cleanup(git_repository *repo)\n{\n\tconst char *state_files[] = { GIT_CHERRYPICK_HEAD_FILE, GIT_MERGE_MSG_FILE };\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexwriter_commit",
          "args": [
            "&indexwriter"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3399-3431",
          "snippet": "int git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_checkout_index",
          "args": [
            "repo",
            "index",
            "&opts.checkout_opts"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_merge__append_conflicts_to_merge_msg",
          "args": [
            "repo",
            "index"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__append_conflicts_to_merge_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2805-2845",
          "snippet": "int git_merge__append_conflicts_to_merge_msg(\n\tgit_repository *repo,\n\tgit_index *index)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tconst char *last = NULL;\n\tsize_t i;\n\tint error;\n\n\tif (!git_index_has_conflicts(index))\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_APPEND, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tgit_filebuf_printf(&file, \"\\nConflicts:\\n\");\n\n\tfor (i = 0; i < git_index_entrycount(index); i++) {\n\t\tconst git_index_entry *e = git_index_get_byindex(index, i);\n\n\t\tif (!git_index_entry_is_conflict(e))\n\t\t\tcontinue;\n\n\t\tif (last == NULL || strcmp(e->path, last) != 0)\n\t\t\tgit_filebuf_printf(&file, \"\\t%s\\n\", e->path);\n\n\t\tlast = e->path;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge__append_conflicts_to_merge_msg(\n\tgit_repository *repo,\n\tgit_index *index)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tconst char *last = NULL;\n\tsize_t i;\n\tint error;\n\n\tif (!git_index_has_conflicts(index))\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_APPEND, GIT_MERGE_FILE_MODE)) < 0)\n\t\tgoto cleanup;\n\n\tgit_filebuf_printf(&file, \"\\nConflicts:\\n\");\n\n\tfor (i = 0; i < git_index_entrycount(index); i++) {\n\t\tconst git_index_entry *e = git_index_get_byindex(index, i);\n\n\t\tif (!git_index_entry_is_conflict(e))\n\t\t\tcontinue;\n\n\t\tif (last == NULL || strcmp(e->path, last) != 0)\n\t\t\tgit_filebuf_printf(&file, \"\\t%s\\n\", e->path);\n\n\t\tlast = e->path;\n\t}\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__check_result",
          "args": [
            "repo",
            "index"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__check_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "2746-2803",
          "snippet": "int git_merge__check_result(git_repository *repo, git_index *index_new)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_iterator *iter_head = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *merged_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_delta *delta;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tsize_t i, index_conflicts = 0, wd_conflicts = 0, conflicts;\n\tconst git_index_entry *e;\n\tint error = 0;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_iterator_for_tree(&iter_head, head_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&merged_list, repo, iter_head, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&merged_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < git_index_entrycount(index_new); i++) {\n\t\te = git_index_get_byindex(index_new, i);\n\n\t\tif (git_index_entry_is_conflict(e) &&\n\t\t\t(git_vector_last(&paths) == NULL ||\n\t\t\tstrcmp(git_vector_last(&paths), e->path) != 0)) {\n\n\t\t\tif ((error = git_vector_insert(&paths, (char *)e->path)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Make sure the index and workdir state do not prevent merging */\n\tif ((error = merge_check_index(&index_conflicts, repo, index_new, &paths)) < 0 ||\n\t\t(error = merge_check_workdir(&wd_conflicts, repo, index_new, &paths)) < 0)\n\t\tgoto done;\n\n\tif ((conflicts = index_conflicts + wd_conflicts) > 0) {\n\t\tgiterr_set(GITERR_MERGE, \"%\" PRIuZ \" uncommitted change%s would be overwritten by merge\",\n\t\t\tconflicts, (conflicts != 1) ? \"s\" : \"\");\n\t\terror = GIT_ECONFLICT;\n\t}\n\ndone:\n\tgit_vector_free(&paths);\n\tgit_tree_free(head_tree);\n\tgit_iterator_free(iter_head);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(merged_list);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge__check_result(git_repository *repo, git_index *index_new)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_iterator *iter_head = NULL, *iter_new = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_diff *merged_list = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_delta *delta;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tsize_t i, index_conflicts = 0, wd_conflicts = 0, conflicts;\n\tconst git_index_entry *e;\n\tint error = 0;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_iterator_for_tree(&iter_head, head_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&iter_new, repo, index_new, &iter_opts)) < 0 ||\n\t\t(error = git_diff__from_iterators(&merged_list, repo, iter_head, iter_new, &opts)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&merged_list->deltas, i, delta) {\n\t\tif ((error = git_vector_insert(&paths, (char *)delta->new_file.path)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < git_index_entrycount(index_new); i++) {\n\t\te = git_index_get_byindex(index_new, i);\n\n\t\tif (git_index_entry_is_conflict(e) &&\n\t\t\t(git_vector_last(&paths) == NULL ||\n\t\t\tstrcmp(git_vector_last(&paths), e->path) != 0)) {\n\n\t\t\tif ((error = git_vector_insert(&paths, (char *)e->path)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Make sure the index and workdir state do not prevent merging */\n\tif ((error = merge_check_index(&index_conflicts, repo, index_new, &paths)) < 0 ||\n\t\t(error = merge_check_workdir(&wd_conflicts, repo, index_new, &paths)) < 0)\n\t\tgoto done;\n\n\tif ((conflicts = index_conflicts + wd_conflicts) > 0) {\n\t\tgiterr_set(GITERR_MERGE, \"%\" PRIuZ \" uncommitted change%s would be overwritten by merge\",\n\t\t\tconflicts, (conflicts != 1) ? \"s\" : \"\");\n\t\terror = GIT_ECONFLICT;\n\t}\n\ndone:\n\tgit_vector_free(&paths);\n\tgit_tree_free(head_tree);\n\tgit_iterator_free(iter_head);\n\tgit_iterator_free(iter_new);\n\tgit_diff_free(merged_list);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_cherrypick_commit",
          "args": [
            "&index",
            "repo",
            "commit",
            "our_commit",
            "opts.mainline",
            "&opts.merge_opts"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "git_cherrypick_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
          "lines": "116-162",
          "snippet": "int git_cherrypick_commit(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_commit *cherrypick_commit,\n\tgit_commit *our_commit,\n\tunsigned int mainline,\n\tconst git_merge_options *merge_opts)\n{\n\tgit_commit *parent_commit = NULL;\n\tgit_tree *parent_tree = NULL, *our_tree = NULL, *cherrypick_tree = NULL;\n\tint parent = 0, error = 0;\n\n\tassert(out && repo && cherrypick_commit && our_commit);\n\n\tif (git_commit_parentcount(cherrypick_commit) > 1) {\n\t\tif (!mainline)\n\t\t\treturn cherrypick_seterr(cherrypick_commit,\n\t\t\t\t\"Mainline branch is not specified but %s is a merge commit\");\n\n\t\tparent = mainline;\n\t} else {\n\t\tif (mainline)\n\t\t\treturn cherrypick_seterr(cherrypick_commit,\n\t\t\t\t\"Mainline branch specified but %s is not a merge commit\");\n\n\t\tparent = git_commit_parentcount(cherrypick_commit);\n\t}\n\n\tif (parent &&\n\t\t((error = git_commit_parent(&parent_commit, cherrypick_commit, (parent - 1))) < 0 ||\n\t\t(error = git_commit_tree(&parent_tree, parent_commit)) < 0))\n\t\tgoto done;\n\n\tif ((error = git_commit_tree(&cherrypick_tree, cherrypick_commit)) < 0 ||\n\t\t(error = git_commit_tree(&our_tree, our_commit)) < 0)\n\t\tgoto done;\n\n\terror = git_merge_trees(out, repo, parent_tree, our_tree, cherrypick_tree, merge_opts);\n\ndone:\n\tgit_tree_free(parent_tree);\n\tgit_tree_free(our_tree);\n\tgit_tree_free(cherrypick_tree);\n\tgit_commit_free(parent_commit);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/cherrypick.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/types.h\"",
            "#include \"index.h\"",
            "#include \"vector.h\"",
            "#include \"merge.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_cherrypick_commit(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_commit *cherrypick_commit,\n\tgit_commit *our_commit,\n\tunsigned int mainline,\n\tconst git_merge_options *merge_opts)\n{\n\tgit_commit *parent_commit = NULL;\n\tgit_tree *parent_tree = NULL, *our_tree = NULL, *cherrypick_tree = NULL;\n\tint parent = 0, error = 0;\n\n\tassert(out && repo && cherrypick_commit && our_commit);\n\n\tif (git_commit_parentcount(cherrypick_commit) > 1) {\n\t\tif (!mainline)\n\t\t\treturn cherrypick_seterr(cherrypick_commit,\n\t\t\t\t\"Mainline branch is not specified but %s is a merge commit\");\n\n\t\tparent = mainline;\n\t} else {\n\t\tif (mainline)\n\t\t\treturn cherrypick_seterr(cherrypick_commit,\n\t\t\t\t\"Mainline branch specified but %s is not a merge commit\");\n\n\t\tparent = git_commit_parentcount(cherrypick_commit);\n\t}\n\n\tif (parent &&\n\t\t((error = git_commit_parent(&parent_commit, cherrypick_commit, (parent - 1))) < 0 ||\n\t\t(error = git_commit_tree(&parent_tree, parent_commit)) < 0))\n\t\tgoto done;\n\n\tif ((error = git_commit_tree(&cherrypick_tree, cherrypick_commit)) < 0 ||\n\t\t(error = git_commit_tree(&our_tree, our_commit)) < 0)\n\t\tgoto done;\n\n\terror = git_merge_trees(out, repo, parent_tree, our_tree, cherrypick_tree, merge_opts);\n\ndone:\n\tgit_tree_free(parent_tree);\n\tgit_tree_free(our_tree);\n\tgit_tree_free(cherrypick_tree);\n\tgit_commit_free(parent_commit);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_peel",
          "args": [
            "(git_object **)&our_commit",
            "our_ref",
            "GIT_OBJ_COMMIT"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1224-1267",
          "snippet": "int git_reference_peel(\n\tgit_object **peeled,\n\tgit_reference *ref,\n\tgit_otype target_type)\n{\n\tgit_reference *resolved = NULL;\n\tgit_object *target = NULL;\n\tint error;\n\n\tassert(ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tresolved = ref;\n\t} else {\n\t\tif ((error = git_reference_resolve(&resolved, ref)) < 0)\n\t\t\treturn peel_error(error, ref, \"Cannot resolve reference\");\n\t}\n\n\tif (!git_oid_iszero(&resolved->peel)) {\n\t\terror = git_object_lookup(&target,\n\t\t\tgit_reference_owner(ref), &resolved->peel, GIT_OBJ_ANY);\n\t} else {\n\t\terror = git_object_lookup(&target,\n\t\t\tgit_reference_owner(ref), &resolved->target.oid, GIT_OBJ_ANY);\n\t}\n\n\tif (error < 0) {\n\t\tpeel_error(error, ref, \"Cannot retrieve reference target\");\n\t\tgoto cleanup;\n\t}\n\n\tif (target_type == GIT_OBJ_ANY && git_object_type(target) != GIT_OBJ_TAG)\n\t\terror = git_object_dup(peeled, target);\n\telse\n\t\terror = git_object_peel(peeled, target, target_type);\n\ncleanup:\n\tgit_object_free(target);\n\n\tif (resolved != ref)\n\t\tgit_reference_free(resolved);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_peel(\n\tgit_object **peeled,\n\tgit_reference *ref,\n\tgit_otype target_type)\n{\n\tgit_reference *resolved = NULL;\n\tgit_object *target = NULL;\n\tint error;\n\n\tassert(ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tresolved = ref;\n\t} else {\n\t\tif ((error = git_reference_resolve(&resolved, ref)) < 0)\n\t\t\treturn peel_error(error, ref, \"Cannot resolve reference\");\n\t}\n\n\tif (!git_oid_iszero(&resolved->peel)) {\n\t\terror = git_object_lookup(&target,\n\t\t\tgit_reference_owner(ref), &resolved->peel, GIT_OBJ_ANY);\n\t} else {\n\t\terror = git_object_lookup(&target,\n\t\t\tgit_reference_owner(ref), &resolved->target.oid, GIT_OBJ_ANY);\n\t}\n\n\tif (error < 0) {\n\t\tpeel_error(error, ref, \"Cannot retrieve reference target\");\n\t\tgoto cleanup;\n\t}\n\n\tif (target_type == GIT_OBJ_ANY && git_object_type(target) != GIT_OBJ_TAG)\n\t\terror = git_object_dup(peeled, target);\n\telse\n\t\terror = git_object_peel(peeled, target, target_type);\n\ncleanup:\n\tgit_object_free(target);\n\n\tif (resolved != ref)\n\t\tgit_reference_free(resolved);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head",
          "args": [
            "&our_ref",
            "repo"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_cherrypick_head",
          "args": [
            "repo",
            "commit_oidstr"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "write_cherrypick_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
          "lines": "23-42",
          "snippet": "static int write_cherrypick_head(\n\tgit_repository *repo,\n\tconst char *commit_oidstr)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_CHERRYPICK_HEAD_FILE)) >= 0 &&\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_CHERRYPICK_FILE_MODE)) >= 0 &&\n\t\t(error = git_filebuf_printf(&file, \"%s\\n\", commit_oidstr)) >= 0)\n\t\terror = git_filebuf_commit(&file);\n\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/cherrypick.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/types.h\"",
            "#include \"index.h\"",
            "#include \"vector.h\"",
            "#include \"merge.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_CHERRYPICK_FILE_MODE\t\t0666"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\n#define GIT_CHERRYPICK_FILE_MODE\t\t0666\n\nstatic int write_cherrypick_head(\n\tgit_repository *repo,\n\tconst char *commit_oidstr)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_CHERRYPICK_HEAD_FILE)) >= 0 &&\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_CHERRYPICK_FILE_MODE)) >= 0 &&\n\t\t(error = git_filebuf_printf(&file, \"%s\\n\", commit_oidstr)) >= 0)\n\t\terror = git_filebuf_commit(&file);\n\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexwriter_init_for_operation",
          "args": [
            "&indexwriter",
            "repo",
            "&opts.checkout_opts.checkout_strategy"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_init_for_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3381-3397",
          "snippet": "int git_indexwriter_init_for_operation(\n\tgit_indexwriter *writer,\n\tgit_repository *repo,\n\tunsigned int *checkout_strategy)\n{\n\tgit_index *index;\n\tint error;\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0 ||\n\t\t(error = git_indexwriter_init(writer, index)) < 0)\n\t\treturn error;\n\n\twriter->should_write = (*checkout_strategy & GIT_CHECKOUT_DONT_WRITE_INDEX) == 0;\n\t*checkout_strategy |= GIT_CHECKOUT_DONT_WRITE_INDEX;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_indexwriter_init_for_operation(\n\tgit_indexwriter *writer,\n\tgit_repository *repo,\n\tunsigned int *checkout_strategy)\n{\n\tgit_index *index;\n\tint error;\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0 ||\n\t\t(error = git_indexwriter_init(writer, index)) < 0)\n\t\treturn error;\n\n\twriter->should_write = (*checkout_strategy & GIT_CHECKOUT_DONT_WRITE_INDEX) == 0;\n\t*checkout_strategy |= GIT_CHECKOUT_DONT_WRITE_INDEX;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cherrypick_normalize_opts",
          "args": [
            "repo",
            "&opts",
            "given_opts",
            "git_buf_cstr(&their_label)"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "cherrypick_normalize_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
          "lines": "68-97",
          "snippet": "static int cherrypick_normalize_opts(\n\tgit_repository *repo,\n\tgit_cherrypick_options *opts,\n\tconst git_cherrypick_options *given,\n\tconst char *their_label)\n{\n\tint error = 0;\n\tunsigned int default_checkout_strategy = GIT_CHECKOUT_SAFE |\n\t\tGIT_CHECKOUT_ALLOW_CONFLICTS;\n\n\tGIT_UNUSED(repo);\n\n\tif (given != NULL)\n\t\tmemcpy(opts, given, sizeof(git_cherrypick_options));\n\telse {\n\t\tgit_cherrypick_options default_opts = GIT_CHERRYPICK_OPTIONS_INIT;\n\t\tmemcpy(opts, &default_opts, sizeof(git_cherrypick_options));\n\t}\n\n\tif (!opts->checkout_opts.checkout_strategy)\n\t\topts->checkout_opts.checkout_strategy = default_checkout_strategy;\n\n\tif (!opts->checkout_opts.our_label)\n\t\topts->checkout_opts.our_label = \"HEAD\";\n\n\tif (!opts->checkout_opts.their_label)\n\t\topts->checkout_opts.their_label = their_label;\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/cherrypick.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/types.h\"",
            "#include \"index.h\"",
            "#include \"vector.h\"",
            "#include \"merge.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int cherrypick_normalize_opts(\n\tgit_repository *repo,\n\tgit_cherrypick_options *opts,\n\tconst git_cherrypick_options *given,\n\tconst char *their_label)\n{\n\tint error = 0;\n\tunsigned int default_checkout_strategy = GIT_CHECKOUT_SAFE |\n\t\tGIT_CHECKOUT_ALLOW_CONFLICTS;\n\n\tGIT_UNUSED(repo);\n\n\tif (given != NULL)\n\t\tmemcpy(opts, given, sizeof(git_cherrypick_options));\n\telse {\n\t\tgit_cherrypick_options default_opts = GIT_CHERRYPICK_OPTIONS_INIT;\n\t\tmemcpy(opts, &default_opts, sizeof(git_cherrypick_options));\n\t}\n\n\tif (!opts->checkout_opts.checkout_strategy)\n\t\topts->checkout_opts.checkout_strategy = default_checkout_strategy;\n\n\tif (!opts->checkout_opts.our_label)\n\t\topts->checkout_opts.our_label = \"HEAD\";\n\n\tif (!opts->checkout_opts.their_label)\n\t\topts->checkout_opts.their_label = their_label;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&their_label"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&their_label",
            "\"%.7s... %s\"",
            "commit_oidstr",
            "commit_summary"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_merge_msg",
          "args": [
            "repo",
            "commit_msg"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "write_merge_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
          "lines": "44-66",
          "snippet": "static int write_merge_msg(\n\tgit_repository *repo,\n\tconst char *commit_msg)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_CHERRYPICK_FILE_MODE)) < 0 ||\n\t\t(error = git_filebuf_printf(&file, \"%s\", commit_msg)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/cherrypick.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/types.h\"",
            "#include \"index.h\"",
            "#include \"vector.h\"",
            "#include \"merge.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_CHERRYPICK_FILE_MODE\t\t0666"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\n#define GIT_CHERRYPICK_FILE_MODE\t\t0666\n\nstatic int write_merge_msg(\n\tgit_repository *repo,\n\tconst char *commit_msg)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_CHERRYPICK_FILE_MODE)) < 0 ||\n\t\t(error = git_filebuf_printf(&file, \"%s\", commit_msg)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_nfmt",
          "args": [
            "commit_oidstr",
            "sizeof(commit_oidstr)",
            "git_commit_id(commit)"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_nfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "66-86",
          "snippet": "void git_oid_nfmt(char *str, size_t n, const git_oid *oid)\n{\n\tsize_t i, max_i;\n\n\tif (!oid) {\n\t\tmemset(str, 0, n);\n\t\treturn;\n\t}\n\tif (n > GIT_OID_HEXSZ) {\n\t\tmemset(&str[GIT_OID_HEXSZ], 0, n - GIT_OID_HEXSZ);\n\t\tn = GIT_OID_HEXSZ;\n\t}\n\n\tmax_i = n / 2;\n\n\tfor (i = 0; i < max_i; i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n\n\tif (n & 1)\n\t\t*str++ = to_hex[oid->id[i] >> 4];\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char to_hex[] = \"0123456789abcdef\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nstatic char to_hex[] = \"0123456789abcdef\";\n\nvoid git_oid_nfmt(char *str, size_t n, const git_oid *oid)\n{\n\tsize_t i, max_i;\n\n\tif (!oid) {\n\t\tmemset(str, 0, n);\n\t\treturn;\n\t}\n\tif (n > GIT_OID_HEXSZ) {\n\t\tmemset(&str[GIT_OID_HEXSZ], 0, n - GIT_OID_HEXSZ);\n\t\tn = GIT_OID_HEXSZ;\n\t}\n\n\tmax_i = n / 2;\n\n\tfor (i = 0; i < max_i; i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n\n\tif (n & 1)\n\t\t*str++ = to_hex[oid->id[i] >> 4];\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_summary",
          "args": [
            "commit"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "458-501",
          "snippet": "const char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_message",
          "args": [
            "commit"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "433-456",
          "snippet": "GIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nGIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "\"cherry-pick\""
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "given_opts",
            "GIT_CHERRYPICK_OPTIONS_VERSION",
            "\"git_cherrypick_options\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && commit"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_cherrypick(\n\tgit_repository *repo,\n\tgit_commit *commit,\n\tconst git_cherrypick_options *given_opts)\n{\n\tgit_cherrypick_options opts;\n\tgit_reference *our_ref = NULL;\n\tgit_commit *our_commit = NULL;\n\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\tconst char *commit_msg, *commit_summary;\n\tgit_buf their_label = GIT_BUF_INIT;\n\tgit_index *index = NULL;\n\tgit_indexwriter indexwriter = GIT_INDEXWRITER_INIT;\n\tint error = 0;\n\n\tassert(repo && commit);\n\n\tGITERR_CHECK_VERSION(given_opts, GIT_CHERRYPICK_OPTIONS_VERSION, \"git_cherrypick_options\");\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"cherry-pick\")) < 0)\n\t\treturn error;\n\n\tif ((commit_msg = git_commit_message(commit)) == NULL ||\n\t\t(commit_summary = git_commit_summary(commit)) == NULL) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tgit_oid_nfmt(commit_oidstr, sizeof(commit_oidstr), git_commit_id(commit));\n\n\tif ((error = write_merge_msg(repo, commit_msg)) < 0 ||\n\t\t(error = git_buf_printf(&their_label, \"%.7s... %s\", commit_oidstr, commit_summary)) < 0 ||\n\t\t(error = cherrypick_normalize_opts(repo, &opts, given_opts, git_buf_cstr(&their_label))) < 0 ||\n\t\t(error = git_indexwriter_init_for_operation(&indexwriter, repo, &opts.checkout_opts.checkout_strategy)) < 0 ||\n\t\t(error = write_cherrypick_head(repo, commit_oidstr)) < 0 ||\n\t\t(error = git_repository_head(&our_ref, repo)) < 0 ||\n\t\t(error = git_reference_peel((git_object **)&our_commit, our_ref, GIT_OBJ_COMMIT)) < 0 ||\n\t\t(error = git_cherrypick_commit(&index, repo, commit, our_commit, opts.mainline, &opts.merge_opts)) < 0 ||\n\t\t(error = git_merge__check_result(repo, index)) < 0 ||\n\t\t(error = git_merge__append_conflicts_to_merge_msg(repo, index)) < 0 ||\n\t\t(error = git_checkout_index(repo, index, &opts.checkout_opts)) < 0 ||\n\t\t(error = git_indexwriter_commit(&indexwriter)) < 0)\n\t\tgoto on_error;\n\n\tgoto done;\n\non_error:\n\tcherrypick_state_cleanup(repo);\n\ndone:\n\tgit_indexwriter_cleanup(&indexwriter);\n\tgit_index_free(index);\n\tgit_commit_free(our_commit);\n\tgit_reference_free(our_ref);\n\tgit_buf_free(&their_label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_cherrypick_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
    "lines": "116-162",
    "snippet": "int git_cherrypick_commit(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_commit *cherrypick_commit,\n\tgit_commit *our_commit,\n\tunsigned int mainline,\n\tconst git_merge_options *merge_opts)\n{\n\tgit_commit *parent_commit = NULL;\n\tgit_tree *parent_tree = NULL, *our_tree = NULL, *cherrypick_tree = NULL;\n\tint parent = 0, error = 0;\n\n\tassert(out && repo && cherrypick_commit && our_commit);\n\n\tif (git_commit_parentcount(cherrypick_commit) > 1) {\n\t\tif (!mainline)\n\t\t\treturn cherrypick_seterr(cherrypick_commit,\n\t\t\t\t\"Mainline branch is not specified but %s is a merge commit\");\n\n\t\tparent = mainline;\n\t} else {\n\t\tif (mainline)\n\t\t\treturn cherrypick_seterr(cherrypick_commit,\n\t\t\t\t\"Mainline branch specified but %s is not a merge commit\");\n\n\t\tparent = git_commit_parentcount(cherrypick_commit);\n\t}\n\n\tif (parent &&\n\t\t((error = git_commit_parent(&parent_commit, cherrypick_commit, (parent - 1))) < 0 ||\n\t\t(error = git_commit_tree(&parent_tree, parent_commit)) < 0))\n\t\tgoto done;\n\n\tif ((error = git_commit_tree(&cherrypick_tree, cherrypick_commit)) < 0 ||\n\t\t(error = git_commit_tree(&our_tree, our_commit)) < 0)\n\t\tgoto done;\n\n\terror = git_merge_trees(out, repo, parent_tree, our_tree, cherrypick_tree, merge_opts);\n\ndone:\n\tgit_tree_free(parent_tree);\n\tgit_tree_free(our_tree);\n\tgit_tree_free(cherrypick_tree);\n\tgit_commit_free(parent_commit);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/cherrypick.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/types.h\"",
      "#include \"index.h\"",
      "#include \"vector.h\"",
      "#include \"merge.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "parent_commit"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "cherrypick_tree"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge_trees",
          "args": [
            "out",
            "repo",
            "parent_tree",
            "our_tree",
            "cherrypick_tree",
            "merge_opts"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1910-1941",
          "snippet": "int git_merge_trees(\n\tgit_index **out,\n\tgit_repository *repo,\n\tconst git_tree *ancestor_tree,\n\tconst git_tree *our_tree,\n\tconst git_tree *their_tree,\n\tconst git_merge_options *merge_opts)\n{\n\tgit_iterator *ancestor_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(\n\t\t\t&ancestor_iter, (git_tree *)ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&our_iter, (git_tree *)our_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&their_iter, (git_tree *)their_tree, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(\n\t\tout, repo, ancestor_iter, our_iter, their_iter, merge_opts);\n\ndone:\n\tgit_iterator_free(ancestor_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_trees(\n\tgit_index **out,\n\tgit_repository *repo,\n\tconst git_tree *ancestor_tree,\n\tconst git_tree *our_tree,\n\tconst git_tree *their_tree,\n\tconst git_merge_options *merge_opts)\n{\n\tgit_iterator *ancestor_iter = NULL, *our_iter = NULL, *their_iter = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(\n\t\t\t&ancestor_iter, (git_tree *)ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&our_iter, (git_tree *)our_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&their_iter, (git_tree *)their_tree, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(\n\t\tout, repo, ancestor_iter, our_iter, their_iter, merge_opts);\n\ndone:\n\tgit_iterator_free(ancestor_iter);\n\tgit_iterator_free(our_iter);\n\tgit_iterator_free(their_iter);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&our_tree",
            "our_commit"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parent",
          "args": [
            "&parent_commit",
            "cherrypick_commit",
            "(parent - 1)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "544-557",
          "snippet": "int git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parentcount",
          "args": [
            "cherrypick_commit"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cherrypick_seterr",
          "args": [
            "cherrypick_commit",
            "\"Mainline branch specified but %s is not a merge commit\""
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "cherrypick_seterr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
          "lines": "106-114",
          "snippet": "static int cherrypick_seterr(git_commit *commit, const char *fmt)\n{\n\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\n\tgiterr_set(GITERR_CHERRYPICK, fmt,\n\t\tgit_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit)));\n\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/cherrypick.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/types.h\"",
            "#include \"index.h\"",
            "#include \"vector.h\"",
            "#include \"merge.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int cherrypick_seterr(git_commit *commit, const char *fmt)\n{\n\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\n\tgiterr_set(GITERR_CHERRYPICK, fmt,\n\t\tgit_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit)));\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parentcount",
          "args": [
            "cherrypick_commit"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && cherrypick_commit && our_commit"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_cherrypick_commit(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_commit *cherrypick_commit,\n\tgit_commit *our_commit,\n\tunsigned int mainline,\n\tconst git_merge_options *merge_opts)\n{\n\tgit_commit *parent_commit = NULL;\n\tgit_tree *parent_tree = NULL, *our_tree = NULL, *cherrypick_tree = NULL;\n\tint parent = 0, error = 0;\n\n\tassert(out && repo && cherrypick_commit && our_commit);\n\n\tif (git_commit_parentcount(cherrypick_commit) > 1) {\n\t\tif (!mainline)\n\t\t\treturn cherrypick_seterr(cherrypick_commit,\n\t\t\t\t\"Mainline branch is not specified but %s is a merge commit\");\n\n\t\tparent = mainline;\n\t} else {\n\t\tif (mainline)\n\t\t\treturn cherrypick_seterr(cherrypick_commit,\n\t\t\t\t\"Mainline branch specified but %s is not a merge commit\");\n\n\t\tparent = git_commit_parentcount(cherrypick_commit);\n\t}\n\n\tif (parent &&\n\t\t((error = git_commit_parent(&parent_commit, cherrypick_commit, (parent - 1))) < 0 ||\n\t\t(error = git_commit_tree(&parent_tree, parent_commit)) < 0))\n\t\tgoto done;\n\n\tif ((error = git_commit_tree(&cherrypick_tree, cherrypick_commit)) < 0 ||\n\t\t(error = git_commit_tree(&our_tree, our_commit)) < 0)\n\t\tgoto done;\n\n\terror = git_merge_trees(out, repo, parent_tree, our_tree, cherrypick_tree, merge_opts);\n\ndone:\n\tgit_tree_free(parent_tree);\n\tgit_tree_free(our_tree);\n\tgit_tree_free(cherrypick_tree);\n\tgit_commit_free(parent_commit);\n\n\treturn error;\n}"
  },
  {
    "function_name": "cherrypick_seterr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
    "lines": "106-114",
    "snippet": "static int cherrypick_seterr(git_commit *commit, const char *fmt)\n{\n\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\n\tgiterr_set(GITERR_CHERRYPICK, fmt,\n\t\tgit_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit)));\n\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/cherrypick.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/types.h\"",
      "#include \"index.h\"",
      "#include \"vector.h\"",
      "#include \"merge.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CHERRYPICK",
            "fmt",
            "git_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit))"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_tostr",
          "args": [
            "commit_oidstr",
            "GIT_OID_HEXSZ + 1",
            "git_commit_id(commit)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_tostr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "119-131",
          "snippet": "char *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nchar *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int cherrypick_seterr(git_commit *commit, const char *fmt)\n{\n\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\n\tgiterr_set(GITERR_CHERRYPICK, fmt,\n\t\tgit_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit)));\n\n\treturn -1;\n}"
  },
  {
    "function_name": "cherrypick_state_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
    "lines": "99-104",
    "snippet": "static int cherrypick_state_cleanup(git_repository *repo)\n{\n\tconst char *state_files[] = { GIT_CHERRYPICK_HEAD_FILE, GIT_MERGE_MSG_FILE };\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}",
    "includes": [
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/cherrypick.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/types.h\"",
      "#include \"index.h\"",
      "#include \"vector.h\"",
      "#include \"merge.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_repository__cleanup_files",
          "args": [
            "repo",
            "state_files",
            "ARRAY_SIZE(state_files)"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cleanup_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "2252-2279",
          "snippet": "int git_repository__cleanup_files(\n\tgit_repository *repo, const char *files[], size_t files_len)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t i;\n\tint error;\n\n\tfor (error = 0, i = 0; !error && i < files_len; ++i) {\n\t\tconst char *path;\n\n\t\tif (git_buf_joinpath(&buf, repo->path_repository, files[i]) < 0)\n\t\t\treturn -1;\n\n\t\tpath = git_buf_cstr(&buf);\n\n\t\tif (git_path_isfile(path)) {\n\t\t\terror = p_unlink(path);\n\t\t} else if (git_path_isdir(path)) {\n\t\t\terror = git_futils_rmdir_r(path, NULL,\n\t\t\t\tGIT_RMDIR_REMOVE_FILES | GIT_RMDIR_REMOVE_BLOCKERS);\n\t\t}\n\t\t\t\n\t\tgit_buf_clear(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository__cleanup_files(\n\tgit_repository *repo, const char *files[], size_t files_len)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t i;\n\tint error;\n\n\tfor (error = 0, i = 0; !error && i < files_len; ++i) {\n\t\tconst char *path;\n\n\t\tif (git_buf_joinpath(&buf, repo->path_repository, files[i]) < 0)\n\t\t\treturn -1;\n\n\t\tpath = git_buf_cstr(&buf);\n\n\t\tif (git_path_isfile(path)) {\n\t\t\terror = p_unlink(path);\n\t\t} else if (git_path_isdir(path)) {\n\t\t\terror = git_futils_rmdir_r(path, NULL,\n\t\t\t\tGIT_RMDIR_REMOVE_FILES | GIT_RMDIR_REMOVE_BLOCKERS);\n\t\t}\n\t\t\t\n\t\tgit_buf_clear(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "state_files"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int cherrypick_state_cleanup(git_repository *repo)\n{\n\tconst char *state_files[] = { GIT_CHERRYPICK_HEAD_FILE, GIT_MERGE_MSG_FILE };\n\n\treturn git_repository__cleanup_files(repo, state_files, ARRAY_SIZE(state_files));\n}"
  },
  {
    "function_name": "cherrypick_normalize_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
    "lines": "68-97",
    "snippet": "static int cherrypick_normalize_opts(\n\tgit_repository *repo,\n\tgit_cherrypick_options *opts,\n\tconst git_cherrypick_options *given,\n\tconst char *their_label)\n{\n\tint error = 0;\n\tunsigned int default_checkout_strategy = GIT_CHECKOUT_SAFE |\n\t\tGIT_CHECKOUT_ALLOW_CONFLICTS;\n\n\tGIT_UNUSED(repo);\n\n\tif (given != NULL)\n\t\tmemcpy(opts, given, sizeof(git_cherrypick_options));\n\telse {\n\t\tgit_cherrypick_options default_opts = GIT_CHERRYPICK_OPTIONS_INIT;\n\t\tmemcpy(opts, &default_opts, sizeof(git_cherrypick_options));\n\t}\n\n\tif (!opts->checkout_opts.checkout_strategy)\n\t\topts->checkout_opts.checkout_strategy = default_checkout_strategy;\n\n\tif (!opts->checkout_opts.our_label)\n\t\topts->checkout_opts.our_label = \"HEAD\";\n\n\tif (!opts->checkout_opts.their_label)\n\t\topts->checkout_opts.their_label = their_label;\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/cherrypick.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/types.h\"",
      "#include \"index.h\"",
      "#include \"vector.h\"",
      "#include \"merge.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "opts",
            "&default_opts",
            "sizeof(git_cherrypick_options)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "opts",
            "given",
            "sizeof(git_cherrypick_options)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "repo"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int cherrypick_normalize_opts(\n\tgit_repository *repo,\n\tgit_cherrypick_options *opts,\n\tconst git_cherrypick_options *given,\n\tconst char *their_label)\n{\n\tint error = 0;\n\tunsigned int default_checkout_strategy = GIT_CHECKOUT_SAFE |\n\t\tGIT_CHECKOUT_ALLOW_CONFLICTS;\n\n\tGIT_UNUSED(repo);\n\n\tif (given != NULL)\n\t\tmemcpy(opts, given, sizeof(git_cherrypick_options));\n\telse {\n\t\tgit_cherrypick_options default_opts = GIT_CHERRYPICK_OPTIONS_INIT;\n\t\tmemcpy(opts, &default_opts, sizeof(git_cherrypick_options));\n\t}\n\n\tif (!opts->checkout_opts.checkout_strategy)\n\t\topts->checkout_opts.checkout_strategy = default_checkout_strategy;\n\n\tif (!opts->checkout_opts.our_label)\n\t\topts->checkout_opts.our_label = \"HEAD\";\n\n\tif (!opts->checkout_opts.their_label)\n\t\topts->checkout_opts.their_label = their_label;\n\n\treturn error;\n}"
  },
  {
    "function_name": "write_merge_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
    "lines": "44-66",
    "snippet": "static int write_merge_msg(\n\tgit_repository *repo,\n\tconst char *commit_msg)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_CHERRYPICK_FILE_MODE)) < 0 ||\n\t\t(error = git_filebuf_printf(&file, \"%s\", commit_msg)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/cherrypick.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/types.h\"",
      "#include \"index.h\"",
      "#include \"vector.h\"",
      "#include \"merge.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define GIT_CHERRYPICK_FILE_MODE\t\t0666"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&file_path"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&file"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "&file",
            "\"%s\"",
            "commit_msg"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&file",
            "file_path.ptr",
            "GIT_FILEBUF_FORCE",
            "GIT_CHERRYPICK_FILE_MODE"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&file_path",
            "repo->path_repository",
            "GIT_MERGE_MSG_FILE"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\n#define GIT_CHERRYPICK_FILE_MODE\t\t0666\n\nstatic int write_merge_msg(\n\tgit_repository *repo,\n\tconst char *commit_msg)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_MERGE_MSG_FILE)) < 0 ||\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_CHERRYPICK_FILE_MODE)) < 0 ||\n\t\t(error = git_filebuf_printf(&file, \"%s\", commit_msg)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_filebuf_commit(&file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "write_cherrypick_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cherrypick.c",
    "lines": "23-42",
    "snippet": "static int write_cherrypick_head(\n\tgit_repository *repo,\n\tconst char *commit_oidstr)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_CHERRYPICK_HEAD_FILE)) >= 0 &&\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_CHERRYPICK_FILE_MODE)) >= 0 &&\n\t\t(error = git_filebuf_printf(&file, \"%s\\n\", commit_oidstr)) >= 0)\n\t\terror = git_filebuf_commit(&file);\n\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/cherrypick.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/types.h\"",
      "#include \"index.h\"",
      "#include \"vector.h\"",
      "#include \"merge.h\"",
      "#include \"filebuf.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define GIT_CHERRYPICK_FILE_MODE\t\t0666"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&file_path"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&file"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "&file",
            "\"%s\\n\"",
            "commit_oidstr"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&file",
            "file_path.ptr",
            "GIT_FILEBUF_FORCE",
            "GIT_CHERRYPICK_FILE_MODE"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&file_path",
            "repo->path_repository",
            "GIT_CHERRYPICK_HEAD_FILE"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/commit.h\"\n#include \"git2/commit.h\"\n#include \"git2/cherrypick.h\"\n#include \"git2/merge.h\"\n#include \"git2/types.h\"\n#include \"index.h\"\n#include \"vector.h\"\n#include \"merge.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\n#define GIT_CHERRYPICK_FILE_MODE\t\t0666\n\nstatic int write_cherrypick_head(\n\tgit_repository *repo,\n\tconst char *commit_oidstr)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf file_path = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(&file_path, repo->path_repository, GIT_CHERRYPICK_HEAD_FILE)) >= 0 &&\n\t\t(error = git_filebuf_open(&file, file_path.ptr, GIT_FILEBUF_FORCE, GIT_CHERRYPICK_FILE_MODE)) >= 0 &&\n\t\t(error = git_filebuf_printf(&file, \"%s\\n\", commit_oidstr)) >= 0)\n\t\terror = git_filebuf_commit(&file);\n\n\tif (error < 0)\n\t\tgit_filebuf_cleanup(&file);\n\n\tgit_buf_free(&file_path);\n\n\treturn error;\n}"
  }
]