[
  {
    "function_name": "git__closedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
    "lines": "106-118",
    "snippet": "int git__closedir(git__DIR *d)\n{\n\tif (!d)\n\t\treturn 0;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t}\n\n\tgit__free(d);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "d"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindClose",
          "args": [
            "d->h"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix.h\"\n\nint git__closedir(git__DIR *d)\n{\n\tif (!d)\n\t\treturn 0;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t}\n\n\tgit__free(d);\n\treturn 0;\n}"
  },
  {
    "function_name": "git__rewinddir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
    "lines": "82-104",
    "snippet": "void git__rewinddir(git__DIR *d)\n{\n\tgit_win32_path filter_w;\n\n\tif (!d)\n\t\treturn;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t\td->first = 0;\n\t}\n\n\tif (!git_win32__findfirstfile_filter(filter_w, d->dir))\n\t\treturn;\n\n\td->h = FindFirstFileW(filter_w, &d->f);\n\n\tif (d->h == INVALID_HANDLE_VALUE)\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", d->dir);\n\telse\n\t\td->first = 1;\n}",
    "includes": [
      "#include \"posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not open directory '%s'\"",
            "d->dir"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindFirstFileW",
          "args": [
            "filter_w",
            "&d->f"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32__findfirstfile_filter",
          "args": [
            "filter_w",
            "d->dir"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__findfirstfile_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
          "lines": "18-43",
          "snippet": "bool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}",
          "includes": [
            "#include \"w32_util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_util.h\"\n\nbool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindClose",
          "args": [
            "d->h"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix.h\"\n\nvoid git__rewinddir(git__DIR *d)\n{\n\tgit_win32_path filter_w;\n\n\tif (!d)\n\t\treturn;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t\td->first = 0;\n\t}\n\n\tif (!git_win32__findfirstfile_filter(filter_w, d->dir))\n\t\treturn;\n\n\td->h = FindFirstFileW(filter_w, &d->f);\n\n\tif (d->h == INVALID_HANDLE_VALUE)\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", d->dir);\n\telse\n\t\td->first = 1;\n}"
  },
  {
    "function_name": "git__readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
    "lines": "74-80",
    "snippet": "struct git__dirent *git__readdir(git__DIR *d)\n{\n\tstruct git__dirent *result;\n\tif (git__readdir_ext(d, &d->entry, &result, NULL) < 0)\n\t\treturn NULL;\n\treturn result;\n}",
    "includes": [
      "#include \"posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__readdir_ext",
          "args": [
            "d",
            "&d->entry",
            "&result",
            "NULL"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "git__readdir_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
          "lines": "40-72",
          "snippet": "int git__readdir_ext(\n\tgit__DIR *d,\n\tstruct git__dirent *entry,\n\tstruct git__dirent **result,\n\tint *is_dir)\n{\n\tif (!d || !entry || !result || d->h == INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\t*result = NULL;\n\n\tif (d->first)\n\t\td->first = 0;\n\telse if (!FindNextFileW(d->h, &d->f)) {\n\t\tif (GetLastError() == ERROR_NO_MORE_FILES)\n\t\t\treturn 0;\n\t\tgiterr_set(GITERR_OS, \"Could not read from directory '%s'\", d->dir);\n\t\treturn -1;\n\t}\n\n\t/* Convert the path to UTF-8 */\n\tif (git_win32_path_to_utf8(entry->d_name, d->f.cFileName) < 0)\n\t\treturn -1;\n\n\tentry->d_ino = 0;\n\n\t*result = entry;\n\n\tif (is_dir != NULL)\n\t\t*is_dir = ((d->f.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n\nint git__readdir_ext(\n\tgit__DIR *d,\n\tstruct git__dirent *entry,\n\tstruct git__dirent **result,\n\tint *is_dir)\n{\n\tif (!d || !entry || !result || d->h == INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\t*result = NULL;\n\n\tif (d->first)\n\t\td->first = 0;\n\telse if (!FindNextFileW(d->h, &d->f)) {\n\t\tif (GetLastError() == ERROR_NO_MORE_FILES)\n\t\t\treturn 0;\n\t\tgiterr_set(GITERR_OS, \"Could not read from directory '%s'\", d->dir);\n\t\treturn -1;\n\t}\n\n\t/* Convert the path to UTF-8 */\n\tif (git_win32_path_to_utf8(entry->d_name, d->f.cFileName) < 0)\n\t\treturn -1;\n\n\tentry->d_ino = 0;\n\n\t*result = entry;\n\n\tif (is_dir != NULL)\n\t\t*is_dir = ((d->f.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix.h\"\n\nstruct git__dirent *git__readdir(git__DIR *d)\n{\n\tstruct git__dirent *result;\n\tif (git__readdir_ext(d, &d->entry, &result, NULL) < 0)\n\t\treturn NULL;\n\treturn result;\n}"
  },
  {
    "function_name": "git__readdir_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
    "lines": "40-72",
    "snippet": "int git__readdir_ext(\n\tgit__DIR *d,\n\tstruct git__dirent *entry,\n\tstruct git__dirent **result,\n\tint *is_dir)\n{\n\tif (!d || !entry || !result || d->h == INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\t*result = NULL;\n\n\tif (d->first)\n\t\td->first = 0;\n\telse if (!FindNextFileW(d->h, &d->f)) {\n\t\tif (GetLastError() == ERROR_NO_MORE_FILES)\n\t\t\treturn 0;\n\t\tgiterr_set(GITERR_OS, \"Could not read from directory '%s'\", d->dir);\n\t\treturn -1;\n\t}\n\n\t/* Convert the path to UTF-8 */\n\tif (git_win32_path_to_utf8(entry->d_name, d->f.cFileName) < 0)\n\t\treturn -1;\n\n\tentry->d_ino = 0;\n\n\t*result = entry;\n\n\tif (is_dir != NULL)\n\t\t*is_dir = ((d->f.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_win32_path_to_utf8",
          "args": [
            "entry->d_name",
            "d->f.cFileName"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_to_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "255-279",
          "snippet": "int git_win32_path_to_utf8(git_win32_utf8_path dest, const wchar_t *src)\n{\n\tchar *out = dest;\n\tint len;\n\n\t/* Strip NT namespacing \"\\\\?\\\" */\n\tif (path__is_nt_namespace(src)) {\n\t\tsrc += 4;\n\n\t\t/* \"\\\\?\\UNC\\server\\share\" -> \"\\\\server\\share\" */\n\t\tif (wcsncmp(src, L\"UNC\\\\\", 4) == 0) {\n\t\t\tsrc += 4;\n\n\t\t\tmemcpy(dest, \"\\\\\\\\\", 2);\n\t\t\tout = dest + 2;\n\t\t}\n\t}\n\n\tif ((len = git__utf16_to_8(out, GIT_WIN_PATH_UTF8, src)) < 0)\n\t\treturn len;\n\n\tgit_path_mkposix(dest);\n\n\treturn len;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path_to_utf8(git_win32_utf8_path dest, const wchar_t *src)\n{\n\tchar *out = dest;\n\tint len;\n\n\t/* Strip NT namespacing \"\\\\?\\\" */\n\tif (path__is_nt_namespace(src)) {\n\t\tsrc += 4;\n\n\t\t/* \"\\\\?\\UNC\\server\\share\" -> \"\\\\server\\share\" */\n\t\tif (wcsncmp(src, L\"UNC\\\\\", 4) == 0) {\n\t\t\tsrc += 4;\n\n\t\t\tmemcpy(dest, \"\\\\\\\\\", 2);\n\t\t\tout = dest + 2;\n\t\t}\n\t}\n\n\tif ((len = git__utf16_to_8(out, GIT_WIN_PATH_UTF8, src)) < 0)\n\t\treturn len;\n\n\tgit_path_mkposix(dest);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not read from directory '%s'\"",
            "d->dir"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FindNextFileW",
          "args": [
            "d->h",
            "&d->f"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix.h\"\n\nint git__readdir_ext(\n\tgit__DIR *d,\n\tstruct git__dirent *entry,\n\tstruct git__dirent **result,\n\tint *is_dir)\n{\n\tif (!d || !entry || !result || d->h == INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\t*result = NULL;\n\n\tif (d->first)\n\t\td->first = 0;\n\telse if (!FindNextFileW(d->h, &d->f)) {\n\t\tif (GetLastError() == ERROR_NO_MORE_FILES)\n\t\t\treturn 0;\n\t\tgiterr_set(GITERR_OS, \"Could not read from directory '%s'\", d->dir);\n\t\treturn -1;\n\t}\n\n\t/* Convert the path to UTF-8 */\n\tif (git_win32_path_to_utf8(entry->d_name, d->f.cFileName) < 0)\n\t\treturn -1;\n\n\tentry->d_ino = 0;\n\n\t*result = entry;\n\n\tif (is_dir != NULL)\n\t\t*is_dir = ((d->f.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git__opendir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
    "lines": "10-38",
    "snippet": "git__DIR *git__opendir(const char *dir)\n{\n\tgit_win32_path filter_w;\n\tgit__DIR *new = NULL;\n\tsize_t dirlen, alloclen;\n\n\tif (!dir || !git_win32__findfirstfile_filter(filter_w, dir))\n\t\treturn NULL;\n\n\tdirlen = strlen(dir);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, sizeof(*new), dirlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1) ||\n\t\t!(new = git__calloc(1, alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(new->dir, dir, dirlen);\n\n\tnew->h = FindFirstFileW(filter_w, &new->f);\n\n\tif (new->h == INVALID_HANDLE_VALUE) {\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", dir);\n\t\tgit__free(new);\n\t\treturn NULL;\n\t}\n\n\tnew->first = 1;\n\treturn new;\n}",
    "includes": [
      "#include \"posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "new"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not open directory '%s'\"",
            "dir"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindFirstFileW",
          "args": [
            "filter_w",
            "&new->f"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new->dir",
            "dir",
            "dirlen"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "alloclen"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloclen",
            "alloclen",
            "1"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloclen",
            "sizeof(*new)",
            "dirlen"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dir"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32__findfirstfile_filter",
          "args": [
            "filter_w",
            "dir"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__findfirstfile_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
          "lines": "18-43",
          "snippet": "bool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}",
          "includes": [
            "#include \"w32_util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_util.h\"\n\nbool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix.h\"\n\ngit__DIR *git__opendir(const char *dir)\n{\n\tgit_win32_path filter_w;\n\tgit__DIR *new = NULL;\n\tsize_t dirlen, alloclen;\n\n\tif (!dir || !git_win32__findfirstfile_filter(filter_w, dir))\n\t\treturn NULL;\n\n\tdirlen = strlen(dir);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, sizeof(*new), dirlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1) ||\n\t\t!(new = git__calloc(1, alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(new->dir, dir, dirlen);\n\n\tnew->h = FindFirstFileW(filter_w, &new->f);\n\n\tif (new->h == INVALID_HANDLE_VALUE) {\n\t\tgiterr_set(GITERR_OS, \"Could not open directory '%s'\", dir);\n\t\tgit__free(new);\n\t\treturn NULL;\n\t}\n\n\tnew->first = 1;\n\treturn new;\n}"
  }
]