[
  {
    "function_name": "git_push_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "713-718",
    "snippet": "int git_push_init_options(git_push_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_push_options, GIT_PUSH_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_push_options",
            "GIT_PUSH_OPTIONS_INIT"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_init_options(git_push_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_push_options, GIT_PUSH_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_push_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "683-711",
    "snippet": "void git_push_free(git_push *push)\n{\n\tpush_spec *spec;\n\tpush_status *status;\n\tgit_push_update *update;\n\tunsigned int i;\n\n\tif (push == NULL)\n\t\treturn;\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tfree_refspec(spec);\n\t}\n\tgit_vector_free(&push->specs);\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tgit_push_status_free(status);\n\t}\n\tgit_vector_free(&push->status);\n\n\tgit_vector_foreach(&push->updates, i, update) {\n\t\tgit__free(update->src_refname);\n\t\tgit__free(update->dst_refname);\n\t\tgit__free(update);\n\t}\n\tgit_vector_free(&push->updates);\n\n\tgit__free(push);\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "push"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&push->updates"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->updates",
            "i",
            "update"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_push_status_free",
          "args": [
            "status"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_status_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "673-681",
          "snippet": "void git_push_status_free(push_status *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit__free(status->msg);\n\tgit__free(status->ref);\n\tgit__free(status);\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nvoid git_push_status_free(push_status *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit__free(status->msg);\n\tgit__free(status->ref);\n\tgit__free(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->status",
            "i",
            "status"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_refspec",
          "args": [
            "spec"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "free_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "81-88",
          "snippet": "static void free_refspec(push_spec *spec)\n{\n\tif (spec == NULL)\n\t\treturn;\n\n\tgit_refspec__free(&spec->refspec);\n\tgit__free(spec);\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic void free_refspec(push_spec *spec)\n{\n\tif (spec == NULL)\n\t\treturn;\n\n\tgit_refspec__free(&spec->refspec);\n\tgit__free(spec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->specs",
            "i",
            "spec"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nvoid git_push_free(git_push *push)\n{\n\tpush_spec *spec;\n\tpush_status *status;\n\tgit_push_update *update;\n\tunsigned int i;\n\n\tif (push == NULL)\n\t\treturn;\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tfree_refspec(spec);\n\t}\n\tgit_vector_free(&push->specs);\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tgit_push_status_free(status);\n\t}\n\tgit_vector_free(&push->status);\n\n\tgit_vector_foreach(&push->updates, i, update) {\n\t\tgit__free(update->src_refname);\n\t\tgit__free(update->dst_refname);\n\t\tgit__free(update);\n\t}\n\tgit_vector_free(&push->updates);\n\n\tgit__free(push);\n}"
  },
  {
    "function_name": "git_push_status_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "673-681",
    "snippet": "void git_push_status_free(push_status *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit__free(status->msg);\n\tgit__free(status->ref);\n\tgit__free(status);\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "status"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nvoid git_push_status_free(push_status *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit__free(status->msg);\n\tgit__free(status->ref);\n\tgit__free(status);\n}"
  },
  {
    "function_name": "git_push_status_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "657-671",
    "snippet": "int git_push_status_foreach(git_push *push,\n\t\tint (*cb)(const char *ref, const char *msg, void *data),\n\t\tvoid *data)\n{\n\tpush_status *status;\n\tunsigned int i;\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tint error = cb(status->ref, status->msg, data);\n\t\tif (error)\n\t\t\treturn giterr_set_after_callback(error);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "status->ref",
            "status->msg",
            "data"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "is_dirty_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "447-454",
          "snippet": "static int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->status",
            "i",
            "status"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_status_foreach(git_push *push,\n\t\tint (*cb)(const char *ref, const char *msg, void *data),\n\t\tvoid *data)\n{\n\tpush_status *status;\n\tunsigned int i;\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tint error = cb(status->ref, status->msg, data);\n\t\tif (error)\n\t\t\treturn giterr_set_after_callback(error);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_push_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "637-655",
    "snippet": "int git_push_finish(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tint error;\n\n\tif (!git_remote_connected(push->remote) &&\n\t    (error = git_remote_connect(push->remote, GIT_DIRECTION_PUSH, callbacks, push->custom_headers)) < 0)\n\t\treturn error;\n\n\tif ((error = filter_refs(push->remote)) < 0 ||\n\t    (error = do_push(push, callbacks)) < 0)\n\t\treturn error;\n\n\tif (!push->unpack_ok) {\n\t\terror = -1;\n\t\tgiterr_set(GITERR_NET, \"unpacking the sent packfile failed on the remote\");\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"unpacking the sent packfile failed on the remote\""
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_push",
          "args": [
            "push",
            "callbacks"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "do_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "576-617",
          "snippet": "static int do_push(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tint error = 0;\n\tgit_transport *transport = push->remote->transport;\n\n\tif (!transport->push) {\n\t\tgiterr_set(GITERR_NET, \"Remote transport doesn't support push\");\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\t/*\n\t * A pack-file MUST be sent if either create or update command\n\t * is used, even if the server already has all the necessary\n\t * objects.  In this case the client MUST send an empty pack-file.\n\t */\n\n\tif ((error = git_packbuilder_new(&push->pb, push->repo)) < 0)\n\t\tgoto on_error;\n\n\tgit_packbuilder_set_threads(push->pb, push->pb_parallelism);\n\n\tif (callbacks && callbacks->pack_progress)\n\t\tif ((error = git_packbuilder_set_callbacks(push->pb, callbacks->pack_progress, callbacks->payload)) < 0)\n\t\t\tgoto on_error;\n\n\tif ((error = calculate_work(push)) < 0)\n\t\tgoto on_error;\n\n\tif (callbacks && callbacks->push_negotiation &&\n\t    (error = callbacks->push_negotiation((const git_push_update **) push->updates.contents,\n\t\t\t\t\t  push->updates.length, callbacks->payload)) < 0)\n\t    goto on_error;\n\n\tif ((error = queue_objects(push)) < 0 ||\n\t    (error = transport->push(transport, push, callbacks)) < 0)\n\t\tgoto on_error;\n\non_error:\n\tgit_packbuilder_free(push->pb);\n\treturn error;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int do_push(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tint error = 0;\n\tgit_transport *transport = push->remote->transport;\n\n\tif (!transport->push) {\n\t\tgiterr_set(GITERR_NET, \"Remote transport doesn't support push\");\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\t/*\n\t * A pack-file MUST be sent if either create or update command\n\t * is used, even if the server already has all the necessary\n\t * objects.  In this case the client MUST send an empty pack-file.\n\t */\n\n\tif ((error = git_packbuilder_new(&push->pb, push->repo)) < 0)\n\t\tgoto on_error;\n\n\tgit_packbuilder_set_threads(push->pb, push->pb_parallelism);\n\n\tif (callbacks && callbacks->pack_progress)\n\t\tif ((error = git_packbuilder_set_callbacks(push->pb, callbacks->pack_progress, callbacks->payload)) < 0)\n\t\t\tgoto on_error;\n\n\tif ((error = calculate_work(push)) < 0)\n\t\tgoto on_error;\n\n\tif (callbacks && callbacks->push_negotiation &&\n\t    (error = callbacks->push_negotiation((const git_push_update **) push->updates.contents,\n\t\t\t\t\t  push->updates.length, callbacks->payload)) < 0)\n\t    goto on_error;\n\n\tif ((error = queue_objects(push)) < 0 ||\n\t    (error = transport->push(transport, push, callbacks)) < 0)\n\t\tgoto on_error;\n\non_error:\n\tgit_packbuilder_free(push->pb);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_refs",
          "args": [
            "push->remote"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "filter_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "619-635",
          "snippet": "static int filter_refs(git_remote *remote)\n{\n\tconst git_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tgit_vector_clear(&remote->refs);\n\n\tif (git_remote_ls(&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(&remote->refs, (void *)heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int filter_refs(git_remote *remote)\n{\n\tconst git_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tgit_vector_clear(&remote->refs);\n\n\tif (git_remote_ls(&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(&remote->refs, (void *)heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_connect",
          "args": [
            "push->remote",
            "GIT_DIRECTION_PUSH",
            "callbacks",
            "push->custom_headers"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "698-755",
          "snippet": "int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
            "char *apply_insteadof(git_config *config, const char *url, int direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nint git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_connected",
          "args": [
            "push->remote"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_connected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1615-1624",
          "snippet": "int git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_finish(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tint error;\n\n\tif (!git_remote_connected(push->remote) &&\n\t    (error = git_remote_connect(push->remote, GIT_DIRECTION_PUSH, callbacks, push->custom_headers)) < 0)\n\t\treturn error;\n\n\tif ((error = filter_refs(push->remote)) < 0 ||\n\t    (error = do_push(push, callbacks)) < 0)\n\t\treturn error;\n\n\tif (!push->unpack_ok) {\n\t\terror = -1;\n\t\tgiterr_set(GITERR_NET, \"unpacking the sent packfile failed on the remote\");\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "filter_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "619-635",
    "snippet": "static int filter_refs(git_remote *remote)\n{\n\tconst git_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tgit_vector_clear(&remote->refs);\n\n\tif (git_remote_ls(&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(&remote->refs, (void *)heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&remote->refs",
            "(void *)heads[i]"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_ls",
          "args": [
            "&heads",
            "&heads_len",
            "remote"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "757-767",
          "snippet": "int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&remote->refs"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int filter_refs(git_remote *remote)\n{\n\tconst git_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tgit_vector_clear(&remote->refs);\n\n\tif (git_remote_ls(&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(&remote->refs, (void *)heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "576-617",
    "snippet": "static int do_push(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tint error = 0;\n\tgit_transport *transport = push->remote->transport;\n\n\tif (!transport->push) {\n\t\tgiterr_set(GITERR_NET, \"Remote transport doesn't support push\");\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\t/*\n\t * A pack-file MUST be sent if either create or update command\n\t * is used, even if the server already has all the necessary\n\t * objects.  In this case the client MUST send an empty pack-file.\n\t */\n\n\tif ((error = git_packbuilder_new(&push->pb, push->repo)) < 0)\n\t\tgoto on_error;\n\n\tgit_packbuilder_set_threads(push->pb, push->pb_parallelism);\n\n\tif (callbacks && callbacks->pack_progress)\n\t\tif ((error = git_packbuilder_set_callbacks(push->pb, callbacks->pack_progress, callbacks->payload)) < 0)\n\t\t\tgoto on_error;\n\n\tif ((error = calculate_work(push)) < 0)\n\t\tgoto on_error;\n\n\tif (callbacks && callbacks->push_negotiation &&\n\t    (error = callbacks->push_negotiation((const git_push_update **) push->updates.contents,\n\t\t\t\t\t  push->updates.length, callbacks->payload)) < 0)\n\t    goto on_error;\n\n\tif ((error = queue_objects(push)) < 0 ||\n\t    (error = transport->push(transport, push, callbacks)) < 0)\n\t\tgoto on_error;\n\non_error:\n\tgit_packbuilder_free(push->pb);\n\treturn error;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_packbuilder_free",
          "args": [
            "push->pb"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1726-1755",
          "snippet": "void git_packbuilder_free(git_packbuilder *pb)\n{\n\tif (pb == NULL)\n\t\treturn;\n\n#ifdef GIT_THREADS\n\n\tgit_mutex_free(&pb->cache_mutex);\n\tgit_mutex_free(&pb->progress_mutex);\n\tgit_cond_free(&pb->progress_cond);\n\n#endif\n\n\tif (pb->odb)\n\t\tgit_odb_free(pb->odb);\n\n\tif (pb->object_ix)\n\t\tgit_oidmap_free(pb->object_ix);\n\n\tif (pb->object_list)\n\t\tgit__free(pb->object_list);\n\n\tgit_oidmap_free(pb->walk_objects);\n\tgit_pool_clear(&pb->object_pool);\n\n\tgit_hash_ctx_cleanup(&pb->ctx);\n\tgit_zstream_free(&pb->zstream);\n\n\tgit__free(pb);\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nvoid git_packbuilder_free(git_packbuilder *pb)\n{\n\tif (pb == NULL)\n\t\treturn;\n\n#ifdef GIT_THREADS\n\n\tgit_mutex_free(&pb->cache_mutex);\n\tgit_mutex_free(&pb->progress_mutex);\n\tgit_cond_free(&pb->progress_cond);\n\n#endif\n\n\tif (pb->odb)\n\t\tgit_odb_free(pb->odb);\n\n\tif (pb->object_ix)\n\t\tgit_oidmap_free(pb->object_ix);\n\n\tif (pb->object_list)\n\t\tgit__free(pb->object_list);\n\n\tgit_oidmap_free(pb->walk_objects);\n\tgit_pool_clear(&pb->object_pool);\n\n\tgit_hash_ctx_cleanup(&pb->ctx);\n\tgit_zstream_free(&pb->zstream);\n\n\tgit__free(pb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "transport->push",
          "args": [
            "transport",
            "push",
            "callbacks"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_objects",
          "args": [
            "push"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "queue_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "453-524",
          "snippet": "static int queue_objects(git_push *push)\n{\n\tgit_vector commits = GIT_VECTOR_INIT;\n\tgit_oid *oid;\n\tsize_t i;\n\tunsigned j;\n\tint error;\n\n\tif ((error = revwalk(&commits, push)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&commits, i, oid) {\n\t\tgit_commit *parent = NULL, *commit;\n\t\tgit_tree *tree = NULL, *ptree = NULL;\n\t\tsize_t parentcount;\n\n\t\tif ((error = git_commit_lookup(&commit,\tpush->repo, oid)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Insert the commit */\n\t\tif ((error = git_packbuilder_insert(push->pb, oid, NULL)) < 0)\n\t\t\tgoto loop_error;\n\n\t\tparentcount = git_commit_parentcount(commit);\n\n\t\tif (!parentcount) {\n\t\t\tif ((error = git_packbuilder_insert_tree(push->pb,\n\t\t\t\tgit_commit_tree_id(commit))) < 0)\n\t\t\t\tgoto loop_error;\n\t\t} else {\n\t\t\tif ((error = git_tree_lookup(&tree, push->repo,\n\t\t\t\t\tgit_commit_tree_id(commit))) < 0 ||\n\t\t\t\t(error = git_packbuilder_insert(push->pb,\n\t\t\t\t\tgit_commit_tree_id(commit), NULL)) < 0)\n\t\t\t\tgoto loop_error;\n\n\t\t\t/* For each parent, add the items which are different */\n\t\t\tfor (j = 0; j < parentcount; j++) {\n\t\t\t\tif ((error = git_commit_parent(&parent, commit, j)) < 0 ||\n\t\t\t\t\t(error = git_commit_tree(&ptree, parent)) < 0 ||\n\t\t\t\t\t(error = queue_differences(ptree, tree, push->pb)) < 0)\n\t\t\t\t\tgoto loop_error;\n\n\t\t\t\tgit_tree_free(ptree); ptree = NULL;\n\t\t\t\tgit_commit_free(parent); parent = NULL;\n\t\t\t}\n\t\t}\n\n\t\terror = 0;\n\n\tloop_error:\n\t\tif (tree)\n\t\t\tgit_tree_free(tree);\n\n\t\tif (ptree)\n\t\t\tgit_tree_free(ptree);\n\n\t\tif (parent)\n\t\t\tgit_commit_free(parent);\n\n\t\tgit_commit_free(commit);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tgit_vector_free_deep(&commits);\n\treturn error;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int queue_objects(git_push *push)\n{\n\tgit_vector commits = GIT_VECTOR_INIT;\n\tgit_oid *oid;\n\tsize_t i;\n\tunsigned j;\n\tint error;\n\n\tif ((error = revwalk(&commits, push)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&commits, i, oid) {\n\t\tgit_commit *parent = NULL, *commit;\n\t\tgit_tree *tree = NULL, *ptree = NULL;\n\t\tsize_t parentcount;\n\n\t\tif ((error = git_commit_lookup(&commit,\tpush->repo, oid)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Insert the commit */\n\t\tif ((error = git_packbuilder_insert(push->pb, oid, NULL)) < 0)\n\t\t\tgoto loop_error;\n\n\t\tparentcount = git_commit_parentcount(commit);\n\n\t\tif (!parentcount) {\n\t\t\tif ((error = git_packbuilder_insert_tree(push->pb,\n\t\t\t\tgit_commit_tree_id(commit))) < 0)\n\t\t\t\tgoto loop_error;\n\t\t} else {\n\t\t\tif ((error = git_tree_lookup(&tree, push->repo,\n\t\t\t\t\tgit_commit_tree_id(commit))) < 0 ||\n\t\t\t\t(error = git_packbuilder_insert(push->pb,\n\t\t\t\t\tgit_commit_tree_id(commit), NULL)) < 0)\n\t\t\t\tgoto loop_error;\n\n\t\t\t/* For each parent, add the items which are different */\n\t\t\tfor (j = 0; j < parentcount; j++) {\n\t\t\t\tif ((error = git_commit_parent(&parent, commit, j)) < 0 ||\n\t\t\t\t\t(error = git_commit_tree(&ptree, parent)) < 0 ||\n\t\t\t\t\t(error = queue_differences(ptree, tree, push->pb)) < 0)\n\t\t\t\t\tgoto loop_error;\n\n\t\t\t\tgit_tree_free(ptree); ptree = NULL;\n\t\t\t\tgit_commit_free(parent); parent = NULL;\n\t\t\t}\n\t\t}\n\n\t\terror = 0;\n\n\tloop_error:\n\t\tif (tree)\n\t\t\tgit_tree_free(tree);\n\n\t\tif (ptree)\n\t\t\tgit_tree_free(ptree);\n\n\t\tif (parent)\n\t\t\tgit_commit_free(parent);\n\n\t\tgit_commit_free(commit);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tgit_vector_free_deep(&commits);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "callbacks->push_negotiation",
          "args": [
            "(const git_push_update **) push->updates.contents",
            "push->updates.length",
            "callbacks->payload"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_work",
          "args": [
            "push"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "543-574",
          "snippet": "static int calculate_work(git_push *push)\n{\n\tgit_remote_head *head;\n\tpush_spec *spec;\n\tunsigned int i, j;\n\n\t/* Update local and remote oids*/\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tif (spec->refspec.src && spec->refspec.src[0]!= '\\0') {\n\t\t\t/* This is a create or update.  Local ref must exist. */\n\t\t\tif (git_reference_name_to_id(\n\t\t\t\t\t&spec->loid, push->repo, spec->refspec.src) < 0) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE, \"No such reference '%s'\", spec->refspec.src);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* Remote ref may or may not (e.g. during create) already exist. */\n\t\tgit_vector_foreach(&push->remote->refs, j, head) {\n\t\t\tif (!strcmp(spec->refspec.dst, head->name)) {\n\t\t\t\tgit_oid_cpy(&spec->roid, &head->oid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (add_update(push, spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int calculate_work(git_push *push)\n{\n\tgit_remote_head *head;\n\tpush_spec *spec;\n\tunsigned int i, j;\n\n\t/* Update local and remote oids*/\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tif (spec->refspec.src && spec->refspec.src[0]!= '\\0') {\n\t\t\t/* This is a create or update.  Local ref must exist. */\n\t\t\tif (git_reference_name_to_id(\n\t\t\t\t\t&spec->loid, push->repo, spec->refspec.src) < 0) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE, \"No such reference '%s'\", spec->refspec.src);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* Remote ref may or may not (e.g. during create) already exist. */\n\t\tgit_vector_foreach(&push->remote->refs, j, head) {\n\t\t\tif (!strcmp(spec->refspec.dst, head->name)) {\n\t\t\t\tgit_oid_cpy(&spec->roid, &head->oid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (add_update(push, spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packbuilder_set_callbacks",
          "args": [
            "push->pb",
            "callbacks->pack_progress",
            "callbacks->payload"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_set_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1715-1724",
          "snippet": "int git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)\n{\n\tif (!pb)\n\t\treturn -1;\n\n\tpb->progress_cb = progress_cb;\n\tpb->progress_cb_payload = progress_cb_payload;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)\n{\n\tif (!pb)\n\t\treturn -1;\n\n\tpb->progress_cb = progress_cb;\n\tpb->progress_cb_payload = progress_cb_payload;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packbuilder_set_threads",
          "args": [
            "push->pb",
            "push->pb_parallelism"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_set_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "172-184",
          "snippet": "unsigned int git_packbuilder_set_threads(git_packbuilder *pb, unsigned int n)\n{\n\tassert(pb);\n\n#ifdef GIT_THREADS\n\tpb->nr_threads = n;\n#else\n\tGIT_UNUSED(n);\n\tassert(1 == pb->nr_threads);\n#endif\n\n\treturn pb->nr_threads;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nunsigned int git_packbuilder_set_threads(git_packbuilder *pb, unsigned int n)\n{\n\tassert(pb);\n\n#ifdef GIT_THREADS\n\tpb->nr_threads = n;\n#else\n\tGIT_UNUSED(n);\n\tassert(1 == pb->nr_threads);\n#endif\n\n\treturn pb->nr_threads;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packbuilder_new",
          "args": [
            "&push->pb",
            "push->repo"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "124-170",
          "snippet": "int git_packbuilder_new(git_packbuilder **out, git_repository *repo)\n{\n\tgit_packbuilder *pb;\n\n\t*out = NULL;\n\n\tpb = git__calloc(1, sizeof(*pb));\n\tGITERR_CHECK_ALLOC(pb);\n\n\tpb->object_ix = git_oidmap_alloc();\n\tif (!pb->object_ix)\n\t\tgoto on_error;\n\n\tpb->walk_objects = git_oidmap_alloc();\n\tif (!pb->walk_objects)\n\t\tgoto on_error;\n\n\tgit_pool_init(&pb->object_pool, sizeof(git_walk_object));\n\n\tpb->repo = repo;\n\tpb->nr_threads = 1; /* do not spawn any thread by default */\n\n\tif (git_hash_ctx_init(&pb->ctx) < 0 ||\n\t\tgit_zstream_init(&pb->zstream) < 0 ||\n\t\tgit_repository_odb(&pb->odb, repo) < 0 ||\n\t\tpackbuilder_config(pb) < 0)\n\t\tgoto on_error;\n\n#ifdef GIT_THREADS\n\n\tif (git_mutex_init(&pb->cache_mutex) ||\n\t\tgit_mutex_init(&pb->progress_mutex) ||\n\t\tgit_cond_init(&pb->progress_cond))\n\t{\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize packbuilder mutex\");\n\t\tgoto on_error;\n\t}\n\n#endif\n\n\t*out = pb;\n\treturn 0;\n\non_error:\n\tgit_packbuilder_free(pb);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_new(git_packbuilder **out, git_repository *repo)\n{\n\tgit_packbuilder *pb;\n\n\t*out = NULL;\n\n\tpb = git__calloc(1, sizeof(*pb));\n\tGITERR_CHECK_ALLOC(pb);\n\n\tpb->object_ix = git_oidmap_alloc();\n\tif (!pb->object_ix)\n\t\tgoto on_error;\n\n\tpb->walk_objects = git_oidmap_alloc();\n\tif (!pb->walk_objects)\n\t\tgoto on_error;\n\n\tgit_pool_init(&pb->object_pool, sizeof(git_walk_object));\n\n\tpb->repo = repo;\n\tpb->nr_threads = 1; /* do not spawn any thread by default */\n\n\tif (git_hash_ctx_init(&pb->ctx) < 0 ||\n\t\tgit_zstream_init(&pb->zstream) < 0 ||\n\t\tgit_repository_odb(&pb->odb, repo) < 0 ||\n\t\tpackbuilder_config(pb) < 0)\n\t\tgoto on_error;\n\n#ifdef GIT_THREADS\n\n\tif (git_mutex_init(&pb->cache_mutex) ||\n\t\tgit_mutex_init(&pb->progress_mutex) ||\n\t\tgit_cond_init(&pb->progress_cond))\n\t{\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize packbuilder mutex\");\n\t\tgoto on_error;\n\t}\n\n#endif\n\n\t*out = pb;\n\treturn 0;\n\non_error:\n\tgit_packbuilder_free(pb);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Remote transport doesn't support push\""
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int do_push(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tint error = 0;\n\tgit_transport *transport = push->remote->transport;\n\n\tif (!transport->push) {\n\t\tgiterr_set(GITERR_NET, \"Remote transport doesn't support push\");\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\t/*\n\t * A pack-file MUST be sent if either create or update command\n\t * is used, even if the server already has all the necessary\n\t * objects.  In this case the client MUST send an empty pack-file.\n\t */\n\n\tif ((error = git_packbuilder_new(&push->pb, push->repo)) < 0)\n\t\tgoto on_error;\n\n\tgit_packbuilder_set_threads(push->pb, push->pb_parallelism);\n\n\tif (callbacks && callbacks->pack_progress)\n\t\tif ((error = git_packbuilder_set_callbacks(push->pb, callbacks->pack_progress, callbacks->payload)) < 0)\n\t\t\tgoto on_error;\n\n\tif ((error = calculate_work(push)) < 0)\n\t\tgoto on_error;\n\n\tif (callbacks && callbacks->push_negotiation &&\n\t    (error = callbacks->push_negotiation((const git_push_update **) push->updates.contents,\n\t\t\t\t\t  push->updates.length, callbacks->payload)) < 0)\n\t    goto on_error;\n\n\tif ((error = queue_objects(push)) < 0 ||\n\t    (error = transport->push(transport, push, callbacks)) < 0)\n\t\tgoto on_error;\n\non_error:\n\tgit_packbuilder_free(push->pb);\n\treturn error;\n}"
  },
  {
    "function_name": "calculate_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "543-574",
    "snippet": "static int calculate_work(git_push *push)\n{\n\tgit_remote_head *head;\n\tpush_spec *spec;\n\tunsigned int i, j;\n\n\t/* Update local and remote oids*/\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tif (spec->refspec.src && spec->refspec.src[0]!= '\\0') {\n\t\t\t/* This is a create or update.  Local ref must exist. */\n\t\t\tif (git_reference_name_to_id(\n\t\t\t\t\t&spec->loid, push->repo, spec->refspec.src) < 0) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE, \"No such reference '%s'\", spec->refspec.src);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* Remote ref may or may not (e.g. during create) already exist. */\n\t\tgit_vector_foreach(&push->remote->refs, j, head) {\n\t\t\tif (!strcmp(spec->refspec.dst, head->name)) {\n\t\t\t\tgit_oid_cpy(&spec->roid, &head->oid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (add_update(push, spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_update",
          "args": [
            "push",
            "spec"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "add_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "526-541",
          "snippet": "static int add_update(git_push *push, push_spec *spec)\n{\n\tgit_push_update *u = git__calloc(1, sizeof(git_push_update));\n\tGITERR_CHECK_ALLOC(u);\n\n\tu->src_refname = git__strdup(spec->refspec.src);\n\tGITERR_CHECK_ALLOC(u->src_refname);\n\n\tu->dst_refname = git__strdup(spec->refspec.dst);\n\tGITERR_CHECK_ALLOC(u->dst_refname);\n\n\tgit_oid_cpy(&u->src, &spec->roid);\n\tgit_oid_cpy(&u->dst, &spec->loid);\n\n\treturn git_vector_insert(&push->updates, u);\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int add_update(git_push *push, push_spec *spec)\n{\n\tgit_push_update *u = git__calloc(1, sizeof(git_push_update));\n\tGITERR_CHECK_ALLOC(u);\n\n\tu->src_refname = git__strdup(spec->refspec.src);\n\tGITERR_CHECK_ALLOC(u->src_refname);\n\n\tu->dst_refname = git__strdup(spec->refspec.dst);\n\tGITERR_CHECK_ALLOC(u->dst_refname);\n\n\tgit_oid_cpy(&u->src, &spec->roid);\n\tgit_oid_cpy(&u->dst, &spec->loid);\n\n\treturn git_vector_insert(&push->updates, u);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&spec->roid",
            "&head->oid"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "spec->refspec.dst",
            "head->name"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->remote->refs",
            "j",
            "head"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"No such reference '%s'\"",
            "spec->refspec.src"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name_to_id",
          "args": [
            "&spec->loid",
            "push->repo",
            "spec->refspec.src"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name_to_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "152-164",
          "snippet": "int git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->specs",
            "i",
            "spec"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int calculate_work(git_push *push)\n{\n\tgit_remote_head *head;\n\tpush_spec *spec;\n\tunsigned int i, j;\n\n\t/* Update local and remote oids*/\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tif (spec->refspec.src && spec->refspec.src[0]!= '\\0') {\n\t\t\t/* This is a create or update.  Local ref must exist. */\n\t\t\tif (git_reference_name_to_id(\n\t\t\t\t\t&spec->loid, push->repo, spec->refspec.src) < 0) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE, \"No such reference '%s'\", spec->refspec.src);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* Remote ref may or may not (e.g. during create) already exist. */\n\t\tgit_vector_foreach(&push->remote->refs, j, head) {\n\t\t\tif (!strcmp(spec->refspec.dst, head->name)) {\n\t\t\t\tgit_oid_cpy(&spec->roid, &head->oid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (add_update(push, spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "526-541",
    "snippet": "static int add_update(git_push *push, push_spec *spec)\n{\n\tgit_push_update *u = git__calloc(1, sizeof(git_push_update));\n\tGITERR_CHECK_ALLOC(u);\n\n\tu->src_refname = git__strdup(spec->refspec.src);\n\tGITERR_CHECK_ALLOC(u->src_refname);\n\n\tu->dst_refname = git__strdup(spec->refspec.dst);\n\tGITERR_CHECK_ALLOC(u->dst_refname);\n\n\tgit_oid_cpy(&u->src, &spec->roid);\n\tgit_oid_cpy(&u->dst, &spec->loid);\n\n\treturn git_vector_insert(&push->updates, u);\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&push->updates",
            "u"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&u->dst",
            "&spec->loid"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "u->dst_refname"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "spec->refspec.dst"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "u->src_refname"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "u"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_push_update)"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int add_update(git_push *push, push_spec *spec)\n{\n\tgit_push_update *u = git__calloc(1, sizeof(git_push_update));\n\tGITERR_CHECK_ALLOC(u);\n\n\tu->src_refname = git__strdup(spec->refspec.src);\n\tGITERR_CHECK_ALLOC(u->src_refname);\n\n\tu->dst_refname = git__strdup(spec->refspec.dst);\n\tGITERR_CHECK_ALLOC(u->dst_refname);\n\n\tgit_oid_cpy(&u->src, &spec->roid);\n\tgit_oid_cpy(&u->dst, &spec->loid);\n\n\treturn git_vector_insert(&push->updates, u);\n}"
  },
  {
    "function_name": "queue_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "453-524",
    "snippet": "static int queue_objects(git_push *push)\n{\n\tgit_vector commits = GIT_VECTOR_INIT;\n\tgit_oid *oid;\n\tsize_t i;\n\tunsigned j;\n\tint error;\n\n\tif ((error = revwalk(&commits, push)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&commits, i, oid) {\n\t\tgit_commit *parent = NULL, *commit;\n\t\tgit_tree *tree = NULL, *ptree = NULL;\n\t\tsize_t parentcount;\n\n\t\tif ((error = git_commit_lookup(&commit,\tpush->repo, oid)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Insert the commit */\n\t\tif ((error = git_packbuilder_insert(push->pb, oid, NULL)) < 0)\n\t\t\tgoto loop_error;\n\n\t\tparentcount = git_commit_parentcount(commit);\n\n\t\tif (!parentcount) {\n\t\t\tif ((error = git_packbuilder_insert_tree(push->pb,\n\t\t\t\tgit_commit_tree_id(commit))) < 0)\n\t\t\t\tgoto loop_error;\n\t\t} else {\n\t\t\tif ((error = git_tree_lookup(&tree, push->repo,\n\t\t\t\t\tgit_commit_tree_id(commit))) < 0 ||\n\t\t\t\t(error = git_packbuilder_insert(push->pb,\n\t\t\t\t\tgit_commit_tree_id(commit), NULL)) < 0)\n\t\t\t\tgoto loop_error;\n\n\t\t\t/* For each parent, add the items which are different */\n\t\t\tfor (j = 0; j < parentcount; j++) {\n\t\t\t\tif ((error = git_commit_parent(&parent, commit, j)) < 0 ||\n\t\t\t\t\t(error = git_commit_tree(&ptree, parent)) < 0 ||\n\t\t\t\t\t(error = queue_differences(ptree, tree, push->pb)) < 0)\n\t\t\t\t\tgoto loop_error;\n\n\t\t\t\tgit_tree_free(ptree); ptree = NULL;\n\t\t\t\tgit_commit_free(parent); parent = NULL;\n\t\t\t}\n\t\t}\n\n\t\terror = 0;\n\n\tloop_error:\n\t\tif (tree)\n\t\t\tgit_tree_free(tree);\n\n\t\tif (ptree)\n\t\t\tgit_tree_free(ptree);\n\n\t\tif (parent)\n\t\t\tgit_commit_free(parent);\n\n\t\tgit_commit_free(commit);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tgit_vector_free_deep(&commits);\n\treturn error;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&commits"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "commit"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "ptree"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_differences",
          "args": [
            "ptree",
            "tree",
            "push->pb"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "queue_differences",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "383-451",
          "snippet": "static int queue_differences(\n\tgit_tree *base,\n\tgit_tree *delta,\n\tgit_packbuilder *pb)\n{\n\tgit_tree *b_child = NULL, *d_child = NULL;\n\tsize_t b_length = git_tree_entrycount(base);\n\tsize_t d_length = git_tree_entrycount(delta);\n\tsize_t i = 0, j = 0;\n\tint error;\n\n\twhile (i < b_length && j < d_length) {\n\t\tconst git_tree_entry *b_entry = git_tree_entry_byindex(base, i);\n\t\tconst git_tree_entry *d_entry = git_tree_entry_byindex(delta, j);\n\t\tint cmp = 0;\n\n\t\tif (!git_oid__cmp(b_entry->oid, d_entry->oid))\n\t\t\tgoto loop;\n\n\t\tcmp = strcmp(b_entry->filename, d_entry->filename);\n\n\t\t/* If the entries are both trees and they have the same name but are\n\t\t * different, then we'll recurse after adding the right-hand entry */\n\t\tif (!cmp &&\n\t\t\tgit_tree_entry__is_tree(b_entry) &&\n\t\t\tgit_tree_entry__is_tree(d_entry)) {\n\t\t\t/* Add the right-hand entry */\n\t\t\tif ((error = git_packbuilder_insert(pb, d_entry->oid,\n\t\t\t\td_entry->filename)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\t/* Acquire the subtrees and recurse */\n\t\t\tif ((error = git_tree_lookup(&b_child,\n\t\t\t\t\tgit_tree_owner(base), b_entry->oid)) < 0 ||\n\t\t\t\t(error = git_tree_lookup(&d_child,\n\t\t\t\t\tgit_tree_owner(delta), d_entry->oid)) < 0 ||\n\t\t\t\t(error = queue_differences(b_child, d_child, pb)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_tree_free(b_child); b_child = NULL;\n\t\t\tgit_tree_free(d_child); d_child = NULL;\n\t\t}\n\t\t/* If the object is new or different in the right-hand tree,\n\t\t * then enumerate it */\n\t\telse if (cmp >= 0 &&\n\t\t\t(error = enqueue_object(d_entry, pb)) < 0)\n\t\t\tgoto on_error;\n\n\tloop:\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\t}\n\n\t/* Drain the right-hand tree of entries */\n\tfor (; j < d_length; j++)\n\t\tif ((error = enqueue_object(git_tree_entry_byindex(delta, j), pb)) < 0)\n\t\t\tgoto on_error;\n\n\terror = 0;\n\non_error:\n\tif (b_child)\n\t\tgit_tree_free(b_child);\n\n\tif (d_child)\n\t\tgit_tree_free(d_child);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int queue_differences(\n\tgit_tree *base,\n\tgit_tree *delta,\n\tgit_packbuilder *pb)\n{\n\tgit_tree *b_child = NULL, *d_child = NULL;\n\tsize_t b_length = git_tree_entrycount(base);\n\tsize_t d_length = git_tree_entrycount(delta);\n\tsize_t i = 0, j = 0;\n\tint error;\n\n\twhile (i < b_length && j < d_length) {\n\t\tconst git_tree_entry *b_entry = git_tree_entry_byindex(base, i);\n\t\tconst git_tree_entry *d_entry = git_tree_entry_byindex(delta, j);\n\t\tint cmp = 0;\n\n\t\tif (!git_oid__cmp(b_entry->oid, d_entry->oid))\n\t\t\tgoto loop;\n\n\t\tcmp = strcmp(b_entry->filename, d_entry->filename);\n\n\t\t/* If the entries are both trees and they have the same name but are\n\t\t * different, then we'll recurse after adding the right-hand entry */\n\t\tif (!cmp &&\n\t\t\tgit_tree_entry__is_tree(b_entry) &&\n\t\t\tgit_tree_entry__is_tree(d_entry)) {\n\t\t\t/* Add the right-hand entry */\n\t\t\tif ((error = git_packbuilder_insert(pb, d_entry->oid,\n\t\t\t\td_entry->filename)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\t/* Acquire the subtrees and recurse */\n\t\t\tif ((error = git_tree_lookup(&b_child,\n\t\t\t\t\tgit_tree_owner(base), b_entry->oid)) < 0 ||\n\t\t\t\t(error = git_tree_lookup(&d_child,\n\t\t\t\t\tgit_tree_owner(delta), d_entry->oid)) < 0 ||\n\t\t\t\t(error = queue_differences(b_child, d_child, pb)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_tree_free(b_child); b_child = NULL;\n\t\t\tgit_tree_free(d_child); d_child = NULL;\n\t\t}\n\t\t/* If the object is new or different in the right-hand tree,\n\t\t * then enumerate it */\n\t\telse if (cmp >= 0 &&\n\t\t\t(error = enqueue_object(d_entry, pb)) < 0)\n\t\t\tgoto on_error;\n\n\tloop:\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\t}\n\n\t/* Drain the right-hand tree of entries */\n\tfor (; j < d_length; j++)\n\t\tif ((error = enqueue_object(git_tree_entry_byindex(delta, j), pb)) < 0)\n\t\t\tgoto on_error;\n\n\terror = 0;\n\non_error:\n\tif (b_child)\n\t\tgit_tree_free(b_child);\n\n\tif (d_child)\n\t\tgit_tree_free(d_child);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&ptree",
            "parent"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parent",
          "args": [
            "&parent",
            "commit",
            "j"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "544-557",
          "snippet": "int git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packbuilder_insert",
          "args": [
            "push->pb",
            "git_commit_tree_id(commit)",
            "NULL"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_insert_recur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1440-1474",
          "snippet": "int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree_id",
          "args": [
            "commit"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_lookup",
          "args": [
            "&tree",
            "push->repo",
            "git_commit_tree_id(commit)"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "49-52",
          "snippet": "int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree_id",
          "args": [
            "commit"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_packbuilder_insert_tree",
          "args": [
            "push->pb",
            "git_commit_tree_id(commit)"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_insert_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1425-1438",
          "snippet": "int git_packbuilder_insert_tree(git_packbuilder *pb, const git_oid *oid)\n{\n\tint error;\n\tgit_tree *tree = NULL;\n\tstruct tree_walk_context context = { pb, GIT_BUF_INIT };\n\n\tif (!(error = git_tree_lookup(&tree, pb->repo, oid)) &&\n\t    !(error = git_packbuilder_insert(pb, oid, NULL)))\n\t\terror = git_tree_walk(tree, GIT_TREEWALK_PRE, cb_tree_walk, &context);\n\n\tgit_tree_free(tree);\n\tgit_buf_free(&context.buf);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_insert_tree(git_packbuilder *pb, const git_oid *oid)\n{\n\tint error;\n\tgit_tree *tree = NULL;\n\tstruct tree_walk_context context = { pb, GIT_BUF_INIT };\n\n\tif (!(error = git_tree_lookup(&tree, pb->repo, oid)) &&\n\t    !(error = git_packbuilder_insert(pb, oid, NULL)))\n\t\terror = git_tree_walk(tree, GIT_TREEWALK_PRE, cb_tree_walk, &context);\n\n\tgit_tree_free(tree);\n\tgit_buf_free(&context.buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree_id",
          "args": [
            "commit"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_parentcount",
          "args": [
            "commit"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_lookup",
          "args": [
            "&commit",
            "push->repo",
            "oid"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "20-23",
          "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&commits",
            "i",
            "oid"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revwalk",
          "args": [
            "&commits",
            "push"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "revwalk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "263-367",
          "snippet": "static int revwalk(git_vector *commits, git_push *push)\n{\n\tgit_remote_head *head;\n\tpush_spec *spec;\n\tgit_revwalk *rw;\n\tgit_oid oid;\n\tunsigned int i;\n\tint error = -1;\n\n\tif (git_revwalk_new(&rw, push->repo) < 0)\n\t\treturn -1;\n\n\tgit_revwalk_sorting(rw, GIT_SORT_TIME);\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tgit_otype type;\n\t\tsize_t size;\n\n\t\tif (git_oid_iszero(&spec->loid))\n\t\t\t/*\n\t\t\t * Delete reference on remote side;\n\t\t\t * nothing to do here.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tif (git_oid_equal(&spec->loid, &spec->roid))\n\t\t\tcontinue; /* up-to-date */\n\n\t\tif (git_odb_read_header(&size, &type, push->repo->_odb, &spec->loid) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (type == GIT_OBJ_TAG) {\n\t\t\tgit_object *target;\n\n\t\t\tif ((error = enqueue_tag(&target, push, &spec->loid)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tif (git_object_type(target) == GIT_OBJ_COMMIT) {\n\t\t\t\tif (git_revwalk_push(rw, git_object_id(target)) < 0) {\n\t\t\t\t\tgit_object_free(target);\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (git_packbuilder_insert(\n\t\t\t\t\tpush->pb, git_object_id(target), NULL) < 0) {\n\t\t\t\t\tgit_object_free(target);\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgit_object_free(target);\n\t\t} else if (git_revwalk_push(rw, &spec->loid) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!spec->refspec.force) {\n\t\t\tgit_oid base;\n\n\t\t\tif (git_oid_iszero(&spec->roid))\n\t\t\t\tcontinue;\n\n\t\t\tif (!git_odb_exists(push->repo->_odb, &spec->roid)) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE, \n\t\t\t\t\t\"Cannot push because a reference that you are trying to update on the remote contains commits that are not present locally.\");\n\t\t\t\terror = GIT_ENONFASTFORWARD;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\terror = git_merge_base(&base, push->repo,\n\t\t\t\t\t       &spec->loid, &spec->roid);\n\n\t\t\tif (error == GIT_ENOTFOUND ||\n\t\t\t\t(!error && !git_oid_equal(&base, &spec->roid))) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Cannot push non-fastforwardable reference\");\n\t\t\t\terror = GIT_ENONFASTFORWARD;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tgit_vector_foreach(&push->remote->refs, i, head) {\n\t\tif (git_oid_iszero(&head->oid))\n\t\t\tcontinue;\n\n\t\t/* TODO */\n\t\tgit_revwalk_hide(rw, &head->oid);\n\t}\n\n\twhile ((error = git_revwalk_next(&oid, rw)) == 0) {\n\t\tgit_oid *o = git__malloc(GIT_OID_RAWSZ);\n\t\tif (!o) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\t\tgit_oid_cpy(o, &oid);\n\t\tif ((error = git_vector_insert(commits, o)) < 0)\n\t\t\tgoto on_error;\n\t}\n\non_error:\n\tgit_revwalk_free(rw);\n\treturn error == GIT_ITEROVER ? 0 : error;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int revwalk(git_vector *commits, git_push *push)\n{\n\tgit_remote_head *head;\n\tpush_spec *spec;\n\tgit_revwalk *rw;\n\tgit_oid oid;\n\tunsigned int i;\n\tint error = -1;\n\n\tif (git_revwalk_new(&rw, push->repo) < 0)\n\t\treturn -1;\n\n\tgit_revwalk_sorting(rw, GIT_SORT_TIME);\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tgit_otype type;\n\t\tsize_t size;\n\n\t\tif (git_oid_iszero(&spec->loid))\n\t\t\t/*\n\t\t\t * Delete reference on remote side;\n\t\t\t * nothing to do here.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tif (git_oid_equal(&spec->loid, &spec->roid))\n\t\t\tcontinue; /* up-to-date */\n\n\t\tif (git_odb_read_header(&size, &type, push->repo->_odb, &spec->loid) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (type == GIT_OBJ_TAG) {\n\t\t\tgit_object *target;\n\n\t\t\tif ((error = enqueue_tag(&target, push, &spec->loid)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tif (git_object_type(target) == GIT_OBJ_COMMIT) {\n\t\t\t\tif (git_revwalk_push(rw, git_object_id(target)) < 0) {\n\t\t\t\t\tgit_object_free(target);\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (git_packbuilder_insert(\n\t\t\t\t\tpush->pb, git_object_id(target), NULL) < 0) {\n\t\t\t\t\tgit_object_free(target);\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgit_object_free(target);\n\t\t} else if (git_revwalk_push(rw, &spec->loid) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!spec->refspec.force) {\n\t\t\tgit_oid base;\n\n\t\t\tif (git_oid_iszero(&spec->roid))\n\t\t\t\tcontinue;\n\n\t\t\tif (!git_odb_exists(push->repo->_odb, &spec->roid)) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE, \n\t\t\t\t\t\"Cannot push because a reference that you are trying to update on the remote contains commits that are not present locally.\");\n\t\t\t\terror = GIT_ENONFASTFORWARD;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\terror = git_merge_base(&base, push->repo,\n\t\t\t\t\t       &spec->loid, &spec->roid);\n\n\t\t\tif (error == GIT_ENOTFOUND ||\n\t\t\t\t(!error && !git_oid_equal(&base, &spec->roid))) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Cannot push non-fastforwardable reference\");\n\t\t\t\terror = GIT_ENONFASTFORWARD;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tgit_vector_foreach(&push->remote->refs, i, head) {\n\t\tif (git_oid_iszero(&head->oid))\n\t\t\tcontinue;\n\n\t\t/* TODO */\n\t\tgit_revwalk_hide(rw, &head->oid);\n\t}\n\n\twhile ((error = git_revwalk_next(&oid, rw)) == 0) {\n\t\tgit_oid *o = git__malloc(GIT_OID_RAWSZ);\n\t\tif (!o) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\t\tgit_oid_cpy(o, &oid);\n\t\tif ((error = git_vector_insert(commits, o)) < 0)\n\t\t\tgoto on_error;\n\t}\n\non_error:\n\tgit_revwalk_free(rw);\n\treturn error == GIT_ITEROVER ? 0 : error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int queue_objects(git_push *push)\n{\n\tgit_vector commits = GIT_VECTOR_INIT;\n\tgit_oid *oid;\n\tsize_t i;\n\tunsigned j;\n\tint error;\n\n\tif ((error = revwalk(&commits, push)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&commits, i, oid) {\n\t\tgit_commit *parent = NULL, *commit;\n\t\tgit_tree *tree = NULL, *ptree = NULL;\n\t\tsize_t parentcount;\n\n\t\tif ((error = git_commit_lookup(&commit,\tpush->repo, oid)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Insert the commit */\n\t\tif ((error = git_packbuilder_insert(push->pb, oid, NULL)) < 0)\n\t\t\tgoto loop_error;\n\n\t\tparentcount = git_commit_parentcount(commit);\n\n\t\tif (!parentcount) {\n\t\t\tif ((error = git_packbuilder_insert_tree(push->pb,\n\t\t\t\tgit_commit_tree_id(commit))) < 0)\n\t\t\t\tgoto loop_error;\n\t\t} else {\n\t\t\tif ((error = git_tree_lookup(&tree, push->repo,\n\t\t\t\t\tgit_commit_tree_id(commit))) < 0 ||\n\t\t\t\t(error = git_packbuilder_insert(push->pb,\n\t\t\t\t\tgit_commit_tree_id(commit), NULL)) < 0)\n\t\t\t\tgoto loop_error;\n\n\t\t\t/* For each parent, add the items which are different */\n\t\t\tfor (j = 0; j < parentcount; j++) {\n\t\t\t\tif ((error = git_commit_parent(&parent, commit, j)) < 0 ||\n\t\t\t\t\t(error = git_commit_tree(&ptree, parent)) < 0 ||\n\t\t\t\t\t(error = queue_differences(ptree, tree, push->pb)) < 0)\n\t\t\t\t\tgoto loop_error;\n\n\t\t\t\tgit_tree_free(ptree); ptree = NULL;\n\t\t\t\tgit_commit_free(parent); parent = NULL;\n\t\t\t}\n\t\t}\n\n\t\terror = 0;\n\n\tloop_error:\n\t\tif (tree)\n\t\t\tgit_tree_free(tree);\n\n\t\tif (ptree)\n\t\t\tgit_tree_free(ptree);\n\n\t\tif (parent)\n\t\t\tgit_commit_free(parent);\n\n\t\tgit_commit_free(commit);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\t}\n\n\terror = 0;\n\non_error:\n\tgit_vector_free_deep(&commits);\n\treturn error;\n}"
  },
  {
    "function_name": "queue_differences",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "383-451",
    "snippet": "static int queue_differences(\n\tgit_tree *base,\n\tgit_tree *delta,\n\tgit_packbuilder *pb)\n{\n\tgit_tree *b_child = NULL, *d_child = NULL;\n\tsize_t b_length = git_tree_entrycount(base);\n\tsize_t d_length = git_tree_entrycount(delta);\n\tsize_t i = 0, j = 0;\n\tint error;\n\n\twhile (i < b_length && j < d_length) {\n\t\tconst git_tree_entry *b_entry = git_tree_entry_byindex(base, i);\n\t\tconst git_tree_entry *d_entry = git_tree_entry_byindex(delta, j);\n\t\tint cmp = 0;\n\n\t\tif (!git_oid__cmp(b_entry->oid, d_entry->oid))\n\t\t\tgoto loop;\n\n\t\tcmp = strcmp(b_entry->filename, d_entry->filename);\n\n\t\t/* If the entries are both trees and they have the same name but are\n\t\t * different, then we'll recurse after adding the right-hand entry */\n\t\tif (!cmp &&\n\t\t\tgit_tree_entry__is_tree(b_entry) &&\n\t\t\tgit_tree_entry__is_tree(d_entry)) {\n\t\t\t/* Add the right-hand entry */\n\t\t\tif ((error = git_packbuilder_insert(pb, d_entry->oid,\n\t\t\t\td_entry->filename)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\t/* Acquire the subtrees and recurse */\n\t\t\tif ((error = git_tree_lookup(&b_child,\n\t\t\t\t\tgit_tree_owner(base), b_entry->oid)) < 0 ||\n\t\t\t\t(error = git_tree_lookup(&d_child,\n\t\t\t\t\tgit_tree_owner(delta), d_entry->oid)) < 0 ||\n\t\t\t\t(error = queue_differences(b_child, d_child, pb)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_tree_free(b_child); b_child = NULL;\n\t\t\tgit_tree_free(d_child); d_child = NULL;\n\t\t}\n\t\t/* If the object is new or different in the right-hand tree,\n\t\t * then enumerate it */\n\t\telse if (cmp >= 0 &&\n\t\t\t(error = enqueue_object(d_entry, pb)) < 0)\n\t\t\tgoto on_error;\n\n\tloop:\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\t}\n\n\t/* Drain the right-hand tree of entries */\n\tfor (; j < d_length; j++)\n\t\tif ((error = enqueue_object(git_tree_entry_byindex(delta, j), pb)) < 0)\n\t\t\tgoto on_error;\n\n\terror = 0;\n\non_error:\n\tif (b_child)\n\t\tgit_tree_free(b_child);\n\n\tif (d_child)\n\t\tgit_tree_free(d_child);\n\n\treturn error;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "d_child"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_object",
          "args": [
            "git_tree_entry_byindex(delta, j)",
            "pb"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "369-381",
          "snippet": "static int enqueue_object(\n\tconst git_tree_entry *entry,\n\tgit_packbuilder *pb)\n{\n\tswitch (git_tree_entry_type(entry)) {\n\t\tcase GIT_OBJ_COMMIT:\n\t\t\treturn 0;\n\t\tcase GIT_OBJ_TREE:\n\t\t\treturn git_packbuilder_insert_tree(pb, entry->oid);\n\t\tdefault:\n\t\t\treturn git_packbuilder_insert(pb, entry->oid, entry->filename);\n\t}\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int enqueue_object(\n\tconst git_tree_entry *entry,\n\tgit_packbuilder *pb)\n{\n\tswitch (git_tree_entry_type(entry)) {\n\t\tcase GIT_OBJ_COMMIT:\n\t\t\treturn 0;\n\t\tcase GIT_OBJ_TREE:\n\t\t\treturn git_packbuilder_insert_tree(pb, entry->oid);\n\t\tdefault:\n\t\t\treturn git_packbuilder_insert(pb, entry->oid, entry->filename);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_byindex",
          "args": [
            "delta",
            "j"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "324-329",
          "snippet": "const git_tree_entry *git_tree_entry_byindex(\n\tconst git_tree *tree, size_t idx)\n{\n\tassert(tree);\n\treturn git_array_get(tree->entries, idx);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst git_tree_entry *git_tree_entry_byindex(\n\tconst git_tree *tree, size_t idx)\n{\n\tassert(tree);\n\treturn git_array_get(tree->entries, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_differences",
          "args": [
            "b_child",
            "d_child",
            "pb"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "queue_differences",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "383-451",
          "snippet": "static int queue_differences(\n\tgit_tree *base,\n\tgit_tree *delta,\n\tgit_packbuilder *pb)\n{\n\tgit_tree *b_child = NULL, *d_child = NULL;\n\tsize_t b_length = git_tree_entrycount(base);\n\tsize_t d_length = git_tree_entrycount(delta);\n\tsize_t i = 0, j = 0;\n\tint error;\n\n\twhile (i < b_length && j < d_length) {\n\t\tconst git_tree_entry *b_entry = git_tree_entry_byindex(base, i);\n\t\tconst git_tree_entry *d_entry = git_tree_entry_byindex(delta, j);\n\t\tint cmp = 0;\n\n\t\tif (!git_oid__cmp(b_entry->oid, d_entry->oid))\n\t\t\tgoto loop;\n\n\t\tcmp = strcmp(b_entry->filename, d_entry->filename);\n\n\t\t/* If the entries are both trees and they have the same name but are\n\t\t * different, then we'll recurse after adding the right-hand entry */\n\t\tif (!cmp &&\n\t\t\tgit_tree_entry__is_tree(b_entry) &&\n\t\t\tgit_tree_entry__is_tree(d_entry)) {\n\t\t\t/* Add the right-hand entry */\n\t\t\tif ((error = git_packbuilder_insert(pb, d_entry->oid,\n\t\t\t\td_entry->filename)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\t/* Acquire the subtrees and recurse */\n\t\t\tif ((error = git_tree_lookup(&b_child,\n\t\t\t\t\tgit_tree_owner(base), b_entry->oid)) < 0 ||\n\t\t\t\t(error = git_tree_lookup(&d_child,\n\t\t\t\t\tgit_tree_owner(delta), d_entry->oid)) < 0 ||\n\t\t\t\t(error = queue_differences(b_child, d_child, pb)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_tree_free(b_child); b_child = NULL;\n\t\t\tgit_tree_free(d_child); d_child = NULL;\n\t\t}\n\t\t/* If the object is new or different in the right-hand tree,\n\t\t * then enumerate it */\n\t\telse if (cmp >= 0 &&\n\t\t\t(error = enqueue_object(d_entry, pb)) < 0)\n\t\t\tgoto on_error;\n\n\tloop:\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\t}\n\n\t/* Drain the right-hand tree of entries */\n\tfor (; j < d_length; j++)\n\t\tif ((error = enqueue_object(git_tree_entry_byindex(delta, j), pb)) < 0)\n\t\t\tgoto on_error;\n\n\terror = 0;\n\non_error:\n\tif (b_child)\n\t\tgit_tree_free(b_child);\n\n\tif (d_child)\n\t\tgit_tree_free(d_child);\n\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_lookup",
          "args": [
            "&d_child",
            "git_tree_owner(delta)",
            "d_entry->oid"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "49-52",
          "snippet": "int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_owner",
          "args": [
            "delta"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "69-72",
          "snippet": "git_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packbuilder_insert",
          "args": [
            "pb",
            "d_entry->oid",
            "d_entry->filename"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_insert_recur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1440-1474",
          "snippet": "int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry__is_tree",
          "args": [
            "d_entry"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry__is_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.h",
          "lines": "35-38",
          "snippet": "GIT_INLINE(bool) git_tree_entry__is_tree(const struct git_tree_entry *e)\n{\n\treturn (S_ISDIR(e->attr) && !S_ISGITLINK(e->attr));\n}",
          "includes": [
            "#include \"pool.h\"",
            "#include \"strmap.h\"",
            "#include \"vector.h\"",
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"git2/tree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pool.h\"\n#include \"strmap.h\"\n#include \"vector.h\"\n#include \"odb.h\"\n#include \"repository.h\"\n#include \"git2/tree.h\"\n\nGIT_INLINE(bool) git_tree_entry__is_tree(const struct git_tree_entry *e)\n{\n\treturn (S_ISDIR(e->attr) && !S_ISGITLINK(e->attr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "b_entry->filename",
            "d_entry->filename"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "b_entry->oid",
            "d_entry->oid"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entrycount",
          "args": [
            "delta"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "382-386",
          "snippet": "size_t git_tree_entrycount(const git_tree *tree)\n{\n\tassert(tree);\n\treturn tree->entries.size;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nsize_t git_tree_entrycount(const git_tree *tree)\n{\n\tassert(tree);\n\treturn tree->entries.size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int queue_differences(\n\tgit_tree *base,\n\tgit_tree *delta,\n\tgit_packbuilder *pb)\n{\n\tgit_tree *b_child = NULL, *d_child = NULL;\n\tsize_t b_length = git_tree_entrycount(base);\n\tsize_t d_length = git_tree_entrycount(delta);\n\tsize_t i = 0, j = 0;\n\tint error;\n\n\twhile (i < b_length && j < d_length) {\n\t\tconst git_tree_entry *b_entry = git_tree_entry_byindex(base, i);\n\t\tconst git_tree_entry *d_entry = git_tree_entry_byindex(delta, j);\n\t\tint cmp = 0;\n\n\t\tif (!git_oid__cmp(b_entry->oid, d_entry->oid))\n\t\t\tgoto loop;\n\n\t\tcmp = strcmp(b_entry->filename, d_entry->filename);\n\n\t\t/* If the entries are both trees and they have the same name but are\n\t\t * different, then we'll recurse after adding the right-hand entry */\n\t\tif (!cmp &&\n\t\t\tgit_tree_entry__is_tree(b_entry) &&\n\t\t\tgit_tree_entry__is_tree(d_entry)) {\n\t\t\t/* Add the right-hand entry */\n\t\t\tif ((error = git_packbuilder_insert(pb, d_entry->oid,\n\t\t\t\td_entry->filename)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\t/* Acquire the subtrees and recurse */\n\t\t\tif ((error = git_tree_lookup(&b_child,\n\t\t\t\t\tgit_tree_owner(base), b_entry->oid)) < 0 ||\n\t\t\t\t(error = git_tree_lookup(&d_child,\n\t\t\t\t\tgit_tree_owner(delta), d_entry->oid)) < 0 ||\n\t\t\t\t(error = queue_differences(b_child, d_child, pb)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_tree_free(b_child); b_child = NULL;\n\t\t\tgit_tree_free(d_child); d_child = NULL;\n\t\t}\n\t\t/* If the object is new or different in the right-hand tree,\n\t\t * then enumerate it */\n\t\telse if (cmp >= 0 &&\n\t\t\t(error = enqueue_object(d_entry, pb)) < 0)\n\t\t\tgoto on_error;\n\n\tloop:\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\t}\n\n\t/* Drain the right-hand tree of entries */\n\tfor (; j < d_length; j++)\n\t\tif ((error = enqueue_object(git_tree_entry_byindex(delta, j), pb)) < 0)\n\t\t\tgoto on_error;\n\n\terror = 0;\n\non_error:\n\tif (b_child)\n\t\tgit_tree_free(b_child);\n\n\tif (d_child)\n\t\tgit_tree_free(d_child);\n\n\treturn error;\n}"
  },
  {
    "function_name": "enqueue_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "369-381",
    "snippet": "static int enqueue_object(\n\tconst git_tree_entry *entry,\n\tgit_packbuilder *pb)\n{\n\tswitch (git_tree_entry_type(entry)) {\n\t\tcase GIT_OBJ_COMMIT:\n\t\t\treturn 0;\n\t\tcase GIT_OBJ_TREE:\n\t\t\treturn git_packbuilder_insert_tree(pb, entry->oid);\n\t\tdefault:\n\t\t\treturn git_packbuilder_insert(pb, entry->oid, entry->filename);\n\t}\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_packbuilder_insert",
          "args": [
            "pb",
            "entry->oid",
            "entry->filename"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_insert_recur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1440-1474",
          "snippet": "int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packbuilder_insert_tree",
          "args": [
            "pb",
            "entry->oid"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_insert_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1425-1438",
          "snippet": "int git_packbuilder_insert_tree(git_packbuilder *pb, const git_oid *oid)\n{\n\tint error;\n\tgit_tree *tree = NULL;\n\tstruct tree_walk_context context = { pb, GIT_BUF_INIT };\n\n\tif (!(error = git_tree_lookup(&tree, pb->repo, oid)) &&\n\t    !(error = git_packbuilder_insert(pb, oid, NULL)))\n\t\terror = git_tree_walk(tree, GIT_TREEWALK_PRE, cb_tree_walk, &context);\n\n\tgit_tree_free(tree);\n\tgit_buf_free(&context.buf);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_insert_tree(git_packbuilder *pb, const git_oid *oid)\n{\n\tint error;\n\tgit_tree *tree = NULL;\n\tstruct tree_walk_context context = { pb, GIT_BUF_INIT };\n\n\tif (!(error = git_tree_lookup(&tree, pb->repo, oid)) &&\n\t    !(error = git_packbuilder_insert(pb, oid, NULL)))\n\t\terror = git_tree_walk(tree, GIT_TREEWALK_PRE, cb_tree_walk, &context);\n\n\tgit_tree_free(tree);\n\tgit_buf_free(&context.buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_type",
          "args": [
            "entry"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "284-294",
          "snippet": "git_otype git_tree_entry_type(const git_tree_entry *entry)\n{\n\tassert(entry);\n\n\tif (S_ISGITLINK(entry->attr))\n\t\treturn GIT_OBJ_COMMIT;\n\telse if (S_ISDIR(entry->attr))\n\t\treturn GIT_OBJ_TREE;\n\telse\n\t\treturn GIT_OBJ_BLOB;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\ngit_otype git_tree_entry_type(const git_tree_entry *entry)\n{\n\tassert(entry);\n\n\tif (S_ISGITLINK(entry->attr))\n\t\treturn GIT_OBJ_COMMIT;\n\telse if (S_ISDIR(entry->attr))\n\t\treturn GIT_OBJ_TREE;\n\telse\n\t\treturn GIT_OBJ_BLOB;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int enqueue_object(\n\tconst git_tree_entry *entry,\n\tgit_packbuilder *pb)\n{\n\tswitch (git_tree_entry_type(entry)) {\n\t\tcase GIT_OBJ_COMMIT:\n\t\t\treturn 0;\n\t\tcase GIT_OBJ_TREE:\n\t\t\treturn git_packbuilder_insert_tree(pb, entry->oid);\n\t\tdefault:\n\t\t\treturn git_packbuilder_insert(pb, entry->oid, entry->filename);\n\t}\n}"
  },
  {
    "function_name": "revwalk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "263-367",
    "snippet": "static int revwalk(git_vector *commits, git_push *push)\n{\n\tgit_remote_head *head;\n\tpush_spec *spec;\n\tgit_revwalk *rw;\n\tgit_oid oid;\n\tunsigned int i;\n\tint error = -1;\n\n\tif (git_revwalk_new(&rw, push->repo) < 0)\n\t\treturn -1;\n\n\tgit_revwalk_sorting(rw, GIT_SORT_TIME);\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tgit_otype type;\n\t\tsize_t size;\n\n\t\tif (git_oid_iszero(&spec->loid))\n\t\t\t/*\n\t\t\t * Delete reference on remote side;\n\t\t\t * nothing to do here.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tif (git_oid_equal(&spec->loid, &spec->roid))\n\t\t\tcontinue; /* up-to-date */\n\n\t\tif (git_odb_read_header(&size, &type, push->repo->_odb, &spec->loid) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (type == GIT_OBJ_TAG) {\n\t\t\tgit_object *target;\n\n\t\t\tif ((error = enqueue_tag(&target, push, &spec->loid)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tif (git_object_type(target) == GIT_OBJ_COMMIT) {\n\t\t\t\tif (git_revwalk_push(rw, git_object_id(target)) < 0) {\n\t\t\t\t\tgit_object_free(target);\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (git_packbuilder_insert(\n\t\t\t\t\tpush->pb, git_object_id(target), NULL) < 0) {\n\t\t\t\t\tgit_object_free(target);\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgit_object_free(target);\n\t\t} else if (git_revwalk_push(rw, &spec->loid) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!spec->refspec.force) {\n\t\t\tgit_oid base;\n\n\t\t\tif (git_oid_iszero(&spec->roid))\n\t\t\t\tcontinue;\n\n\t\t\tif (!git_odb_exists(push->repo->_odb, &spec->roid)) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE, \n\t\t\t\t\t\"Cannot push because a reference that you are trying to update on the remote contains commits that are not present locally.\");\n\t\t\t\terror = GIT_ENONFASTFORWARD;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\terror = git_merge_base(&base, push->repo,\n\t\t\t\t\t       &spec->loid, &spec->roid);\n\n\t\t\tif (error == GIT_ENOTFOUND ||\n\t\t\t\t(!error && !git_oid_equal(&base, &spec->roid))) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Cannot push non-fastforwardable reference\");\n\t\t\t\terror = GIT_ENONFASTFORWARD;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tgit_vector_foreach(&push->remote->refs, i, head) {\n\t\tif (git_oid_iszero(&head->oid))\n\t\t\tcontinue;\n\n\t\t/* TODO */\n\t\tgit_revwalk_hide(rw, &head->oid);\n\t}\n\n\twhile ((error = git_revwalk_next(&oid, rw)) == 0) {\n\t\tgit_oid *o = git__malloc(GIT_OID_RAWSZ);\n\t\tif (!o) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\t\tgit_oid_cpy(o, &oid);\n\t\tif ((error = git_vector_insert(commits, o)) < 0)\n\t\t\tgoto on_error;\n\t}\n\non_error:\n\tgit_revwalk_free(rw);\n\treturn error == GIT_ITEROVER ? 0 : error;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "rw"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "commits",
            "o"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "o",
            "&oid"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "GIT_OID_RAWSZ"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_next",
          "args": [
            "&oid",
            "rw"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "598-622",
          "snippet": "int git_revwalk_next(git_oid *oid, git_revwalk *walk)\n{\n\tint error;\n\tgit_commit_list_node *next;\n\n\tassert(walk && oid);\n\n\tif (!walk->walking) {\n\t\tif ((error = prepare_walk(walk)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = walk->get_next(&next, walk);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgit_revwalk_reset(walk);\n\t\tgiterr_clear();\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tif (!error)\n\t\tgit_oid_cpy(oid, &next->oid);\n\n\treturn error;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_next(git_oid *oid, git_revwalk *walk)\n{\n\tint error;\n\tgit_commit_list_node *next;\n\n\tassert(walk && oid);\n\n\tif (!walk->walking) {\n\t\tif ((error = prepare_walk(walk)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = walk->get_next(&next, walk);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgit_revwalk_reset(walk);\n\t\tgiterr_clear();\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tif (!error)\n\t\tgit_oid_cpy(oid, &next->oid);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_hide",
          "args": [
            "rw",
            "&head->oid"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_hide_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "306-310",
          "snippet": "int git_revwalk_hide_ref(git_revwalk *walk, const char *refname)\n{\n\tassert(walk && refname);\n\treturn push_ref(walk, refname, 1, false);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_hide_ref(git_revwalk *walk, const char *refname)\n{\n\tassert(walk && refname);\n\treturn push_ref(walk, refname, 1, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&head->oid"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->remote->refs",
            "i",
            "head"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Cannot push non-fastforwardable reference\""
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "&base",
            "&spec->roid"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge_base",
          "args": [
            "&base",
            "push->repo",
            "&spec->loid",
            "&spec->roid"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge_bases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "273-305",
          "snippet": "int git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n        git_revwalk *walk;\n\tgit_commit_list *result, *list;\n\tgit_array_oid_t array;\n\n\tgit_array_init(array);\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)\n{\n\tint error;\n        git_revwalk *walk;\n\tgit_commit_list *result, *list;\n\tgit_array_oid_t array;\n\n\tgit_array_init(array);\n\n\tif ((error = merge_bases(&result, &walk, repo, one, two)) < 0)\n\t\treturn error;\n\n\tlist = result;\n\twhile (list) {\n\t\tgit_oid *id = git_array_alloc(array);\n\t\tif (id == NULL)\n\t\t\tgoto on_error;\n\n\t\tgit_oid_cpy(id, &list->item->oid);\n\t\tlist = list->next;\n\t}\n\n\tgit_oidarray__from_array(out, &array);\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\n\treturn 0;\n\non_error:\n\tgit_commit_list_free(&result);\n\tgit_revwalk_free(walk);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_exists",
          "args": [
            "push->repo->_odb",
            "&spec->roid"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "646-665",
          "snippet": "int git_odb_exists(git_odb *db, const git_oid *id)\n{\n\tgit_odb_object *object;\n\n\tassert(db && id);\n\n\tif ((object = git_cache_get_raw(odb_cache(db), id)) != NULL) {\n\t\tgit_odb_object_free(object);\n\t\treturn (int)true;\n\t}\n\n\tif (odb_exists_1(db, id, false))\n\t\treturn 1;\n\n\tif (!git_odb_refresh(db))\n\t\treturn odb_exists_1(db, id, true);\n\n\t/* Failed to refresh, hence not found */\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_exists(git_odb *db, const git_oid *id)\n{\n\tgit_odb_object *object;\n\n\tassert(db && id);\n\n\tif ((object = git_cache_get_raw(odb_cache(db), id)) != NULL) {\n\t\tgit_odb_object_free(object);\n\t\treturn (int)true;\n\t}\n\n\tif (odb_exists_1(db, id, false))\n\t\treturn 1;\n\n\tif (!git_odb_refresh(db))\n\t\treturn odb_exists_1(db, id, true);\n\n\t/* Failed to refresh, hence not found */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_push",
          "args": [
            "rw",
            "&spec->loid"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_push_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "281-304",
          "snippet": "int git_revwalk_push_range(git_revwalk *walk, const char *range)\n{\n\tgit_revspec revspec;\n\tint error = 0;\n\n\tif ((error = git_revparse(&revspec, walk->repo, range)))\n\t\treturn error;\n\n\tif (revspec.flags & GIT_REVPARSE_MERGE_BASE) {\n\t\t/* TODO: support \"<commit>...<commit>\" */\n\t\tgiterr_set(GITERR_INVALID, \"Symmetric differences not implemented in revwalk\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif ((error = push_commit(walk, git_object_id(revspec.from), 1, false)))\n\t\tgoto out;\n\n\terror = push_commit(walk, git_object_id(revspec.to), 0, false);\n\nout:\n\tgit_object_free(revspec.from);\n\tgit_object_free(revspec.to);\n\treturn error;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_push_range(git_revwalk *walk, const char *range)\n{\n\tgit_revspec revspec;\n\tint error = 0;\n\n\tif ((error = git_revparse(&revspec, walk->repo, range)))\n\t\treturn error;\n\n\tif (revspec.flags & GIT_REVPARSE_MERGE_BASE) {\n\t\t/* TODO: support \"<commit>...<commit>\" */\n\t\tgiterr_set(GITERR_INVALID, \"Symmetric differences not implemented in revwalk\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif ((error = push_commit(walk, git_object_id(revspec.from), 1, false)))\n\t\tgoto out;\n\n\terror = push_commit(walk, git_object_id(revspec.to), 0, false);\n\nout:\n\tgit_object_free(revspec.from);\n\tgit_object_free(revspec.to);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "target"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packbuilder_insert",
          "args": [
            "push->pb",
            "git_object_id(target)",
            "NULL"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_insert_recur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1440-1474",
          "snippet": "int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "target"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type",
          "args": [
            "target"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_tag",
          "args": [
            "&target",
            "push",
            "&spec->loid"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "236-261",
          "snippet": "static int enqueue_tag(git_object **out, git_push *push, git_oid *id)\n{\n\tgit_object *obj = NULL, *target = NULL;\n\tint error;\n\n\tif ((error = git_object_lookup(&obj, push->repo, id, GIT_OBJ_TAG)) < 0)\n\t\treturn error;\n\n\twhile (git_object_type(obj) == GIT_OBJ_TAG) {\n\t\tif ((error = git_packbuilder_insert(push->pb, git_object_id(obj), NULL)) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_tag_target(&target, (git_tag *) obj)) < 0)\n\t\t\tbreak;\n\n\t\tgit_object_free(obj);\n\t\tobj = target;\n\t}\n\n\tif (error < 0)\n\t\tgit_object_free(obj);\n\telse\n\t\t*out = obj;\n\n\treturn error;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int enqueue_tag(git_object **out, git_push *push, git_oid *id)\n{\n\tgit_object *obj = NULL, *target = NULL;\n\tint error;\n\n\tif ((error = git_object_lookup(&obj, push->repo, id, GIT_OBJ_TAG)) < 0)\n\t\treturn error;\n\n\twhile (git_object_type(obj) == GIT_OBJ_TAG) {\n\t\tif ((error = git_packbuilder_insert(push->pb, git_object_id(obj), NULL)) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_tag_target(&target, (git_tag *) obj)) < 0)\n\t\t\tbreak;\n\n\t\tgit_object_free(obj);\n\t\tobj = target;\n\t}\n\n\tif (error < 0)\n\t\tgit_object_free(obj);\n\telse\n\t\t*out = obj;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_read_header",
          "args": [
            "&size",
            "&type",
            "push->repo->_odb",
            "&spec->loid"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_read_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "749-760",
          "snippet": "int git_odb_read_header(size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id)\n{\n\tint error;\n\tgit_odb_object *object;\n\n\terror = git_odb__read_header_or_object(&object, len_p, type_p, db, id);\n\n\tif (object)\n\t\tgit_odb_object_free(object);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_read_header(size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id)\n{\n\tint error;\n\tgit_odb_object *object;\n\n\terror = git_odb__read_header_or_object(&object, len_p, type_p, db, id);\n\n\tif (object)\n\t\tgit_odb_object_free(object);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->specs",
            "i",
            "spec"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_revwalk_sorting",
          "args": [
            "rw",
            "GIT_SORT_TIME"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_sorting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "575-591",
          "snippet": "void git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)\n{\n\tassert(walk);\n\n\tif (walk->walking)\n\t\tgit_revwalk_reset(walk);\n\n\twalk->sorting = sort_mode;\n\n\tif (walk->sorting & GIT_SORT_TIME) {\n\t\twalk->get_next = &revwalk_next_timesort;\n\t\twalk->enqueue = &revwalk_enqueue_timesort;\n\t} else {\n\t\twalk->get_next = &revwalk_next_unsorted;\n\t\twalk->enqueue = &revwalk_enqueue_unsorted;\n\t}\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)\n{\n\tassert(walk);\n\n\tif (walk->walking)\n\t\tgit_revwalk_reset(walk);\n\n\twalk->sorting = sort_mode;\n\n\tif (walk->sorting & GIT_SORT_TIME) {\n\t\twalk->get_next = &revwalk_next_timesort;\n\t\twalk->enqueue = &revwalk_enqueue_timesort;\n\t} else {\n\t\twalk->get_next = &revwalk_next_unsorted;\n\t\twalk->enqueue = &revwalk_enqueue_unsorted;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_new",
          "args": [
            "&rw",
            "push->repo"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "529-553",
          "snippet": "int git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int revwalk(git_vector *commits, git_push *push)\n{\n\tgit_remote_head *head;\n\tpush_spec *spec;\n\tgit_revwalk *rw;\n\tgit_oid oid;\n\tunsigned int i;\n\tint error = -1;\n\n\tif (git_revwalk_new(&rw, push->repo) < 0)\n\t\treturn -1;\n\n\tgit_revwalk_sorting(rw, GIT_SORT_TIME);\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tgit_otype type;\n\t\tsize_t size;\n\n\t\tif (git_oid_iszero(&spec->loid))\n\t\t\t/*\n\t\t\t * Delete reference on remote side;\n\t\t\t * nothing to do here.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tif (git_oid_equal(&spec->loid, &spec->roid))\n\t\t\tcontinue; /* up-to-date */\n\n\t\tif (git_odb_read_header(&size, &type, push->repo->_odb, &spec->loid) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (type == GIT_OBJ_TAG) {\n\t\t\tgit_object *target;\n\n\t\t\tif ((error = enqueue_tag(&target, push, &spec->loid)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tif (git_object_type(target) == GIT_OBJ_COMMIT) {\n\t\t\t\tif (git_revwalk_push(rw, git_object_id(target)) < 0) {\n\t\t\t\t\tgit_object_free(target);\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (git_packbuilder_insert(\n\t\t\t\t\tpush->pb, git_object_id(target), NULL) < 0) {\n\t\t\t\t\tgit_object_free(target);\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgit_object_free(target);\n\t\t} else if (git_revwalk_push(rw, &spec->loid) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!spec->refspec.force) {\n\t\t\tgit_oid base;\n\n\t\t\tif (git_oid_iszero(&spec->roid))\n\t\t\t\tcontinue;\n\n\t\t\tif (!git_odb_exists(push->repo->_odb, &spec->roid)) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE, \n\t\t\t\t\t\"Cannot push because a reference that you are trying to update on the remote contains commits that are not present locally.\");\n\t\t\t\terror = GIT_ENONFASTFORWARD;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\terror = git_merge_base(&base, push->repo,\n\t\t\t\t\t       &spec->loid, &spec->roid);\n\n\t\t\tif (error == GIT_ENOTFOUND ||\n\t\t\t\t(!error && !git_oid_equal(&base, &spec->roid))) {\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Cannot push non-fastforwardable reference\");\n\t\t\t\terror = GIT_ENONFASTFORWARD;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tgit_vector_foreach(&push->remote->refs, i, head) {\n\t\tif (git_oid_iszero(&head->oid))\n\t\t\tcontinue;\n\n\t\t/* TODO */\n\t\tgit_revwalk_hide(rw, &head->oid);\n\t}\n\n\twhile ((error = git_revwalk_next(&oid, rw)) == 0) {\n\t\tgit_oid *o = git__malloc(GIT_OID_RAWSZ);\n\t\tif (!o) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\t\tgit_oid_cpy(o, &oid);\n\t\tif ((error = git_vector_insert(commits, o)) < 0)\n\t\t\tgoto on_error;\n\t}\n\non_error:\n\tgit_revwalk_free(rw);\n\treturn error == GIT_ITEROVER ? 0 : error;\n}"
  },
  {
    "function_name": "enqueue_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "236-261",
    "snippet": "static int enqueue_tag(git_object **out, git_push *push, git_oid *id)\n{\n\tgit_object *obj = NULL, *target = NULL;\n\tint error;\n\n\tif ((error = git_object_lookup(&obj, push->repo, id, GIT_OBJ_TAG)) < 0)\n\t\treturn error;\n\n\twhile (git_object_type(obj) == GIT_OBJ_TAG) {\n\t\tif ((error = git_packbuilder_insert(push->pb, git_object_id(obj), NULL)) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_tag_target(&target, (git_tag *) obj)) < 0)\n\t\t\tbreak;\n\n\t\tgit_object_free(obj);\n\t\tobj = target;\n\t}\n\n\tif (error < 0)\n\t\tgit_object_free(obj);\n\telse\n\t\t*out = obj;\n\n\treturn error;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "obj"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tag_target",
          "args": [
            "&target",
            "(git_tag *) obj"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "git_tag_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "27-31",
          "snippet": "int git_tag_target(git_object **target, const git_tag *t)\n{\n\tassert(t);\n\treturn git_object_lookup(target, t->object.repo, &t->target, t->type);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_target(git_object **target, const git_tag *t)\n{\n\tassert(t);\n\treturn git_object_lookup(target, t->object.repo, &t->target, t->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packbuilder_insert",
          "args": [
            "push->pb",
            "git_object_id(obj)",
            "NULL"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_insert_recur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1440-1474",
          "snippet": "int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)\n{\n\tgit_object *obj;\n\tint error;\n\n\tassert(pb && id);\n\n\tif ((error = git_object_lookup(&obj, pb->repo, id, GIT_OBJ_ANY)) < 0)\n\t\treturn error;\n\n\tswitch (git_object_type(obj)) {\n\tcase GIT_OBJ_BLOB:\n\t\terror = git_packbuilder_insert(pb, id, name);\n\t\tbreak;\n\tcase GIT_OBJ_TREE:\n\t\terror = git_packbuilder_insert_tree(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\terror = git_packbuilder_insert_commit(pb, id);\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\tif ((error = git_packbuilder_insert(pb, id, name)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = git_packbuilder_insert_recur(pb, git_tag_target_id((git_tag *) obj), NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"unknown object type\");\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_object_free(obj);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "obj"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type",
          "args": [
            "obj"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "&obj",
            "push->repo",
            "id",
            "GIT_OBJ_TAG"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int enqueue_tag(git_object **out, git_push *push, git_oid *id)\n{\n\tgit_object *obj = NULL, *target = NULL;\n\tint error;\n\n\tif ((error = git_object_lookup(&obj, push->repo, id, GIT_OBJ_TAG)) < 0)\n\t\treturn error;\n\n\twhile (git_object_type(obj) == GIT_OBJ_TAG) {\n\t\tif ((error = git_packbuilder_insert(push->pb, git_object_id(obj), NULL)) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_tag_target(&target, (git_tag *) obj)) < 0)\n\t\t\tbreak;\n\n\t\tgit_object_free(obj);\n\t\tobj = target;\n\t}\n\n\tif (error < 0)\n\t\tgit_object_free(obj);\n\telse\n\t\t*out = obj;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_push_update_tips",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "159-230",
    "snippet": "int git_push_update_tips(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tgit_buf remote_ref_name = GIT_BUF_INIT;\n\tsize_t i, j;\n\tgit_refspec *fetch_spec;\n\tpush_spec *push_spec = NULL;\n\tgit_reference *remote_ref;\n\tpush_status *status;\n\tint error = 0;\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tint fire_callback = 1;\n\n\t\t/* Skip unsuccessful updates which have non-empty messages */\n\t\tif (status->msg)\n\t\t\tcontinue;\n\n\t\t/* Find the corresponding remote ref */\n\t\tfetch_spec = git_remote__matching_refspec(push->remote, status->ref);\n\t\tif (!fetch_spec)\n\t\t\tcontinue;\n\n\t\tif ((error = git_refspec_transform(&remote_ref_name, fetch_spec, status->ref)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Find matching  push ref spec */\n\t\tgit_vector_foreach(&push->specs, j, push_spec) {\n\t\t\tif (!strcmp(push_spec->refspec.dst, status->ref))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Could not find the corresponding push ref spec for this push update */\n\t\tif (j == push->specs.length)\n\t\t\tcontinue;\n\n\t\t/* Update the remote ref */\n\t\tif (git_oid_iszero(&push_spec->loid)) {\n\t\t\terror = git_reference_lookup(&remote_ref, push->remote->repo, git_buf_cstr(&remote_ref_name));\n\n\t\t\tif (error >= 0) {\n\t\t\t\terror = git_reference_delete(remote_ref);\n\t\t\t\tgit_reference_free(remote_ref);\n\t\t\t}\n\t\t} else {\n\t\t\terror = git_reference_create(NULL, push->remote->repo,\n\t\t\t\t\t\tgit_buf_cstr(&remote_ref_name), &push_spec->loid, 1,\n\t\t\t\t\t\t\"update by push\");\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tfire_callback = 0;\n\t\t}\n\n\t\tif (fire_callback && callbacks && callbacks->update_tips) {\n\t\t\terror = callbacks->update_tips(git_buf_cstr(&remote_ref_name),\n\t\t\t\t\t\t&push_spec->roid, &push_spec->loid, callbacks->payload);\n\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\terror = 0;\n\non_error:\n\tgit_buf_free(&remote_ref_name);\n\treturn error;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&remote_ref_name"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "callbacks->update_tips",
          "args": [
            "git_buf_cstr(&remote_ref_name)",
            "&push_spec->roid",
            "&push_spec->loid",
            "callbacks->payload"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&remote_ref_name"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_create",
          "args": [
            "NULL",
            "push->remote->repo",
            "git_buf_cstr(&remote_ref_name)",
            "&push_spec->loid",
            "1",
            "\"update by push\""
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "464-473",
          "snippet": "int git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "remote_ref"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_delete",
          "args": [
            "remote_ref"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "122-133",
          "snippet": "int git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&remote_ref",
            "push->remote->repo",
            "git_buf_cstr(&remote_ref_name)"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&push_spec->loid"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "push_spec->refspec.dst",
            "status->ref"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->specs",
            "j",
            "push_spec"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_refspec_transform",
          "args": [
            "&remote_ref_name",
            "fetch_spec",
            "status->ref"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "244-258",
          "snippet": "int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__matching_refspec",
          "args": [
            "push->remote",
            "status->ref"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__matching_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2055-2069",
          "snippet": "git_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->status",
            "i",
            "status"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_update_tips(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tgit_buf remote_ref_name = GIT_BUF_INIT;\n\tsize_t i, j;\n\tgit_refspec *fetch_spec;\n\tpush_spec *push_spec = NULL;\n\tgit_reference *remote_ref;\n\tpush_status *status;\n\tint error = 0;\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tint fire_callback = 1;\n\n\t\t/* Skip unsuccessful updates which have non-empty messages */\n\t\tif (status->msg)\n\t\t\tcontinue;\n\n\t\t/* Find the corresponding remote ref */\n\t\tfetch_spec = git_remote__matching_refspec(push->remote, status->ref);\n\t\tif (!fetch_spec)\n\t\t\tcontinue;\n\n\t\tif ((error = git_refspec_transform(&remote_ref_name, fetch_spec, status->ref)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Find matching  push ref spec */\n\t\tgit_vector_foreach(&push->specs, j, push_spec) {\n\t\t\tif (!strcmp(push_spec->refspec.dst, status->ref))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Could not find the corresponding push ref spec for this push update */\n\t\tif (j == push->specs.length)\n\t\t\tcontinue;\n\n\t\t/* Update the remote ref */\n\t\tif (git_oid_iszero(&push_spec->loid)) {\n\t\t\terror = git_reference_lookup(&remote_ref, push->remote->repo, git_buf_cstr(&remote_ref_name));\n\n\t\t\tif (error >= 0) {\n\t\t\t\terror = git_reference_delete(remote_ref);\n\t\t\t\tgit_reference_free(remote_ref);\n\t\t\t}\n\t\t} else {\n\t\t\terror = git_reference_create(NULL, push->remote->repo,\n\t\t\t\t\t\tgit_buf_cstr(&remote_ref_name), &push_spec->loid, 1,\n\t\t\t\t\t\t\"update by push\");\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tfire_callback = 0;\n\t\t}\n\n\t\tif (fire_callback && callbacks && callbacks->update_tips) {\n\t\t\terror = callbacks->update_tips(git_buf_cstr(&remote_ref_name),\n\t\t\t\t\t\t&push_spec->roid, &push_spec->loid, callbacks->payload);\n\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\terror = 0;\n\non_error:\n\tgit_buf_free(&remote_ref_name);\n\treturn error;\n}"
  },
  {
    "function_name": "git_push_add_refspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "148-157",
    "snippet": "int git_push_add_refspec(git_push *push, const char *refspec)\n{\n\tpush_spec *spec;\n\n\tif (parse_refspec(push, &spec, refspec) < 0 ||\n\t    git_vector_insert(&push->specs, spec) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&push->specs",
            "spec"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_refspec",
          "args": [
            "push",
            "&spec",
            "refspec"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "parse_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "118-146",
          "snippet": "static int parse_refspec(git_push *push, push_spec **spec, const char *str)\n{\n\tpush_spec *s;\n\n\t*spec = NULL;\n\n\ts = git__calloc(1, sizeof(*s));\n\tGITERR_CHECK_ALLOC(s);\n\n\tif (git_refspec__parse(&s->refspec, str, false) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"invalid refspec %s\", str);\n\t\tgoto on_error;\n\t}\n\n\tif (s->refspec.src && s->refspec.src[0] != '\\0' &&\n\t    check_lref(push, s->refspec.src) < 0) {\n\t\tgoto on_error;\n\t}\n\n\tif (check_rref(s->refspec.dst) < 0)\n\t\tgoto on_error;\n\n\t*spec = s;\n\treturn 0;\n\non_error:\n\tfree_refspec(s);\n\treturn -1;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int parse_refspec(git_push *push, push_spec **spec, const char *str)\n{\n\tpush_spec *s;\n\n\t*spec = NULL;\n\n\ts = git__calloc(1, sizeof(*s));\n\tGITERR_CHECK_ALLOC(s);\n\n\tif (git_refspec__parse(&s->refspec, str, false) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"invalid refspec %s\", str);\n\t\tgoto on_error;\n\t}\n\n\tif (s->refspec.src && s->refspec.src[0] != '\\0' &&\n\t    check_lref(push, s->refspec.src) < 0) {\n\t\tgoto on_error;\n\t}\n\n\tif (check_rref(s->refspec.dst) < 0)\n\t\tgoto on_error;\n\n\t*spec = s;\n\treturn 0;\n\non_error:\n\tfree_refspec(s);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_add_refspec(git_push *push, const char *refspec)\n{\n\tpush_spec *spec;\n\n\tif (parse_refspec(push, &spec, refspec) < 0 ||\n\t    git_vector_insert(&push->specs, spec) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_refspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "118-146",
    "snippet": "static int parse_refspec(git_push *push, push_spec **spec, const char *str)\n{\n\tpush_spec *s;\n\n\t*spec = NULL;\n\n\ts = git__calloc(1, sizeof(*s));\n\tGITERR_CHECK_ALLOC(s);\n\n\tif (git_refspec__parse(&s->refspec, str, false) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"invalid refspec %s\", str);\n\t\tgoto on_error;\n\t}\n\n\tif (s->refspec.src && s->refspec.src[0] != '\\0' &&\n\t    check_lref(push, s->refspec.src) < 0) {\n\t\tgoto on_error;\n\t}\n\n\tif (check_rref(s->refspec.dst) < 0)\n\t\tgoto on_error;\n\n\t*spec = s;\n\treturn 0;\n\non_error:\n\tfree_refspec(s);\n\treturn -1;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_refspec",
          "args": [
            "s"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "free_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "81-88",
          "snippet": "static void free_refspec(push_spec *spec)\n{\n\tif (spec == NULL)\n\t\treturn;\n\n\tgit_refspec__free(&spec->refspec);\n\tgit__free(spec);\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic void free_refspec(push_spec *spec)\n{\n\tif (spec == NULL)\n\t\treturn;\n\n\tgit_refspec__free(&spec->refspec);\n\tgit__free(spec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_rref",
          "args": [
            "s->refspec.dst"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "check_rref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "90-98",
          "snippet": "static int check_rref(char *ref)\n{\n\tif (git__prefixcmp(ref, \"refs/\")) {\n\t\tgiterr_set(GITERR_INVALID, \"Not a valid reference '%s'\", ref);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int check_rref(char *ref)\n{\n\tif (git__prefixcmp(ref, \"refs/\")) {\n\t\tgiterr_set(GITERR_INVALID, \"Not a valid reference '%s'\", ref);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_lref",
          "args": [
            "push",
            "s->refspec.src"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "check_lref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "100-116",
          "snippet": "static int check_lref(git_push *push, char *ref)\n{\n\t/* lref must be resolvable to an existing object */\n\tgit_object *obj;\n\tint error = git_revparse_single(&obj, push->repo, ref);\n\tgit_object_free(obj);\n\n\tif (!error)\n\t\treturn 0;\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"src refspec '%s' does not match any existing object\", ref);\n\telse\n\t\tgiterr_set(GITERR_INVALID, \"Not a valid reference '%s'\", ref);\n\treturn -1;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int check_lref(git_push *push, char *ref)\n{\n\t/* lref must be resolvable to an existing object */\n\tgit_object *obj;\n\tint error = git_revparse_single(&obj, push->repo, ref);\n\tgit_object_free(obj);\n\n\tif (!error)\n\t\treturn 0;\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"src refspec '%s' does not match any existing object\", ref);\n\telse\n\t\tgiterr_set(GITERR_INVALID, \"Not a valid reference '%s'\", ref);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"invalid refspec %s\"",
            "str"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__parse",
          "args": [
            "&s->refspec",
            "str",
            "false"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "17-149",
          "snippet": "int git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "s"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(*s)"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int parse_refspec(git_push *push, push_spec **spec, const char *str)\n{\n\tpush_spec *s;\n\n\t*spec = NULL;\n\n\ts = git__calloc(1, sizeof(*s));\n\tGITERR_CHECK_ALLOC(s);\n\n\tif (git_refspec__parse(&s->refspec, str, false) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"invalid refspec %s\", str);\n\t\tgoto on_error;\n\t}\n\n\tif (s->refspec.src && s->refspec.src[0] != '\\0' &&\n\t    check_lref(push, s->refspec.src) < 0) {\n\t\tgoto on_error;\n\t}\n\n\tif (check_rref(s->refspec.dst) < 0)\n\t\tgoto on_error;\n\n\t*spec = s;\n\treturn 0;\n\non_error:\n\tfree_refspec(s);\n\treturn -1;\n}"
  },
  {
    "function_name": "check_lref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "100-116",
    "snippet": "static int check_lref(git_push *push, char *ref)\n{\n\t/* lref must be resolvable to an existing object */\n\tgit_object *obj;\n\tint error = git_revparse_single(&obj, push->repo, ref);\n\tgit_object_free(obj);\n\n\tif (!error)\n\t\treturn 0;\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"src refspec '%s' does not match any existing object\", ref);\n\telse\n\t\tgiterr_set(GITERR_INVALID, \"Not a valid reference '%s'\", ref);\n\treturn -1;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Not a valid reference '%s'\"",
            "ref"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "obj"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revparse_single",
          "args": [
            "&obj",
            "push->repo",
            "ref"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "git_revparse_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "855-876",
          "snippet": "int git_revparse_single(git_object **out, git_repository *repo, const char *spec)\n{\n\tint error;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\t*out = NULL;\n\n\tif ((error = git_revparse_ext(&obj, &ref, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\tgit_reference_free(ref);\n\n\t*out = obj;\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nint git_revparse_single(git_object **out, git_repository *repo, const char *spec)\n{\n\tint error;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\t*out = NULL;\n\n\tif ((error = git_revparse_ext(&obj, &ref, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\tgit_reference_free(ref);\n\n\t*out = obj;\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int check_lref(git_push *push, char *ref)\n{\n\t/* lref must be resolvable to an existing object */\n\tgit_object *obj;\n\tint error = git_revparse_single(&obj, push->repo, ref);\n\tgit_object_free(obj);\n\n\tif (!error)\n\t\treturn 0;\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"src refspec '%s' does not match any existing object\", ref);\n\telse\n\t\tgiterr_set(GITERR_INVALID, \"Not a valid reference '%s'\", ref);\n\treturn -1;\n}"
  },
  {
    "function_name": "check_rref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "90-98",
    "snippet": "static int check_rref(char *ref)\n{\n\tif (git__prefixcmp(ref, \"refs/\")) {\n\t\tgiterr_set(GITERR_INVALID, \"Not a valid reference '%s'\", ref);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Not a valid reference '%s'\"",
            "ref"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ref",
            "\"refs/\""
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int check_rref(char *ref)\n{\n\tif (git__prefixcmp(ref, \"refs/\")) {\n\t\tgiterr_set(GITERR_INVALID, \"Not a valid reference '%s'\", ref);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_refspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "81-88",
    "snippet": "static void free_refspec(push_spec *spec)\n{\n\tif (spec == NULL)\n\t\treturn;\n\n\tgit_refspec__free(&spec->refspec);\n\tgit__free(spec);\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "spec"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "&spec->refspec"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic void free_refspec(push_spec *spec)\n{\n\tif (spec == NULL)\n\t\treturn;\n\n\tgit_refspec__free(&spec->refspec);\n\tgit__free(spec);\n}"
  },
  {
    "function_name": "git_push_set_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "68-79",
    "snippet": "int git_push_set_options(git_push *push, const git_push_options *opts)\n{\n\tif (!push || !opts)\n\t\treturn -1;\n\n\tGITERR_CHECK_VERSION(opts, GIT_PUSH_OPTIONS_VERSION, \"git_push_options\");\n\n\tpush->pb_parallelism = opts->pb_parallelism;\n\tpush->custom_headers = &opts->custom_headers;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "opts",
            "GIT_PUSH_OPTIONS_VERSION",
            "\"git_push_options\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_set_options(git_push *push, const git_push_options *opts)\n{\n\tif (!push || !opts)\n\t\treturn -1;\n\n\tGITERR_CHECK_VERSION(opts, GIT_PUSH_OPTIONS_VERSION, \"git_push_options\");\n\n\tpush->pb_parallelism = opts->pb_parallelism;\n\tpush->custom_headers = &opts->custom_headers;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_push_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "32-66",
    "snippet": "int git_push_new(git_push **out, git_remote *remote)\n{\n\tgit_push *p;\n\n\t*out = NULL;\n\n\tp = git__calloc(1, sizeof(*p));\n\tGITERR_CHECK_ALLOC(p);\n\n\tp->repo = remote->repo;\n\tp->remote = remote;\n\tp->report_status = 1;\n\tp->pb_parallelism = 1;\n\n\tif (git_vector_init(&p->specs, 0, push_spec_rref_cmp) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&p->status, 0, push_status_ref_cmp) < 0) {\n\t\tgit_vector_free(&p->specs);\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&p->updates, 0, NULL) < 0) {\n\t\tgit_vector_free(&p->status);\n\t\tgit_vector_free(&p->specs);\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*out = p;\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "p"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&p->specs"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&p->updates",
            "0",
            "NULL"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "p"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(*p)"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_new(git_push **out, git_remote *remote)\n{\n\tgit_push *p;\n\n\t*out = NULL;\n\n\tp = git__calloc(1, sizeof(*p));\n\tGITERR_CHECK_ALLOC(p);\n\n\tp->repo = remote->repo;\n\tp->remote = remote;\n\tp->report_status = 1;\n\tp->pb_parallelism = 1;\n\n\tif (git_vector_init(&p->specs, 0, push_spec_rref_cmp) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&p->status, 0, push_status_ref_cmp) < 0) {\n\t\tgit_vector_free(&p->specs);\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&p->updates, 0, NULL) < 0) {\n\t\tgit_vector_free(&p->status);\n\t\tgit_vector_free(&p->specs);\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*out = p;\n\treturn 0;\n}"
  },
  {
    "function_name": "push_status_ref_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "25-30",
    "snippet": "static int push_status_ref_cmp(const void *a, const void *b)\n{\n\tconst push_status *push_status_a = a, *push_status_b = b;\n\n\treturn strcmp(push_status_a->ref, push_status_b->ref);\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "push_status_a->ref",
            "push_status_b->ref"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int push_status_ref_cmp(const void *a, const void *b)\n{\n\tconst push_status *push_status_a = a, *push_status_b = b;\n\n\treturn strcmp(push_status_a->ref, push_status_b->ref);\n}"
  },
  {
    "function_name": "push_spec_rref_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
    "lines": "18-23",
    "snippet": "static int push_spec_rref_cmp(const void *a, const void *b)\n{\n\tconst push_spec *push_spec_a = a, *push_spec_b = b;\n\n\treturn strcmp(push_spec_a->refspec.dst, push_spec_b->refspec.dst);\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"push.h\"",
      "#include \"vector.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"pack.h\"",
      "#include \"common.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "push_spec_a->refspec.dst",
            "push_spec_b->refspec.dst"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nstatic int push_spec_rref_cmp(const void *a, const void *b)\n{\n\tconst push_spec *push_spec_a = a, *push_spec_b = b;\n\n\treturn strcmp(push_spec_a->refspec.dst, push_spec_b->refspec.dst);\n}"
  }
]