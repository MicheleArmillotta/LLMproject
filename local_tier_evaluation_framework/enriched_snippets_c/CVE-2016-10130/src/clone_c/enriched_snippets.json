[
  {
    "function_name": "clone_local_into",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "496-566",
    "snippet": "static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link)\n{\n\tint error, flags;\n\tgit_repository *src;\n\tgit_buf src_odb = GIT_BUF_INIT, dst_odb = GIT_BUF_INIT, src_path = GIT_BUF_INIT;\n\tgit_buf reflog_message = GIT_BUF_INIT;\n\n\tassert(repo && remote);\n\n\tif (!git_repository_is_empty(repo)) {\n\t\tgiterr_set(GITERR_INVALID, \"the repository is not empty\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Let's figure out what path we should use for the source\n\t * repo, if it's not rooted, the path should be relative to\n\t * the repository's worktree/gitdir.\n\t */\n\tif ((error = git_path_from_url_or_path(&src_path, git_remote_url(remote))) < 0)\n\t\treturn error;\n\n\t/* Copy .git/objects/ from the source to the target */\n\tif ((error = git_repository_open(&src, git_buf_cstr(&src_path))) < 0) {\n\t\tgit_buf_free(&src_path);\n\t\treturn error;\n\t}\n\n\tgit_buf_joinpath(&src_odb, git_repository_path(src), GIT_OBJECTS_DIR);\n\tgit_buf_joinpath(&dst_odb, git_repository_path(repo), GIT_OBJECTS_DIR);\n\tif (git_buf_oom(&src_odb) || git_buf_oom(&dst_odb)) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tflags = 0;\n\tif (can_link(git_repository_path(src), git_repository_path(repo), link))\n\t\tflags |= GIT_CPDIR_LINK_FILES;\n\n\terror = git_futils_cp_r(git_buf_cstr(&src_odb), git_buf_cstr(&dst_odb),\n\t\t\t\tflags, GIT_OBJECT_DIR_MODE);\n\n\t/*\n\t * can_link() doesn't catch all variations, so if we hit an\n\t * error and did want to link, let's try again without trying\n\t * to link.\n\t */\n\tif (error < 0 && link) {\n\t\tflags &= ~GIT_CPDIR_LINK_FILES;\n\t\terror = git_futils_cp_r(git_buf_cstr(&src_odb), git_buf_cstr(&dst_odb),\n\t\t\t\t\tflags, GIT_OBJECT_DIR_MODE);\n\t}\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tgit_buf_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));\n\n\tif ((error = git_remote_fetch(remote, NULL, fetch_opts, git_buf_cstr(&reflog_message))) != 0)\n\t\tgoto cleanup;\n\n\terror = checkout_branch(repo, remote, co_opts, branch, git_buf_cstr(&reflog_message));\n\ncleanup:\n\tgit_buf_free(&reflog_message);\n\tgit_buf_free(&src_path);\n\tgit_buf_free(&src_odb);\n\tgit_buf_free(&dst_odb);\n\tgit_repository_free(src);\n\treturn error;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_repository_free",
          "args": [
            "src"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "121-148",
          "snippet": "void git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nvoid git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&dst_odb"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkout_branch",
          "args": [
            "repo",
            "remote",
            "co_opts",
            "branch",
            "git_buf_cstr(&reflog_message)"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "checkout_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "307-322",
          "snippet": "static int checkout_branch(git_repository *repo, git_remote *remote, const git_checkout_options *co_opts, const char *branch, const char *reflog_message)\n{\n\tint error;\n\n\tif (branch)\n\t\terror = update_head_to_branch(repo, git_remote_name(remote), branch,\n\t\t\t\treflog_message);\n\t/* Point HEAD to the same ref as the remote's head */\n\telse\n\t\terror = update_head_to_remote(repo, remote, reflog_message);\n\n\tif (!error && should_checkout(repo, git_repository_is_bare(repo), co_opts))\n\t\terror = git_checkout_head(repo, co_opts);\n\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int checkout_branch(git_repository *repo, git_remote *remote, const git_checkout_options *co_opts, const char *branch, const char *reflog_message)\n{\n\tint error;\n\n\tif (branch)\n\t\terror = update_head_to_branch(repo, git_remote_name(remote), branch,\n\t\t\t\treflog_message);\n\t/* Point HEAD to the same ref as the remote's head */\n\telse\n\t\terror = update_head_to_remote(repo, remote, reflog_message);\n\n\tif (!error && should_checkout(repo, git_repository_is_bare(repo), co_opts))\n\t\terror = git_checkout_head(repo, co_opts);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&reflog_message"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_fetch",
          "args": [
            "remote",
            "NULL",
            "fetch_opts",
            "git_buf_cstr(&reflog_message)"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "962-1023",
          "snippet": "int git_remote_fetch(\n\t\tgit_remote *remote,\n\t\tconst git_strarray *refspecs,\n\t\tconst git_fetch_options *opts,\n\t\tconst char *reflog_message)\n{\n\tint error, update_fetchhead = 1;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\tbool prune = false;\n\tgit_buf reflog_msg_buf = GIT_BUF_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t\tupdate_fetchhead = opts->update_fetchhead;\n\t\ttagopt = opts->download_tags;\n\t}\n\n\t/* Connect and download everything */\n\tif ((error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) != 0)\n\t\treturn error;\n\n\terror = git_remote_download(remote, refspecs, opts);\n\n\t/* We don't need to be connected anymore */\n\tgit_remote_disconnect(remote);\n\n\t/* If the download failed, return the error */\n\tif (error != 0)\n\t\treturn error;\n\n\t/* Default reflog message */\n\tif (reflog_message)\n\t\tgit_buf_sets(&reflog_msg_buf, reflog_message);\n\telse {\n\t\tgit_buf_printf(&reflog_msg_buf, \"fetch %s\",\n\t\t\t\tremote->name ? remote->name : remote->url);\n\t}\n\n\t/* Create \"remote/foo\" branches for all remote branches */\n\terror = git_remote_update_tips(remote, cbs, update_fetchhead, tagopt, git_buf_cstr(&reflog_msg_buf));\n\tgit_buf_free(&reflog_msg_buf);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (opts && opts->prune == GIT_FETCH_PRUNE)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_PRUNE_UNSPECIFIED && remote->prune_refs)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_NO_PRUNE)\n\t\tprune = false;\n\telse\n\t\tprune = remote->prune_refs;\n\n\tif (prune)\n\t\terror = git_remote_prune(remote, cbs);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_fetch(\n\t\tgit_remote *remote,\n\t\tconst git_strarray *refspecs,\n\t\tconst git_fetch_options *opts,\n\t\tconst char *reflog_message)\n{\n\tint error, update_fetchhead = 1;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\tbool prune = false;\n\tgit_buf reflog_msg_buf = GIT_BUF_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t\tupdate_fetchhead = opts->update_fetchhead;\n\t\ttagopt = opts->download_tags;\n\t}\n\n\t/* Connect and download everything */\n\tif ((error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) != 0)\n\t\treturn error;\n\n\terror = git_remote_download(remote, refspecs, opts);\n\n\t/* We don't need to be connected anymore */\n\tgit_remote_disconnect(remote);\n\n\t/* If the download failed, return the error */\n\tif (error != 0)\n\t\treturn error;\n\n\t/* Default reflog message */\n\tif (reflog_message)\n\t\tgit_buf_sets(&reflog_msg_buf, reflog_message);\n\telse {\n\t\tgit_buf_printf(&reflog_msg_buf, \"fetch %s\",\n\t\t\t\tremote->name ? remote->name : remote->url);\n\t}\n\n\t/* Create \"remote/foo\" branches for all remote branches */\n\terror = git_remote_update_tips(remote, cbs, update_fetchhead, tagopt, git_buf_cstr(&reflog_msg_buf));\n\tgit_buf_free(&reflog_msg_buf);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (opts && opts->prune == GIT_FETCH_PRUNE)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_PRUNE_UNSPECIFIED && remote->prune_refs)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_NO_PRUNE)\n\t\tprune = false;\n\telse\n\t\tprune = remote->prune_refs;\n\n\tif (prune)\n\t\terror = git_remote_prune(remote, cbs);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&reflog_message",
            "\"clone: from %s\"",
            "git_remote_url(remote)"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_url",
          "args": [
            "remote"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "609-613",
          "snippet": "const char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nconst char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_cp_r",
          "args": [
            "git_buf_cstr(&src_odb)",
            "git_buf_cstr(&dst_odb)",
            "flags",
            "GIT_OBJECT_DIR_MODE"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_cp_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "991-1031",
          "snippet": "int git_futils_cp_r(\n\tconst char *from,\n\tconst char *to,\n\tuint32_t flags,\n\tmode_t dirmode)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tcp_r_info info;\n\n\tif (git_buf_joinpath(&path, from, \"\") < 0) /* ensure trailing slash */\n\t\treturn -1;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.to_root = to;\n\tinfo.flags   = flags;\n\tinfo.dirmode = dirmode;\n\tinfo.from_prefix = path.size;\n\tgit_buf_init(&info.to, 0);\n\n\t/* precalculate mkdir flags */\n\tif ((flags & GIT_CPDIR_CREATE_EMPTY_DIRS) == 0) {\n\t\t/* if not creating empty dirs, then use mkdir to create the path on\n\t\t * demand right before files are copied.\n\t\t */\n\t\tinfo.mkdir_flags = GIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST;\n\t\tif ((flags & GIT_CPDIR_CHMOD_DIRS) != 0)\n\t\t\tinfo.mkdir_flags |= GIT_MKDIR_CHMOD_PATH;\n\t} else {\n\t\t/* otherwise, we will do simple mkdir as directories are encountered */\n\t\tinfo.mkdir_flags =\n\t\t\t((flags & GIT_CPDIR_CHMOD_DIRS) != 0) ? GIT_MKDIR_CHMOD : 0;\n\t}\n\n\terror = _cp_r_callback(&info, &path);\n\n\tgit_buf_free(&path);\n\tgit_buf_free(&info.to);\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_cp_r(\n\tconst char *from,\n\tconst char *to,\n\tuint32_t flags,\n\tmode_t dirmode)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tcp_r_info info;\n\n\tif (git_buf_joinpath(&path, from, \"\") < 0) /* ensure trailing slash */\n\t\treturn -1;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.to_root = to;\n\tinfo.flags   = flags;\n\tinfo.dirmode = dirmode;\n\tinfo.from_prefix = path.size;\n\tgit_buf_init(&info.to, 0);\n\n\t/* precalculate mkdir flags */\n\tif ((flags & GIT_CPDIR_CREATE_EMPTY_DIRS) == 0) {\n\t\t/* if not creating empty dirs, then use mkdir to create the path on\n\t\t * demand right before files are copied.\n\t\t */\n\t\tinfo.mkdir_flags = GIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST;\n\t\tif ((flags & GIT_CPDIR_CHMOD_DIRS) != 0)\n\t\t\tinfo.mkdir_flags |= GIT_MKDIR_CHMOD_PATH;\n\t} else {\n\t\t/* otherwise, we will do simple mkdir as directories are encountered */\n\t\tinfo.mkdir_flags =\n\t\t\t((flags & GIT_CPDIR_CHMOD_DIRS) != 0) ? GIT_MKDIR_CHMOD : 0;\n\t}\n\n\terror = _cp_r_callback(&info, &path);\n\n\tgit_buf_free(&path);\n\tgit_buf_free(&info.to);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_link",
          "args": [
            "git_repository_path(src)",
            "git_repository_path(repo)",
            "link"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "can_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "472-494",
          "snippet": "static bool can_link(const char *src, const char *dst, int link)\n{\n#ifdef GIT_WIN32\n\tGIT_UNUSED(src);\n\tGIT_UNUSED(dst);\n\tGIT_UNUSED(link);\n\treturn false;\n#else\n\n\tstruct stat st_src, st_dst;\n\n\tif (!link)\n\t\treturn false;\n\n\tif (p_stat(src, &st_src) < 0)\n\t\treturn false;\n\n\tif (p_stat(dst, &st_dst) < 0)\n\t\treturn false;\n\n\treturn st_src.st_dev == st_dst.st_dev;\n#endif\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);\n\nstatic bool can_link(const char *src, const char *dst, int link)\n{\n#ifdef GIT_WIN32\n\tGIT_UNUSED(src);\n\tGIT_UNUSED(dst);\n\tGIT_UNUSED(link);\n\treturn false;\n#else\n\n\tstruct stat st_src, st_dst;\n\n\tif (!link)\n\t\treturn false;\n\n\tif (p_stat(src, &st_src) < 0)\n\t\treturn false;\n\n\tif (p_stat(dst, &st_dst) < 0)\n\t\treturn false;\n\n\treturn st_src.st_dev == st_dst.st_dev;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_path",
          "args": [
            "repo"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1822-1826",
          "snippet": "const char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&dst_odb"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&dst_odb",
            "git_repository_path(repo)",
            "GIT_OBJECTS_DIR"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_open",
          "args": [
            "&src",
            "git_buf_cstr(&src_path)"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "557-561",
          "snippet": "int git_repository_open(git_repository **repo_out, const char *path)\n{\n\treturn git_repository_open_ext(\n\t\trepo_out, path, GIT_REPOSITORY_OPEN_NO_SEARCH, NULL);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_open(git_repository **repo_out, const char *path)\n{\n\treturn git_repository_open_ext(\n\t\trepo_out, path, GIT_REPOSITORY_OPEN_NO_SEARCH, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_from_url_or_path",
          "args": [
            "&src_path",
            "git_remote_url(remote)"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_from_url_or_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1434-1440",
          "snippet": "int git_path_from_url_or_path(git_buf *local_path_out, const char *url_or_path)\n{\n\tif (git_path_is_local_file_url(url_or_path))\n\t\treturn git_path_fromurl(local_path_out, url_or_path);\n\telse\n\t\treturn git_buf_sets(local_path_out, url_or_path);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_from_url_or_path(git_buf *local_path_out, const char *url_or_path)\n{\n\tif (git_path_is_local_file_url(url_or_path))\n\t\treturn git_path_fromurl(local_path_out, url_or_path);\n\telse\n\t\treturn git_buf_sets(local_path_out, url_or_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"the repository is not empty\""
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_is_empty",
          "args": [
            "repo"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1803-1820",
          "snippet": "int git_repository_is_empty(git_repository *repo)\n{\n\tgit_reference *head = NULL;\n\tint is_empty = 0;\n\n\tif (git_reference_lookup(&head, repo, GIT_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif (git_reference_type(head) == GIT_REF_SYMBOLIC)\n\t\tis_empty =\n\t\t\t(strcmp(git_reference_symbolic_target(head),\n\t\t\t\t\tGIT_REFS_HEADS_DIR \"master\") == 0) &&\n\t\t\trepo_contains_no_reference(repo);\n\n\tgit_reference_free(head);\n\n\treturn is_empty;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_is_empty(git_repository *repo)\n{\n\tgit_reference *head = NULL;\n\tint is_empty = 0;\n\n\tif (git_reference_lookup(&head, repo, GIT_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif (git_reference_type(head) == GIT_REF_SYMBOLIC)\n\t\tis_empty =\n\t\t\t(strcmp(git_reference_symbolic_target(head),\n\t\t\t\t\tGIT_REFS_HEADS_DIR \"master\") == 0) &&\n\t\t\trepo_contains_no_reference(repo);\n\n\tgit_reference_free(head);\n\n\treturn is_empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && remote"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);\n\nstatic int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link)\n{\n\tint error, flags;\n\tgit_repository *src;\n\tgit_buf src_odb = GIT_BUF_INIT, dst_odb = GIT_BUF_INIT, src_path = GIT_BUF_INIT;\n\tgit_buf reflog_message = GIT_BUF_INIT;\n\n\tassert(repo && remote);\n\n\tif (!git_repository_is_empty(repo)) {\n\t\tgiterr_set(GITERR_INVALID, \"the repository is not empty\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Let's figure out what path we should use for the source\n\t * repo, if it's not rooted, the path should be relative to\n\t * the repository's worktree/gitdir.\n\t */\n\tif ((error = git_path_from_url_or_path(&src_path, git_remote_url(remote))) < 0)\n\t\treturn error;\n\n\t/* Copy .git/objects/ from the source to the target */\n\tif ((error = git_repository_open(&src, git_buf_cstr(&src_path))) < 0) {\n\t\tgit_buf_free(&src_path);\n\t\treturn error;\n\t}\n\n\tgit_buf_joinpath(&src_odb, git_repository_path(src), GIT_OBJECTS_DIR);\n\tgit_buf_joinpath(&dst_odb, git_repository_path(repo), GIT_OBJECTS_DIR);\n\tif (git_buf_oom(&src_odb) || git_buf_oom(&dst_odb)) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tflags = 0;\n\tif (can_link(git_repository_path(src), git_repository_path(repo), link))\n\t\tflags |= GIT_CPDIR_LINK_FILES;\n\n\terror = git_futils_cp_r(git_buf_cstr(&src_odb), git_buf_cstr(&dst_odb),\n\t\t\t\tflags, GIT_OBJECT_DIR_MODE);\n\n\t/*\n\t * can_link() doesn't catch all variations, so if we hit an\n\t * error and did want to link, let's try again without trying\n\t * to link.\n\t */\n\tif (error < 0 && link) {\n\t\tflags &= ~GIT_CPDIR_LINK_FILES;\n\t\terror = git_futils_cp_r(git_buf_cstr(&src_odb), git_buf_cstr(&dst_odb),\n\t\t\t\t\tflags, GIT_OBJECT_DIR_MODE);\n\t}\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tgit_buf_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));\n\n\tif ((error = git_remote_fetch(remote, NULL, fetch_opts, git_buf_cstr(&reflog_message))) != 0)\n\t\tgoto cleanup;\n\n\terror = checkout_branch(repo, remote, co_opts, branch, git_buf_cstr(&reflog_message));\n\ncleanup:\n\tgit_buf_free(&reflog_message);\n\tgit_buf_free(&src_path);\n\tgit_buf_free(&src_odb);\n\tgit_buf_free(&dst_odb);\n\tgit_repository_free(src);\n\treturn error;\n}"
  },
  {
    "function_name": "can_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "472-494",
    "snippet": "static bool can_link(const char *src, const char *dst, int link)\n{\n#ifdef GIT_WIN32\n\tGIT_UNUSED(src);\n\tGIT_UNUSED(dst);\n\tGIT_UNUSED(link);\n\treturn false;\n#else\n\n\tstruct stat st_src, st_dst;\n\n\tif (!link)\n\t\treturn false;\n\n\tif (p_stat(src, &st_src) < 0)\n\t\treturn false;\n\n\tif (p_stat(dst, &st_dst) < 0)\n\t\treturn false;\n\n\treturn st_src.st_dev == st_dst.st_dev;\n#endif\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "dst",
            "&st_dst"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "link"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "dst"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "src"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);\n\nstatic bool can_link(const char *src, const char *dst, int link)\n{\n#ifdef GIT_WIN32\n\tGIT_UNUSED(src);\n\tGIT_UNUSED(dst);\n\tGIT_UNUSED(link);\n\treturn false;\n#else\n\n\tstruct stat st_src, st_dst;\n\n\tif (!link)\n\t\treturn false;\n\n\tif (p_stat(src, &st_src) < 0)\n\t\treturn false;\n\n\tif (p_stat(dst, &st_dst) < 0)\n\t\treturn false;\n\n\treturn st_src.st_dev == st_dst.st_dev;\n#endif\n}"
  },
  {
    "function_name": "repository_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "464-470",
    "snippet": "static const char *repository_base(git_repository *repo)\n{\n\tif (git_repository_is_bare(repo))\n\t\treturn git_repository_path(repo);\n\n\treturn git_repository_workdir(repo);\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_path",
          "args": [
            "repo"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1822-1826",
          "snippet": "const char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_is_bare",
          "args": [
            "repo"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_is_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1882-1886",
          "snippet": "int git_repository_is_bare(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->is_bare;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_is_bare(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->is_bare;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic const char *repository_base(git_repository *repo)\n{\n\tif (git_repository_is_bare(repo))\n\t\treturn git_repository_path(repo);\n\n\treturn git_repository_workdir(repo);\n}"
  },
  {
    "function_name": "git_clone_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "457-462",
    "snippet": "int git_clone_init_options(git_clone_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_clone_options, GIT_CLONE_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_clone_options",
            "GIT_CLONE_OPTIONS_INIT"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nint git_clone_init_options(git_clone_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_clone_options, GIT_CLONE_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "384-455",
    "snippet": "int git_clone(\n\tgit_repository **out,\n\tconst char *url,\n\tconst char *local_path,\n\tconst git_clone_options *_options)\n{\n\tint error = 0;\n\tgit_repository *repo = NULL;\n\tgit_remote *origin;\n\tgit_clone_options options = GIT_CLONE_OPTIONS_INIT;\n\tuint32_t rmdir_flags = GIT_RMDIR_REMOVE_FILES;\n\tgit_repository_create_cb repository_cb;\n\n\tassert(out && url && local_path);\n\n\tif (_options)\n\t\tmemcpy(&options, _options, sizeof(git_clone_options));\n\n\tGITERR_CHECK_VERSION(&options, GIT_CLONE_OPTIONS_VERSION, \"git_clone_options\");\n\n\t/* Only clone to a new directory or an empty directory */\n\tif (git_path_exists(local_path) && !git_path_is_empty_dir(local_path)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"'%s' exists and is not an empty directory\", local_path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\t/* Only remove the root directory on failure if we create it */\n\tif (git_path_exists(local_path))\n\t\trmdir_flags |= GIT_RMDIR_SKIP_ROOT;\n\n\tif (options.repository_cb)\n\t\trepository_cb = options.repository_cb;\n\telse\n\t\trepository_cb = default_repository_create;\n\n\tif ((error = repository_cb(&repo, local_path, options.bare, options.repository_cb_payload)) < 0)\n\t\treturn error;\n\n\tif (!(error = create_and_configure_origin(&origin, repo, url, &options))) {\n\t\tint clone_local = git_clone__should_clone_local(url, options.local);\n\t\tint link = options.local != GIT_CLONE_LOCAL_NO_LINKS;\n\n\t\tif (clone_local == 1)\n\t\t\terror = clone_local_into(\n\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,\n\t\t\t\toptions.checkout_branch, link);\n\t\telse if (clone_local == 0)\n\t\t\terror = clone_into(\n\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,\n\t\t\t\toptions.checkout_branch);\n\t\telse\n\t\t\terror = -1;\n\n\t\tgit_remote_free(origin);\n\t}\n\n\tif (error != 0) {\n\t\tgit_error_state last_error = {0};\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\tgit_repository_free(repo);\n\t\trepo = NULL;\n\n\t\t(void)git_futils_rmdir_r(local_path, NULL, rmdir_flags);\n\n\t\tgiterr_state_restore(&last_error);\n\t}\n\n\t*out = repo;\n\treturn error;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_state_restore",
          "args": [
            "&last_error"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_state_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "165-182",
          "snippet": "int giterr_state_restore(git_error_state *state)\n{\n\tint ret = 0;\n\n\tgiterr_clear();\n\n\tif (state && state->error_msg.message) {\n\t\tif (state->oom)\n\t\t\tgiterr_set_oom();\n\t\telse\n\t\t\tset_error(state->error_msg.klass, state->error_msg.message);\n\n\t\tret = state->error_code;\n\t\tmemset(state, 0, sizeof(git_error_state));\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nint giterr_state_restore(git_error_state *state)\n{\n\tint ret = 0;\n\n\tgiterr_clear();\n\n\tif (state && state->error_msg.message) {\n\t\tif (state->oom)\n\t\t\tgiterr_set_oom();\n\t\telse\n\t\t\tset_error(state->error_msg.klass, state->error_msg.message);\n\n\t\tret = state->error_code;\n\t\tmemset(state, 0, sizeof(git_error_state));\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_rmdir_r",
          "args": [
            "local_path",
            "NULL",
            "rmdir_flags"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_rmdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "753-784",
          "snippet": "int git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_free",
          "args": [
            "repo"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "121-148",
          "snippet": "void git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nvoid git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_state_capture",
          "args": [
            "&last_error",
            "error"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_state_capture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "139-163",
          "snippet": "int giterr_state_capture(git_error_state *state, int error_code)\n{\n\tgit_error *error = GIT_GLOBAL->last_error;\n\tgit_buf *error_buf = &GIT_GLOBAL->error_buf;\n\n\tmemset(state, 0, sizeof(git_error_state));\n\n\tif (!error_code)\n\t\treturn 0;\n\n\tstate->error_code = error_code;\n\tstate->oom = (error == &g_git_oom_error);\n\n\tif (error) {\n\t\tstate->error_msg.klass = error->klass;\n\n\t\tif (state->oom)\n\t\t\tstate->error_msg.message = g_git_oom_error.message;\n\t\telse\n\t\t\tstate->error_msg.message = git_buf_detach(error_buf);\n\t}\n\n\tgiterr_clear();\n\treturn error_code;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};\n\nint giterr_state_capture(git_error_state *state, int error_code)\n{\n\tgit_error *error = GIT_GLOBAL->last_error;\n\tgit_buf *error_buf = &GIT_GLOBAL->error_buf;\n\n\tmemset(state, 0, sizeof(git_error_state));\n\n\tif (!error_code)\n\t\treturn 0;\n\n\tstate->error_code = error_code;\n\tstate->oom = (error == &g_git_oom_error);\n\n\tif (error) {\n\t\tstate->error_msg.klass = error->klass;\n\n\t\tif (state->oom)\n\t\t\tstate->error_msg.message = g_git_oom_error.message;\n\t\telse\n\t\t\tstate->error_msg.message = git_buf_detach(error_buf);\n\t}\n\n\tgiterr_clear();\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "origin"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone_into",
          "args": [
            "repo",
            "origin",
            "&options.fetch_opts",
            "&options.checkout_opts",
            "options.checkout_branch"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "clone_into",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "324-356",
          "snippet": "static int clone_into(git_repository *repo, git_remote *_remote, const git_fetch_options *opts, const git_checkout_options *co_opts, const char *branch)\n{\n\tint error;\n\tgit_buf reflog_message = GIT_BUF_INIT;\n\tgit_fetch_options fetch_opts;\n\tgit_remote *remote;\n\n\tassert(repo && _remote);\n\n\tif (!git_repository_is_empty(repo)) {\n\t\tgiterr_set(GITERR_INVALID, \"the repository is not empty\");\n\t\treturn -1;\n\t}\n\n\tif ((error = git_remote_dup(&remote, _remote)) < 0)\n\t\treturn error;\n\n\tmemcpy(&fetch_opts, opts, sizeof(git_fetch_options));\n\tfetch_opts.update_fetchhead = 0;\n\tfetch_opts.download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;\n\tgit_buf_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));\n\n\tif ((error = git_remote_fetch(remote, NULL, &fetch_opts, git_buf_cstr(&reflog_message))) != 0)\n\t\tgoto cleanup;\n\n\terror = checkout_branch(repo, remote, co_opts, branch, git_buf_cstr(&reflog_message));\n\ncleanup:\n\tgit_remote_free(remote);\n\tgit_buf_free(&reflog_message);\n\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int clone_into(git_repository *repo, git_remote *_remote, const git_fetch_options *opts, const git_checkout_options *co_opts, const char *branch)\n{\n\tint error;\n\tgit_buf reflog_message = GIT_BUF_INIT;\n\tgit_fetch_options fetch_opts;\n\tgit_remote *remote;\n\n\tassert(repo && _remote);\n\n\tif (!git_repository_is_empty(repo)) {\n\t\tgiterr_set(GITERR_INVALID, \"the repository is not empty\");\n\t\treturn -1;\n\t}\n\n\tif ((error = git_remote_dup(&remote, _remote)) < 0)\n\t\treturn error;\n\n\tmemcpy(&fetch_opts, opts, sizeof(git_fetch_options));\n\tfetch_opts.update_fetchhead = 0;\n\tfetch_opts.download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;\n\tgit_buf_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));\n\n\tif ((error = git_remote_fetch(remote, NULL, &fetch_opts, git_buf_cstr(&reflog_message))) != 0)\n\t\tgoto cleanup;\n\n\terror = checkout_branch(repo, remote, co_opts, branch, git_buf_cstr(&reflog_message));\n\ncleanup:\n\tgit_remote_free(remote);\n\tgit_buf_free(&reflog_message);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone_local_into",
          "args": [
            "repo",
            "origin",
            "&options.fetch_opts",
            "&options.checkout_opts",
            "options.checkout_branch",
            "link"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "clone_local_into",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "496-566",
          "snippet": "static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link)\n{\n\tint error, flags;\n\tgit_repository *src;\n\tgit_buf src_odb = GIT_BUF_INIT, dst_odb = GIT_BUF_INIT, src_path = GIT_BUF_INIT;\n\tgit_buf reflog_message = GIT_BUF_INIT;\n\n\tassert(repo && remote);\n\n\tif (!git_repository_is_empty(repo)) {\n\t\tgiterr_set(GITERR_INVALID, \"the repository is not empty\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Let's figure out what path we should use for the source\n\t * repo, if it's not rooted, the path should be relative to\n\t * the repository's worktree/gitdir.\n\t */\n\tif ((error = git_path_from_url_or_path(&src_path, git_remote_url(remote))) < 0)\n\t\treturn error;\n\n\t/* Copy .git/objects/ from the source to the target */\n\tif ((error = git_repository_open(&src, git_buf_cstr(&src_path))) < 0) {\n\t\tgit_buf_free(&src_path);\n\t\treturn error;\n\t}\n\n\tgit_buf_joinpath(&src_odb, git_repository_path(src), GIT_OBJECTS_DIR);\n\tgit_buf_joinpath(&dst_odb, git_repository_path(repo), GIT_OBJECTS_DIR);\n\tif (git_buf_oom(&src_odb) || git_buf_oom(&dst_odb)) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tflags = 0;\n\tif (can_link(git_repository_path(src), git_repository_path(repo), link))\n\t\tflags |= GIT_CPDIR_LINK_FILES;\n\n\terror = git_futils_cp_r(git_buf_cstr(&src_odb), git_buf_cstr(&dst_odb),\n\t\t\t\tflags, GIT_OBJECT_DIR_MODE);\n\n\t/*\n\t * can_link() doesn't catch all variations, so if we hit an\n\t * error and did want to link, let's try again without trying\n\t * to link.\n\t */\n\tif (error < 0 && link) {\n\t\tflags &= ~GIT_CPDIR_LINK_FILES;\n\t\terror = git_futils_cp_r(git_buf_cstr(&src_odb), git_buf_cstr(&dst_odb),\n\t\t\t\t\tflags, GIT_OBJECT_DIR_MODE);\n\t}\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tgit_buf_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));\n\n\tif ((error = git_remote_fetch(remote, NULL, fetch_opts, git_buf_cstr(&reflog_message))) != 0)\n\t\tgoto cleanup;\n\n\terror = checkout_branch(repo, remote, co_opts, branch, git_buf_cstr(&reflog_message));\n\ncleanup:\n\tgit_buf_free(&reflog_message);\n\tgit_buf_free(&src_path);\n\tgit_buf_free(&src_odb);\n\tgit_buf_free(&dst_odb);\n\tgit_repository_free(src);\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);\n\nstatic int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link)\n{\n\tint error, flags;\n\tgit_repository *src;\n\tgit_buf src_odb = GIT_BUF_INIT, dst_odb = GIT_BUF_INIT, src_path = GIT_BUF_INIT;\n\tgit_buf reflog_message = GIT_BUF_INIT;\n\n\tassert(repo && remote);\n\n\tif (!git_repository_is_empty(repo)) {\n\t\tgiterr_set(GITERR_INVALID, \"the repository is not empty\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Let's figure out what path we should use for the source\n\t * repo, if it's not rooted, the path should be relative to\n\t * the repository's worktree/gitdir.\n\t */\n\tif ((error = git_path_from_url_or_path(&src_path, git_remote_url(remote))) < 0)\n\t\treturn error;\n\n\t/* Copy .git/objects/ from the source to the target */\n\tif ((error = git_repository_open(&src, git_buf_cstr(&src_path))) < 0) {\n\t\tgit_buf_free(&src_path);\n\t\treturn error;\n\t}\n\n\tgit_buf_joinpath(&src_odb, git_repository_path(src), GIT_OBJECTS_DIR);\n\tgit_buf_joinpath(&dst_odb, git_repository_path(repo), GIT_OBJECTS_DIR);\n\tif (git_buf_oom(&src_odb) || git_buf_oom(&dst_odb)) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tflags = 0;\n\tif (can_link(git_repository_path(src), git_repository_path(repo), link))\n\t\tflags |= GIT_CPDIR_LINK_FILES;\n\n\terror = git_futils_cp_r(git_buf_cstr(&src_odb), git_buf_cstr(&dst_odb),\n\t\t\t\tflags, GIT_OBJECT_DIR_MODE);\n\n\t/*\n\t * can_link() doesn't catch all variations, so if we hit an\n\t * error and did want to link, let's try again without trying\n\t * to link.\n\t */\n\tif (error < 0 && link) {\n\t\tflags &= ~GIT_CPDIR_LINK_FILES;\n\t\terror = git_futils_cp_r(git_buf_cstr(&src_odb), git_buf_cstr(&dst_odb),\n\t\t\t\t\tflags, GIT_OBJECT_DIR_MODE);\n\t}\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tgit_buf_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));\n\n\tif ((error = git_remote_fetch(remote, NULL, fetch_opts, git_buf_cstr(&reflog_message))) != 0)\n\t\tgoto cleanup;\n\n\terror = checkout_branch(repo, remote, co_opts, branch, git_buf_cstr(&reflog_message));\n\ncleanup:\n\tgit_buf_free(&reflog_message);\n\tgit_buf_free(&src_path);\n\tgit_buf_free(&src_odb);\n\tgit_buf_free(&dst_odb);\n\tgit_repository_free(src);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_clone__should_clone_local",
          "args": [
            "url",
            "options.local"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "git_clone__should_clone_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "358-382",
          "snippet": "int git_clone__should_clone_local(const char *url_or_path, git_clone_local_t local)\n{\n\tgit_buf fromurl = GIT_BUF_INIT;\n\tconst char *path = url_or_path;\n\tbool is_url, is_local;\n\n\tif (local == GIT_CLONE_NO_LOCAL)\n\t\treturn 0;\n\n\tif ((is_url = git_path_is_local_file_url(url_or_path)) != 0) {\n\t\tif (git_path_fromurl(&fromurl, url_or_path) < 0) {\n\t\t\tis_local = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpath = fromurl.ptr;\n\t}\n\n\tis_local = (!is_url || local != GIT_CLONE_LOCAL_AUTO) &&\n\t\tgit_path_isdir(path);\n\ndone:\n\tgit_buf_free(&fromurl);\n\treturn is_local;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nint git_clone__should_clone_local(const char *url_or_path, git_clone_local_t local)\n{\n\tgit_buf fromurl = GIT_BUF_INIT;\n\tconst char *path = url_or_path;\n\tbool is_url, is_local;\n\n\tif (local == GIT_CLONE_NO_LOCAL)\n\t\treturn 0;\n\n\tif ((is_url = git_path_is_local_file_url(url_or_path)) != 0) {\n\t\tif (git_path_fromurl(&fromurl, url_or_path) < 0) {\n\t\t\tis_local = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpath = fromurl.ptr;\n\t}\n\n\tis_local = (!is_url || local != GIT_CLONE_LOCAL_AUTO) &&\n\t\tgit_path_isdir(path);\n\ndone:\n\tgit_buf_free(&fromurl);\n\treturn is_local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_and_configure_origin",
          "args": [
            "&origin",
            "repo",
            "url",
            "&options"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "create_and_configure_origin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "254-288",
          "snippet": "static int create_and_configure_origin(\n\t\tgit_remote **out,\n\t\tgit_repository *repo,\n\t\tconst char *url,\n\t\tconst git_clone_options *options)\n{\n\tint error;\n\tgit_remote *origin = NULL;\n\tchar buf[GIT_PATH_MAX];\n\tgit_remote_create_cb remote_create = options->remote_cb;\n\tvoid *payload = options->remote_cb_payload;\n\n\t/* If the path exists and is a dir, the url should be the absolute path */\n\tif (git_path_root(url) < 0 && git_path_exists(url) && git_path_isdir(url)) {\n\t\tif (p_realpath(url, buf) == NULL)\n\t\t\treturn -1;\n\n\t\turl = buf;\n\t}\n\n\tif (!remote_create) {\n\t\tremote_create = default_remote_create;\n\t\tpayload = NULL;\n\t}\n\n\tif ((error = remote_create(&origin, repo, \"origin\", url, payload)) < 0)\n\t\tgoto on_error;\n\n\t*out = origin;\n\treturn 0;\n\non_error:\n\tgit_remote_free(origin);\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int create_and_configure_origin(\n\t\tgit_remote **out,\n\t\tgit_repository *repo,\n\t\tconst char *url,\n\t\tconst git_clone_options *options)\n{\n\tint error;\n\tgit_remote *origin = NULL;\n\tchar buf[GIT_PATH_MAX];\n\tgit_remote_create_cb remote_create = options->remote_cb;\n\tvoid *payload = options->remote_cb_payload;\n\n\t/* If the path exists and is a dir, the url should be the absolute path */\n\tif (git_path_root(url) < 0 && git_path_exists(url) && git_path_isdir(url)) {\n\t\tif (p_realpath(url, buf) == NULL)\n\t\t\treturn -1;\n\n\t\turl = buf;\n\t}\n\n\tif (!remote_create) {\n\t\tremote_create = default_remote_create;\n\t\tpayload = NULL;\n\t}\n\n\tif ((error = remote_create(&origin, repo, \"origin\", url, payload)) < 0)\n\t\tgoto on_error;\n\n\t*out = origin;\n\treturn 0;\n\non_error:\n\tgit_remote_free(origin);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "repository_cb",
          "args": [
            "&repo",
            "local_path",
            "options.bare",
            "options.repository_cb_payload"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "local_path"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"'%s' exists and is not an empty directory\"",
            "local_path"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_is_empty_dir",
          "args": [
            "local_path"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_is_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "591-607",
          "snippet": "bool git_path_is_empty_dir(const char *path)\n{\n\tint error;\n\tgit_buf dir = GIT_BUF_INIT;\n\n\tif (!git_path_isdir(path))\n\t\treturn false;\n\n\tif ((error = git_buf_sets(&dir, path)) != 0)\n\t\tgiterr_clear();\n\telse\n\t\terror = git_path_direach(&dir, 0, path_found_entry, NULL);\n\n\tgit_buf_free(&dir);\n\n\treturn !error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_is_empty_dir(const char *path)\n{\n\tint error;\n\tgit_buf dir = GIT_BUF_INIT;\n\n\tif (!git_path_isdir(path))\n\t\treturn false;\n\n\tif ((error = git_buf_sets(&dir, path)) != 0)\n\t\tgiterr_clear();\n\telse\n\t\terror = git_path_direach(&dir, 0, path_found_entry, NULL);\n\n\tgit_buf_free(&dir);\n\n\treturn !error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "&options",
            "GIT_CLONE_OPTIONS_VERSION",
            "\"git_clone_options\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&options",
            "_options",
            "sizeof(git_clone_options)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && url && local_path"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);\n\nint git_clone(\n\tgit_repository **out,\n\tconst char *url,\n\tconst char *local_path,\n\tconst git_clone_options *_options)\n{\n\tint error = 0;\n\tgit_repository *repo = NULL;\n\tgit_remote *origin;\n\tgit_clone_options options = GIT_CLONE_OPTIONS_INIT;\n\tuint32_t rmdir_flags = GIT_RMDIR_REMOVE_FILES;\n\tgit_repository_create_cb repository_cb;\n\n\tassert(out && url && local_path);\n\n\tif (_options)\n\t\tmemcpy(&options, _options, sizeof(git_clone_options));\n\n\tGITERR_CHECK_VERSION(&options, GIT_CLONE_OPTIONS_VERSION, \"git_clone_options\");\n\n\t/* Only clone to a new directory or an empty directory */\n\tif (git_path_exists(local_path) && !git_path_is_empty_dir(local_path)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"'%s' exists and is not an empty directory\", local_path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\t/* Only remove the root directory on failure if we create it */\n\tif (git_path_exists(local_path))\n\t\trmdir_flags |= GIT_RMDIR_SKIP_ROOT;\n\n\tif (options.repository_cb)\n\t\trepository_cb = options.repository_cb;\n\telse\n\t\trepository_cb = default_repository_create;\n\n\tif ((error = repository_cb(&repo, local_path, options.bare, options.repository_cb_payload)) < 0)\n\t\treturn error;\n\n\tif (!(error = create_and_configure_origin(&origin, repo, url, &options))) {\n\t\tint clone_local = git_clone__should_clone_local(url, options.local);\n\t\tint link = options.local != GIT_CLONE_LOCAL_NO_LINKS;\n\n\t\tif (clone_local == 1)\n\t\t\terror = clone_local_into(\n\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,\n\t\t\t\toptions.checkout_branch, link);\n\t\telse if (clone_local == 0)\n\t\t\terror = clone_into(\n\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,\n\t\t\t\toptions.checkout_branch);\n\t\telse\n\t\t\terror = -1;\n\n\t\tgit_remote_free(origin);\n\t}\n\n\tif (error != 0) {\n\t\tgit_error_state last_error = {0};\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\tgit_repository_free(repo);\n\t\trepo = NULL;\n\n\t\t(void)git_futils_rmdir_r(local_path, NULL, rmdir_flags);\n\n\t\tgiterr_state_restore(&last_error);\n\t}\n\n\t*out = repo;\n\treturn error;\n}"
  },
  {
    "function_name": "git_clone__should_clone_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "358-382",
    "snippet": "int git_clone__should_clone_local(const char *url_or_path, git_clone_local_t local)\n{\n\tgit_buf fromurl = GIT_BUF_INIT;\n\tconst char *path = url_or_path;\n\tbool is_url, is_local;\n\n\tif (local == GIT_CLONE_NO_LOCAL)\n\t\treturn 0;\n\n\tif ((is_url = git_path_is_local_file_url(url_or_path)) != 0) {\n\t\tif (git_path_fromurl(&fromurl, url_or_path) < 0) {\n\t\t\tis_local = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpath = fromurl.ptr;\n\t}\n\n\tis_local = (!is_url || local != GIT_CLONE_LOCAL_AUTO) &&\n\t\tgit_path_isdir(path);\n\ndone:\n\tgit_buf_free(&fromurl);\n\treturn is_local;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&fromurl"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "path"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_fromurl",
          "args": [
            "&fromurl",
            "url_or_path"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_fromurl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "421-437",
          "snippet": "int git_path_fromurl(git_buf *local_path_out, const char *file_url)\n{\n\tint offset;\n\n\tassert(local_path_out && file_url);\n\n\tif ((offset = local_file_url_prefixlen(file_url)) < 0 ||\n\t\tfile_url[offset] == '\\0' || file_url[offset] == '/')\n\t\treturn error_invalid_local_file_uri(file_url);\n\n#ifndef GIT_WIN32\n\toffset--;\t/* A *nix absolute path starts with a forward slash */\n#endif\n\n\tgit_buf_clear(local_path_out);\n\treturn git__percent_decode(local_path_out, file_url + offset);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_fromurl(git_buf *local_path_out, const char *file_url)\n{\n\tint offset;\n\n\tassert(local_path_out && file_url);\n\n\tif ((offset = local_file_url_prefixlen(file_url)) < 0 ||\n\t\tfile_url[offset] == '\\0' || file_url[offset] == '/')\n\t\treturn error_invalid_local_file_uri(file_url);\n\n#ifndef GIT_WIN32\n\toffset--;\t/* A *nix absolute path starts with a forward slash */\n#endif\n\n\tgit_buf_clear(local_path_out);\n\treturn git__percent_decode(local_path_out, file_url + offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_is_local_file_url",
          "args": [
            "url_or_path"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_is_local_file_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "416-419",
          "snippet": "bool git_path_is_local_file_url(const char *file_url)\n{\n\treturn (local_file_url_prefixlen(file_url) > 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_is_local_file_url(const char *file_url)\n{\n\treturn (local_file_url_prefixlen(file_url) > 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nint git_clone__should_clone_local(const char *url_or_path, git_clone_local_t local)\n{\n\tgit_buf fromurl = GIT_BUF_INIT;\n\tconst char *path = url_or_path;\n\tbool is_url, is_local;\n\n\tif (local == GIT_CLONE_NO_LOCAL)\n\t\treturn 0;\n\n\tif ((is_url = git_path_is_local_file_url(url_or_path)) != 0) {\n\t\tif (git_path_fromurl(&fromurl, url_or_path) < 0) {\n\t\t\tis_local = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpath = fromurl.ptr;\n\t}\n\n\tis_local = (!is_url || local != GIT_CLONE_LOCAL_AUTO) &&\n\t\tgit_path_isdir(path);\n\ndone:\n\tgit_buf_free(&fromurl);\n\treturn is_local;\n}"
  },
  {
    "function_name": "clone_into",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "324-356",
    "snippet": "static int clone_into(git_repository *repo, git_remote *_remote, const git_fetch_options *opts, const git_checkout_options *co_opts, const char *branch)\n{\n\tint error;\n\tgit_buf reflog_message = GIT_BUF_INIT;\n\tgit_fetch_options fetch_opts;\n\tgit_remote *remote;\n\n\tassert(repo && _remote);\n\n\tif (!git_repository_is_empty(repo)) {\n\t\tgiterr_set(GITERR_INVALID, \"the repository is not empty\");\n\t\treturn -1;\n\t}\n\n\tif ((error = git_remote_dup(&remote, _remote)) < 0)\n\t\treturn error;\n\n\tmemcpy(&fetch_opts, opts, sizeof(git_fetch_options));\n\tfetch_opts.update_fetchhead = 0;\n\tfetch_opts.download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;\n\tgit_buf_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));\n\n\tif ((error = git_remote_fetch(remote, NULL, &fetch_opts, git_buf_cstr(&reflog_message))) != 0)\n\t\tgoto cleanup;\n\n\terror = checkout_branch(repo, remote, co_opts, branch, git_buf_cstr(&reflog_message));\n\ncleanup:\n\tgit_remote_free(remote);\n\tgit_buf_free(&reflog_message);\n\n\treturn error;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&reflog_message"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkout_branch",
          "args": [
            "repo",
            "remote",
            "co_opts",
            "branch",
            "git_buf_cstr(&reflog_message)"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "checkout_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "307-322",
          "snippet": "static int checkout_branch(git_repository *repo, git_remote *remote, const git_checkout_options *co_opts, const char *branch, const char *reflog_message)\n{\n\tint error;\n\n\tif (branch)\n\t\terror = update_head_to_branch(repo, git_remote_name(remote), branch,\n\t\t\t\treflog_message);\n\t/* Point HEAD to the same ref as the remote's head */\n\telse\n\t\terror = update_head_to_remote(repo, remote, reflog_message);\n\n\tif (!error && should_checkout(repo, git_repository_is_bare(repo), co_opts))\n\t\terror = git_checkout_head(repo, co_opts);\n\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int checkout_branch(git_repository *repo, git_remote *remote, const git_checkout_options *co_opts, const char *branch, const char *reflog_message)\n{\n\tint error;\n\n\tif (branch)\n\t\terror = update_head_to_branch(repo, git_remote_name(remote), branch,\n\t\t\t\treflog_message);\n\t/* Point HEAD to the same ref as the remote's head */\n\telse\n\t\terror = update_head_to_remote(repo, remote, reflog_message);\n\n\tif (!error && should_checkout(repo, git_repository_is_bare(repo), co_opts))\n\t\terror = git_checkout_head(repo, co_opts);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&reflog_message"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_fetch",
          "args": [
            "remote",
            "NULL",
            "&fetch_opts",
            "git_buf_cstr(&reflog_message)"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "962-1023",
          "snippet": "int git_remote_fetch(\n\t\tgit_remote *remote,\n\t\tconst git_strarray *refspecs,\n\t\tconst git_fetch_options *opts,\n\t\tconst char *reflog_message)\n{\n\tint error, update_fetchhead = 1;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\tbool prune = false;\n\tgit_buf reflog_msg_buf = GIT_BUF_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t\tupdate_fetchhead = opts->update_fetchhead;\n\t\ttagopt = opts->download_tags;\n\t}\n\n\t/* Connect and download everything */\n\tif ((error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) != 0)\n\t\treturn error;\n\n\terror = git_remote_download(remote, refspecs, opts);\n\n\t/* We don't need to be connected anymore */\n\tgit_remote_disconnect(remote);\n\n\t/* If the download failed, return the error */\n\tif (error != 0)\n\t\treturn error;\n\n\t/* Default reflog message */\n\tif (reflog_message)\n\t\tgit_buf_sets(&reflog_msg_buf, reflog_message);\n\telse {\n\t\tgit_buf_printf(&reflog_msg_buf, \"fetch %s\",\n\t\t\t\tremote->name ? remote->name : remote->url);\n\t}\n\n\t/* Create \"remote/foo\" branches for all remote branches */\n\terror = git_remote_update_tips(remote, cbs, update_fetchhead, tagopt, git_buf_cstr(&reflog_msg_buf));\n\tgit_buf_free(&reflog_msg_buf);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (opts && opts->prune == GIT_FETCH_PRUNE)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_PRUNE_UNSPECIFIED && remote->prune_refs)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_NO_PRUNE)\n\t\tprune = false;\n\telse\n\t\tprune = remote->prune_refs;\n\n\tif (prune)\n\t\terror = git_remote_prune(remote, cbs);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_fetch(\n\t\tgit_remote *remote,\n\t\tconst git_strarray *refspecs,\n\t\tconst git_fetch_options *opts,\n\t\tconst char *reflog_message)\n{\n\tint error, update_fetchhead = 1;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\tbool prune = false;\n\tgit_buf reflog_msg_buf = GIT_BUF_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t\tupdate_fetchhead = opts->update_fetchhead;\n\t\ttagopt = opts->download_tags;\n\t}\n\n\t/* Connect and download everything */\n\tif ((error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) != 0)\n\t\treturn error;\n\n\terror = git_remote_download(remote, refspecs, opts);\n\n\t/* We don't need to be connected anymore */\n\tgit_remote_disconnect(remote);\n\n\t/* If the download failed, return the error */\n\tif (error != 0)\n\t\treturn error;\n\n\t/* Default reflog message */\n\tif (reflog_message)\n\t\tgit_buf_sets(&reflog_msg_buf, reflog_message);\n\telse {\n\t\tgit_buf_printf(&reflog_msg_buf, \"fetch %s\",\n\t\t\t\tremote->name ? remote->name : remote->url);\n\t}\n\n\t/* Create \"remote/foo\" branches for all remote branches */\n\terror = git_remote_update_tips(remote, cbs, update_fetchhead, tagopt, git_buf_cstr(&reflog_msg_buf));\n\tgit_buf_free(&reflog_msg_buf);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (opts && opts->prune == GIT_FETCH_PRUNE)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_PRUNE_UNSPECIFIED && remote->prune_refs)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_NO_PRUNE)\n\t\tprune = false;\n\telse\n\t\tprune = remote->prune_refs;\n\n\tif (prune)\n\t\terror = git_remote_prune(remote, cbs);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&reflog_message",
            "\"clone: from %s\"",
            "git_remote_url(remote)"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_url",
          "args": [
            "remote"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "609-613",
          "snippet": "const char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nconst char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fetch_opts",
            "opts",
            "sizeof(git_fetch_options)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_remote_dup",
          "args": [
            "&remote",
            "_remote"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "334-381",
          "snippet": "int git_remote_dup(git_remote **dest, git_remote *source)\n{\n\tsize_t i;\n\tint error = 0;\n\tgit_refspec *spec;\n\tgit_remote *remote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tif (source->name != NULL) {\n\t\tremote->name = git__strdup(source->name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\t}\n\n\tif (source->url != NULL) {\n\t\tremote->url = git__strdup(source->url);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tif (source->pushurl != NULL) {\n\t\tremote->pushurl = git__strdup(source->pushurl);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tremote->repo = source->repo;\n\tremote->download_tags = source->download_tags;\n\tremote->prune_refs = source->prune_refs;\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tgit_vector_foreach(&source->refspecs, i, spec) {\n\t\tif ((error = add_refspec(remote, spec->string, !spec->push)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t*dest = remote;\n\ncleanup:\n\n\tif (error < 0)\n\t\tgit__free(remote);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_dup(git_remote **dest, git_remote *source)\n{\n\tsize_t i;\n\tint error = 0;\n\tgit_refspec *spec;\n\tgit_remote *remote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tif (source->name != NULL) {\n\t\tremote->name = git__strdup(source->name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\t}\n\n\tif (source->url != NULL) {\n\t\tremote->url = git__strdup(source->url);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tif (source->pushurl != NULL) {\n\t\tremote->pushurl = git__strdup(source->pushurl);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tremote->repo = source->repo;\n\tremote->download_tags = source->download_tags;\n\tremote->prune_refs = source->prune_refs;\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tgit_vector_foreach(&source->refspecs, i, spec) {\n\t\tif ((error = add_refspec(remote, spec->string, !spec->push)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t*dest = remote;\n\ncleanup:\n\n\tif (error < 0)\n\t\tgit__free(remote);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"the repository is not empty\""
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_is_empty",
          "args": [
            "repo"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1803-1820",
          "snippet": "int git_repository_is_empty(git_repository *repo)\n{\n\tgit_reference *head = NULL;\n\tint is_empty = 0;\n\n\tif (git_reference_lookup(&head, repo, GIT_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif (git_reference_type(head) == GIT_REF_SYMBOLIC)\n\t\tis_empty =\n\t\t\t(strcmp(git_reference_symbolic_target(head),\n\t\t\t\t\tGIT_REFS_HEADS_DIR \"master\") == 0) &&\n\t\t\trepo_contains_no_reference(repo);\n\n\tgit_reference_free(head);\n\n\treturn is_empty;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_is_empty(git_repository *repo)\n{\n\tgit_reference *head = NULL;\n\tint is_empty = 0;\n\n\tif (git_reference_lookup(&head, repo, GIT_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif (git_reference_type(head) == GIT_REF_SYMBOLIC)\n\t\tis_empty =\n\t\t\t(strcmp(git_reference_symbolic_target(head),\n\t\t\t\t\tGIT_REFS_HEADS_DIR \"master\") == 0) &&\n\t\t\trepo_contains_no_reference(repo);\n\n\tgit_reference_free(head);\n\n\treturn is_empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && _remote"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int clone_into(git_repository *repo, git_remote *_remote, const git_fetch_options *opts, const git_checkout_options *co_opts, const char *branch)\n{\n\tint error;\n\tgit_buf reflog_message = GIT_BUF_INIT;\n\tgit_fetch_options fetch_opts;\n\tgit_remote *remote;\n\n\tassert(repo && _remote);\n\n\tif (!git_repository_is_empty(repo)) {\n\t\tgiterr_set(GITERR_INVALID, \"the repository is not empty\");\n\t\treturn -1;\n\t}\n\n\tif ((error = git_remote_dup(&remote, _remote)) < 0)\n\t\treturn error;\n\n\tmemcpy(&fetch_opts, opts, sizeof(git_fetch_options));\n\tfetch_opts.update_fetchhead = 0;\n\tfetch_opts.download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;\n\tgit_buf_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));\n\n\tif ((error = git_remote_fetch(remote, NULL, &fetch_opts, git_buf_cstr(&reflog_message))) != 0)\n\t\tgoto cleanup;\n\n\terror = checkout_branch(repo, remote, co_opts, branch, git_buf_cstr(&reflog_message));\n\ncleanup:\n\tgit_remote_free(remote);\n\tgit_buf_free(&reflog_message);\n\n\treturn error;\n}"
  },
  {
    "function_name": "checkout_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "307-322",
    "snippet": "static int checkout_branch(git_repository *repo, git_remote *remote, const git_checkout_options *co_opts, const char *branch, const char *reflog_message)\n{\n\tint error;\n\n\tif (branch)\n\t\terror = update_head_to_branch(repo, git_remote_name(remote), branch,\n\t\t\t\treflog_message);\n\t/* Point HEAD to the same ref as the remote's head */\n\telse\n\t\terror = update_head_to_remote(repo, remote, reflog_message);\n\n\tif (!error && should_checkout(repo, git_repository_is_bare(repo), co_opts))\n\t\terror = git_checkout_head(repo, co_opts);\n\n\treturn error;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_checkout_head",
          "args": [
            "repo",
            "co_opts"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_checkout",
          "args": [
            "repo",
            "git_repository_is_bare(repo)",
            "co_opts"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "should_checkout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "290-305",
          "snippet": "static bool should_checkout(\n\tgit_repository *repo,\n\tbool is_bare,\n\tconst git_checkout_options *opts)\n{\n\tif (is_bare)\n\t\treturn false;\n\n\tif (!opts)\n\t\treturn false;\n\n\tif (opts->checkout_strategy == GIT_CHECKOUT_NONE)\n\t\treturn false;\n\n\treturn !git_repository_head_unborn(repo);\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic bool should_checkout(\n\tgit_repository *repo,\n\tbool is_bare,\n\tconst git_checkout_options *opts)\n{\n\tif (is_bare)\n\t\treturn false;\n\n\tif (!opts)\n\t\treturn false;\n\n\tif (opts->checkout_strategy == GIT_CHECKOUT_NONE)\n\t\treturn false;\n\n\treturn !git_repository_head_unborn(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_is_bare",
          "args": [
            "repo"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_is_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1882-1886",
          "snippet": "int git_repository_is_bare(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->is_bare;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_is_bare(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->is_bare;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_head_to_remote",
          "args": [
            "repo",
            "remote",
            "reflog_message"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "update_head_to_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "141-201",
          "snippet": "static int update_head_to_remote(\n\t\tgit_repository *repo,\n\t\tgit_remote *remote,\n\t\tconst char *reflog_message)\n{\n\tint error = 0;\n\tsize_t refs_len;\n\tgit_refspec *refspec;\n\tconst git_remote_head *remote_head, **refs;\n\tconst git_oid *remote_head_id;\n\tgit_buf remote_master_name = GIT_BUF_INIT;\n\tgit_buf branch = GIT_BUF_INIT;\n\n\tif ((error = git_remote_ls(&refs, &refs_len, remote)) < 0)\n\t\treturn error;\n\n\t/* We cloned an empty repository or one with an unborn HEAD */\n\tif (refs_len == 0 || strcmp(refs[0]->name, GIT_HEAD_FILE))\n\t\treturn setup_tracking_config(\n\t\t\trepo, \"master\", GIT_REMOTE_ORIGIN, GIT_REFS_HEADS_MASTER_FILE);\n\n\t/* We know we have HEAD, let's see where it points */\n\tremote_head = refs[0];\n\tassert(remote_head);\n\n\tremote_head_id = &remote_head->oid;\n\n\terror = git_remote_default_branch(&branch, remote);\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = git_repository_set_head_detached(\n\t\t\trepo, remote_head_id);\n\t\tgoto cleanup;\n\t}\n\n\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&branch));\n\n\tif (refspec == NULL) {\n\t\tgiterr_set(GITERR_NET, \"the remote's default branch does not fit the refspec configuration\");\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\t/* Determine the remote tracking reference name from the local master */\n\tif ((error = git_refspec_transform(\n\t\t&remote_master_name,\n\t\trefspec,\n\t\tgit_buf_cstr(&branch))) < 0)\n\t\tgoto cleanup;\n\n\terror = update_head_to_new_branch(\n\t\trepo,\n\t\tremote_head_id,\n\t\tgit_buf_cstr(&branch),\n\t\treflog_message);\n\ncleanup:\n\tgit_buf_free(&remote_master_name);\n\tgit_buf_free(&branch);\n\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int update_head_to_remote(\n\t\tgit_repository *repo,\n\t\tgit_remote *remote,\n\t\tconst char *reflog_message)\n{\n\tint error = 0;\n\tsize_t refs_len;\n\tgit_refspec *refspec;\n\tconst git_remote_head *remote_head, **refs;\n\tconst git_oid *remote_head_id;\n\tgit_buf remote_master_name = GIT_BUF_INIT;\n\tgit_buf branch = GIT_BUF_INIT;\n\n\tif ((error = git_remote_ls(&refs, &refs_len, remote)) < 0)\n\t\treturn error;\n\n\t/* We cloned an empty repository or one with an unborn HEAD */\n\tif (refs_len == 0 || strcmp(refs[0]->name, GIT_HEAD_FILE))\n\t\treturn setup_tracking_config(\n\t\t\trepo, \"master\", GIT_REMOTE_ORIGIN, GIT_REFS_HEADS_MASTER_FILE);\n\n\t/* We know we have HEAD, let's see where it points */\n\tremote_head = refs[0];\n\tassert(remote_head);\n\n\tremote_head_id = &remote_head->oid;\n\n\terror = git_remote_default_branch(&branch, remote);\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = git_repository_set_head_detached(\n\t\t\trepo, remote_head_id);\n\t\tgoto cleanup;\n\t}\n\n\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&branch));\n\n\tif (refspec == NULL) {\n\t\tgiterr_set(GITERR_NET, \"the remote's default branch does not fit the refspec configuration\");\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\t/* Determine the remote tracking reference name from the local master */\n\tif ((error = git_refspec_transform(\n\t\t&remote_master_name,\n\t\trefspec,\n\t\tgit_buf_cstr(&branch))) < 0)\n\t\tgoto cleanup;\n\n\terror = update_head_to_new_branch(\n\t\trepo,\n\t\tremote_head_id,\n\t\tgit_buf_cstr(&branch),\n\t\treflog_message);\n\ncleanup:\n\tgit_buf_free(&remote_master_name);\n\tgit_buf_free(&branch);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_head_to_branch",
          "args": [
            "repo",
            "git_remote_name(remote)",
            "branch",
            "reflog_message"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "update_head_to_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "203-229",
          "snippet": "static int update_head_to_branch(\n\t\tgit_repository *repo,\n\t\tconst char *remote_name,\n\t\tconst char *branch,\n\t\tconst char *reflog_message)\n{\n\tint retcode;\n\tgit_buf remote_branch_name = GIT_BUF_INIT;\n\tgit_reference* remote_ref = NULL;\n\n\tassert(remote_name && branch);\n\n\tif ((retcode = git_buf_printf(&remote_branch_name, GIT_REFS_REMOTES_DIR \"%s/%s\",\n\t\tremote_name, branch)) < 0 )\n\t\tgoto cleanup;\n\n\tif ((retcode = git_reference_lookup(&remote_ref, repo, git_buf_cstr(&remote_branch_name))) < 0)\n\t\tgoto cleanup;\n\n\tretcode = update_head_to_new_branch(repo, git_reference_target(remote_ref), branch,\n\t\t\treflog_message);\n\ncleanup:\n\tgit_reference_free(remote_ref);\n\tgit_buf_free(&remote_branch_name);\n\treturn retcode;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int update_head_to_branch(\n\t\tgit_repository *repo,\n\t\tconst char *remote_name,\n\t\tconst char *branch,\n\t\tconst char *reflog_message)\n{\n\tint retcode;\n\tgit_buf remote_branch_name = GIT_BUF_INIT;\n\tgit_reference* remote_ref = NULL;\n\n\tassert(remote_name && branch);\n\n\tif ((retcode = git_buf_printf(&remote_branch_name, GIT_REFS_REMOTES_DIR \"%s/%s\",\n\t\tremote_name, branch)) < 0 )\n\t\tgoto cleanup;\n\n\tif ((retcode = git_reference_lookup(&remote_ref, repo, git_buf_cstr(&remote_branch_name))) < 0)\n\t\tgoto cleanup;\n\n\tretcode = update_head_to_new_branch(repo, git_reference_target(remote_ref), branch,\n\t\t\treflog_message);\n\ncleanup:\n\tgit_reference_free(remote_ref);\n\tgit_buf_free(&remote_branch_name);\n\treturn retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_name",
          "args": [
            "remote"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "597-601",
          "snippet": "const char *git_remote_name(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->name;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nconst char *git_remote_name(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int checkout_branch(git_repository *repo, git_remote *remote, const git_checkout_options *co_opts, const char *branch, const char *reflog_message)\n{\n\tint error;\n\n\tif (branch)\n\t\terror = update_head_to_branch(repo, git_remote_name(remote), branch,\n\t\t\t\treflog_message);\n\t/* Point HEAD to the same ref as the remote's head */\n\telse\n\t\terror = update_head_to_remote(repo, remote, reflog_message);\n\n\tif (!error && should_checkout(repo, git_repository_is_bare(repo), co_opts))\n\t\terror = git_checkout_head(repo, co_opts);\n\n\treturn error;\n}"
  },
  {
    "function_name": "should_checkout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "290-305",
    "snippet": "static bool should_checkout(\n\tgit_repository *repo,\n\tbool is_bare,\n\tconst git_checkout_options *opts)\n{\n\tif (is_bare)\n\t\treturn false;\n\n\tif (!opts)\n\t\treturn false;\n\n\tif (opts->checkout_strategy == GIT_CHECKOUT_NONE)\n\t\treturn false;\n\n\treturn !git_repository_head_unborn(repo);\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_repository_head_unborn",
          "args": [
            "repo"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_unborn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1764-1781",
          "snippet": "int git_repository_head_unborn(git_repository *repo)\n{\n\tgit_reference *ref = NULL;\n\tint error;\n\n\terror = git_repository_head(&ref, repo);\n\tgit_reference_free(ref);\n\n\tif (error == GIT_EUNBORNBRANCH) {\n\t\tgiterr_clear();\n\t\treturn 1;\n\t}\n\n\tif (error < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_unborn(git_repository *repo)\n{\n\tgit_reference *ref = NULL;\n\tint error;\n\n\terror = git_repository_head(&ref, repo);\n\tgit_reference_free(ref);\n\n\tif (error == GIT_EUNBORNBRANCH) {\n\t\tgiterr_clear();\n\t\treturn 1;\n\t}\n\n\tif (error < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic bool should_checkout(\n\tgit_repository *repo,\n\tbool is_bare,\n\tconst git_checkout_options *opts)\n{\n\tif (is_bare)\n\t\treturn false;\n\n\tif (!opts)\n\t\treturn false;\n\n\tif (opts->checkout_strategy == GIT_CHECKOUT_NONE)\n\t\treturn false;\n\n\treturn !git_repository_head_unborn(repo);\n}"
  },
  {
    "function_name": "create_and_configure_origin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "254-288",
    "snippet": "static int create_and_configure_origin(\n\t\tgit_remote **out,\n\t\tgit_repository *repo,\n\t\tconst char *url,\n\t\tconst git_clone_options *options)\n{\n\tint error;\n\tgit_remote *origin = NULL;\n\tchar buf[GIT_PATH_MAX];\n\tgit_remote_create_cb remote_create = options->remote_cb;\n\tvoid *payload = options->remote_cb_payload;\n\n\t/* If the path exists and is a dir, the url should be the absolute path */\n\tif (git_path_root(url) < 0 && git_path_exists(url) && git_path_isdir(url)) {\n\t\tif (p_realpath(url, buf) == NULL)\n\t\t\treturn -1;\n\n\t\turl = buf;\n\t}\n\n\tif (!remote_create) {\n\t\tremote_create = default_remote_create;\n\t\tpayload = NULL;\n\t}\n\n\tif ((error = remote_create(&origin, repo, \"origin\", url, payload)) < 0)\n\t\tgoto on_error;\n\n\t*out = origin;\n\treturn 0;\n\non_error:\n\tgit_remote_free(origin);\n\treturn error;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "origin"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote_create",
          "args": [
            "&origin",
            "repo",
            "\"origin\"",
            "url",
            "payload"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "default_remote_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "238-248",
          "snippet": "static int default_remote_create(\n\t\tgit_remote **out,\n\t\tgit_repository *repo,\n\t\tconst char *name,\n\t\tconst char *url,\n\t\tvoid *payload)\n{\n\tGIT_UNUSED(payload);\n\n\treturn git_remote_create(out, repo, name, url);\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int default_remote_create(\n\t\tgit_remote **out,\n\t\tgit_repository *repo,\n\t\tconst char *name,\n\t\tconst char *url,\n\t\tvoid *payload)\n{\n\tGIT_UNUSED(payload);\n\n\treturn git_remote_create(out, repo, name, url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_realpath",
          "args": [
            "url",
            "buf"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "p_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/unix/realpath.c",
          "lines": "16-29",
          "snippet": "char *p_realpath(const char *pathname, char *resolved)\n{\n\tchar *ret;\n\tif ((ret = realpath(pathname, resolved)) == NULL)\n\t\treturn NULL;\n\n#ifdef __OpenBSD__\n\t/* The OpenBSD realpath function behaves differently,\n\t * figure out if the file exists */\n\tif (access(ret, F_OK) < 0)\n\t\tret = NULL;\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <git2/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <git2/common.h>\n\nchar *p_realpath(const char *pathname, char *resolved)\n{\n\tchar *ret;\n\tif ((ret = realpath(pathname, resolved)) == NULL)\n\t\treturn NULL;\n\n#ifdef __OpenBSD__\n\t/* The OpenBSD realpath function behaves differently,\n\t * figure out if the file exists */\n\tif (access(ret, F_OK) < 0)\n\t\tret = NULL;\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "url"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "url"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "url"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int create_and_configure_origin(\n\t\tgit_remote **out,\n\t\tgit_repository *repo,\n\t\tconst char *url,\n\t\tconst git_clone_options *options)\n{\n\tint error;\n\tgit_remote *origin = NULL;\n\tchar buf[GIT_PATH_MAX];\n\tgit_remote_create_cb remote_create = options->remote_cb;\n\tvoid *payload = options->remote_cb_payload;\n\n\t/* If the path exists and is a dir, the url should be the absolute path */\n\tif (git_path_root(url) < 0 && git_path_exists(url) && git_path_isdir(url)) {\n\t\tif (p_realpath(url, buf) == NULL)\n\t\t\treturn -1;\n\n\t\turl = buf;\n\t}\n\n\tif (!remote_create) {\n\t\tremote_create = default_remote_create;\n\t\tpayload = NULL;\n\t}\n\n\tif ((error = remote_create(&origin, repo, \"origin\", url, payload)) < 0)\n\t\tgoto on_error;\n\n\t*out = origin;\n\treturn 0;\n\non_error:\n\tgit_remote_free(origin);\n\treturn error;\n}"
  },
  {
    "function_name": "default_remote_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "238-248",
    "snippet": "static int default_remote_create(\n\t\tgit_remote **out,\n\t\tgit_repository *repo,\n\t\tconst char *name,\n\t\tconst char *url,\n\t\tvoid *payload)\n{\n\tGIT_UNUSED(payload);\n\n\treturn git_remote_create(out, repo, name, url);\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_remote_create",
          "args": [
            "out",
            "repo",
            "name",
            "url"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "292-304",
          "snippet": "int git_remote_create(git_remote **out, git_repository *repo, const char *name, const char *url)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, \"+refs/heads/*:refs/remotes/%s/*\", name) < 0)\n\t\treturn -1;\n\n\terror = git_remote_create_with_fetchspec(out, repo, name, url, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_create(git_remote **out, git_repository *repo, const char *name, const char *url)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, \"+refs/heads/*:refs/remotes/%s/*\", name) < 0)\n\t\treturn -1;\n\n\terror = git_remote_create_with_fetchspec(out, repo, name, url, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int default_remote_create(\n\t\tgit_remote **out,\n\t\tgit_repository *repo,\n\t\tconst char *name,\n\t\tconst char *url,\n\t\tvoid *payload)\n{\n\tGIT_UNUSED(payload);\n\n\treturn git_remote_create(out, repo, name, url);\n}"
  },
  {
    "function_name": "default_repository_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "231-236",
    "snippet": "static int default_repository_create(git_repository **out, const char *path, int bare, void *payload)\n{\n\tGIT_UNUSED(payload);\n\n\treturn git_repository_init(out, path, bare);\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_repository_init",
          "args": [
            "out",
            "path",
            "bare"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_init_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1665-1720",
          "snippet": "int git_repository_init_ext(\n\tgit_repository **out,\n\tconst char *given_repo,\n\tgit_repository_init_options *opts)\n{\n\tint error;\n\tgit_buf repo_path = GIT_BUF_INIT, wd_path = GIT_BUF_INIT;\n\tconst char *wd;\n\n\tassert(out && given_repo && opts);\n\n\tGITERR_CHECK_VERSION(opts, GIT_REPOSITORY_INIT_OPTIONS_VERSION, \"git_repository_init_options\");\n\n\terror = repo_init_directories(&repo_path, &wd_path, given_repo, opts);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\twd = (opts->flags & GIT_REPOSITORY_INIT_BARE) ? NULL : git_buf_cstr(&wd_path);\n\tif (valid_repository_path(&repo_path)) {\n\n\t\tif ((opts->flags & GIT_REPOSITORY_INIT_NO_REINIT) != 0) {\n\t\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\t\"Attempt to reinitialize '%s'\", given_repo);\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\topts->flags |= GIT_REPOSITORY_INIT__IS_REINIT;\n\n\t\terror = repo_init_config(\n\t\t\trepo_path.ptr, wd, opts->flags, opts->mode);\n\n\t\t/* TODO: reinitialize the templates */\n\t}\n\telse {\n\t\tif (!(error = repo_init_structure(\n\t\t\t\trepo_path.ptr, wd, opts)) &&\n\t\t\t!(error = repo_init_config(\n\t\t\t\trepo_path.ptr, wd, opts->flags, opts->mode)))\n\t\t\terror = repo_init_create_head(\n\t\t\t\trepo_path.ptr, opts->initial_head);\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_open(out, repo_path.ptr);\n\n\tif (!error && opts->origin_url)\n\t\terror = repo_init_create_origin(*out, opts->origin_url);\n\ncleanup:\n\tgit_buf_free(&repo_path);\n\tgit_buf_free(&wd_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_init_ext(\n\tgit_repository **out,\n\tconst char *given_repo,\n\tgit_repository_init_options *opts)\n{\n\tint error;\n\tgit_buf repo_path = GIT_BUF_INIT, wd_path = GIT_BUF_INIT;\n\tconst char *wd;\n\n\tassert(out && given_repo && opts);\n\n\tGITERR_CHECK_VERSION(opts, GIT_REPOSITORY_INIT_OPTIONS_VERSION, \"git_repository_init_options\");\n\n\terror = repo_init_directories(&repo_path, &wd_path, given_repo, opts);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\twd = (opts->flags & GIT_REPOSITORY_INIT_BARE) ? NULL : git_buf_cstr(&wd_path);\n\tif (valid_repository_path(&repo_path)) {\n\n\t\tif ((opts->flags & GIT_REPOSITORY_INIT_NO_REINIT) != 0) {\n\t\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\t\"Attempt to reinitialize '%s'\", given_repo);\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\topts->flags |= GIT_REPOSITORY_INIT__IS_REINIT;\n\n\t\terror = repo_init_config(\n\t\t\trepo_path.ptr, wd, opts->flags, opts->mode);\n\n\t\t/* TODO: reinitialize the templates */\n\t}\n\telse {\n\t\tif (!(error = repo_init_structure(\n\t\t\t\trepo_path.ptr, wd, opts)) &&\n\t\t\t!(error = repo_init_config(\n\t\t\t\trepo_path.ptr, wd, opts->flags, opts->mode)))\n\t\t\terror = repo_init_create_head(\n\t\t\t\trepo_path.ptr, opts->initial_head);\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_open(out, repo_path.ptr);\n\n\tif (!error && opts->origin_url)\n\t\terror = repo_init_create_origin(*out, opts->origin_url);\n\ncleanup:\n\tgit_buf_free(&repo_path);\n\tgit_buf_free(&wd_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int default_repository_create(git_repository **out, const char *path, int bare, void *payload)\n{\n\tGIT_UNUSED(payload);\n\n\treturn git_repository_init(out, path, bare);\n}"
  },
  {
    "function_name": "update_head_to_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "203-229",
    "snippet": "static int update_head_to_branch(\n\t\tgit_repository *repo,\n\t\tconst char *remote_name,\n\t\tconst char *branch,\n\t\tconst char *reflog_message)\n{\n\tint retcode;\n\tgit_buf remote_branch_name = GIT_BUF_INIT;\n\tgit_reference* remote_ref = NULL;\n\n\tassert(remote_name && branch);\n\n\tif ((retcode = git_buf_printf(&remote_branch_name, GIT_REFS_REMOTES_DIR \"%s/%s\",\n\t\tremote_name, branch)) < 0 )\n\t\tgoto cleanup;\n\n\tif ((retcode = git_reference_lookup(&remote_ref, repo, git_buf_cstr(&remote_branch_name))) < 0)\n\t\tgoto cleanup;\n\n\tretcode = update_head_to_new_branch(repo, git_reference_target(remote_ref), branch,\n\t\t\treflog_message);\n\ncleanup:\n\tgit_reference_free(remote_ref);\n\tgit_buf_free(&remote_branch_name);\n\treturn retcode;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&remote_branch_name"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "remote_ref"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_head_to_new_branch",
          "args": [
            "repo",
            "git_reference_target(remote_ref)",
            "branch",
            "reflog_message"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "update_head_to_new_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "113-139",
          "snippet": "static int update_head_to_new_branch(\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *reflog_message)\n{\n\tgit_reference *tracking_branch = NULL;\n\tint error;\n\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\tname += strlen(GIT_REFS_HEADS_DIR);\n\n\terror = create_tracking_branch(&tracking_branch, repo, target, name,\n\t\t\treflog_message);\n\n\tif (!error)\n\t\terror = git_repository_set_head(\n\t\t\trepo, git_reference_name(tracking_branch));\n\n\tgit_reference_free(tracking_branch);\n\n\t/* if it already existed, then the user's refspec created it for us, ignore it' */\n\tif (error == GIT_EEXISTS)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int update_head_to_new_branch(\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *reflog_message)\n{\n\tgit_reference *tracking_branch = NULL;\n\tint error;\n\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\tname += strlen(GIT_REFS_HEADS_DIR);\n\n\terror = create_tracking_branch(&tracking_branch, repo, target, name,\n\t\t\treflog_message);\n\n\tif (!error)\n\t\terror = git_repository_set_head(\n\t\t\trepo, git_reference_name(tracking_branch));\n\n\tgit_reference_free(tracking_branch);\n\n\t/* if it already existed, then the user's refspec created it for us, ignore it' */\n\tif (error == GIT_EEXISTS)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "remote_ref"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&remote_ref",
            "repo",
            "git_buf_cstr(&remote_branch_name)"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&remote_branch_name"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&remote_branch_name",
            "GIT_REFS_REMOTES_DIR \"%s/%s\"",
            "remote_name",
            "branch"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote_name && branch"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int update_head_to_branch(\n\t\tgit_repository *repo,\n\t\tconst char *remote_name,\n\t\tconst char *branch,\n\t\tconst char *reflog_message)\n{\n\tint retcode;\n\tgit_buf remote_branch_name = GIT_BUF_INIT;\n\tgit_reference* remote_ref = NULL;\n\n\tassert(remote_name && branch);\n\n\tif ((retcode = git_buf_printf(&remote_branch_name, GIT_REFS_REMOTES_DIR \"%s/%s\",\n\t\tremote_name, branch)) < 0 )\n\t\tgoto cleanup;\n\n\tif ((retcode = git_reference_lookup(&remote_ref, repo, git_buf_cstr(&remote_branch_name))) < 0)\n\t\tgoto cleanup;\n\n\tretcode = update_head_to_new_branch(repo, git_reference_target(remote_ref), branch,\n\t\t\treflog_message);\n\ncleanup:\n\tgit_reference_free(remote_ref);\n\tgit_buf_free(&remote_branch_name);\n\treturn retcode;\n}"
  },
  {
    "function_name": "update_head_to_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "141-201",
    "snippet": "static int update_head_to_remote(\n\t\tgit_repository *repo,\n\t\tgit_remote *remote,\n\t\tconst char *reflog_message)\n{\n\tint error = 0;\n\tsize_t refs_len;\n\tgit_refspec *refspec;\n\tconst git_remote_head *remote_head, **refs;\n\tconst git_oid *remote_head_id;\n\tgit_buf remote_master_name = GIT_BUF_INIT;\n\tgit_buf branch = GIT_BUF_INIT;\n\n\tif ((error = git_remote_ls(&refs, &refs_len, remote)) < 0)\n\t\treturn error;\n\n\t/* We cloned an empty repository or one with an unborn HEAD */\n\tif (refs_len == 0 || strcmp(refs[0]->name, GIT_HEAD_FILE))\n\t\treturn setup_tracking_config(\n\t\t\trepo, \"master\", GIT_REMOTE_ORIGIN, GIT_REFS_HEADS_MASTER_FILE);\n\n\t/* We know we have HEAD, let's see where it points */\n\tremote_head = refs[0];\n\tassert(remote_head);\n\n\tremote_head_id = &remote_head->oid;\n\n\terror = git_remote_default_branch(&branch, remote);\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = git_repository_set_head_detached(\n\t\t\trepo, remote_head_id);\n\t\tgoto cleanup;\n\t}\n\n\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&branch));\n\n\tif (refspec == NULL) {\n\t\tgiterr_set(GITERR_NET, \"the remote's default branch does not fit the refspec configuration\");\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\t/* Determine the remote tracking reference name from the local master */\n\tif ((error = git_refspec_transform(\n\t\t&remote_master_name,\n\t\trefspec,\n\t\tgit_buf_cstr(&branch))) < 0)\n\t\tgoto cleanup;\n\n\terror = update_head_to_new_branch(\n\t\trepo,\n\t\tremote_head_id,\n\t\tgit_buf_cstr(&branch),\n\t\treflog_message);\n\ncleanup:\n\tgit_buf_free(&remote_master_name);\n\tgit_buf_free(&branch);\n\n\treturn error;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&branch"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_head_to_new_branch",
          "args": [
            "repo",
            "remote_head_id",
            "git_buf_cstr(&branch)",
            "reflog_message"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "update_head_to_new_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "113-139",
          "snippet": "static int update_head_to_new_branch(\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *reflog_message)\n{\n\tgit_reference *tracking_branch = NULL;\n\tint error;\n\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\tname += strlen(GIT_REFS_HEADS_DIR);\n\n\terror = create_tracking_branch(&tracking_branch, repo, target, name,\n\t\t\treflog_message);\n\n\tif (!error)\n\t\terror = git_repository_set_head(\n\t\t\trepo, git_reference_name(tracking_branch));\n\n\tgit_reference_free(tracking_branch);\n\n\t/* if it already existed, then the user's refspec created it for us, ignore it' */\n\tif (error == GIT_EEXISTS)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int update_head_to_new_branch(\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *reflog_message)\n{\n\tgit_reference *tracking_branch = NULL;\n\tint error;\n\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\tname += strlen(GIT_REFS_HEADS_DIR);\n\n\terror = create_tracking_branch(&tracking_branch, repo, target, name,\n\t\t\treflog_message);\n\n\tif (!error)\n\t\terror = git_repository_set_head(\n\t\t\trepo, git_reference_name(tracking_branch));\n\n\tgit_reference_free(tracking_branch);\n\n\t/* if it already existed, then the user's refspec created it for us, ignore it' */\n\tif (error == GIT_EEXISTS)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&branch"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_transform",
          "args": [
            "&remote_master_name",
            "refspec",
            "git_buf_cstr(&branch)"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "244-258",
          "snippet": "int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"the remote's default branch does not fit the refspec configuration\""
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__matching_refspec",
          "args": [
            "remote",
            "git_buf_cstr(&branch)"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__matching_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2055-2069",
          "snippet": "git_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_set_head_detached",
          "args": [
            "repo",
            "remote_head_id"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_set_head_detached_from_annotated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "2167-2174",
          "snippet": "int git_repository_set_head_detached_from_annotated(\n\tgit_repository *repo,\n\tconst git_annotated_commit *commitish)\n{\n\tassert(repo && commitish);\n\n\treturn detach(repo, git_annotated_commit_id(commitish), commitish->ref_name);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_set_head_detached_from_annotated(\n\tgit_repository *repo,\n\tconst git_annotated_commit *commitish)\n{\n\tassert(repo && commitish);\n\n\treturn detach(repo, git_annotated_commit_id(commitish), commitish->ref_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_default_branch",
          "args": [
            "&branch",
            "remote"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_default_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2343-2396",
          "snippet": "int git_remote_default_branch(git_buf *out, git_remote *remote)\n{\n\tconst git_remote_head **heads;\n\tconst git_remote_head *guess = NULL;\n\tconst git_oid *head_id;\n\tsize_t heads_len, i;\n\tint error;\n\n\tassert(out);\n\n\tif ((error = git_remote_ls(&heads, &heads_len, remote)) < 0)\n\t\treturn error;\n\n\tif (heads_len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (strcmp(heads[0]->name, GIT_HEAD_FILE))\n\t\treturn GIT_ENOTFOUND;\n\n\tgit_buf_sanitize(out);\n\t/* the first one must be HEAD so if that has the symref info, we're done */\n\tif (heads[0]->symref_target)\n\t\treturn git_buf_puts(out, heads[0]->symref_target);\n\n\t/*\n\t * If there's no symref information, we have to look over them\n\t * and guess. We return the first match unless the master\n\t * branch is a candidate. Then we return the master branch.\n\t */\n\thead_id = &heads[0]->oid;\n\n\tfor (i = 1; i < heads_len; i++) {\n\t\tif (git_oid_cmp(head_id, &heads[i]->oid))\n\t\t\tcontinue;\n\n\t\tif (git__prefixcmp(heads[i]->name, GIT_REFS_HEADS_DIR))\n\t\t\tcontinue;\n\n\t\tif (!guess) {\n\t\t\tguess = heads[i];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__strcmp(GIT_REFS_HEADS_MASTER_FILE, heads[i]->name)) {\n\t\t\tguess = heads[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!guess)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_buf_puts(out, guess->name);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_default_branch(git_buf *out, git_remote *remote)\n{\n\tconst git_remote_head **heads;\n\tconst git_remote_head *guess = NULL;\n\tconst git_oid *head_id;\n\tsize_t heads_len, i;\n\tint error;\n\n\tassert(out);\n\n\tif ((error = git_remote_ls(&heads, &heads_len, remote)) < 0)\n\t\treturn error;\n\n\tif (heads_len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (strcmp(heads[0]->name, GIT_HEAD_FILE))\n\t\treturn GIT_ENOTFOUND;\n\n\tgit_buf_sanitize(out);\n\t/* the first one must be HEAD so if that has the symref info, we're done */\n\tif (heads[0]->symref_target)\n\t\treturn git_buf_puts(out, heads[0]->symref_target);\n\n\t/*\n\t * If there's no symref information, we have to look over them\n\t * and guess. We return the first match unless the master\n\t * branch is a candidate. Then we return the master branch.\n\t */\n\thead_id = &heads[0]->oid;\n\n\tfor (i = 1; i < heads_len; i++) {\n\t\tif (git_oid_cmp(head_id, &heads[i]->oid))\n\t\t\tcontinue;\n\n\t\tif (git__prefixcmp(heads[i]->name, GIT_REFS_HEADS_DIR))\n\t\t\tcontinue;\n\n\t\tif (!guess) {\n\t\t\tguess = heads[i];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__strcmp(GIT_REFS_HEADS_MASTER_FILE, heads[i]->name)) {\n\t\t\tguess = heads[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!guess)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_buf_puts(out, guess->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote_head"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_tracking_config",
          "args": [
            "repo",
            "\"master\"",
            "GIT_REMOTE_ORIGIN",
            "GIT_REFS_HEADS_MASTER_FILE"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "setup_tracking_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "61-92",
          "snippet": "static int setup_tracking_config(\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tconst char *remote_name,\n\tconst char *merge_target)\n{\n\tgit_config *cfg;\n\tgit_buf remote_key = GIT_BUF_INIT, merge_key = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_repository_config__weakptr(&cfg, repo) < 0)\n\t\treturn -1;\n\n\tif (git_buf_printf(&remote_key, \"branch.%s.remote\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&merge_key, \"branch.%s.merge\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&remote_key), remote_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&merge_key), merge_target) < 0)\n\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&remote_key);\n\tgit_buf_free(&merge_key);\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int setup_tracking_config(\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tconst char *remote_name,\n\tconst char *merge_target)\n{\n\tgit_config *cfg;\n\tgit_buf remote_key = GIT_BUF_INIT, merge_key = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_repository_config__weakptr(&cfg, repo) < 0)\n\t\treturn -1;\n\n\tif (git_buf_printf(&remote_key, \"branch.%s.remote\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&merge_key, \"branch.%s.merge\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&remote_key), remote_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&merge_key), merge_target) < 0)\n\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&remote_key);\n\tgit_buf_free(&merge_key);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "refs[0]->name",
            "GIT_HEAD_FILE"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_ls",
          "args": [
            "&refs",
            "&refs_len",
            "remote"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "757-767",
          "snippet": "int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int update_head_to_remote(\n\t\tgit_repository *repo,\n\t\tgit_remote *remote,\n\t\tconst char *reflog_message)\n{\n\tint error = 0;\n\tsize_t refs_len;\n\tgit_refspec *refspec;\n\tconst git_remote_head *remote_head, **refs;\n\tconst git_oid *remote_head_id;\n\tgit_buf remote_master_name = GIT_BUF_INIT;\n\tgit_buf branch = GIT_BUF_INIT;\n\n\tif ((error = git_remote_ls(&refs, &refs_len, remote)) < 0)\n\t\treturn error;\n\n\t/* We cloned an empty repository or one with an unborn HEAD */\n\tif (refs_len == 0 || strcmp(refs[0]->name, GIT_HEAD_FILE))\n\t\treturn setup_tracking_config(\n\t\t\trepo, \"master\", GIT_REMOTE_ORIGIN, GIT_REFS_HEADS_MASTER_FILE);\n\n\t/* We know we have HEAD, let's see where it points */\n\tremote_head = refs[0];\n\tassert(remote_head);\n\n\tremote_head_id = &remote_head->oid;\n\n\terror = git_remote_default_branch(&branch, remote);\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = git_repository_set_head_detached(\n\t\t\trepo, remote_head_id);\n\t\tgoto cleanup;\n\t}\n\n\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&branch));\n\n\tif (refspec == NULL) {\n\t\tgiterr_set(GITERR_NET, \"the remote's default branch does not fit the refspec configuration\");\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\t/* Determine the remote tracking reference name from the local master */\n\tif ((error = git_refspec_transform(\n\t\t&remote_master_name,\n\t\trefspec,\n\t\tgit_buf_cstr(&branch))) < 0)\n\t\tgoto cleanup;\n\n\terror = update_head_to_new_branch(\n\t\trepo,\n\t\tremote_head_id,\n\t\tgit_buf_cstr(&branch),\n\t\treflog_message);\n\ncleanup:\n\tgit_buf_free(&remote_master_name);\n\tgit_buf_free(&branch);\n\n\treturn error;\n}"
  },
  {
    "function_name": "update_head_to_new_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "113-139",
    "snippet": "static int update_head_to_new_branch(\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *reflog_message)\n{\n\tgit_reference *tracking_branch = NULL;\n\tint error;\n\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\tname += strlen(GIT_REFS_HEADS_DIR);\n\n\terror = create_tracking_branch(&tracking_branch, repo, target, name,\n\t\t\treflog_message);\n\n\tif (!error)\n\t\terror = git_repository_set_head(\n\t\t\trepo, git_reference_name(tracking_branch));\n\n\tgit_reference_free(tracking_branch);\n\n\t/* if it already existed, then the user's refspec created it for us, ignore it' */\n\tif (error == GIT_EEXISTS)\n\t\terror = 0;\n\n\treturn error;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "tracking_branch"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_set_head",
          "args": [
            "repo",
            "git_reference_name(tracking_branch)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_set_head_detached_from_annotated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "2167-2174",
          "snippet": "int git_repository_set_head_detached_from_annotated(\n\tgit_repository *repo,\n\tconst git_annotated_commit *commitish)\n{\n\tassert(repo && commitish);\n\n\treturn detach(repo, git_annotated_commit_id(commitish), commitish->ref_name);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_set_head_detached_from_annotated(\n\tgit_repository *repo,\n\tconst git_annotated_commit *commitish)\n{\n\tassert(repo && commitish);\n\n\treturn detach(repo, git_annotated_commit_id(commitish), commitish->ref_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "tracking_branch"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_tracking_branch",
          "args": [
            "&tracking_branch",
            "repo",
            "target",
            "name",
            "reflog_message"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "create_tracking_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "94-111",
          "snippet": "static int create_tracking_branch(\n\tgit_reference **branch,\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *branch_name,\n\tconst char *log_message)\n{\n\tint error;\n\n\tif ((error = create_branch(branch, repo, target, branch_name, log_message)) < 0)\n\t\treturn error;\n\n\treturn setup_tracking_config(\n\t\trepo,\n\t\tbranch_name,\n\t\tGIT_REMOTE_ORIGIN,\n\t\tgit_reference_name(*branch));\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int create_tracking_branch(\n\tgit_reference **branch,\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *branch_name,\n\tconst char *log_message)\n{\n\tint error;\n\n\tif ((error = create_branch(branch, repo, target, branch_name, log_message)) < 0)\n\t\treturn error;\n\n\treturn setup_tracking_config(\n\t\trepo,\n\t\tbranch_name,\n\t\tGIT_REMOTE_ORIGIN,\n\t\tgit_reference_name(*branch));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "name",
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int update_head_to_new_branch(\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *reflog_message)\n{\n\tgit_reference *tracking_branch = NULL;\n\tint error;\n\n\tif (!git__prefixcmp(name, GIT_REFS_HEADS_DIR))\n\t\tname += strlen(GIT_REFS_HEADS_DIR);\n\n\terror = create_tracking_branch(&tracking_branch, repo, target, name,\n\t\t\treflog_message);\n\n\tif (!error)\n\t\terror = git_repository_set_head(\n\t\t\trepo, git_reference_name(tracking_branch));\n\n\tgit_reference_free(tracking_branch);\n\n\t/* if it already existed, then the user's refspec created it for us, ignore it' */\n\tif (error == GIT_EEXISTS)\n\t\terror = 0;\n\n\treturn error;\n}"
  },
  {
    "function_name": "create_tracking_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "94-111",
    "snippet": "static int create_tracking_branch(\n\tgit_reference **branch,\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *branch_name,\n\tconst char *log_message)\n{\n\tint error;\n\n\tif ((error = create_branch(branch, repo, target, branch_name, log_message)) < 0)\n\t\treturn error;\n\n\treturn setup_tracking_config(\n\t\trepo,\n\t\tbranch_name,\n\t\tGIT_REMOTE_ORIGIN,\n\t\tgit_reference_name(*branch));\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_tracking_config",
          "args": [
            "repo",
            "branch_name",
            "GIT_REMOTE_ORIGIN",
            "git_reference_name(*branch)"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "setup_tracking_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "61-92",
          "snippet": "static int setup_tracking_config(\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tconst char *remote_name,\n\tconst char *merge_target)\n{\n\tgit_config *cfg;\n\tgit_buf remote_key = GIT_BUF_INIT, merge_key = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_repository_config__weakptr(&cfg, repo) < 0)\n\t\treturn -1;\n\n\tif (git_buf_printf(&remote_key, \"branch.%s.remote\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&merge_key, \"branch.%s.merge\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&remote_key), remote_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&merge_key), merge_target) < 0)\n\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&remote_key);\n\tgit_buf_free(&merge_key);\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int setup_tracking_config(\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tconst char *remote_name,\n\tconst char *merge_target)\n{\n\tgit_config *cfg;\n\tgit_buf remote_key = GIT_BUF_INIT, merge_key = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_repository_config__weakptr(&cfg, repo) < 0)\n\t\treturn -1;\n\n\tif (git_buf_printf(&remote_key, \"branch.%s.remote\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&merge_key, \"branch.%s.merge\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&remote_key), remote_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&merge_key), merge_target) < 0)\n\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&remote_key);\n\tgit_buf_free(&merge_key);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "*branch"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "branch",
            "repo",
            "target",
            "branch_name",
            "log_message"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "create_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "29-59",
          "snippet": "static int create_branch(\n\tgit_reference **branch,\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *log_message)\n{\n\tgit_commit *head_obj = NULL;\n\tgit_reference *branch_ref = NULL;\n\tgit_buf refname = GIT_BUF_INIT;\n\tint error;\n\n\t/* Find the target commit */\n\tif ((error = git_commit_lookup(&head_obj, repo, target)) < 0)\n\t\treturn error;\n\n\t/* Create the new branch */\n\tif ((error = git_buf_printf(&refname, GIT_REFS_HEADS_DIR \"%s\", name)) < 0)\n\t\treturn error;\n\n\terror = git_reference_create(&branch_ref, repo, git_buf_cstr(&refname), target, 0, log_message);\n\tgit_buf_free(&refname);\n\tgit_commit_free(head_obj);\n\n\tif (!error)\n\t\t*branch = branch_ref;\n\telse\n\t\tgit_reference_free(branch_ref);\n\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int create_branch(\n\tgit_reference **branch,\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *log_message)\n{\n\tgit_commit *head_obj = NULL;\n\tgit_reference *branch_ref = NULL;\n\tgit_buf refname = GIT_BUF_INIT;\n\tint error;\n\n\t/* Find the target commit */\n\tif ((error = git_commit_lookup(&head_obj, repo, target)) < 0)\n\t\treturn error;\n\n\t/* Create the new branch */\n\tif ((error = git_buf_printf(&refname, GIT_REFS_HEADS_DIR \"%s\", name)) < 0)\n\t\treturn error;\n\n\terror = git_reference_create(&branch_ref, repo, git_buf_cstr(&refname), target, 0, log_message);\n\tgit_buf_free(&refname);\n\tgit_commit_free(head_obj);\n\n\tif (!error)\n\t\t*branch = branch_ref;\n\telse\n\t\tgit_reference_free(branch_ref);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int create_tracking_branch(\n\tgit_reference **branch,\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *branch_name,\n\tconst char *log_message)\n{\n\tint error;\n\n\tif ((error = create_branch(branch, repo, target, branch_name, log_message)) < 0)\n\t\treturn error;\n\n\treturn setup_tracking_config(\n\t\trepo,\n\t\tbranch_name,\n\t\tGIT_REMOTE_ORIGIN,\n\t\tgit_reference_name(*branch));\n}"
  },
  {
    "function_name": "setup_tracking_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "61-92",
    "snippet": "static int setup_tracking_config(\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tconst char *remote_name,\n\tconst char *merge_target)\n{\n\tgit_config *cfg;\n\tgit_buf remote_key = GIT_BUF_INIT, merge_key = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_repository_config__weakptr(&cfg, repo) < 0)\n\t\treturn -1;\n\n\tif (git_buf_printf(&remote_key, \"branch.%s.remote\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&merge_key, \"branch.%s.merge\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&remote_key), remote_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&merge_key), merge_target) < 0)\n\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&remote_key);\n\tgit_buf_free(&merge_key);\n\treturn error;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&merge_key"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_set_string",
          "args": [
            "cfg",
            "git_buf_cstr(&merge_key)",
            "merge_target"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "616-638",
          "snippet": "int git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&merge_key"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&merge_key",
            "\"branch.%s.merge\"",
            "branch_name"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "repo"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int setup_tracking_config(\n\tgit_repository *repo,\n\tconst char *branch_name,\n\tconst char *remote_name,\n\tconst char *merge_target)\n{\n\tgit_config *cfg;\n\tgit_buf remote_key = GIT_BUF_INIT, merge_key = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_repository_config__weakptr(&cfg, repo) < 0)\n\t\treturn -1;\n\n\tif (git_buf_printf(&remote_key, \"branch.%s.remote\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_buf_printf(&merge_key, \"branch.%s.merge\", branch_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&remote_key), remote_name) < 0)\n\t\tgoto cleanup;\n\n\tif (git_config_set_string(cfg, git_buf_cstr(&merge_key), merge_target) < 0)\n\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&remote_key);\n\tgit_buf_free(&merge_key);\n\treturn error;\n}"
  },
  {
    "function_name": "create_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
    "lines": "29-59",
    "snippet": "static int create_branch(\n\tgit_reference **branch,\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *log_message)\n{\n\tgit_commit *head_obj = NULL;\n\tgit_reference *branch_ref = NULL;\n\tgit_buf refname = GIT_BUF_INIT;\n\tint error;\n\n\t/* Find the target commit */\n\tif ((error = git_commit_lookup(&head_obj, repo, target)) < 0)\n\t\treturn error;\n\n\t/* Create the new branch */\n\tif ((error = git_buf_printf(&refname, GIT_REFS_HEADS_DIR \"%s\", name)) < 0)\n\t\treturn error;\n\n\terror = git_reference_create(&branch_ref, repo, git_buf_cstr(&refname), target, 0, log_message);\n\tgit_buf_free(&refname);\n\tgit_commit_free(head_obj);\n\n\tif (!error)\n\t\t*branch = branch_ref;\n\telse\n\t\tgit_reference_free(branch_ref);\n\n\treturn error;\n}",
    "includes": [
      "#include \"odb.h\"",
      "#include \"repository.h\"",
      "#include \"path.h\"",
      "#include \"refs.h\"",
      "#include \"fileops.h\"",
      "#include \"remote.h\"",
      "#include \"common.h\"",
      "#include \"git2/tree.h\"",
      "#include \"git2/commit.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/branch.h\"",
      "#include \"git2/revparse.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/clone.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "branch_ref"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "head_obj"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&refname"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_create",
          "args": [
            "&branch_ref",
            "repo",
            "git_buf_cstr(&refname)",
            "target",
            "0",
            "log_message"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "464-473",
          "snippet": "int git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&refname"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&refname",
            "GIT_REFS_HEADS_DIR \"%s\"",
            "name"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_lookup",
          "args": [
            "&head_obj",
            "repo",
            "target"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "20-23",
          "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int create_branch(\n\tgit_reference **branch,\n\tgit_repository *repo,\n\tconst git_oid *target,\n\tconst char *name,\n\tconst char *log_message)\n{\n\tgit_commit *head_obj = NULL;\n\tgit_reference *branch_ref = NULL;\n\tgit_buf refname = GIT_BUF_INIT;\n\tint error;\n\n\t/* Find the target commit */\n\tif ((error = git_commit_lookup(&head_obj, repo, target)) < 0)\n\t\treturn error;\n\n\t/* Create the new branch */\n\tif ((error = git_buf_printf(&refname, GIT_REFS_HEADS_DIR \"%s\", name)) < 0)\n\t\treturn error;\n\n\terror = git_reference_create(&branch_ref, repo, git_buf_cstr(&refname), target, 0, log_message);\n\tgit_buf_free(&refname);\n\tgit_commit_free(head_obj);\n\n\tif (!error)\n\t\t*branch = branch_ref;\n\telse\n\t\tgit_reference_free(branch_ref);\n\n\treturn error;\n}"
  }
]