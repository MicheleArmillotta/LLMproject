[
  {
    "function_name": "xdl_optimize_ctxs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "474-483",
    "snippet": "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\n\tif (xdl_trim_ends(xdf1, xdf2) < 0 ||\n\t    xdl_cleanup_records(cf, xdf1, xdf2) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xdl_free_classifier(xdlclassifier_t *cf);",
      "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_cleanup_records",
          "args": [
            "cf",
            "xdf1",
            "xdf2"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cleanup_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "385-442",
          "snippet": "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, nm, nreff, mlim;\n\txrecord_t **recs;\n\txdlclass_t *rcrec;\n\tchar *dis, *dis1, *dis2;\n\n\tif (!(dis = (char *) xdl_malloc(xdf1->nrec + xdf2->nrec + 2))) {\n\n\t\treturn -1;\n\t}\n\tmemset(dis, 0, xdf1->nrec + xdf2->nrec + 2);\n\tdis1 = dis;\n\tdis2 = dis1 + xdf1->nrec + 1;\n\n\tif ((mlim = xdl_bogosqrt(xdf1->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart]; i <= xdf1->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len2 : 0;\n\t\tdis1[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tif ((mlim = xdl_bogosqrt(xdf2->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart]; i <= xdf2->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len1 : 0;\n\t\tdis2[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tfor (nreff = 0, i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart];\n\t     i <= xdf1->dend; i++, recs++) {\n\t\tif (dis1[i] == 1 ||\n\t\t    (dis1[i] == 2 && !xdl_clean_mmatch(dis1, i, xdf1->dstart, xdf1->dend))) {\n\t\t\txdf1->rindex[nreff] = i;\n\t\t\txdf1->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf1->rchg[i] = 1;\n\t}\n\txdf1->nreff = nreff;\n\n\tfor (nreff = 0, i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart];\n\t     i <= xdf2->dend; i++, recs++) {\n\t\tif (dis2[i] == 1 ||\n\t\t    (dis2[i] == 2 && !xdl_clean_mmatch(dis2, i, xdf2->dstart, xdf2->dend))) {\n\t\t\txdf2->rindex[nreff] = i;\n\t\t\txdf2->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf2->rchg[i] = 1;\n\t}\n\txdf2->nreff = nreff;\n\n\txdl_free(dis);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_MAX_EQLIMIT 1024"
          ],
          "globals_used": [
            "static void xdl_free_classifier(xdlclassifier_t *cf);",
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\n#define XDL_MAX_EQLIMIT 1024\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, nm, nreff, mlim;\n\txrecord_t **recs;\n\txdlclass_t *rcrec;\n\tchar *dis, *dis1, *dis2;\n\n\tif (!(dis = (char *) xdl_malloc(xdf1->nrec + xdf2->nrec + 2))) {\n\n\t\treturn -1;\n\t}\n\tmemset(dis, 0, xdf1->nrec + xdf2->nrec + 2);\n\tdis1 = dis;\n\tdis2 = dis1 + xdf1->nrec + 1;\n\n\tif ((mlim = xdl_bogosqrt(xdf1->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart]; i <= xdf1->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len2 : 0;\n\t\tdis1[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tif ((mlim = xdl_bogosqrt(xdf2->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart]; i <= xdf2->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len1 : 0;\n\t\tdis2[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tfor (nreff = 0, i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart];\n\t     i <= xdf1->dend; i++, recs++) {\n\t\tif (dis1[i] == 1 ||\n\t\t    (dis1[i] == 2 && !xdl_clean_mmatch(dis1, i, xdf1->dstart, xdf1->dend))) {\n\t\t\txdf1->rindex[nreff] = i;\n\t\t\txdf1->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf1->rchg[i] = 1;\n\t}\n\txdf1->nreff = nreff;\n\n\tfor (nreff = 0, i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart];\n\t     i <= xdf2->dend; i++, recs++) {\n\t\tif (dis2[i] == 1 ||\n\t\t    (dis2[i] == 2 && !xdl_clean_mmatch(dis2, i, xdf2->dstart, xdf2->dend))) {\n\t\t\txdf2->rindex[nreff] = i;\n\t\t\txdf2->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf2->rchg[i] = 1;\n\t}\n\txdf2->nreff = nreff;\n\n\txdl_free(dis);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_trim_ends",
          "args": [
            "xdf1",
            "xdf2"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_trim_ends",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "448-471",
          "snippet": "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, lim;\n\txrecord_t **recs1, **recs2;\n\n\trecs1 = xdf1->recs;\n\trecs2 = xdf2->recs;\n\tfor (i = 0, lim = XDL_MIN(xdf1->nrec, xdf2->nrec); i < lim;\n\t     i++, recs1++, recs2++)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dstart = xdf2->dstart = i;\n\n\trecs1 = xdf1->recs + xdf1->nrec - 1;\n\trecs2 = xdf2->recs + xdf2->nrec - 1;\n\tfor (lim -= i, i = 0; i < lim; i++, recs1--, recs2--)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dend = xdf1->nrec - i - 1;\n\txdf2->dend = xdf2->nrec - i - 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, lim;\n\txrecord_t **recs1, **recs2;\n\n\trecs1 = xdf1->recs;\n\trecs2 = xdf2->recs;\n\tfor (i = 0, lim = XDL_MIN(xdf1->nrec, xdf2->nrec); i < lim;\n\t     i++, recs1++, recs2++)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dstart = xdf2->dstart = i;\n\n\trecs1 = xdf1->recs + xdf1->nrec - 1;\n\trecs2 = xdf2->recs + xdf2->nrec - 1;\n\tfor (lim -= i, i = 0; i < lim; i++, recs1--, recs2--)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dend = xdf1->nrec - i - 1;\n\txdf2->dend = xdf2->nrec - i - 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\n\tif (xdl_trim_ends(xdf1, xdf2) < 0 ||\n\t    xdl_cleanup_records(cf, xdf1, xdf2) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_trim_ends",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "448-471",
    "snippet": "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, lim;\n\txrecord_t **recs1, **recs2;\n\n\trecs1 = xdf1->recs;\n\trecs2 = xdf2->recs;\n\tfor (i = 0, lim = XDL_MIN(xdf1->nrec, xdf2->nrec); i < lim;\n\t     i++, recs1++, recs2++)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dstart = xdf2->dstart = i;\n\n\trecs1 = xdf1->recs + xdf1->nrec - 1;\n\trecs2 = xdf2->recs + xdf2->nrec - 1;\n\tfor (lim -= i, i = 0; i < lim; i++, recs1--, recs2--)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dend = xdf1->nrec - i - 1;\n\txdf2->dend = xdf2->nrec - i - 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDL_MIN",
          "args": [
            "xdf1->nrec",
            "xdf2->nrec"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, lim;\n\txrecord_t **recs1, **recs2;\n\n\trecs1 = xdf1->recs;\n\trecs2 = xdf2->recs;\n\tfor (i = 0, lim = XDL_MIN(xdf1->nrec, xdf2->nrec); i < lim;\n\t     i++, recs1++, recs2++)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dstart = xdf2->dstart = i;\n\n\trecs1 = xdf1->recs + xdf1->nrec - 1;\n\trecs2 = xdf2->recs + xdf2->nrec - 1;\n\tfor (lim -= i, i = 0; i < lim; i++, recs1--, recs2--)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dend = xdf1->nrec - i - 1;\n\txdf2->dend = xdf2->nrec - i - 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_cleanup_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "385-442",
    "snippet": "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, nm, nreff, mlim;\n\txrecord_t **recs;\n\txdlclass_t *rcrec;\n\tchar *dis, *dis1, *dis2;\n\n\tif (!(dis = (char *) xdl_malloc(xdf1->nrec + xdf2->nrec + 2))) {\n\n\t\treturn -1;\n\t}\n\tmemset(dis, 0, xdf1->nrec + xdf2->nrec + 2);\n\tdis1 = dis;\n\tdis2 = dis1 + xdf1->nrec + 1;\n\n\tif ((mlim = xdl_bogosqrt(xdf1->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart]; i <= xdf1->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len2 : 0;\n\t\tdis1[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tif ((mlim = xdl_bogosqrt(xdf2->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart]; i <= xdf2->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len1 : 0;\n\t\tdis2[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tfor (nreff = 0, i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart];\n\t     i <= xdf1->dend; i++, recs++) {\n\t\tif (dis1[i] == 1 ||\n\t\t    (dis1[i] == 2 && !xdl_clean_mmatch(dis1, i, xdf1->dstart, xdf1->dend))) {\n\t\t\txdf1->rindex[nreff] = i;\n\t\t\txdf1->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf1->rchg[i] = 1;\n\t}\n\txdf1->nreff = nreff;\n\n\tfor (nreff = 0, i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart];\n\t     i <= xdf2->dend; i++, recs++) {\n\t\tif (dis2[i] == 1 ||\n\t\t    (dis2[i] == 2 && !xdl_clean_mmatch(dis2, i, xdf2->dstart, xdf2->dend))) {\n\t\t\txdf2->rindex[nreff] = i;\n\t\t\txdf2->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf2->rchg[i] = 1;\n\t}\n\txdf2->nreff = nreff;\n\n\txdl_free(dis);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [
      "#define XDL_MAX_EQLIMIT 1024"
    ],
    "globals_used": [
      "static void xdl_free_classifier(xdlclassifier_t *cf);",
      "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "dis"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_clean_mmatch",
          "args": [
            "dis2",
            "i",
            "xdf2->dstart",
            "xdf2->dend"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_clean_mmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "322-377",
          "snippet": "static int xdl_clean_mmatch(char const *dis, long i, long s, long e) {\n\tlong r, rdis0, rpdis0, rdis1, rpdis1;\n\n\t/*\n\t * Limits the window the is examined during the similar-lines\n\t * scan. The loops below stops when dis[i - r] == 1 (line that\n\t * has no match), but there are corner cases where the loop\n\t * proceed all the way to the extremities by causing huge\n\t * performance penalties in case of big files.\n\t */\n\tif (i - s > XDL_SIMSCAN_WINDOW)\n\t\ts = i - XDL_SIMSCAN_WINDOW;\n\tif (e - i > XDL_SIMSCAN_WINDOW)\n\t\te = i + XDL_SIMSCAN_WINDOW;\n\n\t/*\n\t * Scans the lines before 'i' to find a run of lines that either\n\t * have no match (dis[j] == 0) or have multiple matches (dis[j] > 1).\n\t * Note that we always call this function with dis[i] > 1, so the\n\t * current line (i) is already a multimatch line.\n\t */\n\tfor (r = 1, rdis0 = 0, rpdis0 = 1; (i - r) >= s; r++) {\n\t\tif (!dis[i - r])\n\t\t\trdis0++;\n\t\telse if (dis[i - r] == 2)\n\t\t\trpdis0++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run before the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t * We want to discard multimatch lines only when they appear in the\n\t * middle of runs with nomatch lines (dis[j] == 0).\n\t */\n\tif (rdis0 == 0)\n\t\treturn 0;\n\tfor (r = 1, rdis1 = 0, rpdis1 = 1; (i + r) <= e; r++) {\n\t\tif (!dis[i + r])\n\t\t\trdis1++;\n\t\telse if (dis[i + r] == 2)\n\t\t\trpdis1++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run after the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t */\n\tif (rdis1 == 0)\n\t\treturn 0;\n\trdis1 += rdis0;\n\trpdis1 += rpdis0;\n\n\treturn rpdis1 * XDL_KPDIS_RUN < (rpdis1 + rdis1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_SIMSCAN_WINDOW 100",
            "#define XDL_KPDIS_RUN 4"
          ],
          "globals_used": [
            "static int xdl_clean_mmatch(char const *dis, long i, long s, long e);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\n#define XDL_SIMSCAN_WINDOW 100\n#define XDL_KPDIS_RUN 4\n\nstatic int xdl_clean_mmatch(char const *dis, long i, long s, long e);\n\nstatic int xdl_clean_mmatch(char const *dis, long i, long s, long e) {\n\tlong r, rdis0, rpdis0, rdis1, rpdis1;\n\n\t/*\n\t * Limits the window the is examined during the similar-lines\n\t * scan. The loops below stops when dis[i - r] == 1 (line that\n\t * has no match), but there are corner cases where the loop\n\t * proceed all the way to the extremities by causing huge\n\t * performance penalties in case of big files.\n\t */\n\tif (i - s > XDL_SIMSCAN_WINDOW)\n\t\ts = i - XDL_SIMSCAN_WINDOW;\n\tif (e - i > XDL_SIMSCAN_WINDOW)\n\t\te = i + XDL_SIMSCAN_WINDOW;\n\n\t/*\n\t * Scans the lines before 'i' to find a run of lines that either\n\t * have no match (dis[j] == 0) or have multiple matches (dis[j] > 1).\n\t * Note that we always call this function with dis[i] > 1, so the\n\t * current line (i) is already a multimatch line.\n\t */\n\tfor (r = 1, rdis0 = 0, rpdis0 = 1; (i - r) >= s; r++) {\n\t\tif (!dis[i - r])\n\t\t\trdis0++;\n\t\telse if (dis[i - r] == 2)\n\t\t\trpdis0++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run before the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t * We want to discard multimatch lines only when they appear in the\n\t * middle of runs with nomatch lines (dis[j] == 0).\n\t */\n\tif (rdis0 == 0)\n\t\treturn 0;\n\tfor (r = 1, rdis1 = 0, rpdis1 = 1; (i + r) <= e; r++) {\n\t\tif (!dis[i + r])\n\t\t\trdis1++;\n\t\telse if (dis[i + r] == 2)\n\t\t\trpdis1++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run after the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t */\n\tif (rdis1 == 0)\n\t\treturn 0;\n\trdis1 += rdis0;\n\trpdis1 += rpdis0;\n\n\treturn rpdis1 * XDL_KPDIS_RUN < (rpdis1 + rdis1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_bogosqrt",
          "args": [
            "xdf2->nrec"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_bogosqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "28-38",
          "snippet": "long xdl_bogosqrt(long n) {\n\tlong i;\n\n\t/*\n\t * Classical integer square root approximation using shifts.\n\t */\n\tfor (i = 1; n > 0; n >>= 2)\n\t\ti <<= 1;\n\n\treturn i;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nlong xdl_bogosqrt(long n) {\n\tlong i;\n\n\t/*\n\t * Classical integer square root approximation using shifts.\n\t */\n\tfor (i = 1; n > 0; n >>= 2)\n\t\ti <<= 1;\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dis",
            "0",
            "xdf1->nrec + xdf2->nrec + 2"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "xdf1->nrec + xdf2->nrec + 2"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\n#define XDL_MAX_EQLIMIT 1024\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, nm, nreff, mlim;\n\txrecord_t **recs;\n\txdlclass_t *rcrec;\n\tchar *dis, *dis1, *dis2;\n\n\tif (!(dis = (char *) xdl_malloc(xdf1->nrec + xdf2->nrec + 2))) {\n\n\t\treturn -1;\n\t}\n\tmemset(dis, 0, xdf1->nrec + xdf2->nrec + 2);\n\tdis1 = dis;\n\tdis2 = dis1 + xdf1->nrec + 1;\n\n\tif ((mlim = xdl_bogosqrt(xdf1->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart]; i <= xdf1->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len2 : 0;\n\t\tdis1[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tif ((mlim = xdl_bogosqrt(xdf2->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart]; i <= xdf2->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len1 : 0;\n\t\tdis2[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tfor (nreff = 0, i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart];\n\t     i <= xdf1->dend; i++, recs++) {\n\t\tif (dis1[i] == 1 ||\n\t\t    (dis1[i] == 2 && !xdl_clean_mmatch(dis1, i, xdf1->dstart, xdf1->dend))) {\n\t\t\txdf1->rindex[nreff] = i;\n\t\t\txdf1->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf1->rchg[i] = 1;\n\t}\n\txdf1->nreff = nreff;\n\n\tfor (nreff = 0, i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart];\n\t     i <= xdf2->dend; i++, recs++) {\n\t\tif (dis2[i] == 1 ||\n\t\t    (dis2[i] == 2 && !xdl_clean_mmatch(dis2, i, xdf2->dstart, xdf2->dend))) {\n\t\t\txdf2->rindex[nreff] = i;\n\t\t\txdf2->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf2->rchg[i] = 1;\n\t}\n\txdf2->nreff = nreff;\n\n\txdl_free(dis);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_clean_mmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "322-377",
    "snippet": "static int xdl_clean_mmatch(char const *dis, long i, long s, long e) {\n\tlong r, rdis0, rpdis0, rdis1, rpdis1;\n\n\t/*\n\t * Limits the window the is examined during the similar-lines\n\t * scan. The loops below stops when dis[i - r] == 1 (line that\n\t * has no match), but there are corner cases where the loop\n\t * proceed all the way to the extremities by causing huge\n\t * performance penalties in case of big files.\n\t */\n\tif (i - s > XDL_SIMSCAN_WINDOW)\n\t\ts = i - XDL_SIMSCAN_WINDOW;\n\tif (e - i > XDL_SIMSCAN_WINDOW)\n\t\te = i + XDL_SIMSCAN_WINDOW;\n\n\t/*\n\t * Scans the lines before 'i' to find a run of lines that either\n\t * have no match (dis[j] == 0) or have multiple matches (dis[j] > 1).\n\t * Note that we always call this function with dis[i] > 1, so the\n\t * current line (i) is already a multimatch line.\n\t */\n\tfor (r = 1, rdis0 = 0, rpdis0 = 1; (i - r) >= s; r++) {\n\t\tif (!dis[i - r])\n\t\t\trdis0++;\n\t\telse if (dis[i - r] == 2)\n\t\t\trpdis0++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run before the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t * We want to discard multimatch lines only when they appear in the\n\t * middle of runs with nomatch lines (dis[j] == 0).\n\t */\n\tif (rdis0 == 0)\n\t\treturn 0;\n\tfor (r = 1, rdis1 = 0, rpdis1 = 1; (i + r) <= e; r++) {\n\t\tif (!dis[i + r])\n\t\t\trdis1++;\n\t\telse if (dis[i + r] == 2)\n\t\t\trpdis1++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run after the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t */\n\tif (rdis1 == 0)\n\t\treturn 0;\n\trdis1 += rdis0;\n\trpdis1 += rpdis0;\n\n\treturn rpdis1 * XDL_KPDIS_RUN < (rpdis1 + rdis1);\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [
      "#define XDL_SIMSCAN_WINDOW 100",
      "#define XDL_KPDIS_RUN 4"
    ],
    "globals_used": [
      "static int xdl_clean_mmatch(char const *dis, long i, long s, long e);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xinclude.h\"\n\n#define XDL_SIMSCAN_WINDOW 100\n#define XDL_KPDIS_RUN 4\n\nstatic int xdl_clean_mmatch(char const *dis, long i, long s, long e);\n\nstatic int xdl_clean_mmatch(char const *dis, long i, long s, long e) {\n\tlong r, rdis0, rpdis0, rdis1, rpdis1;\n\n\t/*\n\t * Limits the window the is examined during the similar-lines\n\t * scan. The loops below stops when dis[i - r] == 1 (line that\n\t * has no match), but there are corner cases where the loop\n\t * proceed all the way to the extremities by causing huge\n\t * performance penalties in case of big files.\n\t */\n\tif (i - s > XDL_SIMSCAN_WINDOW)\n\t\ts = i - XDL_SIMSCAN_WINDOW;\n\tif (e - i > XDL_SIMSCAN_WINDOW)\n\t\te = i + XDL_SIMSCAN_WINDOW;\n\n\t/*\n\t * Scans the lines before 'i' to find a run of lines that either\n\t * have no match (dis[j] == 0) or have multiple matches (dis[j] > 1).\n\t * Note that we always call this function with dis[i] > 1, so the\n\t * current line (i) is already a multimatch line.\n\t */\n\tfor (r = 1, rdis0 = 0, rpdis0 = 1; (i - r) >= s; r++) {\n\t\tif (!dis[i - r])\n\t\t\trdis0++;\n\t\telse if (dis[i - r] == 2)\n\t\t\trpdis0++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run before the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t * We want to discard multimatch lines only when they appear in the\n\t * middle of runs with nomatch lines (dis[j] == 0).\n\t */\n\tif (rdis0 == 0)\n\t\treturn 0;\n\tfor (r = 1, rdis1 = 0, rpdis1 = 1; (i + r) <= e; r++) {\n\t\tif (!dis[i + r])\n\t\t\trdis1++;\n\t\telse if (dis[i + r] == 2)\n\t\t\trpdis1++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run after the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t */\n\tif (rdis1 == 0)\n\t\treturn 0;\n\trdis1 += rdis0;\n\trpdis1 += rpdis0;\n\n\treturn rpdis1 * XDL_KPDIS_RUN < (rpdis1 + rdis1);\n}"
  },
  {
    "function_name": "xdl_free_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "315-319",
    "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free_ctx",
          "args": [
            "&xe->xdf1"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "251-259",
          "snippet": "static void xdl_free_ctx(xdfile_t *xdf) {\n\n\txdl_free(xdf->rhash);\n\txdl_free(xdf->rindex);\n\txdl_free(xdf->rchg - 1);\n\txdl_free(xdf->ha);\n\txdl_free(xdf->recs);\n\txdl_cha_free(&xdf->rcha);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);",
            "static void xdl_free_ctx(xdfile_t *xdf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);\nstatic void xdl_free_ctx(xdfile_t *xdf);\n\nstatic void xdl_free_ctx(xdfile_t *xdf) {\n\n\txdl_free(xdf->rhash);\n\txdl_free(xdf->rindex);\n\txdl_free(xdf->rchg - 1);\n\txdl_free(xdf->ha);\n\txdl_free(xdf->recs);\n\txdl_cha_free(&xdf->rcha);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
  },
  {
    "function_name": "xdl_prepare_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "262-312",
    "snippet": "int xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF &&\n\t    xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)\n\t\txdl_free_classifier(&cf);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [
      "#define XDL_GUESS_NLINES2 20",
      "#define XDL_GUESS_NLINES1 256"
    ],
    "globals_used": [
      "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
      "static void xdl_free_classifier(xdlclassifier_t *cf);",
      "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
      "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free_classifier",
          "args": [
            "&cf"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_classifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "102-107",
          "snippet": "static void xdl_free_classifier(xdlclassifier_t *cf) {\n\n\txdl_free(cf->rcrecs);\n\txdl_free(cf->rchash);\n\txdl_cha_free(&cf->ncha);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xdl_free_classifier(xdlclassifier_t *cf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf) {\n\n\txdl_free(cf->rcrecs);\n\txdl_free(cf->rchash);\n\txdl_cha_free(&cf->ncha);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDF_DIFF_ALG",
          "args": [
            "xpp->flags"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_free_ctx",
          "args": [
            "&xe->xdf1"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "251-259",
          "snippet": "static void xdl_free_ctx(xdfile_t *xdf) {\n\n\txdl_free(xdf->rhash);\n\txdl_free(xdf->rindex);\n\txdl_free(xdf->rchg - 1);\n\txdl_free(xdf->ha);\n\txdl_free(xdf->recs);\n\txdl_cha_free(&xdf->rcha);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);",
            "static void xdl_free_ctx(xdfile_t *xdf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);\nstatic void xdl_free_ctx(xdfile_t *xdf);\n\nstatic void xdl_free_ctx(xdfile_t *xdf) {\n\n\txdl_free(xdf->rhash);\n\txdl_free(xdf->rindex);\n\txdl_free(xdf->rchg - 1);\n\txdl_free(xdf->ha);\n\txdl_free(xdf->recs);\n\txdl_cha_free(&xdf->rcha);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_optimize_ctxs",
          "args": [
            "&cf",
            "&xe->xdf1",
            "&xe->xdf2"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_optimize_ctxs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "474-483",
          "snippet": "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\n\tif (xdl_trim_ends(xdf1, xdf2) < 0 ||\n\t    xdl_cleanup_records(cf, xdf1, xdf2) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xdl_free_classifier(xdlclassifier_t *cf);",
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\n\tif (xdl_trim_ends(xdf1, xdf2) < 0 ||\n\t    xdl_cleanup_records(cf, xdf1, xdf2) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDF_DIFF_ALG",
          "args": [
            "xpp->flags"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDF_DIFF_ALG",
          "args": [
            "xpp->flags"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_prepare_ctx",
          "args": [
            "2",
            "mf2",
            "enl2",
            "xpp",
            "&cf",
            "&xe->xdf2"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_prepare_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "160-248",
          "snippet": "static int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf) {\n\tunsigned int hbits;\n\tlong nrec, hsize, bsize;\n\tunsigned long hav;\n\tchar const *blk, *cur, *top, *prev;\n\txrecord_t *crec;\n\txrecord_t **recs, **rrecs;\n\txrecord_t **rhash;\n\tunsigned long *ha;\n\tchar *rchg;\n\tlong *rindex;\n\n\tha = NULL;\n\trindex = NULL;\n\trchg = NULL;\n\trhash = NULL;\n\trecs = NULL;\n\n\tif (xdl_cha_init(&xdf->rcha, sizeof(xrecord_t), narec / 4 + 1) < 0)\n\t\tgoto abort;\n\tif (!(recs = (xrecord_t **) xdl_malloc(narec * sizeof(xrecord_t *))))\n\t\tgoto abort;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\thbits = hsize = 0;\n\telse {\n\t\thbits = xdl_hashbits((unsigned int) narec);\n\t\thsize = 1 << hbits;\n\t\tif (!(rhash = (xrecord_t **) xdl_malloc(hsize * sizeof(xrecord_t *))))\n\t\t\tgoto abort;\n\t\tmemset(rhash, 0, hsize * sizeof(xrecord_t *));\n\t}\n\n\tnrec = 0;\n\tif ((cur = blk = xdl_mmfile_first(mf, &bsize)) != NULL) {\n\t\tfor (top = blk + bsize; cur < top; ) {\n\t\t\tprev = cur;\n\t\t\thav = xdl_hash_record(&cur, top, xpp->flags);\n\t\t\tif (nrec >= narec) {\n\t\t\t\tnarec *= 2;\n\t\t\t\tif (!(rrecs = (xrecord_t **) xdl_realloc(recs, narec * sizeof(xrecord_t *))))\n\t\t\t\t\tgoto abort;\n\t\t\t\trecs = rrecs;\n\t\t\t}\n\t\t\tif (!(crec = xdl_cha_alloc(&xdf->rcha)))\n\t\t\t\tgoto abort;\n\t\t\tcrec->ptr = prev;\n\t\t\tcrec->size = (long) (cur - prev);\n\t\t\tcrec->ha = hav;\n\t\t\trecs[nrec++] = crec;\n\n\t\t\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t\t\t    xdl_classify_record(pass, cf, rhash, hbits, crec) < 0)\n\t\t\t\tgoto abort;\n\t\t}\n\t}\n\n\tif (!(rchg = (char *) xdl_malloc((nrec + 2) * sizeof(char))))\n\t\tgoto abort;\n\tmemset(rchg, 0, (nrec + 2) * sizeof(char));\n\n\tif (!(rindex = (long *) xdl_malloc((nrec + 1) * sizeof(long))))\n\t\tgoto abort;\n\tif (!(ha = (unsigned long *) xdl_malloc((nrec + 1) * sizeof(unsigned long))))\n\t\tgoto abort;\n\n\txdf->nrec = nrec;\n\txdf->recs = recs;\n\txdf->hbits = hbits;\n\txdf->rhash = rhash;\n\txdf->rchg = rchg + 1;\n\txdf->rindex = rindex;\n\txdf->nreff = 0;\n\txdf->ha = ha;\n\txdf->dstart = 0;\n\txdf->dend = nrec - 1;\n\n\treturn 0;\n\nabort:\n\txdl_free(ha);\n\txdl_free(rindex);\n\txdl_free(rchg);\n\txdl_free(rhash);\n\txdl_free(recs);\n\txdl_cha_free(&xdf->rcha);\n\treturn -1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
            "static void xdl_free_classifier(xdlclassifier_t *cf);",
            "static int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);",
            "static void xdl_free_ctx(xdfile_t *xdf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);\nstatic void xdl_free_ctx(xdfile_t *xdf);\n\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf) {\n\tunsigned int hbits;\n\tlong nrec, hsize, bsize;\n\tunsigned long hav;\n\tchar const *blk, *cur, *top, *prev;\n\txrecord_t *crec;\n\txrecord_t **recs, **rrecs;\n\txrecord_t **rhash;\n\tunsigned long *ha;\n\tchar *rchg;\n\tlong *rindex;\n\n\tha = NULL;\n\trindex = NULL;\n\trchg = NULL;\n\trhash = NULL;\n\trecs = NULL;\n\n\tif (xdl_cha_init(&xdf->rcha, sizeof(xrecord_t), narec / 4 + 1) < 0)\n\t\tgoto abort;\n\tif (!(recs = (xrecord_t **) xdl_malloc(narec * sizeof(xrecord_t *))))\n\t\tgoto abort;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\thbits = hsize = 0;\n\telse {\n\t\thbits = xdl_hashbits((unsigned int) narec);\n\t\thsize = 1 << hbits;\n\t\tif (!(rhash = (xrecord_t **) xdl_malloc(hsize * sizeof(xrecord_t *))))\n\t\t\tgoto abort;\n\t\tmemset(rhash, 0, hsize * sizeof(xrecord_t *));\n\t}\n\n\tnrec = 0;\n\tif ((cur = blk = xdl_mmfile_first(mf, &bsize)) != NULL) {\n\t\tfor (top = blk + bsize; cur < top; ) {\n\t\t\tprev = cur;\n\t\t\thav = xdl_hash_record(&cur, top, xpp->flags);\n\t\t\tif (nrec >= narec) {\n\t\t\t\tnarec *= 2;\n\t\t\t\tif (!(rrecs = (xrecord_t **) xdl_realloc(recs, narec * sizeof(xrecord_t *))))\n\t\t\t\t\tgoto abort;\n\t\t\t\trecs = rrecs;\n\t\t\t}\n\t\t\tif (!(crec = xdl_cha_alloc(&xdf->rcha)))\n\t\t\t\tgoto abort;\n\t\t\tcrec->ptr = prev;\n\t\t\tcrec->size = (long) (cur - prev);\n\t\t\tcrec->ha = hav;\n\t\t\trecs[nrec++] = crec;\n\n\t\t\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t\t\t    xdl_classify_record(pass, cf, rhash, hbits, crec) < 0)\n\t\t\t\tgoto abort;\n\t\t}\n\t}\n\n\tif (!(rchg = (char *) xdl_malloc((nrec + 2) * sizeof(char))))\n\t\tgoto abort;\n\tmemset(rchg, 0, (nrec + 2) * sizeof(char));\n\n\tif (!(rindex = (long *) xdl_malloc((nrec + 1) * sizeof(long))))\n\t\tgoto abort;\n\tif (!(ha = (unsigned long *) xdl_malloc((nrec + 1) * sizeof(unsigned long))))\n\t\tgoto abort;\n\n\txdf->nrec = nrec;\n\txdf->recs = recs;\n\txdf->hbits = hbits;\n\txdf->rhash = rhash;\n\txdf->rchg = rchg + 1;\n\txdf->rindex = rindex;\n\txdf->nreff = 0;\n\txdf->ha = ha;\n\txdf->dstart = 0;\n\txdf->dend = nrec - 1;\n\n\treturn 0;\n\nabort:\n\txdl_free(ha);\n\txdl_free(rindex);\n\txdl_free(rchg);\n\txdl_free(rhash);\n\txdl_free(recs);\n\txdl_cha_free(&xdf->rcha);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_init_classifier",
          "args": [
            "&cf",
            "enl1 + enl2 + 1",
            "xpp->flags"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_init_classifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "71-99",
          "snippet": "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags) {\n\tcf->flags = flags;\n\n\tcf->hbits = xdl_hashbits((unsigned int) size);\n\tcf->hsize = 1 << cf->hbits;\n\n\tif (xdl_cha_init(&cf->ncha, sizeof(xdlclass_t), size / 4 + 1) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (!(cf->rchash = (xdlclass_t **) xdl_malloc(cf->hsize * sizeof(xdlclass_t *)))) {\n\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\tmemset(cf->rchash, 0, cf->hsize * sizeof(xdlclass_t *));\n\n\tcf->alloc = size;\n\tif (!(cf->rcrecs = (xdlclass_t **) xdl_malloc(cf->alloc * sizeof(xdlclass_t *)))) {\n\n\t\txdl_free(cf->rchash);\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\n\tcf->count = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
            "static void xdl_free_classifier(xdlclassifier_t *cf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags) {\n\tcf->flags = flags;\n\n\tcf->hbits = xdl_hashbits((unsigned int) size);\n\tcf->hsize = 1 << cf->hbits;\n\n\tif (xdl_cha_init(&cf->ncha, sizeof(xdlclass_t), size / 4 + 1) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (!(cf->rchash = (xdlclass_t **) xdl_malloc(cf->hsize * sizeof(xdlclass_t *)))) {\n\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\tmemset(cf->rchash, 0, cf->hsize * sizeof(xdlclass_t *));\n\n\tcf->alloc = size;\n\tif (!(cf->rcrecs = (xdlclass_t **) xdl_malloc(cf->alloc * sizeof(xdlclass_t *)))) {\n\n\t\txdl_free(cf->rchash);\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\n\tcf->count = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDF_DIFF_ALG",
          "args": [
            "xpp->flags"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_guess_lines",
          "args": [
            "mf2",
            "sample"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_guess_lines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "123-142",
          "snippet": "long xdl_guess_lines(mmfile_t *mf, long sample) {\n\tlong nl = 0, size, tsize = 0;\n\tchar const *data, *cur, *top;\n\n\tif ((cur = data = xdl_mmfile_first(mf, &size)) != NULL) {\n\t\tfor (top = data + size; nl < sample && cur < top; ) {\n\t\t\tnl++;\n\t\t\tif (!(cur = memchr(cur, '\\n', top - cur)))\n\t\t\t\tcur = top;\n\t\t\telse\n\t\t\t\tcur++;\n\t\t}\n\t\ttsize += (long) (cur - data);\n\t}\n\n\tif (nl && tsize)\n\t\tnl = xdl_mmfile_size(mf) / (tsize / nl);\n\n\treturn nl + 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nlong xdl_guess_lines(mmfile_t *mf, long sample) {\n\tlong nl = 0, size, tsize = 0;\n\tchar const *data, *cur, *top;\n\n\tif ((cur = data = xdl_mmfile_first(mf, &size)) != NULL) {\n\t\tfor (top = data + size; nl < sample && cur < top; ) {\n\t\t\tnl++;\n\t\t\tif (!(cur = memchr(cur, '\\n', top - cur)))\n\t\t\t\tcur = top;\n\t\t\telse\n\t\t\t\tcur++;\n\t\t}\n\t\ttsize += (long) (cur - data);\n\t}\n\n\tif (nl && tsize)\n\t\tnl = xdl_mmfile_size(mf) / (tsize / nl);\n\n\treturn nl + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDF_DIFF_ALG",
          "args": [
            "xpp->flags"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cf",
            "0",
            "sizeof(cf)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\n#define XDL_GUESS_NLINES2 20\n#define XDL_GUESS_NLINES1 256\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nint xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF &&\n\t    xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)\n\t\txdl_free_classifier(&cf);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_free_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "251-259",
    "snippet": "static void xdl_free_ctx(xdfile_t *xdf) {\n\n\txdl_free(xdf->rhash);\n\txdl_free(xdf->rindex);\n\txdl_free(xdf->rchg - 1);\n\txdl_free(xdf->ha);\n\txdl_free(xdf->recs);\n\txdl_cha_free(&xdf->rcha);\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);",
      "static void xdl_free_ctx(xdfile_t *xdf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_cha_free",
          "args": [
            "&xdf->rcha"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "88-95",
          "snippet": "void xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "xdf->recs"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);\nstatic void xdl_free_ctx(xdfile_t *xdf);\n\nstatic void xdl_free_ctx(xdfile_t *xdf) {\n\n\txdl_free(xdf->rhash);\n\txdl_free(xdf->rindex);\n\txdl_free(xdf->rchg - 1);\n\txdl_free(xdf->ha);\n\txdl_free(xdf->recs);\n\txdl_cha_free(&xdf->rcha);\n}"
  },
  {
    "function_name": "xdl_prepare_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "160-248",
    "snippet": "static int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf) {\n\tunsigned int hbits;\n\tlong nrec, hsize, bsize;\n\tunsigned long hav;\n\tchar const *blk, *cur, *top, *prev;\n\txrecord_t *crec;\n\txrecord_t **recs, **rrecs;\n\txrecord_t **rhash;\n\tunsigned long *ha;\n\tchar *rchg;\n\tlong *rindex;\n\n\tha = NULL;\n\trindex = NULL;\n\trchg = NULL;\n\trhash = NULL;\n\trecs = NULL;\n\n\tif (xdl_cha_init(&xdf->rcha, sizeof(xrecord_t), narec / 4 + 1) < 0)\n\t\tgoto abort;\n\tif (!(recs = (xrecord_t **) xdl_malloc(narec * sizeof(xrecord_t *))))\n\t\tgoto abort;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\thbits = hsize = 0;\n\telse {\n\t\thbits = xdl_hashbits((unsigned int) narec);\n\t\thsize = 1 << hbits;\n\t\tif (!(rhash = (xrecord_t **) xdl_malloc(hsize * sizeof(xrecord_t *))))\n\t\t\tgoto abort;\n\t\tmemset(rhash, 0, hsize * sizeof(xrecord_t *));\n\t}\n\n\tnrec = 0;\n\tif ((cur = blk = xdl_mmfile_first(mf, &bsize)) != NULL) {\n\t\tfor (top = blk + bsize; cur < top; ) {\n\t\t\tprev = cur;\n\t\t\thav = xdl_hash_record(&cur, top, xpp->flags);\n\t\t\tif (nrec >= narec) {\n\t\t\t\tnarec *= 2;\n\t\t\t\tif (!(rrecs = (xrecord_t **) xdl_realloc(recs, narec * sizeof(xrecord_t *))))\n\t\t\t\t\tgoto abort;\n\t\t\t\trecs = rrecs;\n\t\t\t}\n\t\t\tif (!(crec = xdl_cha_alloc(&xdf->rcha)))\n\t\t\t\tgoto abort;\n\t\t\tcrec->ptr = prev;\n\t\t\tcrec->size = (long) (cur - prev);\n\t\t\tcrec->ha = hav;\n\t\t\trecs[nrec++] = crec;\n\n\t\t\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t\t\t    xdl_classify_record(pass, cf, rhash, hbits, crec) < 0)\n\t\t\t\tgoto abort;\n\t\t}\n\t}\n\n\tif (!(rchg = (char *) xdl_malloc((nrec + 2) * sizeof(char))))\n\t\tgoto abort;\n\tmemset(rchg, 0, (nrec + 2) * sizeof(char));\n\n\tif (!(rindex = (long *) xdl_malloc((nrec + 1) * sizeof(long))))\n\t\tgoto abort;\n\tif (!(ha = (unsigned long *) xdl_malloc((nrec + 1) * sizeof(unsigned long))))\n\t\tgoto abort;\n\n\txdf->nrec = nrec;\n\txdf->recs = recs;\n\txdf->hbits = hbits;\n\txdf->rhash = rhash;\n\txdf->rchg = rchg + 1;\n\txdf->rindex = rindex;\n\txdf->nreff = 0;\n\txdf->ha = ha;\n\txdf->dstart = 0;\n\txdf->dend = nrec - 1;\n\n\treturn 0;\n\nabort:\n\txdl_free(ha);\n\txdl_free(rindex);\n\txdl_free(rchg);\n\txdl_free(rhash);\n\txdl_free(recs);\n\txdl_cha_free(&xdf->rcha);\n\treturn -1;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
      "static void xdl_free_classifier(xdlclassifier_t *cf);",
      "static int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);",
      "static void xdl_free_ctx(xdfile_t *xdf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_cha_free",
          "args": [
            "&xdf->rcha"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "88-95",
          "snippet": "void xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "recs"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "(nrec + 1) * sizeof(unsigned long)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "(nrec + 1) * sizeof(long)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rchg",
            "0",
            "(nrec + 2) * sizeof(char)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "(nrec + 2) * sizeof(char)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_classify_record",
          "args": [
            "pass",
            "cf",
            "rhash",
            "hbits",
            "crec"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_classify_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "110-157",
          "snippet": "static int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec) {\n\tlong hi;\n\tchar const *line;\n\txdlclass_t *rcrec;\n\txdlclass_t **rcrecs;\n\n\tline = rec->ptr;\n\thi = (long) XDL_HASHLONG(rec->ha, cf->hbits);\n\tfor (rcrec = cf->rchash[hi]; rcrec; rcrec = rcrec->next)\n\t\tif (rcrec->ha == rec->ha &&\n\t\t\t\txdl_recmatch(rcrec->line, rcrec->size,\n\t\t\t\t\trec->ptr, rec->size, cf->flags))\n\t\t\tbreak;\n\n\tif (!rcrec) {\n\t\tif (!(rcrec = xdl_cha_alloc(&cf->ncha))) {\n\n\t\t\treturn -1;\n\t\t}\n\t\trcrec->idx = cf->count++;\n\t\tif (cf->count > cf->alloc) {\n\t\t\tcf->alloc *= 2;\n\t\t\tif (!(rcrecs = (xdlclass_t **) xdl_realloc(cf->rcrecs, cf->alloc * sizeof(xdlclass_t *)))) {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcf->rcrecs = rcrecs;\n\t\t}\n\t\tcf->rcrecs[rcrec->idx] = rcrec;\n\t\trcrec->line = line;\n\t\trcrec->size = rec->size;\n\t\trcrec->ha = rec->ha;\n\t\trcrec->len1 = rcrec->len2 = 0;\n\t\trcrec->next = cf->rchash[hi];\n\t\tcf->rchash[hi] = rcrec;\n\t}\n\n\t(pass == 1) ? rcrec->len1++ : rcrec->len2++;\n\n\trec->ha = (unsigned long) rcrec->idx;\n\n\thi = (long) XDL_HASHLONG(rec->ha, hbits);\n\trec->next = rhash[hi];\n\trhash[hi] = rec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
            "static void xdl_free_classifier(xdlclassifier_t *cf);",
            "static int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec);\n\nstatic int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec) {\n\tlong hi;\n\tchar const *line;\n\txdlclass_t *rcrec;\n\txdlclass_t **rcrecs;\n\n\tline = rec->ptr;\n\thi = (long) XDL_HASHLONG(rec->ha, cf->hbits);\n\tfor (rcrec = cf->rchash[hi]; rcrec; rcrec = rcrec->next)\n\t\tif (rcrec->ha == rec->ha &&\n\t\t\t\txdl_recmatch(rcrec->line, rcrec->size,\n\t\t\t\t\trec->ptr, rec->size, cf->flags))\n\t\t\tbreak;\n\n\tif (!rcrec) {\n\t\tif (!(rcrec = xdl_cha_alloc(&cf->ncha))) {\n\n\t\t\treturn -1;\n\t\t}\n\t\trcrec->idx = cf->count++;\n\t\tif (cf->count > cf->alloc) {\n\t\t\tcf->alloc *= 2;\n\t\t\tif (!(rcrecs = (xdlclass_t **) xdl_realloc(cf->rcrecs, cf->alloc * sizeof(xdlclass_t *)))) {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcf->rcrecs = rcrecs;\n\t\t}\n\t\tcf->rcrecs[rcrec->idx] = rcrec;\n\t\trcrec->line = line;\n\t\trcrec->size = rec->size;\n\t\trcrec->ha = rec->ha;\n\t\trcrec->len1 = rcrec->len2 = 0;\n\t\trcrec->next = cf->rchash[hi];\n\t\tcf->rchash[hi] = rcrec;\n\t}\n\n\t(pass == 1) ? rcrec->len1++ : rcrec->len2++;\n\n\trec->ha = (unsigned long) rcrec->idx;\n\n\thi = (long) XDL_HASHLONG(rec->ha, hbits);\n\trec->next = rhash[hi];\n\trhash[hi] = rec;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDF_DIFF_ALG",
          "args": [
            "xpp->flags"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_cha_alloc",
          "args": [
            "&xdf->rcha"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "98-121",
          "snippet": "void *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_realloc",
          "args": [
            "recs",
            "narec * sizeof(xrecord_t *)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_hash_record",
          "args": [
            "&cur",
            "top",
            "xpp->flags"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_hash_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "264-278",
          "snippet": "unsigned long xdl_hash_record(char const **data, char const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tif (flags & XDF_WHITESPACE_FLAGS)\n\t\treturn xdl_hash_record_with_whitespace(data, top, flags);\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nunsigned long xdl_hash_record(char const **data, char const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tif (flags & XDF_WHITESPACE_FLAGS)\n\t\treturn xdl_hash_record_with_whitespace(data, top, flags);\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_mmfile_first",
          "args": [
            "mf",
            "&bsize"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_mmfile_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "63-67",
          "snippet": "void *xdl_mmfile_first(mmfile_t *mmf, long *size)\n{\n\t*size = (long)mmf->size;\n\treturn mmf->ptr;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size)\n{\n\t*size = (long)mmf->size;\n\treturn mmf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rhash",
            "0",
            "hsize * sizeof(xrecord_t *)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "hsize * sizeof(xrecord_t *)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_hashbits",
          "args": [
            "(unsigned int) narec"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_hashbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "281-286",
          "snippet": "unsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nunsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDF_DIFF_ALG",
          "args": [
            "xpp->flags"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "narec * sizeof(xrecord_t *)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_cha_init",
          "args": [
            "&xdf->rcha",
            "sizeof(xrecord_t)",
            "narec / 4 + 1"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "76-85",
          "snippet": "int xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);\nstatic void xdl_free_ctx(xdfile_t *xdf);\n\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf) {\n\tunsigned int hbits;\n\tlong nrec, hsize, bsize;\n\tunsigned long hav;\n\tchar const *blk, *cur, *top, *prev;\n\txrecord_t *crec;\n\txrecord_t **recs, **rrecs;\n\txrecord_t **rhash;\n\tunsigned long *ha;\n\tchar *rchg;\n\tlong *rindex;\n\n\tha = NULL;\n\trindex = NULL;\n\trchg = NULL;\n\trhash = NULL;\n\trecs = NULL;\n\n\tif (xdl_cha_init(&xdf->rcha, sizeof(xrecord_t), narec / 4 + 1) < 0)\n\t\tgoto abort;\n\tif (!(recs = (xrecord_t **) xdl_malloc(narec * sizeof(xrecord_t *))))\n\t\tgoto abort;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\thbits = hsize = 0;\n\telse {\n\t\thbits = xdl_hashbits((unsigned int) narec);\n\t\thsize = 1 << hbits;\n\t\tif (!(rhash = (xrecord_t **) xdl_malloc(hsize * sizeof(xrecord_t *))))\n\t\t\tgoto abort;\n\t\tmemset(rhash, 0, hsize * sizeof(xrecord_t *));\n\t}\n\n\tnrec = 0;\n\tif ((cur = blk = xdl_mmfile_first(mf, &bsize)) != NULL) {\n\t\tfor (top = blk + bsize; cur < top; ) {\n\t\t\tprev = cur;\n\t\t\thav = xdl_hash_record(&cur, top, xpp->flags);\n\t\t\tif (nrec >= narec) {\n\t\t\t\tnarec *= 2;\n\t\t\t\tif (!(rrecs = (xrecord_t **) xdl_realloc(recs, narec * sizeof(xrecord_t *))))\n\t\t\t\t\tgoto abort;\n\t\t\t\trecs = rrecs;\n\t\t\t}\n\t\t\tif (!(crec = xdl_cha_alloc(&xdf->rcha)))\n\t\t\t\tgoto abort;\n\t\t\tcrec->ptr = prev;\n\t\t\tcrec->size = (long) (cur - prev);\n\t\t\tcrec->ha = hav;\n\t\t\trecs[nrec++] = crec;\n\n\t\t\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t\t\t    xdl_classify_record(pass, cf, rhash, hbits, crec) < 0)\n\t\t\t\tgoto abort;\n\t\t}\n\t}\n\n\tif (!(rchg = (char *) xdl_malloc((nrec + 2) * sizeof(char))))\n\t\tgoto abort;\n\tmemset(rchg, 0, (nrec + 2) * sizeof(char));\n\n\tif (!(rindex = (long *) xdl_malloc((nrec + 1) * sizeof(long))))\n\t\tgoto abort;\n\tif (!(ha = (unsigned long *) xdl_malloc((nrec + 1) * sizeof(unsigned long))))\n\t\tgoto abort;\n\n\txdf->nrec = nrec;\n\txdf->recs = recs;\n\txdf->hbits = hbits;\n\txdf->rhash = rhash;\n\txdf->rchg = rchg + 1;\n\txdf->rindex = rindex;\n\txdf->nreff = 0;\n\txdf->ha = ha;\n\txdf->dstart = 0;\n\txdf->dend = nrec - 1;\n\n\treturn 0;\n\nabort:\n\txdl_free(ha);\n\txdl_free(rindex);\n\txdl_free(rchg);\n\txdl_free(rhash);\n\txdl_free(recs);\n\txdl_cha_free(&xdf->rcha);\n\treturn -1;\n}"
  },
  {
    "function_name": "xdl_classify_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "110-157",
    "snippet": "static int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec) {\n\tlong hi;\n\tchar const *line;\n\txdlclass_t *rcrec;\n\txdlclass_t **rcrecs;\n\n\tline = rec->ptr;\n\thi = (long) XDL_HASHLONG(rec->ha, cf->hbits);\n\tfor (rcrec = cf->rchash[hi]; rcrec; rcrec = rcrec->next)\n\t\tif (rcrec->ha == rec->ha &&\n\t\t\t\txdl_recmatch(rcrec->line, rcrec->size,\n\t\t\t\t\trec->ptr, rec->size, cf->flags))\n\t\t\tbreak;\n\n\tif (!rcrec) {\n\t\tif (!(rcrec = xdl_cha_alloc(&cf->ncha))) {\n\n\t\t\treturn -1;\n\t\t}\n\t\trcrec->idx = cf->count++;\n\t\tif (cf->count > cf->alloc) {\n\t\t\tcf->alloc *= 2;\n\t\t\tif (!(rcrecs = (xdlclass_t **) xdl_realloc(cf->rcrecs, cf->alloc * sizeof(xdlclass_t *)))) {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcf->rcrecs = rcrecs;\n\t\t}\n\t\tcf->rcrecs[rcrec->idx] = rcrec;\n\t\trcrec->line = line;\n\t\trcrec->size = rec->size;\n\t\trcrec->ha = rec->ha;\n\t\trcrec->len1 = rcrec->len2 = 0;\n\t\trcrec->next = cf->rchash[hi];\n\t\tcf->rchash[hi] = rcrec;\n\t}\n\n\t(pass == 1) ? rcrec->len1++ : rcrec->len2++;\n\n\trec->ha = (unsigned long) rcrec->idx;\n\n\thi = (long) XDL_HASHLONG(rec->ha, hbits);\n\trec->next = rhash[hi];\n\trhash[hi] = rec;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
      "static void xdl_free_classifier(xdlclassifier_t *cf);",
      "static int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDL_HASHLONG",
          "args": [
            "rec->ha",
            "hbits"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_realloc",
          "args": [
            "cf->rcrecs",
            "cf->alloc * sizeof(xdlclass_t *)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_cha_alloc",
          "args": [
            "&cf->ncha"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "98-121",
          "snippet": "void *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_recmatch",
          "args": [
            "rcrec->line",
            "rcrec->size",
            "rec->ptr",
            "rec->size",
            "cf->flags"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "157-223",
          "snippet": "int xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDL_HASHLONG",
          "args": [
            "rec->ha",
            "cf->hbits"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec);\n\nstatic int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec) {\n\tlong hi;\n\tchar const *line;\n\txdlclass_t *rcrec;\n\txdlclass_t **rcrecs;\n\n\tline = rec->ptr;\n\thi = (long) XDL_HASHLONG(rec->ha, cf->hbits);\n\tfor (rcrec = cf->rchash[hi]; rcrec; rcrec = rcrec->next)\n\t\tif (rcrec->ha == rec->ha &&\n\t\t\t\txdl_recmatch(rcrec->line, rcrec->size,\n\t\t\t\t\trec->ptr, rec->size, cf->flags))\n\t\t\tbreak;\n\n\tif (!rcrec) {\n\t\tif (!(rcrec = xdl_cha_alloc(&cf->ncha))) {\n\n\t\t\treturn -1;\n\t\t}\n\t\trcrec->idx = cf->count++;\n\t\tif (cf->count > cf->alloc) {\n\t\t\tcf->alloc *= 2;\n\t\t\tif (!(rcrecs = (xdlclass_t **) xdl_realloc(cf->rcrecs, cf->alloc * sizeof(xdlclass_t *)))) {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcf->rcrecs = rcrecs;\n\t\t}\n\t\tcf->rcrecs[rcrec->idx] = rcrec;\n\t\trcrec->line = line;\n\t\trcrec->size = rec->size;\n\t\trcrec->ha = rec->ha;\n\t\trcrec->len1 = rcrec->len2 = 0;\n\t\trcrec->next = cf->rchash[hi];\n\t\tcf->rchash[hi] = rcrec;\n\t}\n\n\t(pass == 1) ? rcrec->len1++ : rcrec->len2++;\n\n\trec->ha = (unsigned long) rcrec->idx;\n\n\thi = (long) XDL_HASHLONG(rec->ha, hbits);\n\trec->next = rhash[hi];\n\trhash[hi] = rec;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_free_classifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "102-107",
    "snippet": "static void xdl_free_classifier(xdlclassifier_t *cf) {\n\n\txdl_free(cf->rcrecs);\n\txdl_free(cf->rchash);\n\txdl_cha_free(&cf->ncha);\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xdl_free_classifier(xdlclassifier_t *cf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_cha_free",
          "args": [
            "&cf->ncha"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "88-95",
          "snippet": "void xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "cf->rchash"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf) {\n\n\txdl_free(cf->rcrecs);\n\txdl_free(cf->rchash);\n\txdl_cha_free(&cf->ncha);\n}"
  },
  {
    "function_name": "xdl_init_classifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
    "lines": "71-99",
    "snippet": "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags) {\n\tcf->flags = flags;\n\n\tcf->hbits = xdl_hashbits((unsigned int) size);\n\tcf->hsize = 1 << cf->hbits;\n\n\tif (xdl_cha_init(&cf->ncha, sizeof(xdlclass_t), size / 4 + 1) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (!(cf->rchash = (xdlclass_t **) xdl_malloc(cf->hsize * sizeof(xdlclass_t *)))) {\n\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\tmemset(cf->rchash, 0, cf->hsize * sizeof(xdlclass_t *));\n\n\tcf->alloc = size;\n\tif (!(cf->rcrecs = (xdlclass_t **) xdl_malloc(cf->alloc * sizeof(xdlclass_t *)))) {\n\n\t\txdl_free(cf->rchash);\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\n\tcf->count = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
      "static void xdl_free_classifier(xdlclassifier_t *cf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_cha_free",
          "args": [
            "&cf->ncha"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "88-95",
          "snippet": "void xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "cf->rchash"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "cf->alloc * sizeof(xdlclass_t *)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cf->rchash",
            "0",
            "cf->hsize * sizeof(xdlclass_t *)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "cf->hsize * sizeof(xdlclass_t *)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_cha_init",
          "args": [
            "&cf->ncha",
            "sizeof(xdlclass_t)",
            "size / 4 + 1"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "76-85",
          "snippet": "int xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_hashbits",
          "args": [
            "(unsigned int) size"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_hashbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "281-286",
          "snippet": "unsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nunsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags) {\n\tcf->flags = flags;\n\n\tcf->hbits = xdl_hashbits((unsigned int) size);\n\tcf->hsize = 1 << cf->hbits;\n\n\tif (xdl_cha_init(&cf->ncha, sizeof(xdlclass_t), size / 4 + 1) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (!(cf->rchash = (xdlclass_t **) xdl_malloc(cf->hsize * sizeof(xdlclass_t *)))) {\n\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\tmemset(cf->rchash, 0, cf->hsize * sizeof(xdlclass_t *));\n\n\tcf->alloc = size;\n\tif (!(cf->rcrecs = (xdlclass_t **) xdl_malloc(cf->alloc * sizeof(xdlclass_t *)))) {\n\n\t\txdl_free(cf->rchash);\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\n\tcf->count = 0;\n\n\treturn 0;\n}"
  }
]