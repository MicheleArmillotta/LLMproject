[
  {
    "function_name": "git_pqueue_pop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
    "lines": "102-117",
    "snippet": "void *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"pqueue.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_pop",
          "args": [
            "pq"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "252-256",
          "snippet": "void git_vector_pop(git_vector *v)\n{\n\tif (v->length > 0)\n\t\tv->length--;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_pop(git_vector *v)\n{\n\tif (v->length > 0)\n\t\tv->length--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pqueue_down",
          "args": [
            "pq",
            "0"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "pqueue_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "55-79",
          "snippet": "static void pqueue_down(git_pqueue *pq, size_t el)\n{\n\tvoid *parent = git_vector_get(pq, el), *kid, *rkid;\n\n\twhile (1) {\n\t\tsize_t kid_el = PQUEUE_LCHILD_OF(el);\n\n\t\tif ((kid = git_vector_get(pq, kid_el)) == NULL)\n\t\t\tbreak;\n\n\t\tif ((rkid = git_vector_get(pq, kid_el + 1)) != NULL &&\n\t\t\tpq->_cmp(kid, rkid) > 0) {\n\t\t\tkid    = rkid;\n\t\t\tkid_el += 1;\n\t\t}\n\n\t\tif (pq->_cmp(parent, kid) <= 0)\n\t\t\tbreak;\n\n\t\tpq->contents[el] = kid;\n\t\tel = kid_el;\n\t}\n\n\tpq->contents[el] = parent;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nstatic void pqueue_down(git_pqueue *pq, size_t el)\n{\n\tvoid *parent = git_vector_get(pq, el), *kid, *rkid;\n\n\twhile (1) {\n\t\tsize_t kid_el = PQUEUE_LCHILD_OF(el);\n\n\t\tif ((kid = git_vector_get(pq, kid_el)) == NULL)\n\t\t\tbreak;\n\n\t\tif ((rkid = git_vector_get(pq, kid_el + 1)) != NULL &&\n\t\t\tpq->_cmp(kid, rkid) > 0) {\n\t\t\tkid    = rkid;\n\t\t\tkid_el += 1;\n\t\t}\n\n\t\tif (pq->_cmp(parent, kid) <= 0)\n\t\t\tbreak;\n\n\t\tpq->contents[el] = kid;\n\t\tel = kid_el;\n\t}\n\n\tpq->contents[el] = parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_last",
          "args": [
            "pq"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "72-75",
          "snippet": "GIT_INLINE(void *) git_vector_last(const git_vector *v)\n{\n\treturn (v->length > 0) ? git_vector_get(v, v->length - 1) : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_last(const git_vector *v)\n{\n\treturn (v->length > 0) ? git_vector_get(v, v->length - 1) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pqueue_size",
          "args": [
            "pq"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pqueue_get",
          "args": [
            "pq",
            "0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nvoid *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}"
  },
  {
    "function_name": "git_pqueue_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
    "lines": "81-100",
    "snippet": "int git_pqueue_insert(git_pqueue *pq, void *item)\n{\n\tint error = 0;\n\n\t/* if heap is full, pop the top element if new one should replace it */\n\tif ((pq->flags & GIT_PQUEUE_FIXED_SIZE) != 0 &&\n\t\tpq->length >= pq->_alloc_size)\n\t{\n\t\t/* skip this item if below min item in heap */\n\t\tif (pq->_cmp(item, git_vector_get(pq, 0)) <= 0)\n\t\t\treturn 0;\n\t\t/* otherwise remove the min item before inserting new */\n\t\t(void)git_pqueue_pop(pq);\n\t}\n\n\tif (!(error = git_vector_insert(pq, item)))\n\t\tpqueue_up(pq, pq->length - 1);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"pqueue.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pqueue_up",
          "args": [
            "pq",
            "pq->length - 1"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "pqueue_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "35-53",
          "snippet": "static void pqueue_up(git_pqueue *pq, size_t el)\n{\n\tsize_t parent_el = PQUEUE_PARENT_OF(el);\n\tvoid *kid = git_vector_get(pq, el);\n\n\twhile (el > 0) {\n\t\tvoid *parent = pq->contents[parent_el];\n\n\t\tif (pq->_cmp(parent, kid) <= 0)\n\t\t\tbreak;\n\n\t\tpq->contents[el] = parent;\n\n\t\tel = parent_el;\n\t\tparent_el = PQUEUE_PARENT_OF(el);\n\t}\n\n\tpq->contents[el] = kid;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nstatic void pqueue_up(git_pqueue *pq, size_t el)\n{\n\tsize_t parent_el = PQUEUE_PARENT_OF(el);\n\tvoid *kid = git_vector_get(pq, el);\n\n\twhile (el > 0) {\n\t\tvoid *parent = pq->contents[parent_el];\n\n\t\tif (pq->_cmp(parent, kid) <= 0)\n\t\t\tbreak;\n\n\t\tpq->contents[el] = parent;\n\n\t\tel = parent_el;\n\t\tparent_el = PQUEUE_PARENT_OF(el);\n\t}\n\n\tpq->contents[el] = kid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "pq",
            "item"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pqueue_pop",
          "args": [
            "pq"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "git_pqueue_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
          "lines": "102-117",
          "snippet": "void *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"pqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nvoid *git_pqueue_pop(git_pqueue *pq)\n{\n\tvoid *rval = git_pqueue_get(pq, 0);\n\n\tif (git_pqueue_size(pq) > 1) {\n\t\t/* move last item to top of heap, shrink, and push item down */\n\t\tpq->contents[0] = git_vector_last(pq);\n\t\tgit_vector_pop(pq);\n\t\tpqueue_down(pq, 0);\n\t} else {\n\t\t/* all we need to do is shrink the heap in this case */\n\t\tgit_vector_pop(pq);\n\t}\n\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq->_cmp",
          "args": [
            "item",
            "git_vector_get(pq, 0)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "pq",
            "0"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nint git_pqueue_insert(git_pqueue *pq, void *item)\n{\n\tint error = 0;\n\n\t/* if heap is full, pop the top element if new one should replace it */\n\tif ((pq->flags & GIT_PQUEUE_FIXED_SIZE) != 0 &&\n\t\tpq->length >= pq->_alloc_size)\n\t{\n\t\t/* skip this item if below min item in heap */\n\t\tif (pq->_cmp(item, git_vector_get(pq, 0)) <= 0)\n\t\t\treturn 0;\n\t\t/* otherwise remove the min item before inserting new */\n\t\t(void)git_pqueue_pop(pq);\n\t}\n\n\tif (!(error = git_vector_insert(pq, item)))\n\t\tpqueue_up(pq, pq->length - 1);\n\n\treturn error;\n}"
  },
  {
    "function_name": "pqueue_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
    "lines": "55-79",
    "snippet": "static void pqueue_down(git_pqueue *pq, size_t el)\n{\n\tvoid *parent = git_vector_get(pq, el), *kid, *rkid;\n\n\twhile (1) {\n\t\tsize_t kid_el = PQUEUE_LCHILD_OF(el);\n\n\t\tif ((kid = git_vector_get(pq, kid_el)) == NULL)\n\t\t\tbreak;\n\n\t\tif ((rkid = git_vector_get(pq, kid_el + 1)) != NULL &&\n\t\t\tpq->_cmp(kid, rkid) > 0) {\n\t\t\tkid    = rkid;\n\t\t\tkid_el += 1;\n\t\t}\n\n\t\tif (pq->_cmp(parent, kid) <= 0)\n\t\t\tbreak;\n\n\t\tpq->contents[el] = kid;\n\t\tel = kid_el;\n\t}\n\n\tpq->contents[el] = parent;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"pqueue.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pq->_cmp",
          "args": [
            "parent",
            "kid"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq->_cmp",
          "args": [
            "kid",
            "rkid"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "pq",
            "kid_el + 1"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PQUEUE_LCHILD_OF",
          "args": [
            "el"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nstatic void pqueue_down(git_pqueue *pq, size_t el)\n{\n\tvoid *parent = git_vector_get(pq, el), *kid, *rkid;\n\n\twhile (1) {\n\t\tsize_t kid_el = PQUEUE_LCHILD_OF(el);\n\n\t\tif ((kid = git_vector_get(pq, kid_el)) == NULL)\n\t\t\tbreak;\n\n\t\tif ((rkid = git_vector_get(pq, kid_el + 1)) != NULL &&\n\t\t\tpq->_cmp(kid, rkid) > 0) {\n\t\t\tkid    = rkid;\n\t\t\tkid_el += 1;\n\t\t}\n\n\t\tif (pq->_cmp(parent, kid) <= 0)\n\t\t\tbreak;\n\n\t\tpq->contents[el] = kid;\n\t\tel = kid_el;\n\t}\n\n\tpq->contents[el] = parent;\n}"
  },
  {
    "function_name": "pqueue_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
    "lines": "35-53",
    "snippet": "static void pqueue_up(git_pqueue *pq, size_t el)\n{\n\tsize_t parent_el = PQUEUE_PARENT_OF(el);\n\tvoid *kid = git_vector_get(pq, el);\n\n\twhile (el > 0) {\n\t\tvoid *parent = pq->contents[parent_el];\n\n\t\tif (pq->_cmp(parent, kid) <= 0)\n\t\t\tbreak;\n\n\t\tpq->contents[el] = parent;\n\n\t\tel = parent_el;\n\t\tparent_el = PQUEUE_PARENT_OF(el);\n\t}\n\n\tpq->contents[el] = kid;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"pqueue.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PQUEUE_PARENT_OF",
          "args": [
            "el"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq->_cmp",
          "args": [
            "parent",
            "kid"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "pq",
            "el"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PQUEUE_PARENT_OF",
          "args": [
            "el"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nstatic void pqueue_up(git_pqueue *pq, size_t el)\n{\n\tsize_t parent_el = PQUEUE_PARENT_OF(el);\n\tvoid *kid = git_vector_get(pq, el);\n\n\twhile (el > 0) {\n\t\tvoid *parent = pq->contents[parent_el];\n\n\t\tif (pq->_cmp(parent, kid) <= 0)\n\t\t\tbreak;\n\n\t\tpq->contents[el] = parent;\n\n\t\tel = parent_el;\n\t\tparent_el = PQUEUE_PARENT_OF(el);\n\t}\n\n\tpq->contents[el] = kid;\n}"
  },
  {
    "function_name": "git_pqueue_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pqueue.c",
    "lines": "15-33",
    "snippet": "int git_pqueue_init(\n\tgit_pqueue *pq,\n\tuint32_t flags,\n\tsize_t init_size,\n\tgit_vector_cmp cmp)\n{\n\tint error = git_vector_init(pq, init_size, cmp);\n\n\tif (!error) {\n\t\t/* mix in our flags */\n\t\tpq->flags |= flags;\n\n\t\t/* if fixed size heap, pretend vector is exactly init_size elements */\n\t\tif ((flags & GIT_PQUEUE_FIXED_SIZE) && init_size > 0)\n\t\t\tpq->_alloc_size = init_size;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"pqueue.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "pq",
            "init_size",
            "cmp"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"pqueue.h\"\n\nint git_pqueue_init(\n\tgit_pqueue *pq,\n\tuint32_t flags,\n\tsize_t init_size,\n\tgit_vector_cmp cmp)\n{\n\tint error = git_vector_init(pq, init_size, cmp);\n\n\tif (!error) {\n\t\t/* mix in our flags */\n\t\tpq->flags |= flags;\n\n\t\t/* if fixed size heap, pretend vector is exactly init_size elements */\n\t\tif ((flags & GIT_PQUEUE_FIXED_SIZE) && init_size > 0)\n\t\t\tpq->_alloc_size = init_size;\n\t}\n\n\treturn error;\n}"
  }
]