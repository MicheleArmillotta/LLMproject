[
  {
    "function_name": "git_futils_filestamp_set_from_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "1075-1090",
    "snippet": "void git_futils_filestamp_set_from_stat(\n\tgit_futils_filestamp *stamp, struct stat *st)\n{\n\tif (st) {\n\t\tstamp->mtime.tv_sec = st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec = st->st_mtime_nsec;\n#else\n\t\tstamp->mtime.tv_nsec = 0;\n#endif\n\t\tstamp->size  = (git_off_t)st->st_size;\n\t\tstamp->ino   = (unsigned int)st->st_ino;\n\t} else {\n\t\tmemset(stamp, 0, sizeof(*stamp));\n\t}\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stamp",
            "0",
            "sizeof(*stamp)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_filestamp_set_from_stat(\n\tgit_futils_filestamp *stamp, struct stat *st)\n{\n\tif (st) {\n\t\tstamp->mtime.tv_sec = st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec = st->st_mtime_nsec;\n#else\n\t\tstamp->mtime.tv_nsec = 0;\n#endif\n\t\tstamp->size  = (git_off_t)st->st_size;\n\t\tstamp->ino   = (unsigned int)st->st_ino;\n\t} else {\n\t\tmemset(stamp, 0, sizeof(*stamp));\n\t}\n}"
  },
  {
    "function_name": "git_futils_filestamp_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "1063-1072",
    "snippet": "void git_futils_filestamp_set(\n\tgit_futils_filestamp *target, const git_futils_filestamp *source)\n{\n\tassert(target);\n\n\tif (source)\n\t\tmemcpy(target, source, sizeof(*target));\n\telse\n\t\tmemset(target, 0, sizeof(*target));\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "target",
            "0",
            "sizeof(*target)"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "target",
            "source",
            "sizeof(*target)"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "target"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_filestamp_set(\n\tgit_futils_filestamp *target, const git_futils_filestamp *source)\n{\n\tassert(target);\n\n\tif (source)\n\t\tmemcpy(target, source, sizeof(*target));\n\telse\n\t\tmemset(target, 0, sizeof(*target));\n}"
  },
  {
    "function_name": "git_futils_filestamp_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "1033-1061",
    "snippet": "int git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "path",
            "&st"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "git_futils_cp_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "991-1031",
    "snippet": "int git_futils_cp_r(\n\tconst char *from,\n\tconst char *to,\n\tuint32_t flags,\n\tmode_t dirmode)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tcp_r_info info;\n\n\tif (git_buf_joinpath(&path, from, \"\") < 0) /* ensure trailing slash */\n\t\treturn -1;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.to_root = to;\n\tinfo.flags   = flags;\n\tinfo.dirmode = dirmode;\n\tinfo.from_prefix = path.size;\n\tgit_buf_init(&info.to, 0);\n\n\t/* precalculate mkdir flags */\n\tif ((flags & GIT_CPDIR_CREATE_EMPTY_DIRS) == 0) {\n\t\t/* if not creating empty dirs, then use mkdir to create the path on\n\t\t * demand right before files are copied.\n\t\t */\n\t\tinfo.mkdir_flags = GIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST;\n\t\tif ((flags & GIT_CPDIR_CHMOD_DIRS) != 0)\n\t\t\tinfo.mkdir_flags |= GIT_MKDIR_CHMOD_PATH;\n\t} else {\n\t\t/* otherwise, we will do simple mkdir as directories are encountered */\n\t\tinfo.mkdir_flags =\n\t\t\t((flags & GIT_CPDIR_CHMOD_DIRS) != 0) ? GIT_MKDIR_CHMOD : 0;\n\t}\n\n\terror = _cp_r_callback(&info, &path);\n\n\tgit_buf_free(&path);\n\tgit_buf_free(&info.to);\n\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&info.to"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cp_r_callback",
          "args": [
            "&info",
            "&path"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "_cp_r_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "903-989",
          "snippet": "static int _cp_r_callback(void *ref, git_buf *from)\n{\n\tint error = 0;\n\tcp_r_info *info = ref;\n\tstruct stat from_st, to_st;\n\tbool exists = false;\n\n\tif ((info->flags & GIT_CPDIR_COPY_DOTFILES) == 0 &&\n\t\tfrom->ptr[git_path_basename_offset(from)] == '.')\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(\n\t\t\t&info->to, info->to_root, from->ptr + info->from_prefix)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_path_lstat(info->to.ptr, &to_st)))\n\t\texists = true;\n\telse if (error != GIT_ENOTFOUND)\n\t\treturn error;\n\telse {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tif ((error = git_path_lstat(from->ptr, &from_st)) < 0)\n\t\treturn error;\n\n\tif (S_ISDIR(from_st.st_mode)) {\n\t\tmode_t oldmode = info->dirmode;\n\n\t\t/* if we are not chmod'ing, then overwrite dirmode */\n\t\tif ((info->flags & GIT_CPDIR_CHMOD_DIRS) == 0)\n\t\t\tinfo->dirmode = from_st.st_mode;\n\n\t\t/* make directory now if CREATE_EMPTY_DIRS is requested and needed */\n\t\tif (!exists && (info->flags & GIT_CPDIR_CREATE_EMPTY_DIRS) != 0)\n\t\t\terror = _cp_r_mkdir(info, from);\n\n\t\t/* recurse onto target directory */\n\t\tif (!error && (!exists || S_ISDIR(to_st.st_mode)))\n\t\t\terror = git_path_direach(from, 0, _cp_r_callback, info);\n\n\t\tif (oldmode != 0)\n\t\t\tinfo->dirmode = oldmode;\n\n\t\treturn error;\n\t}\n\n\tif (exists) {\n\t\tif ((info->flags & GIT_CPDIR_OVERWRITE) == 0)\n\t\t\treturn 0;\n\n\t\tif (p_unlink(info->to.ptr) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Cannot overwrite existing file '%s'\",\n\t\t\t\tinfo->to.ptr);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\t/* Done if this isn't a regular file or a symlink */\n\tif (!S_ISREG(from_st.st_mode) &&\n\t\t(!S_ISLNK(from_st.st_mode) ||\n\t\t (info->flags & GIT_CPDIR_COPY_SYMLINKS) == 0))\n\t\treturn 0;\n\n\t/* Make container directory on demand if needed */\n\tif ((info->flags & GIT_CPDIR_CREATE_EMPTY_DIRS) == 0 &&\n\t\t(error = _cp_r_mkdir(info, from)) < 0)\n\t\treturn error;\n\n\t/* make symlink or regular file */\n\tif (info->flags & GIT_CPDIR_LINK_FILES) {\n\t\tif ((error = p_link(from->ptr, info->to.ptr)) < 0)\n\t\t\tgiterr_set(GITERR_OS, \"failed to link '%s'\", from->ptr);\n\t} else if (S_ISLNK(from_st.st_mode)) {\n\t\terror = cp_link(from->ptr, info->to.ptr, (size_t)from_st.st_size);\n\t} else {\n\t\tmode_t usemode = from_st.st_mode;\n\n\t\tif ((info->flags & GIT_CPDIR_SIMPLE_TO_MODE) != 0)\n\t\t\tusemode = GIT_PERMS_FOR_WRITE(usemode);\n\n\t\terror = git_futils_cp(from->ptr, info->to.ptr, usemode);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int _cp_r_callback(void *ref, git_buf *from)\n{\n\tint error = 0;\n\tcp_r_info *info = ref;\n\tstruct stat from_st, to_st;\n\tbool exists = false;\n\n\tif ((info->flags & GIT_CPDIR_COPY_DOTFILES) == 0 &&\n\t\tfrom->ptr[git_path_basename_offset(from)] == '.')\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(\n\t\t\t&info->to, info->to_root, from->ptr + info->from_prefix)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_path_lstat(info->to.ptr, &to_st)))\n\t\texists = true;\n\telse if (error != GIT_ENOTFOUND)\n\t\treturn error;\n\telse {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tif ((error = git_path_lstat(from->ptr, &from_st)) < 0)\n\t\treturn error;\n\n\tif (S_ISDIR(from_st.st_mode)) {\n\t\tmode_t oldmode = info->dirmode;\n\n\t\t/* if we are not chmod'ing, then overwrite dirmode */\n\t\tif ((info->flags & GIT_CPDIR_CHMOD_DIRS) == 0)\n\t\t\tinfo->dirmode = from_st.st_mode;\n\n\t\t/* make directory now if CREATE_EMPTY_DIRS is requested and needed */\n\t\tif (!exists && (info->flags & GIT_CPDIR_CREATE_EMPTY_DIRS) != 0)\n\t\t\terror = _cp_r_mkdir(info, from);\n\n\t\t/* recurse onto target directory */\n\t\tif (!error && (!exists || S_ISDIR(to_st.st_mode)))\n\t\t\terror = git_path_direach(from, 0, _cp_r_callback, info);\n\n\t\tif (oldmode != 0)\n\t\t\tinfo->dirmode = oldmode;\n\n\t\treturn error;\n\t}\n\n\tif (exists) {\n\t\tif ((info->flags & GIT_CPDIR_OVERWRITE) == 0)\n\t\t\treturn 0;\n\n\t\tif (p_unlink(info->to.ptr) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Cannot overwrite existing file '%s'\",\n\t\t\t\tinfo->to.ptr);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\t/* Done if this isn't a regular file or a symlink */\n\tif (!S_ISREG(from_st.st_mode) &&\n\t\t(!S_ISLNK(from_st.st_mode) ||\n\t\t (info->flags & GIT_CPDIR_COPY_SYMLINKS) == 0))\n\t\treturn 0;\n\n\t/* Make container directory on demand if needed */\n\tif ((info->flags & GIT_CPDIR_CREATE_EMPTY_DIRS) == 0 &&\n\t\t(error = _cp_r_mkdir(info, from)) < 0)\n\t\treturn error;\n\n\t/* make symlink or regular file */\n\tif (info->flags & GIT_CPDIR_LINK_FILES) {\n\t\tif ((error = p_link(from->ptr, info->to.ptr)) < 0)\n\t\t\tgiterr_set(GITERR_OS, \"failed to link '%s'\", from->ptr);\n\t} else if (S_ISLNK(from_st.st_mode)) {\n\t\terror = cp_link(from->ptr, info->to.ptr, (size_t)from_st.st_size);\n\t} else {\n\t\tmode_t usemode = from_st.st_mode;\n\n\t\tif ((info->flags & GIT_CPDIR_SIMPLE_TO_MODE) != 0)\n\t\t\tusemode = GIT_PERMS_FOR_WRITE(usemode);\n\n\t\terror = git_futils_cp(from->ptr, info->to.ptr, usemode);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "&info.to",
            "0"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "from",
            "\"\""
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_cp_r(\n\tconst char *from,\n\tconst char *to,\n\tuint32_t flags,\n\tmode_t dirmode)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tcp_r_info info;\n\n\tif (git_buf_joinpath(&path, from, \"\") < 0) /* ensure trailing slash */\n\t\treturn -1;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.to_root = to;\n\tinfo.flags   = flags;\n\tinfo.dirmode = dirmode;\n\tinfo.from_prefix = path.size;\n\tgit_buf_init(&info.to, 0);\n\n\t/* precalculate mkdir flags */\n\tif ((flags & GIT_CPDIR_CREATE_EMPTY_DIRS) == 0) {\n\t\t/* if not creating empty dirs, then use mkdir to create the path on\n\t\t * demand right before files are copied.\n\t\t */\n\t\tinfo.mkdir_flags = GIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST;\n\t\tif ((flags & GIT_CPDIR_CHMOD_DIRS) != 0)\n\t\t\tinfo.mkdir_flags |= GIT_MKDIR_CHMOD_PATH;\n\t} else {\n\t\t/* otherwise, we will do simple mkdir as directories are encountered */\n\t\tinfo.mkdir_flags =\n\t\t\t((flags & GIT_CPDIR_CHMOD_DIRS) != 0) ? GIT_MKDIR_CHMOD : 0;\n\t}\n\n\terror = _cp_r_callback(&info, &path);\n\n\tgit_buf_free(&path);\n\tgit_buf_free(&info.to);\n\n\treturn error;\n}"
  },
  {
    "function_name": "_cp_r_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "903-989",
    "snippet": "static int _cp_r_callback(void *ref, git_buf *from)\n{\n\tint error = 0;\n\tcp_r_info *info = ref;\n\tstruct stat from_st, to_st;\n\tbool exists = false;\n\n\tif ((info->flags & GIT_CPDIR_COPY_DOTFILES) == 0 &&\n\t\tfrom->ptr[git_path_basename_offset(from)] == '.')\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(\n\t\t\t&info->to, info->to_root, from->ptr + info->from_prefix)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_path_lstat(info->to.ptr, &to_st)))\n\t\texists = true;\n\telse if (error != GIT_ENOTFOUND)\n\t\treturn error;\n\telse {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tif ((error = git_path_lstat(from->ptr, &from_st)) < 0)\n\t\treturn error;\n\n\tif (S_ISDIR(from_st.st_mode)) {\n\t\tmode_t oldmode = info->dirmode;\n\n\t\t/* if we are not chmod'ing, then overwrite dirmode */\n\t\tif ((info->flags & GIT_CPDIR_CHMOD_DIRS) == 0)\n\t\t\tinfo->dirmode = from_st.st_mode;\n\n\t\t/* make directory now if CREATE_EMPTY_DIRS is requested and needed */\n\t\tif (!exists && (info->flags & GIT_CPDIR_CREATE_EMPTY_DIRS) != 0)\n\t\t\terror = _cp_r_mkdir(info, from);\n\n\t\t/* recurse onto target directory */\n\t\tif (!error && (!exists || S_ISDIR(to_st.st_mode)))\n\t\t\terror = git_path_direach(from, 0, _cp_r_callback, info);\n\n\t\tif (oldmode != 0)\n\t\t\tinfo->dirmode = oldmode;\n\n\t\treturn error;\n\t}\n\n\tif (exists) {\n\t\tif ((info->flags & GIT_CPDIR_OVERWRITE) == 0)\n\t\t\treturn 0;\n\n\t\tif (p_unlink(info->to.ptr) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Cannot overwrite existing file '%s'\",\n\t\t\t\tinfo->to.ptr);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\t/* Done if this isn't a regular file or a symlink */\n\tif (!S_ISREG(from_st.st_mode) &&\n\t\t(!S_ISLNK(from_st.st_mode) ||\n\t\t (info->flags & GIT_CPDIR_COPY_SYMLINKS) == 0))\n\t\treturn 0;\n\n\t/* Make container directory on demand if needed */\n\tif ((info->flags & GIT_CPDIR_CREATE_EMPTY_DIRS) == 0 &&\n\t\t(error = _cp_r_mkdir(info, from)) < 0)\n\t\treturn error;\n\n\t/* make symlink or regular file */\n\tif (info->flags & GIT_CPDIR_LINK_FILES) {\n\t\tif ((error = p_link(from->ptr, info->to.ptr)) < 0)\n\t\t\tgiterr_set(GITERR_OS, \"failed to link '%s'\", from->ptr);\n\t} else if (S_ISLNK(from_st.st_mode)) {\n\t\terror = cp_link(from->ptr, info->to.ptr, (size_t)from_st.st_size);\n\t} else {\n\t\tmode_t usemode = from_st.st_mode;\n\n\t\tif ((info->flags & GIT_CPDIR_SIMPLE_TO_MODE) != 0)\n\t\t\tusemode = GIT_PERMS_FOR_WRITE(usemode);\n\n\t\terror = git_futils_cp(from->ptr, info->to.ptr, usemode);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_cp",
          "args": [
            "from->ptr",
            "info->to.ptr",
            "usemode"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "825-838",
          "snippet": "int git_futils_cp(const char *from, const char *to, mode_t filemode)\n{\n\tint ifd, ofd;\n\n\tif ((ifd = git_futils_open_ro(from)) < 0)\n\t\treturn ifd;\n\n\tif ((ofd = p_open(to, O_WRONLY | O_CREAT | O_EXCL, filemode)) < 0) {\n\t\tp_close(ifd);\n\t\treturn git_path_set_error(errno, to, \"open for writing\");\n\t}\n\n\treturn cp_by_fd(ifd, ofd, true);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_cp(const char *from, const char *to, mode_t filemode)\n{\n\tint ifd, ofd;\n\n\tif ((ifd = git_futils_open_ro(from)) < 0)\n\t\treturn ifd;\n\n\tif ((ofd = p_open(to, O_WRONLY | O_CREAT | O_EXCL, filemode)) < 0) {\n\t\tp_close(ifd);\n\t\treturn git_path_set_error(errno, to, \"open for writing\");\n\t}\n\n\treturn cp_by_fd(ifd, ofd, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_PERMS_FOR_WRITE",
          "args": [
            "usemode"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cp_link",
          "args": [
            "from->ptr",
            "info->to.ptr",
            "(size_t)from_st.st_size"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "cp_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "840-868",
          "snippet": "static int cp_link(const char *from, const char *to, size_t link_size)\n{\n\tint error = 0;\n\tssize_t read_len;\n\tchar *link_data;\n\tsize_t alloc_size;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_size, link_size, 1);\n\tlink_data = git__malloc(alloc_size);\n\tGITERR_CHECK_ALLOC(link_data);\n\n\tread_len = p_readlink(from, link_data, link_size);\n\tif (read_len != (ssize_t)link_size) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read symlink data for '%s'\", from);\n\t\terror = -1;\n\t}\n\telse {\n\t\tlink_data[read_len] = '\\0';\n\n\t\tif (p_symlink(link_data, to) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Could not symlink '%s' as '%s'\",\n\t\t\t\tlink_data, to);\n\t\t\terror = -1;\n\t\t}\n\t}\n\n\tgit__free(link_data);\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int cp_link(const char *from, const char *to, size_t link_size)\n{\n\tint error = 0;\n\tssize_t read_len;\n\tchar *link_data;\n\tsize_t alloc_size;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_size, link_size, 1);\n\tlink_data = git__malloc(alloc_size);\n\tGITERR_CHECK_ALLOC(link_data);\n\n\tread_len = p_readlink(from, link_data, link_size);\n\tif (read_len != (ssize_t)link_size) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read symlink data for '%s'\", from);\n\t\terror = -1;\n\t}\n\telse {\n\t\tlink_data[read_len] = '\\0';\n\n\t\tif (p_symlink(link_data, to) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Could not symlink '%s' as '%s'\",\n\t\t\t\tlink_data, to);\n\t\t\terror = -1;\n\t\t}\n\t}\n\n\tgit__free(link_data);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "from_st.st_mode"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to link '%s'\"",
            "from->ptr"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_link",
          "args": [
            "from->ptr",
            "info->to.ptr"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "p_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "84-90",
          "snippet": "int p_link(const char *old, const char *new)\n{\n\tGIT_UNUSED(old);\n\tGIT_UNUSED(new);\n\terrno = ENOSYS;\n\treturn -1;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_link(const char *old, const char *new)\n{\n\tGIT_UNUSED(old);\n\tGIT_UNUSED(new);\n\terrno = ENOSYS;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cp_r_mkdir",
          "args": [
            "info",
            "from"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "_cp_r_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "881-901",
          "snippet": "static int _cp_r_mkdir(cp_r_info *info, git_buf *from)\n{\n\tint error = 0;\n\n\t/* create root directory the first time we need to create a directory */\n\tif ((info->flags & GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT) == 0) {\n\t\terror = git_futils_mkdir(\n\t\t\tinfo->to_root, info->dirmode,\n\t\t\t(info->flags & GIT_CPDIR_CHMOD_DIRS) ? GIT_MKDIR_CHMOD : 0);\n\n\t\tinfo->flags |= GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT;\n\t}\n\n\t/* create directory with root as base to prevent excess chmods */\n\tif (!error)\n\t\terror = git_futils_mkdir_relative(\n\t\t\tfrom->ptr + info->from_prefix, info->to_root,\n\t\t\tinfo->dirmode, info->mkdir_flags, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT (1u << 10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\n#define GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT (1u << 10)\n\nstatic int _cp_r_mkdir(cp_r_info *info, git_buf *from)\n{\n\tint error = 0;\n\n\t/* create root directory the first time we need to create a directory */\n\tif ((info->flags & GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT) == 0) {\n\t\terror = git_futils_mkdir(\n\t\t\tinfo->to_root, info->dirmode,\n\t\t\t(info->flags & GIT_CPDIR_CHMOD_DIRS) ? GIT_MKDIR_CHMOD : 0);\n\n\t\tinfo->flags |= GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT;\n\t}\n\n\t/* create directory with root as base to prevent excess chmods */\n\tif (!error)\n\t\terror = git_futils_mkdir_relative(\n\t\t\tfrom->ptr + info->from_prefix, info->to_root,\n\t\t\tinfo->dirmode, info->mkdir_flags, NULL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "from_st.st_mode"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "from_st.st_mode"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "info->to.ptr"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_direach",
          "args": [
            "from",
            "0",
            "_cp_r_callback",
            "info"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_direach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1023-1094",
          "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "to_st.st_mode"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "from_st.st_mode"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_lstat",
          "args": [
            "from->ptr",
            "&from_st"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "634-640",
          "snippet": "int git_path_lstat(const char *path, struct stat *st)\n{\n\tif (p_lstat(path, st) == 0)\n\t\treturn 0;\n\n\treturn git_path_set_error(errno, path, \"stat\");\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_lstat(const char *path, struct stat *st)\n{\n\tif (p_lstat(path, st) == 0)\n\t\treturn 0;\n\n\treturn git_path_set_error(errno, path, \"stat\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&info->to",
            "info->to_root",
            "from->ptr + info->from_prefix"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_basename_offset",
          "args": [
            "from"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_basename_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "205-218",
          "snippet": "size_t git_path_basename_offset(git_buf *buffer)\n{\n\tssize_t slash;\n\n\tif (!buffer || buffer->size <= 0)\n\t\treturn 0;\n\n\tslash = git_buf_rfind_next(buffer, '/');\n\n\tif (slash >= 0 && buffer->ptr[slash] == '/')\n\t\treturn (size_t)(slash + 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nsize_t git_path_basename_offset(git_buf *buffer)\n{\n\tssize_t slash;\n\n\tif (!buffer || buffer->size <= 0)\n\t\treturn 0;\n\n\tslash = git_buf_rfind_next(buffer, '/');\n\n\tif (slash >= 0 && buffer->ptr[slash] == '/')\n\t\treturn (size_t)(slash + 1);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int _cp_r_callback(void *ref, git_buf *from)\n{\n\tint error = 0;\n\tcp_r_info *info = ref;\n\tstruct stat from_st, to_st;\n\tbool exists = false;\n\n\tif ((info->flags & GIT_CPDIR_COPY_DOTFILES) == 0 &&\n\t\tfrom->ptr[git_path_basename_offset(from)] == '.')\n\t\treturn 0;\n\n\tif ((error = git_buf_joinpath(\n\t\t\t&info->to, info->to_root, from->ptr + info->from_prefix)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_path_lstat(info->to.ptr, &to_st)))\n\t\texists = true;\n\telse if (error != GIT_ENOTFOUND)\n\t\treturn error;\n\telse {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tif ((error = git_path_lstat(from->ptr, &from_st)) < 0)\n\t\treturn error;\n\n\tif (S_ISDIR(from_st.st_mode)) {\n\t\tmode_t oldmode = info->dirmode;\n\n\t\t/* if we are not chmod'ing, then overwrite dirmode */\n\t\tif ((info->flags & GIT_CPDIR_CHMOD_DIRS) == 0)\n\t\t\tinfo->dirmode = from_st.st_mode;\n\n\t\t/* make directory now if CREATE_EMPTY_DIRS is requested and needed */\n\t\tif (!exists && (info->flags & GIT_CPDIR_CREATE_EMPTY_DIRS) != 0)\n\t\t\terror = _cp_r_mkdir(info, from);\n\n\t\t/* recurse onto target directory */\n\t\tif (!error && (!exists || S_ISDIR(to_st.st_mode)))\n\t\t\terror = git_path_direach(from, 0, _cp_r_callback, info);\n\n\t\tif (oldmode != 0)\n\t\t\tinfo->dirmode = oldmode;\n\n\t\treturn error;\n\t}\n\n\tif (exists) {\n\t\tif ((info->flags & GIT_CPDIR_OVERWRITE) == 0)\n\t\t\treturn 0;\n\n\t\tif (p_unlink(info->to.ptr) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Cannot overwrite existing file '%s'\",\n\t\t\t\tinfo->to.ptr);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\t/* Done if this isn't a regular file or a symlink */\n\tif (!S_ISREG(from_st.st_mode) &&\n\t\t(!S_ISLNK(from_st.st_mode) ||\n\t\t (info->flags & GIT_CPDIR_COPY_SYMLINKS) == 0))\n\t\treturn 0;\n\n\t/* Make container directory on demand if needed */\n\tif ((info->flags & GIT_CPDIR_CREATE_EMPTY_DIRS) == 0 &&\n\t\t(error = _cp_r_mkdir(info, from)) < 0)\n\t\treturn error;\n\n\t/* make symlink or regular file */\n\tif (info->flags & GIT_CPDIR_LINK_FILES) {\n\t\tif ((error = p_link(from->ptr, info->to.ptr)) < 0)\n\t\t\tgiterr_set(GITERR_OS, \"failed to link '%s'\", from->ptr);\n\t} else if (S_ISLNK(from_st.st_mode)) {\n\t\terror = cp_link(from->ptr, info->to.ptr, (size_t)from_st.st_size);\n\t} else {\n\t\tmode_t usemode = from_st.st_mode;\n\n\t\tif ((info->flags & GIT_CPDIR_SIMPLE_TO_MODE) != 0)\n\t\t\tusemode = GIT_PERMS_FOR_WRITE(usemode);\n\n\t\terror = git_futils_cp(from->ptr, info->to.ptr, usemode);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "_cp_r_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "881-901",
    "snippet": "static int _cp_r_mkdir(cp_r_info *info, git_buf *from)\n{\n\tint error = 0;\n\n\t/* create root directory the first time we need to create a directory */\n\tif ((info->flags & GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT) == 0) {\n\t\terror = git_futils_mkdir(\n\t\t\tinfo->to_root, info->dirmode,\n\t\t\t(info->flags & GIT_CPDIR_CHMOD_DIRS) ? GIT_MKDIR_CHMOD : 0);\n\n\t\tinfo->flags |= GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT;\n\t}\n\n\t/* create directory with root as base to prevent excess chmods */\n\tif (!error)\n\t\terror = git_futils_mkdir_relative(\n\t\t\tfrom->ptr + info->from_prefix, info->to_root,\n\t\t\tinfo->dirmode, info->mkdir_flags, NULL);\n\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT (1u << 10)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_mkdir_relative",
          "args": [
            "from->ptr + info->from_prefix",
            "info->to_root",
            "info->dirmode",
            "info->mkdir_flags",
            "NULL"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkdir_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "498-625",
          "snippet": "int git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mkdir",
          "args": [
            "info->to_root",
            "info->dirmode",
            "(info->flags & GIT_CPDIR_CHMOD_DIRS) ? GIT_MKDIR_CHMOD : 0"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "408-491",
          "snippet": "int git_futils_mkdir(\n\tconst char *path,\n\tmode_t mode,\n\tuint32_t flags)\n{\n\tgit_buf make_path = GIT_BUF_INIT, parent_path = GIT_BUF_INIT;\n\tconst char *relative;\n\tstruct git_futils_mkdir_options opts = { 0 };\n\tstruct stat st;\n\tsize_t depth = 0;\n\tint len = 0, root_len, error;\n\n\tif ((error = git_buf_puts(&make_path, path)) < 0 ||\n\t\t(error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\t(error = git_buf_puts(&parent_path, make_path.ptr)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\troot_len = git_path_root(make_path.ptr);\n\n\t/* find the first parent directory that exists.  this will be used\n\t * as the base to dirname_relative.\n\t */\n\tfor (relative = make_path.ptr; parent_path.size; ) {\n\t\terror = p_lstat(parent_path.ptr, &st);\n\n\t\tif (error == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != ENOENT) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", parent_path.ptr);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdepth++;\n\n\t\t/* examine the parent of the current path */\n\t\tif ((len = git_path_dirname_r(&parent_path, parent_path.ptr)) < 0) {\n\t\t\terror = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tassert(len);\n\n\t\t/* we've walked all the given path's parents and it's either relative\n\t\t * or rooted.  either way, give up and make the entire path.\n\t\t */\n\t\tif ((len == 1 && parent_path.ptr[0] == '.') || len == root_len+1) {\n\t\t\trelative = make_path.ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\trelative = make_path.ptr + len + 1;\n\n\t\t/* not recursive? just make this directory relative to its parent. */\n\t\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* we found an item at the location we're trying to create,\n\t * validate it.\n\t */\n\tif (depth == 0) {\n\t\terror = mkdir_validate_dir(make_path.ptr, &st, mode, flags, &opts);\n\n\t\tif (!error)\n\t\t\terror = mkdir_validate_mode(\n\t\t\t\tmake_path.ptr, &st, true, mode, flags, &opts);\n\n\t\tgoto done;\n\t}\n\n\t/* we already took `SKIP_LAST` and `SKIP_LAST2` into account when\n\t * canonicalizing `make_path`.\n\t */\n\tflags &= ~(GIT_MKDIR_SKIP_LAST2 | GIT_MKDIR_SKIP_LAST);\n\n\terror = git_futils_mkdir_relative(relative,\n\t\tparent_path.size ? parent_path.ptr : NULL, mode, flags, &opts);\n\ndone:\n\tgit_buf_free(&make_path);\n\tgit_buf_free(&parent_path);\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir(\n\tconst char *path,\n\tmode_t mode,\n\tuint32_t flags)\n{\n\tgit_buf make_path = GIT_BUF_INIT, parent_path = GIT_BUF_INIT;\n\tconst char *relative;\n\tstruct git_futils_mkdir_options opts = { 0 };\n\tstruct stat st;\n\tsize_t depth = 0;\n\tint len = 0, root_len, error;\n\n\tif ((error = git_buf_puts(&make_path, path)) < 0 ||\n\t\t(error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\t(error = git_buf_puts(&parent_path, make_path.ptr)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\troot_len = git_path_root(make_path.ptr);\n\n\t/* find the first parent directory that exists.  this will be used\n\t * as the base to dirname_relative.\n\t */\n\tfor (relative = make_path.ptr; parent_path.size; ) {\n\t\terror = p_lstat(parent_path.ptr, &st);\n\n\t\tif (error == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != ENOENT) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", parent_path.ptr);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdepth++;\n\n\t\t/* examine the parent of the current path */\n\t\tif ((len = git_path_dirname_r(&parent_path, parent_path.ptr)) < 0) {\n\t\t\terror = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tassert(len);\n\n\t\t/* we've walked all the given path's parents and it's either relative\n\t\t * or rooted.  either way, give up and make the entire path.\n\t\t */\n\t\tif ((len == 1 && parent_path.ptr[0] == '.') || len == root_len+1) {\n\t\t\trelative = make_path.ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\trelative = make_path.ptr + len + 1;\n\n\t\t/* not recursive? just make this directory relative to its parent. */\n\t\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* we found an item at the location we're trying to create,\n\t * validate it.\n\t */\n\tif (depth == 0) {\n\t\terror = mkdir_validate_dir(make_path.ptr, &st, mode, flags, &opts);\n\n\t\tif (!error)\n\t\t\terror = mkdir_validate_mode(\n\t\t\t\tmake_path.ptr, &st, true, mode, flags, &opts);\n\n\t\tgoto done;\n\t}\n\n\t/* we already took `SKIP_LAST` and `SKIP_LAST2` into account when\n\t * canonicalizing `make_path`.\n\t */\n\tflags &= ~(GIT_MKDIR_SKIP_LAST2 | GIT_MKDIR_SKIP_LAST);\n\n\terror = git_futils_mkdir_relative(relative,\n\t\tparent_path.size ? parent_path.ptr : NULL, mode, flags, &opts);\n\ndone:\n\tgit_buf_free(&make_path);\n\tgit_buf_free(&parent_path);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\n#define GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT (1u << 10)\n\nstatic int _cp_r_mkdir(cp_r_info *info, git_buf *from)\n{\n\tint error = 0;\n\n\t/* create root directory the first time we need to create a directory */\n\tif ((info->flags & GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT) == 0) {\n\t\terror = git_futils_mkdir(\n\t\t\tinfo->to_root, info->dirmode,\n\t\t\t(info->flags & GIT_CPDIR_CHMOD_DIRS) ? GIT_MKDIR_CHMOD : 0);\n\n\t\tinfo->flags |= GIT_CPDIR__MKDIR_DONE_FOR_TO_ROOT;\n\t}\n\n\t/* create directory with root as base to prevent excess chmods */\n\tif (!error)\n\t\terror = git_futils_mkdir_relative(\n\t\t\tfrom->ptr + info->from_prefix, info->to_root,\n\t\t\tinfo->dirmode, info->mkdir_flags, NULL);\n\n\treturn error;\n}"
  },
  {
    "function_name": "cp_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "840-868",
    "snippet": "static int cp_link(const char *from, const char *to, size_t link_size)\n{\n\tint error = 0;\n\tssize_t read_len;\n\tchar *link_data;\n\tsize_t alloc_size;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_size, link_size, 1);\n\tlink_data = git__malloc(alloc_size);\n\tGITERR_CHECK_ALLOC(link_data);\n\n\tread_len = p_readlink(from, link_data, link_size);\n\tif (read_len != (ssize_t)link_size) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read symlink data for '%s'\", from);\n\t\terror = -1;\n\t}\n\telse {\n\t\tlink_data[read_len] = '\\0';\n\n\t\tif (p_symlink(link_data, to) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Could not symlink '%s' as '%s'\",\n\t\t\t\tlink_data, to);\n\t\t\terror = -1;\n\t\t}\n\t}\n\n\tgit__free(link_data);\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "link_data"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not symlink '%s' as '%s'\"",
            "link_data",
            "to"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_symlink",
          "args": [
            "link_data",
            "to"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "p_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "275-281",
          "snippet": "int p_symlink(const char *old, const char *new)\n{\n\t/* Real symlinks on NTFS require admin privileges. Until this changes,\n\t * libgit2 just creates a text file with the link target in the contents.\n\t */\n\treturn git_futils_fake_symlink(old, new);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_symlink(const char *old, const char *new)\n{\n\t/* Real symlinks on NTFS require admin privileges. Until this changes,\n\t * libgit2 just creates a text file with the link target in the contents.\n\t */\n\treturn git_futils_fake_symlink(old, new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_readlink",
          "args": [
            "from",
            "link_data",
            "link_size"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "p_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "251-273",
          "snippet": "int p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "link_data"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloc_size"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_size",
            "link_size",
            "1"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int cp_link(const char *from, const char *to, size_t link_size)\n{\n\tint error = 0;\n\tssize_t read_len;\n\tchar *link_data;\n\tsize_t alloc_size;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_size, link_size, 1);\n\tlink_data = git__malloc(alloc_size);\n\tGITERR_CHECK_ALLOC(link_data);\n\n\tread_len = p_readlink(from, link_data, link_size);\n\tif (read_len != (ssize_t)link_size) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read symlink data for '%s'\", from);\n\t\terror = -1;\n\t}\n\telse {\n\t\tlink_data[read_len] = '\\0';\n\n\t\tif (p_symlink(link_data, to) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Could not symlink '%s' as '%s'\",\n\t\t\t\tlink_data, to);\n\t\t\terror = -1;\n\t\t}\n\t}\n\n\tgit__free(link_data);\n\treturn error;\n}"
  },
  {
    "function_name": "git_futils_cp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "825-838",
    "snippet": "int git_futils_cp(const char *from, const char *to, mode_t filemode)\n{\n\tint ifd, ofd;\n\n\tif ((ifd = git_futils_open_ro(from)) < 0)\n\t\treturn ifd;\n\n\tif ((ofd = p_open(to, O_WRONLY | O_CREAT | O_EXCL, filemode)) < 0) {\n\t\tp_close(ifd);\n\t\treturn git_path_set_error(errno, to, \"open for writing\");\n\t}\n\n\treturn cp_by_fd(ifd, ofd, true);\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cp_by_fd",
          "args": [
            "ifd",
            "ofd",
            "true"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "cp_by_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "797-823",
          "snippet": "static int cp_by_fd(int ifd, int ofd, bool close_fd_when_done)\n{\n\tint error = 0;\n\tchar buffer[FILEIO_BUFSIZE];\n\tssize_t len = 0;\n\n\twhile (!error && (len = p_read(ifd, buffer, sizeof(buffer))) > 0)\n\t\t/* p_write() does not have the same semantics as write().  It loops\n\t\t * internally and will return 0 when it has completed writing.\n\t\t */\n\t\terror = p_write(ofd, buffer, len);\n\n\tif (len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Read error while copying file\");\n\t\terror = (int)len;\n\t}\n\n\tif (error < 0)\n\t\tgiterr_set(GITERR_OS, \"write error while copying file\");\n\n\tif (close_fd_when_done) {\n\t\tp_close(ifd);\n\t\tp_close(ofd);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int cp_by_fd(int ifd, int ofd, bool close_fd_when_done)\n{\n\tint error = 0;\n\tchar buffer[FILEIO_BUFSIZE];\n\tssize_t len = 0;\n\n\twhile (!error && (len = p_read(ifd, buffer, sizeof(buffer))) > 0)\n\t\t/* p_write() does not have the same semantics as write().  It loops\n\t\t * internally and will return 0 when it has completed writing.\n\t\t */\n\t\terror = p_write(ofd, buffer, len);\n\n\tif (len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Read error while copying file\");\n\t\terror = (int)len;\n\t}\n\n\tif (error < 0)\n\t\tgiterr_set(GITERR_OS, \"write error while copying file\");\n\n\tif (close_fd_when_done) {\n\t\tp_close(ifd);\n\t\tp_close(ofd);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_set_error",
          "args": [
            "errno",
            "to",
            "\"open for writing\""
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "611-632",
          "snippet": "int git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "ifd"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_open",
          "args": [
            "to",
            "O_WRONLY | O_CREAT | O_EXCL",
            "filemode"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "p_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "105-118",
          "snippet": "int p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "from"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_cp(const char *from, const char *to, mode_t filemode)\n{\n\tint ifd, ofd;\n\n\tif ((ifd = git_futils_open_ro(from)) < 0)\n\t\treturn ifd;\n\n\tif ((ofd = p_open(to, O_WRONLY | O_CREAT | O_EXCL, filemode)) < 0) {\n\t\tp_close(ifd);\n\t\treturn git_path_set_error(errno, to, \"open for writing\");\n\t}\n\n\treturn cp_by_fd(ifd, ofd, true);\n}"
  },
  {
    "function_name": "cp_by_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "797-823",
    "snippet": "static int cp_by_fd(int ifd, int ofd, bool close_fd_when_done)\n{\n\tint error = 0;\n\tchar buffer[FILEIO_BUFSIZE];\n\tssize_t len = 0;\n\n\twhile (!error && (len = p_read(ifd, buffer, sizeof(buffer))) > 0)\n\t\t/* p_write() does not have the same semantics as write().  It loops\n\t\t * internally and will return 0 when it has completed writing.\n\t\t */\n\t\terror = p_write(ofd, buffer, len);\n\n\tif (len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Read error while copying file\");\n\t\terror = (int)len;\n\t}\n\n\tif (error < 0)\n\t\tgiterr_set(GITERR_OS, \"write error while copying file\");\n\n\tif (close_fd_when_done) {\n\t\tp_close(ifd);\n\t\tp_close(ofd);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "ofd"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"write error while copying file\""
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write",
          "args": [
            "ofd",
            "buffer",
            "len"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "p_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "189-214",
          "snippet": "int p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_read",
          "args": [
            "ifd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "p_readdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.h",
          "lines": "126-131",
          "snippet": "GIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <netdb.h>",
            "#include \"strnlen.h\"",
            "#\tinclude \"unix/posix.h\"",
            "#\tinclude \"win32/posix.h\"",
            "#include \"fnmatch.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <netdb.h>\n#include \"strnlen.h\"\n#\tinclude \"unix/posix.h\"\n#\tinclude \"win32/posix.h\"\n#include \"fnmatch.h\"\n#include <time.h>\n#include <fcntl.h>\n#include \"common.h\"\n\nGIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int cp_by_fd(int ifd, int ofd, bool close_fd_when_done)\n{\n\tint error = 0;\n\tchar buffer[FILEIO_BUFSIZE];\n\tssize_t len = 0;\n\n\twhile (!error && (len = p_read(ifd, buffer, sizeof(buffer))) > 0)\n\t\t/* p_write() does not have the same semantics as write().  It loops\n\t\t * internally and will return 0 when it has completed writing.\n\t\t */\n\t\terror = p_write(ofd, buffer, len);\n\n\tif (len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Read error while copying file\");\n\t\terror = (int)len;\n\t}\n\n\tif (error < 0)\n\t\tgiterr_set(GITERR_OS, \"write error while copying file\");\n\n\tif (close_fd_when_done) {\n\t\tp_close(ifd);\n\t\tp_close(ofd);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_futils_fake_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "786-795",
    "snippet": "int git_futils_fake_symlink(const char *old, const char *new)\n{\n\tint retcode = GIT_ERROR;\n\tint fd = git_futils_creat_withpath(new, 0755, 0644);\n\tif (fd >= 0) {\n\t\tretcode = p_write(fd, old, strlen(old));\n\t\tp_close(fd);\n\t}\n\treturn retcode;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write",
          "args": [
            "fd",
            "old",
            "strlen(old)"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "p_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "189-214",
          "snippet": "int p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "old"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_futils_creat_withpath",
          "args": [
            "new",
            "0755",
            "0644"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_creat_withpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "53-67",
          "snippet": "int git_futils_creat_withpath(const char *path, const mode_t dirmode, const mode_t mode)\n{\n\tint fd;\n\n\tif (git_futils_mkpath2file(path, dirmode) < 0)\n\t\treturn -1;\n\n\tfd = p_creat(path, mode);\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create file '%s'\", path);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_creat_withpath(const char *path, const mode_t dirmode, const mode_t mode)\n{\n\tint fd;\n\n\tif (git_futils_mkpath2file(path, dirmode) < 0)\n\t\treturn -1;\n\n\tfd = p_creat(path, mode);\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create file '%s'\", path);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_fake_symlink(const char *old, const char *new)\n{\n\tint retcode = GIT_ERROR;\n\tint fd = git_futils_creat_withpath(new, 0755, 0644);\n\tif (fd >= 0) {\n\t\tretcode = p_write(fd, old, strlen(old));\n\t\tp_close(fd);\n\t}\n\treturn retcode;\n}"
  },
  {
    "function_name": "git_futils_rmdir_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "753-784",
    "snippet": "int git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&fullpath"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_walk_up",
          "args": [
            "&fullpath",
            "base",
            "futils__rmdir_empty_parent",
            "&data"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_walk_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "439-501",
          "snippet": "int git_path_walk_up(\n\tgit_buf *path,\n\tconst char *ceiling,\n\tint (*cb)(void *data, const char *),\n\tvoid *data)\n{\n\tint error = 0;\n\tgit_buf iter;\n\tssize_t stop = 0, scan;\n\tchar oldc = '\\0';\n\n\tassert(path && cb);\n\n\tif (ceiling != NULL) {\n\t\tif (git__prefixcmp(path->ptr, ceiling) == 0)\n\t\t\tstop = (ssize_t)strlen(ceiling);\n\t\telse\n\t\t\tstop = git_buf_len(path);\n\t}\n\tscan = git_buf_len(path);\n\n\t/* empty path: yield only once */\n\tif (!scan) {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t\treturn error;\n\t}\n\n\titer.ptr = path->ptr;\n\titer.size = git_buf_len(path);\n\titer.asize = path->asize;\n\n\twhile (scan >= stop) {\n\t\terror = cb(data, iter.ptr);\n\t\titer.ptr[scan] = oldc;\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\n\t\tscan = git_buf_rfind_next(&iter, '/');\n\t\tif (scan >= 0) {\n\t\t\tscan++;\n\t\t\toldc = iter.ptr[scan];\n\t\t\titer.size = scan;\n\t\t\titer.ptr[scan] = '\\0';\n\t\t}\n\t}\n\n\tif (scan >= 0)\n\t\titer.ptr[scan] = oldc;\n\n\t/* relative path: yield for the last component */\n\tif (!error && stop == 0 && iter.ptr[0] != '/') {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_walk_up(\n\tgit_buf *path,\n\tconst char *ceiling,\n\tint (*cb)(void *data, const char *),\n\tvoid *data)\n{\n\tint error = 0;\n\tgit_buf iter;\n\tssize_t stop = 0, scan;\n\tchar oldc = '\\0';\n\n\tassert(path && cb);\n\n\tif (ceiling != NULL) {\n\t\tif (git__prefixcmp(path->ptr, ceiling) == 0)\n\t\t\tstop = (ssize_t)strlen(ceiling);\n\t\telse\n\t\t\tstop = git_buf_len(path);\n\t}\n\tscan = git_buf_len(path);\n\n\t/* empty path: yield only once */\n\tif (!scan) {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t\treturn error;\n\t}\n\n\titer.ptr = path->ptr;\n\titer.size = git_buf_len(path);\n\titer.asize = path->asize;\n\n\twhile (scan >= stop) {\n\t\terror = cb(data, iter.ptr);\n\t\titer.ptr[scan] = oldc;\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\n\t\tscan = git_buf_rfind_next(&iter, '/');\n\t\tif (scan >= 0) {\n\t\t\tscan++;\n\t\t\toldc = iter.ptr[scan];\n\t\t\titer.size = scan;\n\t\t\titer.ptr[scan] = '\\0';\n\t\t}\n\t}\n\n\tif (scan >= 0)\n\t\titer.ptr[scan] = oldc;\n\n\t/* relative path: yield for the last component */\n\tif (!error && stop == 0 && iter.ptr[0] != '/') {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futils__rmdir_recurs_foreach",
          "args": [
            "&data",
            "&fullpath"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "futils__rmdir_recurs_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "672-728",
          "snippet": "static int futils__rmdir_recurs_foreach(void *opaque, git_buf *path)\n{\n\tint error = 0;\n\tfutils__rmdir_data *data = opaque;\n\tstruct stat st;\n\n\tif (data->depth > FUTILS_MAX_DEPTH)\n\t\terror = futils__error_cannot_rmdir(\n\t\t\tpath->ptr, \"directory nesting too deep\");\n\n\telse if ((error = p_lstat_posixly(path->ptr, &st)) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\terror = 0;\n\t\telse if (errno == ENOTDIR) {\n\t\t\t/* asked to remove a/b/c/d/e and a/b is a normal file */\n\t\t\tif ((data->flags & GIT_RMDIR_REMOVE_BLOCKERS) != 0)\n\t\t\t\terror = futils__rm_first_parent(path, data->base);\n\t\t\telse\n\t\t\t\tfutils__error_cannot_rmdir(\n\t\t\t\t\tpath->ptr, \"parent is not directory\");\n\t\t}\n\t\telse\n\t\t\terror = git_path_set_error(errno, path->ptr, \"rmdir\");\n\t}\n\n\telse if (S_ISDIR(st.st_mode)) {\n\t\tdata->depth++;\n\n\t\terror = git_path_direach(path, 0, futils__rmdir_recurs_foreach, data);\n\n\t\tdata->depth--;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (data->depth == 0 && (data->flags & GIT_RMDIR_SKIP_ROOT) != 0)\n\t\t\treturn error;\n\n\t\tif ((error = p_rmdir(path->ptr)) < 0) {\n\t\t\tif ((data->flags & GIT_RMDIR_SKIP_NONEMPTY) != 0 &&\n\t\t\t\t(errno == ENOTEMPTY || errno == EEXIST || errno == EBUSY))\n\t\t\t\terror = 0;\n\t\t\telse\n\t\t\t\terror = git_path_set_error(errno, path->ptr, \"rmdir\");\n\t\t}\n\t}\n\n\telse if ((data->flags & GIT_RMDIR_REMOVE_FILES) != 0) {\n\t\tif (p_unlink(path->ptr) < 0)\n\t\t\terror = git_path_set_error(errno, path->ptr, \"remove\");\n\t}\n\n\telse if ((data->flags & GIT_RMDIR_SKIP_NONEMPTY) == 0)\n\t\terror = futils__error_cannot_rmdir(path->ptr, \"still present\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define FUTILS_MAX_DEPTH 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\n#define FUTILS_MAX_DEPTH 100\n\nstatic int futils__rmdir_recurs_foreach(void *opaque, git_buf *path)\n{\n\tint error = 0;\n\tfutils__rmdir_data *data = opaque;\n\tstruct stat st;\n\n\tif (data->depth > FUTILS_MAX_DEPTH)\n\t\terror = futils__error_cannot_rmdir(\n\t\t\tpath->ptr, \"directory nesting too deep\");\n\n\telse if ((error = p_lstat_posixly(path->ptr, &st)) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\terror = 0;\n\t\telse if (errno == ENOTDIR) {\n\t\t\t/* asked to remove a/b/c/d/e and a/b is a normal file */\n\t\t\tif ((data->flags & GIT_RMDIR_REMOVE_BLOCKERS) != 0)\n\t\t\t\terror = futils__rm_first_parent(path, data->base);\n\t\t\telse\n\t\t\t\tfutils__error_cannot_rmdir(\n\t\t\t\t\tpath->ptr, \"parent is not directory\");\n\t\t}\n\t\telse\n\t\t\terror = git_path_set_error(errno, path->ptr, \"rmdir\");\n\t}\n\n\telse if (S_ISDIR(st.st_mode)) {\n\t\tdata->depth++;\n\n\t\terror = git_path_direach(path, 0, futils__rmdir_recurs_foreach, data);\n\n\t\tdata->depth--;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (data->depth == 0 && (data->flags & GIT_RMDIR_SKIP_ROOT) != 0)\n\t\t\treturn error;\n\n\t\tif ((error = p_rmdir(path->ptr)) < 0) {\n\t\t\tif ((data->flags & GIT_RMDIR_SKIP_NONEMPTY) != 0 &&\n\t\t\t\t(errno == ENOTEMPTY || errno == EEXIST || errno == EBUSY))\n\t\t\t\terror = 0;\n\t\t\telse\n\t\t\t\terror = git_path_set_error(errno, path->ptr, \"rmdir\");\n\t\t}\n\t}\n\n\telse if ((data->flags & GIT_RMDIR_REMOVE_FILES) != 0) {\n\t\tif (p_unlink(path->ptr) < 0)\n\t\t\terror = git_path_set_error(errno, path->ptr, \"remove\");\n\t}\n\n\telse if ((data->flags & GIT_RMDIR_SKIP_NONEMPTY) == 0)\n\t\terror = futils__error_cannot_rmdir(path->ptr, \"still present\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "base"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_join_unrooted",
          "args": [
            "&fullpath",
            "path",
            "base",
            "NULL"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_join_unrooted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "279-307",
          "snippet": "int git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}"
  },
  {
    "function_name": "futils__rmdir_empty_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "730-751",
    "snippet": "static int futils__rmdir_empty_parent(void *opaque, const char *path)\n{\n\tfutils__rmdir_data *data = opaque;\n\tint error = 0;\n\n\tif (strlen(path) <= data->baselen)\n\t\terror = GIT_ITEROVER;\n\n\telse if (p_rmdir(path) < 0) {\n\t\tint en = errno;\n\n\t\tif (en == ENOENT || en == ENOTDIR) {\n\t\t\t/* do nothing */\n\t\t} else if (en == ENOTEMPTY || en == EEXIST || en == EBUSY) {\n\t\t\terror = GIT_ITEROVER;\n\t\t} else {\n\t\t\terror = git_path_set_error(errno, path, \"rmdir\");\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_set_error",
          "args": [
            "errno",
            "path",
            "\"rmdir\""
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "611-632",
          "snippet": "int git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_rmdir",
          "args": [
            "path"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "p_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "454-482",
          "snippet": "int p_rmdir(const char* path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wrmdir(buf);\n\n\tif (error == -1) {\n\t\tswitch (GetLastError()) {\n\t\t\t/* _wrmdir() is documented to return EACCES if \"A program has an open\n\t\t\t * handle to the directory.\"  This sounds like what everybody else calls\n\t\t\t * EBUSY.  Let's convert appropriate error codes.\n\t\t\t */\n\t\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\t\terrno = EBUSY;\n\t\t\t\tbreak;\n\n\t\t\t/* This error can be returned when trying to rmdir an extant file. */\n\t\t\tcase ERROR_DIRECTORY:\n\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_rmdir(const char* path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wrmdir(buf);\n\n\tif (error == -1) {\n\t\tswitch (GetLastError()) {\n\t\t\t/* _wrmdir() is documented to return EACCES if \"A program has an open\n\t\t\t * handle to the directory.\"  This sounds like what everybody else calls\n\t\t\t * EBUSY.  Let's convert appropriate error codes.\n\t\t\t */\n\t\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\t\terrno = EBUSY;\n\t\t\t\tbreak;\n\n\t\t\t/* This error can be returned when trying to rmdir an extant file. */\n\t\t\tcase ERROR_DIRECTORY:\n\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int futils__rmdir_empty_parent(void *opaque, const char *path)\n{\n\tfutils__rmdir_data *data = opaque;\n\tint error = 0;\n\n\tif (strlen(path) <= data->baselen)\n\t\terror = GIT_ITEROVER;\n\n\telse if (p_rmdir(path) < 0) {\n\t\tint en = errno;\n\n\t\tif (en == ENOENT || en == ENOTDIR) {\n\t\t\t/* do nothing */\n\t\t} else if (en == ENOTEMPTY || en == EEXIST || en == EBUSY) {\n\t\t\terror = GIT_ITEROVER;\n\t\t} else {\n\t\t\terror = git_path_set_error(errno, path, \"rmdir\");\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "futils__rmdir_recurs_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "672-728",
    "snippet": "static int futils__rmdir_recurs_foreach(void *opaque, git_buf *path)\n{\n\tint error = 0;\n\tfutils__rmdir_data *data = opaque;\n\tstruct stat st;\n\n\tif (data->depth > FUTILS_MAX_DEPTH)\n\t\terror = futils__error_cannot_rmdir(\n\t\t\tpath->ptr, \"directory nesting too deep\");\n\n\telse if ((error = p_lstat_posixly(path->ptr, &st)) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\terror = 0;\n\t\telse if (errno == ENOTDIR) {\n\t\t\t/* asked to remove a/b/c/d/e and a/b is a normal file */\n\t\t\tif ((data->flags & GIT_RMDIR_REMOVE_BLOCKERS) != 0)\n\t\t\t\terror = futils__rm_first_parent(path, data->base);\n\t\t\telse\n\t\t\t\tfutils__error_cannot_rmdir(\n\t\t\t\t\tpath->ptr, \"parent is not directory\");\n\t\t}\n\t\telse\n\t\t\terror = git_path_set_error(errno, path->ptr, \"rmdir\");\n\t}\n\n\telse if (S_ISDIR(st.st_mode)) {\n\t\tdata->depth++;\n\n\t\terror = git_path_direach(path, 0, futils__rmdir_recurs_foreach, data);\n\n\t\tdata->depth--;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (data->depth == 0 && (data->flags & GIT_RMDIR_SKIP_ROOT) != 0)\n\t\t\treturn error;\n\n\t\tif ((error = p_rmdir(path->ptr)) < 0) {\n\t\t\tif ((data->flags & GIT_RMDIR_SKIP_NONEMPTY) != 0 &&\n\t\t\t\t(errno == ENOTEMPTY || errno == EEXIST || errno == EBUSY))\n\t\t\t\terror = 0;\n\t\t\telse\n\t\t\t\terror = git_path_set_error(errno, path->ptr, \"rmdir\");\n\t\t}\n\t}\n\n\telse if ((data->flags & GIT_RMDIR_REMOVE_FILES) != 0) {\n\t\tif (p_unlink(path->ptr) < 0)\n\t\t\terror = git_path_set_error(errno, path->ptr, \"remove\");\n\t}\n\n\telse if ((data->flags & GIT_RMDIR_SKIP_NONEMPTY) == 0)\n\t\terror = futils__error_cannot_rmdir(path->ptr, \"still present\");\n\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define FUTILS_MAX_DEPTH 100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "futils__error_cannot_rmdir",
          "args": [
            "path->ptr",
            "\"still present\""
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "futils__error_cannot_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "636-645",
          "snippet": "static int futils__error_cannot_rmdir(const char *path, const char *filemsg)\n{\n\tif (filemsg)\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory. File '%s' %s\",\n\t\t\t\t   path, filemsg);\n\telse\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory '%s'\", path);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int futils__error_cannot_rmdir(const char *path, const char *filemsg)\n{\n\tif (filemsg)\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory. File '%s' %s\",\n\t\t\t\t   path, filemsg);\n\telse\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory '%s'\", path);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_set_error",
          "args": [
            "errno",
            "path->ptr",
            "\"remove\""
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "611-632",
          "snippet": "int git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "path->ptr"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_rmdir",
          "args": [
            "path->ptr"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "p_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "454-482",
          "snippet": "int p_rmdir(const char* path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wrmdir(buf);\n\n\tif (error == -1) {\n\t\tswitch (GetLastError()) {\n\t\t\t/* _wrmdir() is documented to return EACCES if \"A program has an open\n\t\t\t * handle to the directory.\"  This sounds like what everybody else calls\n\t\t\t * EBUSY.  Let's convert appropriate error codes.\n\t\t\t */\n\t\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\t\terrno = EBUSY;\n\t\t\t\tbreak;\n\n\t\t\t/* This error can be returned when trying to rmdir an extant file. */\n\t\t\tcase ERROR_DIRECTORY:\n\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_rmdir(const char* path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wrmdir(buf);\n\n\tif (error == -1) {\n\t\tswitch (GetLastError()) {\n\t\t\t/* _wrmdir() is documented to return EACCES if \"A program has an open\n\t\t\t * handle to the directory.\"  This sounds like what everybody else calls\n\t\t\t * EBUSY.  Let's convert appropriate error codes.\n\t\t\t */\n\t\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\t\terrno = EBUSY;\n\t\t\t\tbreak;\n\n\t\t\t/* This error can be returned when trying to rmdir an extant file. */\n\t\t\tcase ERROR_DIRECTORY:\n\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_direach",
          "args": [
            "path",
            "0",
            "futils__rmdir_recurs_foreach",
            "data"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_direach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1023-1094",
          "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "futils__rm_first_parent",
          "args": [
            "path",
            "data->base"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "futils__rm_first_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "647-670",
          "snippet": "static int futils__rm_first_parent(git_buf *path, const char *ceiling)\n{\n\tint error = GIT_ENOTFOUND;\n\tstruct stat st;\n\n\twhile (error == GIT_ENOTFOUND) {\n\t\tgit_buf_rtruncate_at_char(path, '/');\n\n\t\tif (!path->size || git__prefixcmp(path->ptr, ceiling) != 0)\n\t\t\terror = 0;\n\t\telse if (p_lstat_posixly(path->ptr, &st) == 0) {\n\t\t\tif (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode))\n\t\t\t\terror = p_unlink(path->ptr);\n\t\t\telse if (!S_ISDIR(st.st_mode))\n\t\t\t\terror = -1; /* fail to remove non-regular file */\n\t\t} else if (errno != ENOTDIR)\n\t\t\terror = -1;\n\t}\n\n\tif (error)\n\t\tfutils__error_cannot_rmdir(path->ptr, \"cannot remove parent\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int futils__rm_first_parent(git_buf *path, const char *ceiling)\n{\n\tint error = GIT_ENOTFOUND;\n\tstruct stat st;\n\n\twhile (error == GIT_ENOTFOUND) {\n\t\tgit_buf_rtruncate_at_char(path, '/');\n\n\t\tif (!path->size || git__prefixcmp(path->ptr, ceiling) != 0)\n\t\t\terror = 0;\n\t\telse if (p_lstat_posixly(path->ptr, &st) == 0) {\n\t\t\tif (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode))\n\t\t\t\terror = p_unlink(path->ptr);\n\t\t\telse if (!S_ISDIR(st.st_mode))\n\t\t\t\terror = -1; /* fail to remove non-regular file */\n\t\t} else if (errno != ENOTDIR)\n\t\t\terror = -1;\n\t}\n\n\tif (error)\n\t\tfutils__error_cannot_rmdir(path->ptr, \"cannot remove parent\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_lstat_posixly",
          "args": [
            "path->ptr",
            "&st"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "p_lstat_posixly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "208-211",
          "snippet": "int p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\n#define FUTILS_MAX_DEPTH 100\n\nstatic int futils__rmdir_recurs_foreach(void *opaque, git_buf *path)\n{\n\tint error = 0;\n\tfutils__rmdir_data *data = opaque;\n\tstruct stat st;\n\n\tif (data->depth > FUTILS_MAX_DEPTH)\n\t\terror = futils__error_cannot_rmdir(\n\t\t\tpath->ptr, \"directory nesting too deep\");\n\n\telse if ((error = p_lstat_posixly(path->ptr, &st)) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\terror = 0;\n\t\telse if (errno == ENOTDIR) {\n\t\t\t/* asked to remove a/b/c/d/e and a/b is a normal file */\n\t\t\tif ((data->flags & GIT_RMDIR_REMOVE_BLOCKERS) != 0)\n\t\t\t\terror = futils__rm_first_parent(path, data->base);\n\t\t\telse\n\t\t\t\tfutils__error_cannot_rmdir(\n\t\t\t\t\tpath->ptr, \"parent is not directory\");\n\t\t}\n\t\telse\n\t\t\terror = git_path_set_error(errno, path->ptr, \"rmdir\");\n\t}\n\n\telse if (S_ISDIR(st.st_mode)) {\n\t\tdata->depth++;\n\n\t\terror = git_path_direach(path, 0, futils__rmdir_recurs_foreach, data);\n\n\t\tdata->depth--;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (data->depth == 0 && (data->flags & GIT_RMDIR_SKIP_ROOT) != 0)\n\t\t\treturn error;\n\n\t\tif ((error = p_rmdir(path->ptr)) < 0) {\n\t\t\tif ((data->flags & GIT_RMDIR_SKIP_NONEMPTY) != 0 &&\n\t\t\t\t(errno == ENOTEMPTY || errno == EEXIST || errno == EBUSY))\n\t\t\t\terror = 0;\n\t\t\telse\n\t\t\t\terror = git_path_set_error(errno, path->ptr, \"rmdir\");\n\t\t}\n\t}\n\n\telse if ((data->flags & GIT_RMDIR_REMOVE_FILES) != 0) {\n\t\tif (p_unlink(path->ptr) < 0)\n\t\t\terror = git_path_set_error(errno, path->ptr, \"remove\");\n\t}\n\n\telse if ((data->flags & GIT_RMDIR_SKIP_NONEMPTY) == 0)\n\t\terror = futils__error_cannot_rmdir(path->ptr, \"still present\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "futils__rm_first_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "647-670",
    "snippet": "static int futils__rm_first_parent(git_buf *path, const char *ceiling)\n{\n\tint error = GIT_ENOTFOUND;\n\tstruct stat st;\n\n\twhile (error == GIT_ENOTFOUND) {\n\t\tgit_buf_rtruncate_at_char(path, '/');\n\n\t\tif (!path->size || git__prefixcmp(path->ptr, ceiling) != 0)\n\t\t\terror = 0;\n\t\telse if (p_lstat_posixly(path->ptr, &st) == 0) {\n\t\t\tif (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode))\n\t\t\t\terror = p_unlink(path->ptr);\n\t\t\telse if (!S_ISDIR(st.st_mode))\n\t\t\t\terror = -1; /* fail to remove non-regular file */\n\t\t} else if (errno != ENOTDIR)\n\t\t\terror = -1;\n\t}\n\n\tif (error)\n\t\tfutils__error_cannot_rmdir(path->ptr, \"cannot remove parent\");\n\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "futils__error_cannot_rmdir",
          "args": [
            "path->ptr",
            "\"cannot remove parent\""
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "futils__error_cannot_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "636-645",
          "snippet": "static int futils__error_cannot_rmdir(const char *path, const char *filemsg)\n{\n\tif (filemsg)\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory. File '%s' %s\",\n\t\t\t\t   path, filemsg);\n\telse\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory '%s'\", path);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int futils__error_cannot_rmdir(const char *path, const char *filemsg)\n{\n\tif (filemsg)\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory. File '%s' %s\",\n\t\t\t\t   path, filemsg);\n\telse\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory '%s'\", path);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "path->ptr"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st.st_mode"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_lstat_posixly",
          "args": [
            "path->ptr",
            "&st"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "p_lstat_posixly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "208-211",
          "snippet": "int p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "path->ptr",
            "ceiling"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rtruncate_at_char",
          "args": [
            "path",
            "'/'"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rtruncate_at_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "464-468",
          "snippet": "void git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int futils__rm_first_parent(git_buf *path, const char *ceiling)\n{\n\tint error = GIT_ENOTFOUND;\n\tstruct stat st;\n\n\twhile (error == GIT_ENOTFOUND) {\n\t\tgit_buf_rtruncate_at_char(path, '/');\n\n\t\tif (!path->size || git__prefixcmp(path->ptr, ceiling) != 0)\n\t\t\terror = 0;\n\t\telse if (p_lstat_posixly(path->ptr, &st) == 0) {\n\t\t\tif (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode))\n\t\t\t\terror = p_unlink(path->ptr);\n\t\t\telse if (!S_ISDIR(st.st_mode))\n\t\t\t\terror = -1; /* fail to remove non-regular file */\n\t\t} else if (errno != ENOTDIR)\n\t\t\terror = -1;\n\t}\n\n\tif (error)\n\t\tfutils__error_cannot_rmdir(path->ptr, \"cannot remove parent\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "futils__error_cannot_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "636-645",
    "snippet": "static int futils__error_cannot_rmdir(const char *path, const char *filemsg)\n{\n\tif (filemsg)\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory. File '%s' %s\",\n\t\t\t\t   path, filemsg);\n\telse\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory '%s'\", path);\n\n\treturn -1;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not remove directory '%s'\"",
            "path"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic int futils__error_cannot_rmdir(const char *path, const char *filemsg)\n{\n\tif (filemsg)\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory. File '%s' %s\",\n\t\t\t\t   path, filemsg);\n\telse\n\t\tgiterr_set(GITERR_OS, \"Could not remove directory '%s'\", path);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "git_futils_mkdir_relative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "498-625",
    "snippet": "int git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&make_path"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Path is not a directory '%s'\"",
            "make_path.ptr"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "make_path.ptr",
            "&st"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_insert",
          "args": [
            "opts->dir_map",
            "cache_path",
            "cache_path",
            "error"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cache_path",
            "make_path.ptr",
            "make_path.size + 1"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "cache_path"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_malloc",
          "args": [
            "opts->pool",
            "(uint32_t)alloc_size"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__is_uint32",
          "args": [
            "alloc_size"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_uint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "25-29",
          "snippet": "GIT_INLINE(int) git__is_uint32(size_t p)\n{\n\tuint32_t r = (uint32_t)p;\n\treturn p == (size_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_uint32(size_t p)\n{\n\tuint32_t r = (uint32_t)p;\n\treturn p == (size_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_size",
            "make_path.size",
            "1"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_validate_mode",
          "args": [
            "make_path.ptr",
            "&st",
            "(lastch == '\\0')",
            "mode",
            "flags",
            "opts"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_validate_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "348-368",
          "snippet": "GIT_INLINE(int) mkdir_validate_mode(\n\tconst char *path,\n\tstruct stat *st,\n\tbool terminal_path,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tif (((terminal_path && (flags & GIT_MKDIR_CHMOD) != 0) ||\n\t\t(flags & GIT_MKDIR_CHMOD_PATH) != 0) && st->st_mode != mode) {\n\n\t\topts->perfdata.chmod_calls++;\n\n\t\tif (p_chmod(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to set permissions on '%s'\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) mkdir_validate_mode(\n\tconst char *path,\n\tstruct stat *st,\n\tbool terminal_path,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tif (((terminal_path && (flags & GIT_MKDIR_CHMOD) != 0) ||\n\t\t(flags & GIT_MKDIR_CHMOD_PATH) != 0) && st->st_mode != mode) {\n\n\t\topts->perfdata.chmod_calls++;\n\n\t\tif (p_chmod(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to set permissions on '%s'\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir_validate_dir",
          "args": [
            "make_path.ptr",
            "&st",
            "mode",
            "flags",
            "opts"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_validate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "299-346",
          "snippet": "GIT_INLINE(int) mkdir_validate_dir(\n\tconst char *path,\n\tstruct stat *st,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\t/* with exclusive create, existing dir is an error */\n\tif ((flags & GIT_MKDIR_EXCL) != 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif ((S_ISREG(st->st_mode) && (flags & GIT_MKDIR_REMOVE_FILES)) ||\n\t\t(S_ISLNK(st->st_mode) && (flags & GIT_MKDIR_REMOVE_SYMLINKS))) {\n\t\tif (p_unlink(path) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to remove %s '%s'\",\n\t\t\t\tS_ISLNK(st->st_mode) ? \"symlink\" : \"file\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\n\t\topts->perfdata.mkdir_calls++;\n\n\t\tif (p_mkdir(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (S_ISLNK(st->st_mode)) {\n\t\t/* Re-stat the target, make sure it's a directory */\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(path, st) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (!S_ISDIR(st->st_mode)) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) mkdir_validate_dir(\n\tconst char *path,\n\tstruct stat *st,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\t/* with exclusive create, existing dir is an error */\n\tif ((flags & GIT_MKDIR_EXCL) != 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif ((S_ISREG(st->st_mode) && (flags & GIT_MKDIR_REMOVE_FILES)) ||\n\t\t(S_ISLNK(st->st_mode) && (flags & GIT_MKDIR_REMOVE_SYMLINKS))) {\n\t\tif (p_unlink(path) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to remove %s '%s'\",\n\t\t\t\tS_ISLNK(st->st_mode) ? \"symlink\" : \"file\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\n\t\topts->perfdata.mkdir_calls++;\n\n\t\tif (p_mkdir(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (S_ISLNK(st->st_mode)) {\n\t\t/* Re-stat the target, make sure it's a directory */\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(path, st) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (!S_ISDIR(st->st_mode)) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_mkdir",
          "args": [
            "make_path.ptr",
            "mode"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "p_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "72-82",
          "snippet": "int p_mkdir(const char *path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tGIT_UNUSED(mode);\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wmkdir(buf);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_mkdir(const char *path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tGIT_UNUSED(mode);\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wmkdir(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_lstat",
          "args": [
            "make_path.ptr",
            "&st"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "p_lstat_posixly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "208-211",
          "snippet": "int p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_exists",
          "args": [
            "opts->dir_map",
            "make_path.ptr"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "make_path.ptr"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rfind",
          "args": [
            "&make_path",
            "'/'"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rfind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "158-163",
          "snippet": "GIT_INLINE(ssize_t) git_buf_rfind(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_buf_rfind(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir_canonicalize",
          "args": [
            "&make_path",
            "flags"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_canonicalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "370-406",
          "snippet": "GIT_INLINE(int) mkdir_canonicalize(\n\tgit_buf *path,\n\tuint32_t flags)\n{\n\tssize_t root_len;\n\n\tif (path->size == 0) {\n\t\tgiterr_set(GITERR_OS, \"attempt to create empty path\");\n\t\treturn -1;\n\t}\n\n\t/* Trim trailing slashes (except the root) */\n\tif ((root_len = git_path_root(path->ptr)) < 0)\n\t\troot_len = 0;\n\telse\n\t\troot_len++;\n\n\twhile (path->size > (size_t)root_len && path->ptr[path->size - 1] == '/')\n\t\tpath->ptr[--path->size] = '\\0';\n\n\t/* if we are not supposed to made the last element, truncate it */\n\tif ((flags & GIT_MKDIR_SKIP_LAST2) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t\tflags |= GIT_MKDIR_SKIP_LAST;\n\t}\n\tif ((flags & GIT_MKDIR_SKIP_LAST) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t}\n\n\t/* We were either given the root path (or trimmed it to\n\t* the root), we don't have anything to do.\n\t*/\n\tif (path->size <= (size_t)root_len)\n\t\tgit_buf_clear(path);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) mkdir_canonicalize(\n\tgit_buf *path,\n\tuint32_t flags)\n{\n\tssize_t root_len;\n\n\tif (path->size == 0) {\n\t\tgiterr_set(GITERR_OS, \"attempt to create empty path\");\n\t\treturn -1;\n\t}\n\n\t/* Trim trailing slashes (except the root) */\n\tif ((root_len = git_path_root(path->ptr)) < 0)\n\t\troot_len = 0;\n\telse\n\t\troot_len++;\n\n\twhile (path->size > (size_t)root_len && path->ptr[path->size - 1] == '/')\n\t\tpath->ptr[--path->size] = '\\0';\n\n\t/* if we are not supposed to made the last element, truncate it */\n\tif ((flags & GIT_MKDIR_SKIP_LAST2) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t\tflags |= GIT_MKDIR_SKIP_LAST;\n\t}\n\tif ((flags & GIT_MKDIR_SKIP_LAST) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t}\n\n\t/* We were either given the root path (or trimmed it to\n\t* the root), we don't have anything to do.\n\t*/\n\tif (path->size <= (size_t)root_len)\n\t\tgit_buf_clear(path);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_join_unrooted",
          "args": [
            "&make_path",
            "relative_path",
            "base",
            "&root"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_join_unrooted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "279-307",
          "snippet": "int git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_join_unrooted(\n\tgit_buf *path_out, const char *path, const char *base, ssize_t *root_at)\n{\n\tssize_t root;\n\n\tassert(path && path_out);\n\n\troot = (ssize_t)git_path_root(path);\n\n\tif (base != NULL && root < 0) {\n\t\tif (git_buf_joinpath(path_out, base, path) < 0)\n\t\t\treturn -1;\n\n\t\troot = (ssize_t)strlen(base);\n\t} else {\n\t\tif (git_buf_sets(path_out, path) < 0)\n\t\t\treturn -1;\n\n\t\tif (root < 0)\n\t\t\troot = 0;\n\t\telse if (base)\n\t\t\tgit_path_equal_or_prefixed(base, path, &root);\n\t}\n\n\tif (root_at)\n\t\t*root_at = root;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}"
  },
  {
    "function_name": "git_futils_mkdir_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "493-496",
    "snippet": "int git_futils_mkdir_r(const char *path, const mode_t mode)\n{\n\treturn git_futils_mkdir(path, mode, GIT_MKDIR_PATH);\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_mkdir",
          "args": [
            "path",
            "mode",
            "GIT_MKDIR_PATH"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "408-491",
          "snippet": "int git_futils_mkdir(\n\tconst char *path,\n\tmode_t mode,\n\tuint32_t flags)\n{\n\tgit_buf make_path = GIT_BUF_INIT, parent_path = GIT_BUF_INIT;\n\tconst char *relative;\n\tstruct git_futils_mkdir_options opts = { 0 };\n\tstruct stat st;\n\tsize_t depth = 0;\n\tint len = 0, root_len, error;\n\n\tif ((error = git_buf_puts(&make_path, path)) < 0 ||\n\t\t(error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\t(error = git_buf_puts(&parent_path, make_path.ptr)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\troot_len = git_path_root(make_path.ptr);\n\n\t/* find the first parent directory that exists.  this will be used\n\t * as the base to dirname_relative.\n\t */\n\tfor (relative = make_path.ptr; parent_path.size; ) {\n\t\terror = p_lstat(parent_path.ptr, &st);\n\n\t\tif (error == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != ENOENT) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", parent_path.ptr);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdepth++;\n\n\t\t/* examine the parent of the current path */\n\t\tif ((len = git_path_dirname_r(&parent_path, parent_path.ptr)) < 0) {\n\t\t\terror = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tassert(len);\n\n\t\t/* we've walked all the given path's parents and it's either relative\n\t\t * or rooted.  either way, give up and make the entire path.\n\t\t */\n\t\tif ((len == 1 && parent_path.ptr[0] == '.') || len == root_len+1) {\n\t\t\trelative = make_path.ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\trelative = make_path.ptr + len + 1;\n\n\t\t/* not recursive? just make this directory relative to its parent. */\n\t\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* we found an item at the location we're trying to create,\n\t * validate it.\n\t */\n\tif (depth == 0) {\n\t\terror = mkdir_validate_dir(make_path.ptr, &st, mode, flags, &opts);\n\n\t\tif (!error)\n\t\t\terror = mkdir_validate_mode(\n\t\t\t\tmake_path.ptr, &st, true, mode, flags, &opts);\n\n\t\tgoto done;\n\t}\n\n\t/* we already took `SKIP_LAST` and `SKIP_LAST2` into account when\n\t * canonicalizing `make_path`.\n\t */\n\tflags &= ~(GIT_MKDIR_SKIP_LAST2 | GIT_MKDIR_SKIP_LAST);\n\n\terror = git_futils_mkdir_relative(relative,\n\t\tparent_path.size ? parent_path.ptr : NULL, mode, flags, &opts);\n\ndone:\n\tgit_buf_free(&make_path);\n\tgit_buf_free(&parent_path);\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir(\n\tconst char *path,\n\tmode_t mode,\n\tuint32_t flags)\n{\n\tgit_buf make_path = GIT_BUF_INIT, parent_path = GIT_BUF_INIT;\n\tconst char *relative;\n\tstruct git_futils_mkdir_options opts = { 0 };\n\tstruct stat st;\n\tsize_t depth = 0;\n\tint len = 0, root_len, error;\n\n\tif ((error = git_buf_puts(&make_path, path)) < 0 ||\n\t\t(error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\t(error = git_buf_puts(&parent_path, make_path.ptr)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\troot_len = git_path_root(make_path.ptr);\n\n\t/* find the first parent directory that exists.  this will be used\n\t * as the base to dirname_relative.\n\t */\n\tfor (relative = make_path.ptr; parent_path.size; ) {\n\t\terror = p_lstat(parent_path.ptr, &st);\n\n\t\tif (error == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != ENOENT) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", parent_path.ptr);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdepth++;\n\n\t\t/* examine the parent of the current path */\n\t\tif ((len = git_path_dirname_r(&parent_path, parent_path.ptr)) < 0) {\n\t\t\terror = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tassert(len);\n\n\t\t/* we've walked all the given path's parents and it's either relative\n\t\t * or rooted.  either way, give up and make the entire path.\n\t\t */\n\t\tif ((len == 1 && parent_path.ptr[0] == '.') || len == root_len+1) {\n\t\t\trelative = make_path.ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\trelative = make_path.ptr + len + 1;\n\n\t\t/* not recursive? just make this directory relative to its parent. */\n\t\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* we found an item at the location we're trying to create,\n\t * validate it.\n\t */\n\tif (depth == 0) {\n\t\terror = mkdir_validate_dir(make_path.ptr, &st, mode, flags, &opts);\n\n\t\tif (!error)\n\t\t\terror = mkdir_validate_mode(\n\t\t\t\tmake_path.ptr, &st, true, mode, flags, &opts);\n\n\t\tgoto done;\n\t}\n\n\t/* we already took `SKIP_LAST` and `SKIP_LAST2` into account when\n\t * canonicalizing `make_path`.\n\t */\n\tflags &= ~(GIT_MKDIR_SKIP_LAST2 | GIT_MKDIR_SKIP_LAST);\n\n\terror = git_futils_mkdir_relative(relative,\n\t\tparent_path.size ? parent_path.ptr : NULL, mode, flags, &opts);\n\ndone:\n\tgit_buf_free(&make_path);\n\tgit_buf_free(&parent_path);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir_r(const char *path, const mode_t mode)\n{\n\treturn git_futils_mkdir(path, mode, GIT_MKDIR_PATH);\n}"
  },
  {
    "function_name": "git_futils_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "408-491",
    "snippet": "int git_futils_mkdir(\n\tconst char *path,\n\tmode_t mode,\n\tuint32_t flags)\n{\n\tgit_buf make_path = GIT_BUF_INIT, parent_path = GIT_BUF_INIT;\n\tconst char *relative;\n\tstruct git_futils_mkdir_options opts = { 0 };\n\tstruct stat st;\n\tsize_t depth = 0;\n\tint len = 0, root_len, error;\n\n\tif ((error = git_buf_puts(&make_path, path)) < 0 ||\n\t\t(error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\t(error = git_buf_puts(&parent_path, make_path.ptr)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\troot_len = git_path_root(make_path.ptr);\n\n\t/* find the first parent directory that exists.  this will be used\n\t * as the base to dirname_relative.\n\t */\n\tfor (relative = make_path.ptr; parent_path.size; ) {\n\t\terror = p_lstat(parent_path.ptr, &st);\n\n\t\tif (error == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != ENOENT) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", parent_path.ptr);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdepth++;\n\n\t\t/* examine the parent of the current path */\n\t\tif ((len = git_path_dirname_r(&parent_path, parent_path.ptr)) < 0) {\n\t\t\terror = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tassert(len);\n\n\t\t/* we've walked all the given path's parents and it's either relative\n\t\t * or rooted.  either way, give up and make the entire path.\n\t\t */\n\t\tif ((len == 1 && parent_path.ptr[0] == '.') || len == root_len+1) {\n\t\t\trelative = make_path.ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\trelative = make_path.ptr + len + 1;\n\n\t\t/* not recursive? just make this directory relative to its parent. */\n\t\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* we found an item at the location we're trying to create,\n\t * validate it.\n\t */\n\tif (depth == 0) {\n\t\terror = mkdir_validate_dir(make_path.ptr, &st, mode, flags, &opts);\n\n\t\tif (!error)\n\t\t\terror = mkdir_validate_mode(\n\t\t\t\tmake_path.ptr, &st, true, mode, flags, &opts);\n\n\t\tgoto done;\n\t}\n\n\t/* we already took `SKIP_LAST` and `SKIP_LAST2` into account when\n\t * canonicalizing `make_path`.\n\t */\n\tflags &= ~(GIT_MKDIR_SKIP_LAST2 | GIT_MKDIR_SKIP_LAST);\n\n\terror = git_futils_mkdir_relative(relative,\n\t\tparent_path.size ? parent_path.ptr : NULL, mode, flags, &opts);\n\ndone:\n\tgit_buf_free(&make_path);\n\tgit_buf_free(&parent_path);\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&parent_path"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mkdir_relative",
          "args": [
            "relative",
            "parent_path.size ? parent_path.ptr : NULL",
            "mode",
            "flags",
            "&opts"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkdir_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "498-625",
          "snippet": "int git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir_validate_mode",
          "args": [
            "make_path.ptr",
            "&st",
            "true",
            "mode",
            "flags",
            "&opts"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_validate_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "348-368",
          "snippet": "GIT_INLINE(int) mkdir_validate_mode(\n\tconst char *path,\n\tstruct stat *st,\n\tbool terminal_path,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tif (((terminal_path && (flags & GIT_MKDIR_CHMOD) != 0) ||\n\t\t(flags & GIT_MKDIR_CHMOD_PATH) != 0) && st->st_mode != mode) {\n\n\t\topts->perfdata.chmod_calls++;\n\n\t\tif (p_chmod(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to set permissions on '%s'\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) mkdir_validate_mode(\n\tconst char *path,\n\tstruct stat *st,\n\tbool terminal_path,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tif (((terminal_path && (flags & GIT_MKDIR_CHMOD) != 0) ||\n\t\t(flags & GIT_MKDIR_CHMOD_PATH) != 0) && st->st_mode != mode) {\n\n\t\topts->perfdata.chmod_calls++;\n\n\t\tif (p_chmod(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to set permissions on '%s'\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir_validate_dir",
          "args": [
            "make_path.ptr",
            "&st",
            "mode",
            "flags",
            "&opts"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_validate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "299-346",
          "snippet": "GIT_INLINE(int) mkdir_validate_dir(\n\tconst char *path,\n\tstruct stat *st,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\t/* with exclusive create, existing dir is an error */\n\tif ((flags & GIT_MKDIR_EXCL) != 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif ((S_ISREG(st->st_mode) && (flags & GIT_MKDIR_REMOVE_FILES)) ||\n\t\t(S_ISLNK(st->st_mode) && (flags & GIT_MKDIR_REMOVE_SYMLINKS))) {\n\t\tif (p_unlink(path) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to remove %s '%s'\",\n\t\t\t\tS_ISLNK(st->st_mode) ? \"symlink\" : \"file\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\n\t\topts->perfdata.mkdir_calls++;\n\n\t\tif (p_mkdir(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (S_ISLNK(st->st_mode)) {\n\t\t/* Re-stat the target, make sure it's a directory */\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(path, st) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (!S_ISDIR(st->st_mode)) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) mkdir_validate_dir(\n\tconst char *path,\n\tstruct stat *st,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\t/* with exclusive create, existing dir is an error */\n\tif ((flags & GIT_MKDIR_EXCL) != 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif ((S_ISREG(st->st_mode) && (flags & GIT_MKDIR_REMOVE_FILES)) ||\n\t\t(S_ISLNK(st->st_mode) && (flags & GIT_MKDIR_REMOVE_SYMLINKS))) {\n\t\tif (p_unlink(path) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to remove %s '%s'\",\n\t\t\t\tS_ISLNK(st->st_mode) ? \"symlink\" : \"file\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\n\t\topts->perfdata.mkdir_calls++;\n\n\t\tif (p_mkdir(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (S_ISLNK(st->st_mode)) {\n\t\t/* Re-stat the target, make sure it's a directory */\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(path, st) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (!S_ISDIR(st->st_mode)) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_dirname_r",
          "args": [
            "&parent_path",
            "parent_path.ptr"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_dirname_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "117-178",
          "snippet": "int git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to stat '%s'\"",
            "parent_path.ptr"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_lstat",
          "args": [
            "parent_path.ptr",
            "&st"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "p_lstat_posixly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "208-211",
          "snippet": "int p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "make_path.ptr"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&parent_path",
            "make_path.ptr"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir_canonicalize",
          "args": [
            "&make_path",
            "flags"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_canonicalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "370-406",
          "snippet": "GIT_INLINE(int) mkdir_canonicalize(\n\tgit_buf *path,\n\tuint32_t flags)\n{\n\tssize_t root_len;\n\n\tif (path->size == 0) {\n\t\tgiterr_set(GITERR_OS, \"attempt to create empty path\");\n\t\treturn -1;\n\t}\n\n\t/* Trim trailing slashes (except the root) */\n\tif ((root_len = git_path_root(path->ptr)) < 0)\n\t\troot_len = 0;\n\telse\n\t\troot_len++;\n\n\twhile (path->size > (size_t)root_len && path->ptr[path->size - 1] == '/')\n\t\tpath->ptr[--path->size] = '\\0';\n\n\t/* if we are not supposed to made the last element, truncate it */\n\tif ((flags & GIT_MKDIR_SKIP_LAST2) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t\tflags |= GIT_MKDIR_SKIP_LAST;\n\t}\n\tif ((flags & GIT_MKDIR_SKIP_LAST) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t}\n\n\t/* We were either given the root path (or trimmed it to\n\t* the root), we don't have anything to do.\n\t*/\n\tif (path->size <= (size_t)root_len)\n\t\tgit_buf_clear(path);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) mkdir_canonicalize(\n\tgit_buf *path,\n\tuint32_t flags)\n{\n\tssize_t root_len;\n\n\tif (path->size == 0) {\n\t\tgiterr_set(GITERR_OS, \"attempt to create empty path\");\n\t\treturn -1;\n\t}\n\n\t/* Trim trailing slashes (except the root) */\n\tif ((root_len = git_path_root(path->ptr)) < 0)\n\t\troot_len = 0;\n\telse\n\t\troot_len++;\n\n\twhile (path->size > (size_t)root_len && path->ptr[path->size - 1] == '/')\n\t\tpath->ptr[--path->size] = '\\0';\n\n\t/* if we are not supposed to made the last element, truncate it */\n\tif ((flags & GIT_MKDIR_SKIP_LAST2) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t\tflags |= GIT_MKDIR_SKIP_LAST;\n\t}\n\tif ((flags & GIT_MKDIR_SKIP_LAST) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t}\n\n\t/* We were either given the root path (or trimmed it to\n\t* the root), we don't have anything to do.\n\t*/\n\tif (path->size <= (size_t)root_len)\n\t\tgit_buf_clear(path);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir(\n\tconst char *path,\n\tmode_t mode,\n\tuint32_t flags)\n{\n\tgit_buf make_path = GIT_BUF_INIT, parent_path = GIT_BUF_INIT;\n\tconst char *relative;\n\tstruct git_futils_mkdir_options opts = { 0 };\n\tstruct stat st;\n\tsize_t depth = 0;\n\tint len = 0, root_len, error;\n\n\tif ((error = git_buf_puts(&make_path, path)) < 0 ||\n\t\t(error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\t(error = git_buf_puts(&parent_path, make_path.ptr)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\troot_len = git_path_root(make_path.ptr);\n\n\t/* find the first parent directory that exists.  this will be used\n\t * as the base to dirname_relative.\n\t */\n\tfor (relative = make_path.ptr; parent_path.size; ) {\n\t\terror = p_lstat(parent_path.ptr, &st);\n\n\t\tif (error == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != ENOENT) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", parent_path.ptr);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdepth++;\n\n\t\t/* examine the parent of the current path */\n\t\tif ((len = git_path_dirname_r(&parent_path, parent_path.ptr)) < 0) {\n\t\t\terror = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tassert(len);\n\n\t\t/* we've walked all the given path's parents and it's either relative\n\t\t * or rooted.  either way, give up and make the entire path.\n\t\t */\n\t\tif ((len == 1 && parent_path.ptr[0] == '.') || len == root_len+1) {\n\t\t\trelative = make_path.ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\trelative = make_path.ptr + len + 1;\n\n\t\t/* not recursive? just make this directory relative to its parent. */\n\t\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* we found an item at the location we're trying to create,\n\t * validate it.\n\t */\n\tif (depth == 0) {\n\t\terror = mkdir_validate_dir(make_path.ptr, &st, mode, flags, &opts);\n\n\t\tif (!error)\n\t\t\terror = mkdir_validate_mode(\n\t\t\t\tmake_path.ptr, &st, true, mode, flags, &opts);\n\n\t\tgoto done;\n\t}\n\n\t/* we already took `SKIP_LAST` and `SKIP_LAST2` into account when\n\t * canonicalizing `make_path`.\n\t */\n\tflags &= ~(GIT_MKDIR_SKIP_LAST2 | GIT_MKDIR_SKIP_LAST);\n\n\terror = git_futils_mkdir_relative(relative,\n\t\tparent_path.size ? parent_path.ptr : NULL, mode, flags, &opts);\n\ndone:\n\tgit_buf_free(&make_path);\n\tgit_buf_free(&parent_path);\n\treturn error;\n}"
  },
  {
    "function_name": "mkdir_canonicalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "370-406",
    "snippet": "GIT_INLINE(int) mkdir_canonicalize(\n\tgit_buf *path,\n\tuint32_t flags)\n{\n\tssize_t root_len;\n\n\tif (path->size == 0) {\n\t\tgiterr_set(GITERR_OS, \"attempt to create empty path\");\n\t\treturn -1;\n\t}\n\n\t/* Trim trailing slashes (except the root) */\n\tif ((root_len = git_path_root(path->ptr)) < 0)\n\t\troot_len = 0;\n\telse\n\t\troot_len++;\n\n\twhile (path->size > (size_t)root_len && path->ptr[path->size - 1] == '/')\n\t\tpath->ptr[--path->size] = '\\0';\n\n\t/* if we are not supposed to made the last element, truncate it */\n\tif ((flags & GIT_MKDIR_SKIP_LAST2) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t\tflags |= GIT_MKDIR_SKIP_LAST;\n\t}\n\tif ((flags & GIT_MKDIR_SKIP_LAST) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t}\n\n\t/* We were either given the root path (or trimmed it to\n\t* the root), we don't have anything to do.\n\t*/\n\tif (path->size <= (size_t)root_len)\n\t\tgit_buf_clear(path);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "path"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_dirname_r",
          "args": [
            "path",
            "path->ptr"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_dirname_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "117-178",
          "snippet": "int git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "path->ptr"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"attempt to create empty path\""
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) mkdir_canonicalize(\n\tgit_buf *path,\n\tuint32_t flags)\n{\n\tssize_t root_len;\n\n\tif (path->size == 0) {\n\t\tgiterr_set(GITERR_OS, \"attempt to create empty path\");\n\t\treturn -1;\n\t}\n\n\t/* Trim trailing slashes (except the root) */\n\tif ((root_len = git_path_root(path->ptr)) < 0)\n\t\troot_len = 0;\n\telse\n\t\troot_len++;\n\n\twhile (path->size > (size_t)root_len && path->ptr[path->size - 1] == '/')\n\t\tpath->ptr[--path->size] = '\\0';\n\n\t/* if we are not supposed to made the last element, truncate it */\n\tif ((flags & GIT_MKDIR_SKIP_LAST2) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t\tflags |= GIT_MKDIR_SKIP_LAST;\n\t}\n\tif ((flags & GIT_MKDIR_SKIP_LAST) != 0) {\n\t\tgit_path_dirname_r(path, path->ptr);\n\t}\n\n\t/* We were either given the root path (or trimmed it to\n\t* the root), we don't have anything to do.\n\t*/\n\tif (path->size <= (size_t)root_len)\n\t\tgit_buf_clear(path);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mkdir_validate_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "348-368",
    "snippet": "GIT_INLINE(int) mkdir_validate_mode(\n\tconst char *path,\n\tstruct stat *st,\n\tbool terminal_path,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tif (((terminal_path && (flags & GIT_MKDIR_CHMOD) != 0) ||\n\t\t(flags & GIT_MKDIR_CHMOD_PATH) != 0) && st->st_mode != mode) {\n\n\t\topts->perfdata.chmod_calls++;\n\n\t\tif (p_chmod(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to set permissions on '%s'\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to set permissions on '%s'\"",
            "path"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_chmod",
          "args": [
            "path",
            "mode"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "p_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "444-452",
          "snippet": "int p_chmod(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wchmod(buf, mode);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_chmod(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wchmod(buf, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) mkdir_validate_mode(\n\tconst char *path,\n\tstruct stat *st,\n\tbool terminal_path,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tif (((terminal_path && (flags & GIT_MKDIR_CHMOD) != 0) ||\n\t\t(flags & GIT_MKDIR_CHMOD_PATH) != 0) && st->st_mode != mode) {\n\n\t\topts->perfdata.chmod_calls++;\n\n\t\tif (p_chmod(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to set permissions on '%s'\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mkdir_validate_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "299-346",
    "snippet": "GIT_INLINE(int) mkdir_validate_dir(\n\tconst char *path,\n\tstruct stat *st,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\t/* with exclusive create, existing dir is an error */\n\tif ((flags & GIT_MKDIR_EXCL) != 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif ((S_ISREG(st->st_mode) && (flags & GIT_MKDIR_REMOVE_FILES)) ||\n\t\t(S_ISLNK(st->st_mode) && (flags & GIT_MKDIR_REMOVE_SYMLINKS))) {\n\t\tif (p_unlink(path) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to remove %s '%s'\",\n\t\t\t\tS_ISLNK(st->st_mode) ? \"symlink\" : \"file\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\n\t\topts->perfdata.mkdir_calls++;\n\n\t\tif (p_mkdir(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (S_ISLNK(st->st_mode)) {\n\t\t/* Re-stat the target, make sure it's a directory */\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(path, st) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (!S_ISDIR(st->st_mode)) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_FILESYSTEM",
            "\"Failed to make directory '%s': directory exists\"",
            "path"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st->st_mode"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "path",
            "st"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st->st_mode"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_mkdir",
          "args": [
            "path",
            "mode"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "p_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "72-82",
          "snippet": "int p_mkdir(const char *path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tGIT_UNUSED(mode);\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wmkdir(buf);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_mkdir(const char *path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tGIT_UNUSED(mode);\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wmkdir(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st->st_mode"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "path"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st->st_mode"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st->st_mode"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) mkdir_validate_dir(\n\tconst char *path,\n\tstruct stat *st,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\t/* with exclusive create, existing dir is an error */\n\tif ((flags & GIT_MKDIR_EXCL) != 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\tif ((S_ISREG(st->st_mode) && (flags & GIT_MKDIR_REMOVE_FILES)) ||\n\t\t(S_ISLNK(st->st_mode) && (flags & GIT_MKDIR_REMOVE_SYMLINKS))) {\n\t\tif (p_unlink(path) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to remove %s '%s'\",\n\t\t\t\tS_ISLNK(st->st_mode) ? \"symlink\" : \"file\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\n\t\topts->perfdata.mkdir_calls++;\n\n\t\tif (p_mkdir(path, mode) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (S_ISLNK(st->st_mode)) {\n\t\t/* Re-stat the target, make sure it's a directory */\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(path, st) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\telse if (!S_ISDIR(st->st_mode)) {\n\t\tgiterr_set(GITERR_FILESYSTEM,\n\t\t\t\"Failed to make directory '%s': directory exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_futils_mmap_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "294-297",
    "snippet": "void git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_munmap",
          "args": [
            "out"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "p_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "261-267",
          "snippet": "int p_munmap(git_map *map)\n{\n\tassert(map != NULL);\n\tfree(map->data);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_munmap(git_map *map)\n{\n\tassert(map != NULL);\n\tfree(map->data);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}"
  },
  {
    "function_name": "git_futils_mmap_ro_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "274-292",
    "snippet": "int git_futils_mmap_ro_file(git_map *out, const char *path)\n{\n\tgit_file fd = git_futils_open_ro(path);\n\tgit_off_t len;\n\tint result;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tlen = git_futils_filesize(fd);\n\tif (!git__is_sizet(len)) {\n\t\tgiterr_set(GITERR_OS, \"File `%s` too large to mmap\", path);\n\t\treturn -1;\n\t}\n\n\tresult = git_futils_mmap_ro(out, fd, 0, (size_t)len);\n\tp_close(fd);\n\treturn result;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mmap_ro",
          "args": [
            "out",
            "fd",
            "0",
            "(size_t)len"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mmap_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "269-272",
          "snippet": "int git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"File `%s` too large to mmap\"",
            "path"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__is_sizet",
          "args": [
            "len"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_sizet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "11-15",
          "snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_filesize",
          "args": [
            "fd"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "98-108",
          "snippet": "git_off_t git_futils_filesize(git_file fd)\n{\n\tstruct stat sb;\n\n\tif (p_fstat(fd, &sb)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to stat file descriptor\");\n\t\treturn -1;\n\t}\n\n\treturn sb.st_size;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\ngit_off_t git_futils_filesize(git_file fd)\n{\n\tstruct stat sb;\n\n\tif (p_fstat(fd, &sb)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to stat file descriptor\");\n\t\treturn -1;\n\t}\n\n\treturn sb.st_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "path"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mmap_ro_file(git_map *out, const char *path)\n{\n\tgit_file fd = git_futils_open_ro(path);\n\tgit_off_t len;\n\tint result;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tlen = git_futils_filesize(fd);\n\tif (!git__is_sizet(len)) {\n\t\tgiterr_set(GITERR_OS, \"File `%s` too large to mmap\", path);\n\t\treturn -1;\n\t}\n\n\tresult = git_futils_mmap_ro(out, fd, 0, (size_t)len);\n\tp_close(fd);\n\treturn result;\n}"
  },
  {
    "function_name": "git_futils_mmap_ro",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "269-272",
    "snippet": "int git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_mmap",
          "args": [
            "out",
            "len",
            "GIT_PROT_READ",
            "GIT_MAP_SHARED",
            "fd",
            "begin"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "p_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "235-259",
          "snippet": "int p_mmap(git_map *out, size_t len, int prot, int flags, int fd, git_off_t offset)\n{\n\tGIT_MMAP_VALIDATE(out, len, prot, flags);\n\n\tout->data = NULL;\n\tout->len = 0;\n\n\tif ((prot & GIT_PROT_WRITE) && ((flags & GIT_MAP_TYPE) == GIT_MAP_SHARED)) {\n\t\tgiterr_set(GITERR_OS, \"Trying to map shared-writeable\");\n\t\treturn -1;\n\t}\n\n\tout->data = malloc(len);\n\tGITERR_CHECK_ALLOC(out->data);\n\n\tif (!git__is_ssizet(len) ||\n\t\t(p_lseek(fd, offset, SEEK_SET) < 0) ||\n\t\t(p_read(fd, out->data, len) != (ssize_t)len)) {\n\t\tgiterr_set(GITERR_OS, \"mmap emulation failed\");\n\t\treturn -1;\n\t}\n\n\tout->len = len;\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_mmap(git_map *out, size_t len, int prot, int flags, int fd, git_off_t offset)\n{\n\tGIT_MMAP_VALIDATE(out, len, prot, flags);\n\n\tout->data = NULL;\n\tout->len = 0;\n\n\tif ((prot & GIT_PROT_WRITE) && ((flags & GIT_MAP_TYPE) == GIT_MAP_SHARED)) {\n\t\tgiterr_set(GITERR_OS, \"Trying to map shared-writeable\");\n\t\treturn -1;\n\t}\n\n\tout->data = malloc(len);\n\tGITERR_CHECK_ALLOC(out->data);\n\n\tif (!git__is_ssizet(len) ||\n\t\t(p_lseek(fd, offset, SEEK_SET) < 0) ||\n\t\t(p_read(fd, out->data, len) != (ssize_t)len)) {\n\t\tgiterr_set(GITERR_OS, \"mmap emulation failed\");\n\t\treturn -1;\n\t}\n\n\tout->len = len;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}"
  },
  {
    "function_name": "git_futils_mv_withpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "256-267",
    "snippet": "int git_futils_mv_withpath(const char *from, const char *to, const mode_t dirmode)\n{\n\tif (git_futils_mkpath2file(to, dirmode) < 0)\n\t\treturn -1;\n\n\tif (p_rename(from, to) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename '%s' to '%s'\", from, to);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to rename '%s' to '%s'\"",
            "from",
            "to"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_rename",
          "args": [
            "from",
            "to"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "p_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "142-153",
          "snippet": "int p_rename(const char *from, const char *to)\n{\n\tif (!link(from, to)) {\n\t\tp_unlink(from);\n\t\treturn 0;\n\t}\n\n\tif (!rename(from, to))\n\t\treturn 0;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_rename(const char *from, const char *to)\n{\n\tif (!link(from, to)) {\n\t\tp_unlink(from);\n\t\treturn 0;\n\t}\n\n\tif (!rename(from, to))\n\t\treturn 0;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mkpath2file",
          "args": [
            "to",
            "dirmode"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkpath2file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "16-23",
          "snippet": "GIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mv_withpath(const char *from, const char *to, const mode_t dirmode)\n{\n\tif (git_futils_mkpath2file(to, dirmode) < 0)\n\t\treturn -1;\n\n\tif (p_rename(from, to) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename '%s' to '%s'\", from, to);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_futils_writebuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "229-254",
    "snippet": "int git_futils_writebuffer(\n\tconst git_buf *buf,\tconst char *path, int flags, mode_t mode)\n{\n\tint fd, error = 0;\n\n\tif (flags <= 0)\n\t\tflags = O_CREAT | O_TRUNC | O_WRONLY;\n\tif (!mode)\n\t\tmode = GIT_FILEMODE_BLOB;\n\n\tif ((fd = p_open(path, flags, mode)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not open '%s' for writing\", path);\n\t\treturn fd;\n\t}\n\n\tif ((error = p_write(fd, git_buf_cstr(buf), git_buf_len(buf))) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not write to '%s'\", path);\n\t\t(void)p_close(fd);\n\t\treturn error;\n\t}\n\n\tif ((error = p_close(fd)) < 0)\n\t\tgiterr_set(GITERR_OS, \"Error while closing '%s'\", path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Error while closing '%s'\"",
            "path"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write",
          "args": [
            "fd",
            "git_buf_cstr(buf)",
            "git_buf_len(buf)"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "p_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "189-214",
          "snippet": "int p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_write(git_file fd, const void *buf, size_t cnt)\n{\n\tconst char *b = buf;\n\n\twhile (cnt) {\n\t\tssize_t r;\n#ifdef GIT_WIN32\n\t\tassert((size_t)((unsigned int)cnt) == cnt);\n\t\tr = write(fd, b, (unsigned int)cnt);\n#else\n\t\tr = write(fd, b, cnt);\n#endif\n\t\tif (r < 0) {\n\t\t\tif (errno == EINTR || GIT_ISBLOCKED(errno))\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!r) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\tcnt -= r;\n\t\tb += r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "buf"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "buf"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_open",
          "args": [
            "path",
            "flags",
            "mode"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "p_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "105-118",
          "snippet": "int p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_writebuffer(\n\tconst git_buf *buf,\tconst char *path, int flags, mode_t mode)\n{\n\tint fd, error = 0;\n\n\tif (flags <= 0)\n\t\tflags = O_CREAT | O_TRUNC | O_WRONLY;\n\tif (!mode)\n\t\tmode = GIT_FILEMODE_BLOB;\n\n\tif ((fd = p_open(path, flags, mode)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not open '%s' for writing\", path);\n\t\treturn fd;\n\t}\n\n\tif ((error = p_write(fd, git_buf_cstr(buf), git_buf_len(buf))) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not write to '%s'\", path);\n\t\t(void)p_close(fd);\n\t\treturn error;\n\t}\n\n\tif ((error = p_close(fd)) < 0)\n\t\tgiterr_set(GITERR_OS, \"Error while closing '%s'\", path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_futils_readbuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "224-227",
    "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_readbuffer_updated",
          "args": [
            "buf",
            "path",
            "NULL",
            "NULL"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer_updated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "155-222",
          "snippet": "int git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
  },
  {
    "function_name": "git_futils_readbuffer_updated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "155-222",
    "snippet": "int git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_swap",
          "args": [
            "out",
            "&buf"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "470-475",
          "snippet": "void git_buf_swap(git_buf *buf_a, git_buf *buf_b)\n{\n\tgit_buf t = *buf_a;\n\t*buf_a = *buf_b;\n\t*buf_b = t;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_swap(git_buf *buf_a, git_buf *buf_b)\n{\n\tgit_buf t = *buf_a;\n\t*buf_a = *buf_b;\n\t*buf_b = t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "checksum",
            "&checksum_new"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "checksum",
            "&checksum_new"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_buf",
          "args": [
            "&checksum_new",
            "buf.ptr",
            "buf.size"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash.c",
          "lines": "11-25",
          "snippet": "int git_hash_buf(git_oid *out, const void *data, size_t len)\n{\n\tgit_hash_ctx ctx;\n\tint error = 0;\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\tif ((error = git_hash_update(&ctx, data, len)) >= 0)\n\t\terror = git_hash_final(out, &ctx);\n\n\tgit_hash_ctx_cleanup(&ctx);\n\t\n\treturn error;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"common.h\"\n\nint git_hash_buf(git_oid *out, const void *data, size_t len)\n{\n\tgit_hash_ctx ctx;\n\tint error = 0;\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\tif ((error = git_hash_update(&ctx, data, len)) >= 0)\n\t\terror = git_hash_final(out, &ctx);\n\n\tgit_hash_ctx_cleanup(&ctx);\n\t\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer_fd",
          "args": [
            "&buf",
            "fd",
            "(size_t)st.st_size"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "124-153",
          "snippet": "int git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "path"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Invalid regular file stat for '%s'\"",
            "path"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__is_sizet",
          "args": [
            "st.st_size+1"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_sizet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "11-15",
          "snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"requested file is a directory\""
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_set_error",
          "args": [
            "errno",
            "path",
            "\"stat\""
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "611-632",
          "snippet": "int git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "path",
            "&st"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && path && *path"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_updated(\n\tgit_buf *out, const char *path, git_oid *checksum, int *updated)\n{\n\tint error;\n\tgit_file fd;\n\tstruct stat st;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_oid checksum_new;\n\n\tassert(out && path && *path);\n\n\tif (updated != NULL)\n\t\t*updated = 0;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn git_path_set_error(errno, path, \"stat\");\n\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_INVALID, \"requested file is a directory\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (!git__is_sizet(st.st_size+1)) {\n\t\tgiterr_set(GITERR_OS, \"Invalid regular file stat for '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((fd = git_futils_open_ro(path)) < 0)\n\t\treturn fd;\n\n\tif (git_futils_readbuffer_fd(&buf, fd, (size_t)st.st_size) < 0) {\n\t\tp_close(fd);\n\t\treturn -1;\n\t}\n\n\tp_close(fd);\n\n\tif ((error = git_hash_buf(&checksum_new, buf.ptr, buf.size)) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn error;\n\t}\n\n\t/*\n\t * If we were given a checksum, we only want to use it if it's different\n\t */\n\tif (checksum && !git_oid__cmp(checksum, &checksum_new)) {\n\t\tgit_buf_free(&buf);\n\t\tif (updated)\n\t\t\t*updated = 0;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we're here, the file did change, or the user didn't have an old version\n\t */\n\tif (checksum)\n\t\tgit_oid_cpy(checksum, &checksum_new);\n\n\tif (updated != NULL)\n\t\t*updated = 1;\n\n\tgit_buf_swap(out, &buf);\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_futils_readbuffer_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "124-153",
    "snippet": "int git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "buf"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to read descriptor\""
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_read",
          "args": [
            "fd",
            "buf->ptr",
            "len"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "p_readdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.h",
          "lines": "126-131",
          "snippet": "GIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <netdb.h>",
            "#include \"strnlen.h\"",
            "#\tinclude \"unix/posix.h\"",
            "#\tinclude \"win32/posix.h\"",
            "#include \"fnmatch.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <netdb.h>\n#include \"strnlen.h\"\n#\tinclude \"unix/posix.h\"\n#\tinclude \"win32/posix.h\"\n#include \"fnmatch.h\"\n#include <time.h>\n#include <fcntl.h>\n#include \"common.h\"\n\nGIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "buf",
            "alloc_len"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "len",
            "1"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__is_ssizet",
          "args": [
            "len"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_ssizet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "18-22",
          "snippet": "GIT_INLINE(int) git__is_ssizet(size_t p)\n{\n\tssize_t r = (ssize_t)p;\n\treturn p == (size_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_ssizet(size_t p)\n{\n\tssize_t r = (ssize_t)p;\n\treturn p == (size_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_futils_canonical_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "110-122",
    "snippet": "mode_t git_futils_canonical_mode(mode_t raw_mode)\n{\n\tif (S_ISREG(raw_mode))\n\t\treturn S_IFREG | GIT_PERMS_CANONICAL(raw_mode);\n\telse if (S_ISLNK(raw_mode))\n\t\treturn S_IFLNK;\n\telse if (S_ISGITLINK(raw_mode))\n\t\treturn S_IFGITLINK;\n\telse if (S_ISDIR(raw_mode))\n\t\treturn S_IFDIR;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "raw_mode"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "raw_mode"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "raw_mode"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_PERMS_CANONICAL",
          "args": [
            "raw_mode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "raw_mode"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nmode_t git_futils_canonical_mode(mode_t raw_mode)\n{\n\tif (S_ISREG(raw_mode))\n\t\treturn S_IFREG | GIT_PERMS_CANONICAL(raw_mode);\n\telse if (S_ISLNK(raw_mode))\n\t\treturn S_IFLNK;\n\telse if (S_ISGITLINK(raw_mode))\n\t\treturn S_IFGITLINK;\n\telse if (S_ISDIR(raw_mode))\n\t\treturn S_IFDIR;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "git_futils_filesize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "98-108",
    "snippet": "git_off_t git_futils_filesize(git_file fd)\n{\n\tstruct stat sb;\n\n\tif (p_fstat(fd, &sb)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to stat file descriptor\");\n\t\treturn -1;\n\t}\n\n\treturn sb.st_size;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to stat file descriptor\""
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_fstat",
          "args": [
            "fd",
            "&sb"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "p_fstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "401-415",
          "snippet": "int p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\ngit_off_t git_futils_filesize(git_file fd)\n{\n\tstruct stat sb;\n\n\tif (p_fstat(fd, &sb)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to stat file descriptor\");\n\t\treturn -1;\n\t}\n\n\treturn sb.st_size;\n}"
  },
  {
    "function_name": "git_futils_open_ro",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "90-96",
    "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_set_error",
          "args": [
            "errno",
            "path",
            "\"open\""
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "611-632",
          "snippet": "int git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "p_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "105-118",
          "snippet": "int p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
  },
  {
    "function_name": "git_futils_creat_locked_withpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "82-88",
    "snippet": "int git_futils_creat_locked_withpath(const char *path, const mode_t dirmode, const mode_t mode)\n{\n\tif (git_futils_mkpath2file(path, dirmode) < 0)\n\t\treturn -1;\n\n\treturn git_futils_creat_locked(path, mode);\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_creat_locked",
          "args": [
            "path",
            "mode"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_creat_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "69-80",
          "snippet": "int git_futils_creat_locked(const char *path, const mode_t mode)\n{\n\tint fd = p_open(path, O_WRONLY | O_CREAT | O_TRUNC |\n\t\tO_EXCL | O_BINARY | O_CLOEXEC, mode);\n\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create locked file '%s'\", path);\n\t\treturn errno == EEXIST ? GIT_ELOCKED : -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_creat_locked(const char *path, const mode_t mode)\n{\n\tint fd = p_open(path, O_WRONLY | O_CREAT | O_TRUNC |\n\t\tO_EXCL | O_BINARY | O_CLOEXEC, mode);\n\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create locked file '%s'\", path);\n\t\treturn errno == EEXIST ? GIT_ELOCKED : -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mkpath2file",
          "args": [
            "path",
            "dirmode"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkpath2file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "16-23",
          "snippet": "GIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_creat_locked_withpath(const char *path, const mode_t dirmode, const mode_t mode)\n{\n\tif (git_futils_mkpath2file(path, dirmode) < 0)\n\t\treturn -1;\n\n\treturn git_futils_creat_locked(path, mode);\n}"
  },
  {
    "function_name": "git_futils_creat_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "69-80",
    "snippet": "int git_futils_creat_locked(const char *path, const mode_t mode)\n{\n\tint fd = p_open(path, O_WRONLY | O_CREAT | O_TRUNC |\n\t\tO_EXCL | O_BINARY | O_CLOEXEC, mode);\n\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create locked file '%s'\", path);\n\t\treturn errno == EEXIST ? GIT_ELOCKED : -1;\n\t}\n\n\treturn fd;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to create locked file '%s'\"",
            "path"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_open",
          "args": [
            "path",
            "O_WRONLY | O_CREAT | O_TRUNC |\n\t\tO_EXCL | O_BINARY | O_CLOEXEC",
            "mode"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "p_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "105-118",
          "snippet": "int p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_creat_locked(const char *path, const mode_t mode)\n{\n\tint fd = p_open(path, O_WRONLY | O_CREAT | O_TRUNC |\n\t\tO_EXCL | O_BINARY | O_CLOEXEC, mode);\n\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create locked file '%s'\", path);\n\t\treturn errno == EEXIST ? GIT_ELOCKED : -1;\n\t}\n\n\treturn fd;\n}"
  },
  {
    "function_name": "git_futils_creat_withpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "53-67",
    "snippet": "int git_futils_creat_withpath(const char *path, const mode_t dirmode, const mode_t mode)\n{\n\tint fd;\n\n\tif (git_futils_mkpath2file(path, dirmode) < 0)\n\t\treturn -1;\n\n\tfd = p_creat(path, mode);\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create file '%s'\", path);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to create file '%s'\"",
            "path"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_creat",
          "args": [
            "path",
            "mode"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "p_creat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "120-123",
          "snippet": "int p_creat(const char *path, mode_t mode)\n{\n\treturn open(path, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY | O_CLOEXEC, mode);\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_creat(const char *path, mode_t mode)\n{\n\treturn open(path, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY | O_CLOEXEC, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mkpath2file",
          "args": [
            "path",
            "dirmode"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkpath2file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "16-23",
          "snippet": "GIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_creat_withpath(const char *path, const mode_t dirmode, const mode_t mode)\n{\n\tint fd;\n\n\tif (git_futils_mkpath2file(path, dirmode) < 0)\n\t\treturn -1;\n\n\tfd = p_creat(path, mode);\n\tif (fd < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create file '%s'\", path);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
  },
  {
    "function_name": "git_futils_mktmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "25-51",
    "snippet": "int git_futils_mktmp(git_buf *path_out, const char *filename, mode_t mode)\n{\n\tint fd;\n\tmode_t mask;\n\n\tp_umask(mask = p_umask(0));\n\n\tgit_buf_sets(path_out, filename);\n\tgit_buf_puts(path_out, \"_git2_XXXXXX\");\n\n\tif (git_buf_oom(path_out))\n\t\treturn -1;\n\n\tif ((fd = p_mkstemp(path_out->ptr)) < 0) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to create temporary file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\tif (p_chmod(path_out->ptr, (mode & ~mask))) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to set permissions on file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to set permissions on file '%s'\"",
            "path_out->ptr"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_chmod",
          "args": [
            "path_out->ptr",
            "(mode & ~mask)"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "p_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "444-452",
          "snippet": "int p_chmod(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wchmod(buf, mode);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_chmod(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wchmod(buf, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_mkstemp",
          "args": [
            "path_out->ptr"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "p_mkstemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "561-572",
          "snippet": "int p_mkstemp(char *tmp_path)\n{\n#if defined(_MSC_VER) && _MSC_VER >= 1500\n\tif (_mktemp_s(tmp_path, strlen(tmp_path) + 1) != 0)\n\t\treturn -1;\n#else\n\tif (_mktemp(tmp_path) == NULL)\n\t\treturn -1;\n#endif\n\n\treturn p_open(tmp_path, O_RDWR | O_CREAT | O_EXCL, 0744); //-V536\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_mkstemp(char *tmp_path)\n{\n#if defined(_MSC_VER) && _MSC_VER >= 1500\n\tif (_mktemp_s(tmp_path, strlen(tmp_path) + 1) != 0)\n\t\treturn -1;\n#else\n\tif (_mktemp(tmp_path) == NULL)\n\t\treturn -1;\n#endif\n\n\treturn p_open(tmp_path, O_RDWR | O_CREAT | O_EXCL, 0744); //-V536\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "path_out"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "path_out",
            "\"_git2_XXXXXX\""
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "path_out",
            "filename"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_umask",
          "args": [
            "mask = p_umask(0)"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_umask",
          "args": [
            "0"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mktmp(git_buf *path_out, const char *filename, mode_t mode)\n{\n\tint fd;\n\tmode_t mask;\n\n\tp_umask(mask = p_umask(0));\n\n\tgit_buf_sets(path_out, filename);\n\tgit_buf_puts(path_out, \"_git2_XXXXXX\");\n\n\tif (git_buf_oom(path_out))\n\t\treturn -1;\n\n\tif ((fd = p_mkstemp(path_out->ptr)) < 0) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to create temporary file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\tif (p_chmod(path_out->ptr, (mode & ~mask))) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to set permissions on file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
  },
  {
    "function_name": "git_futils_mkpath2file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
    "lines": "16-23",
    "snippet": "GIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}",
    "includes": [
      "#include \"win32/findfile.h\"",
      "#include <ctype.h>",
      "#include \"strmap.h\"",
      "#include \"global.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_mkdir",
          "args": [
            "file_path",
            "mode",
            "GIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "408-491",
          "snippet": "int git_futils_mkdir(\n\tconst char *path,\n\tmode_t mode,\n\tuint32_t flags)\n{\n\tgit_buf make_path = GIT_BUF_INIT, parent_path = GIT_BUF_INIT;\n\tconst char *relative;\n\tstruct git_futils_mkdir_options opts = { 0 };\n\tstruct stat st;\n\tsize_t depth = 0;\n\tint len = 0, root_len, error;\n\n\tif ((error = git_buf_puts(&make_path, path)) < 0 ||\n\t\t(error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\t(error = git_buf_puts(&parent_path, make_path.ptr)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\troot_len = git_path_root(make_path.ptr);\n\n\t/* find the first parent directory that exists.  this will be used\n\t * as the base to dirname_relative.\n\t */\n\tfor (relative = make_path.ptr; parent_path.size; ) {\n\t\terror = p_lstat(parent_path.ptr, &st);\n\n\t\tif (error == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != ENOENT) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", parent_path.ptr);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdepth++;\n\n\t\t/* examine the parent of the current path */\n\t\tif ((len = git_path_dirname_r(&parent_path, parent_path.ptr)) < 0) {\n\t\t\terror = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tassert(len);\n\n\t\t/* we've walked all the given path's parents and it's either relative\n\t\t * or rooted.  either way, give up and make the entire path.\n\t\t */\n\t\tif ((len == 1 && parent_path.ptr[0] == '.') || len == root_len+1) {\n\t\t\trelative = make_path.ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\trelative = make_path.ptr + len + 1;\n\n\t\t/* not recursive? just make this directory relative to its parent. */\n\t\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* we found an item at the location we're trying to create,\n\t * validate it.\n\t */\n\tif (depth == 0) {\n\t\terror = mkdir_validate_dir(make_path.ptr, &st, mode, flags, &opts);\n\n\t\tif (!error)\n\t\t\terror = mkdir_validate_mode(\n\t\t\t\tmake_path.ptr, &st, true, mode, flags, &opts);\n\n\t\tgoto done;\n\t}\n\n\t/* we already took `SKIP_LAST` and `SKIP_LAST2` into account when\n\t * canonicalizing `make_path`.\n\t */\n\tflags &= ~(GIT_MKDIR_SKIP_LAST2 | GIT_MKDIR_SKIP_LAST);\n\n\terror = git_futils_mkdir_relative(relative,\n\t\tparent_path.size ? parent_path.ptr : NULL, mode, flags, &opts);\n\ndone:\n\tgit_buf_free(&make_path);\n\tgit_buf_free(&parent_path);\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir(\n\tconst char *path,\n\tmode_t mode,\n\tuint32_t flags)\n{\n\tgit_buf make_path = GIT_BUF_INIT, parent_path = GIT_BUF_INIT;\n\tconst char *relative;\n\tstruct git_futils_mkdir_options opts = { 0 };\n\tstruct stat st;\n\tsize_t depth = 0;\n\tint len = 0, root_len, error;\n\n\tif ((error = git_buf_puts(&make_path, path)) < 0 ||\n\t\t(error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\t(error = git_buf_puts(&parent_path, make_path.ptr)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\troot_len = git_path_root(make_path.ptr);\n\n\t/* find the first parent directory that exists.  this will be used\n\t * as the base to dirname_relative.\n\t */\n\tfor (relative = make_path.ptr; parent_path.size; ) {\n\t\terror = p_lstat(parent_path.ptr, &st);\n\n\t\tif (error == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != ENOENT) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to stat '%s'\", parent_path.ptr);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdepth++;\n\n\t\t/* examine the parent of the current path */\n\t\tif ((len = git_path_dirname_r(&parent_path, parent_path.ptr)) < 0) {\n\t\t\terror = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tassert(len);\n\n\t\t/* we've walked all the given path's parents and it's either relative\n\t\t * or rooted.  either way, give up and make the entire path.\n\t\t */\n\t\tif ((len == 1 && parent_path.ptr[0] == '.') || len == root_len+1) {\n\t\t\trelative = make_path.ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\trelative = make_path.ptr + len + 1;\n\n\t\t/* not recursive? just make this directory relative to its parent. */\n\t\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* we found an item at the location we're trying to create,\n\t * validate it.\n\t */\n\tif (depth == 0) {\n\t\terror = mkdir_validate_dir(make_path.ptr, &st, mode, flags, &opts);\n\n\t\tif (!error)\n\t\t\terror = mkdir_validate_mode(\n\t\t\t\tmake_path.ptr, &st, true, mode, flags, &opts);\n\n\t\tgoto done;\n\t}\n\n\t/* we already took `SKIP_LAST` and `SKIP_LAST2` into account when\n\t * canonicalizing `make_path`.\n\t */\n\tflags &= ~(GIT_MKDIR_SKIP_LAST2 | GIT_MKDIR_SKIP_LAST);\n\n\terror = git_futils_mkdir_relative(relative,\n\t\tparent_path.size ? parent_path.ptr : NULL, mode, flags, &opts);\n\ndone:\n\tgit_buf_free(&make_path);\n\tgit_buf_free(&parent_path);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}"
  }
]