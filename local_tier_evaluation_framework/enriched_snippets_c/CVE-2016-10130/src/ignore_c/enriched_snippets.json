[
  {
    "function_name": "git_ignore__check_pathspec_for_exact_ignores",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "556-611",
    "snippet": "int git_ignore__check_pathspec_for_exact_ignores(\n\tgit_repository *repo,\n\tgit_vector *vspec,\n\tbool no_fnmatch)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_attr_fnmatch *match;\n\tint ignored;\n\tgit_buf path = GIT_BUF_INIT;\n\tconst char *wd, *filename;\n\tgit_index *idx;\n\n\tif ((error = git_repository__ensure_not_bare(\n\t\t\trepo, \"validate pathspec\")) < 0 ||\n\t\t(error = git_repository_index(&idx, repo)) < 0)\n\t\treturn error;\n\n\twd = git_repository_workdir(repo);\n\n\tgit_vector_foreach(vspec, i, match) {\n\t\t/* skip wildcard matches (if they are being used) */\n\t\tif ((match->flags & GIT_ATTR_FNMATCH_HASWILD) != 0 &&\n\t\t\t!no_fnmatch)\n\t\t\tcontinue;\n\n\t\tfilename = match->pattern;\n\n\t\t/* if file is already in the index, it's fine */\n\t\tif (git_index_get_bypath(idx, filename, 0) != NULL)\n\t\t\tcontinue;\n\n\t\tif ((error = git_buf_joinpath(&path, wd, filename)) < 0)\n\t\t\tbreak;\n\n\t\t/* is there a file on disk that matches this exactly? */\n\t\tif (!git_path_isfile(path.ptr))\n\t\t\tcontinue;\n\n\t\t/* is that file ignored? */\n\t\tif ((error = git_ignore_path_is_ignored(&ignored, repo, filename)) < 0)\n\t\t\tbreak;\n\n\t\tif (ignored) {\n\t\t\tgiterr_set(GITERR_INVALID, \"pathspec contains ignored file '%s'\",\n\t\t\t\tfilename);\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_index_free(idx);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "idx"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"pathspec contains ignored file '%s'\"",
            "filename"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_ignore_path_is_ignored",
          "args": [
            "&ignored",
            "repo",
            "filename"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore_path_is_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "494-554",
          "snippet": "int git_ignore_path_is_ignored(\n\tint *ignored,\n\tgit_repository *repo,\n\tconst char *pathname)\n{\n\tint error;\n\tconst char *workdir;\n\tgit_attr_path path;\n\tgit_ignores ignores;\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tassert(ignored && pathname);\n\n\tworkdir = repo ? git_repository_workdir(repo) : NULL;\n\n\tmemset(&path, 0, sizeof(path));\n\tmemset(&ignores, 0, sizeof(ignores));\n\n\tif ((error = git_attr_path__init(&path, pathname, workdir, GIT_DIR_FLAG_UNKNOWN)) < 0 ||\n\t\t(error = git_ignore__for_path(repo, path.path, &ignores)) < 0)\n\t\tgoto cleanup;\n\n\twhile (1) {\n\t\t/* first process builtins - success means path was found */\n\t\tif (ignore_lookup_in_rules(ignored, ignores.ign_internal, &path))\n\t\t\tgoto cleanup;\n\n\t\t/* next process files in the path */\n\t\tgit_vector_foreach(&ignores.ign_path, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* last process global ignores */\n\t\tgit_vector_foreach(&ignores.ign_global, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* move up one directory */\n\t\tif (path.basename == path.path)\n\t\t\tbreak;\n\t\tpath.basename[-1] = '\\0';\n\t\twhile (path.basename > path.path && *path.basename != '/')\n\t\t\tpath.basename--;\n\t\tif (path.basename > path.path)\n\t\t\tpath.basename++;\n\t\tpath.is_dir = 1;\n\n\t\tif ((error = git_ignore__pop_dir(&ignores)) < 0)\n\t\t\tbreak;\n\t}\n\n\t*ignored = 0;\n\ncleanup:\n\tgit_attr_path__free(&path);\n\tgit_ignore__free(&ignores);\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore_path_is_ignored(\n\tint *ignored,\n\tgit_repository *repo,\n\tconst char *pathname)\n{\n\tint error;\n\tconst char *workdir;\n\tgit_attr_path path;\n\tgit_ignores ignores;\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tassert(ignored && pathname);\n\n\tworkdir = repo ? git_repository_workdir(repo) : NULL;\n\n\tmemset(&path, 0, sizeof(path));\n\tmemset(&ignores, 0, sizeof(ignores));\n\n\tif ((error = git_attr_path__init(&path, pathname, workdir, GIT_DIR_FLAG_UNKNOWN)) < 0 ||\n\t\t(error = git_ignore__for_path(repo, path.path, &ignores)) < 0)\n\t\tgoto cleanup;\n\n\twhile (1) {\n\t\t/* first process builtins - success means path was found */\n\t\tif (ignore_lookup_in_rules(ignored, ignores.ign_internal, &path))\n\t\t\tgoto cleanup;\n\n\t\t/* next process files in the path */\n\t\tgit_vector_foreach(&ignores.ign_path, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* last process global ignores */\n\t\tgit_vector_foreach(&ignores.ign_global, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* move up one directory */\n\t\tif (path.basename == path.path)\n\t\t\tbreak;\n\t\tpath.basename[-1] = '\\0';\n\t\twhile (path.basename > path.path && *path.basename != '/')\n\t\t\tpath.basename--;\n\t\tif (path.basename > path.path)\n\t\t\tpath.basename++;\n\t\tpath.is_dir = 1;\n\n\t\tif ((error = git_ignore__pop_dir(&ignores)) < 0)\n\t\t\tbreak;\n\t}\n\n\t*ignored = 0;\n\ncleanup:\n\tgit_attr_path__free(&path);\n\tgit_ignore__free(&ignores);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isfile",
          "args": [
            "path.ptr"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "518-527",
          "snippet": "bool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "wd",
            "filename"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_get_bypath",
          "args": [
            "idx",
            "filename",
            "0"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_get_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "807-825",
          "snippet": "const git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "vspec",
            "i",
            "match"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index",
          "args": [
            "&idx",
            "repo"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "852-859",
          "snippet": "int git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "\"validate pathspec\""
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__check_pathspec_for_exact_ignores(\n\tgit_repository *repo,\n\tgit_vector *vspec,\n\tbool no_fnmatch)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_attr_fnmatch *match;\n\tint ignored;\n\tgit_buf path = GIT_BUF_INIT;\n\tconst char *wd, *filename;\n\tgit_index *idx;\n\n\tif ((error = git_repository__ensure_not_bare(\n\t\t\trepo, \"validate pathspec\")) < 0 ||\n\t\t(error = git_repository_index(&idx, repo)) < 0)\n\t\treturn error;\n\n\twd = git_repository_workdir(repo);\n\n\tgit_vector_foreach(vspec, i, match) {\n\t\t/* skip wildcard matches (if they are being used) */\n\t\tif ((match->flags & GIT_ATTR_FNMATCH_HASWILD) != 0 &&\n\t\t\t!no_fnmatch)\n\t\t\tcontinue;\n\n\t\tfilename = match->pattern;\n\n\t\t/* if file is already in the index, it's fine */\n\t\tif (git_index_get_bypath(idx, filename, 0) != NULL)\n\t\t\tcontinue;\n\n\t\tif ((error = git_buf_joinpath(&path, wd, filename)) < 0)\n\t\t\tbreak;\n\n\t\t/* is there a file on disk that matches this exactly? */\n\t\tif (!git_path_isfile(path.ptr))\n\t\t\tcontinue;\n\n\t\t/* is that file ignored? */\n\t\tif ((error = git_ignore_path_is_ignored(&ignored, repo, filename)) < 0)\n\t\t\tbreak;\n\n\t\tif (ignored) {\n\t\t\tgiterr_set(GITERR_INVALID, \"pathspec contains ignored file '%s'\",\n\t\t\t\tfilename);\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_index_free(idx);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_ignore_path_is_ignored",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "494-554",
    "snippet": "int git_ignore_path_is_ignored(\n\tint *ignored,\n\tgit_repository *repo,\n\tconst char *pathname)\n{\n\tint error;\n\tconst char *workdir;\n\tgit_attr_path path;\n\tgit_ignores ignores;\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tassert(ignored && pathname);\n\n\tworkdir = repo ? git_repository_workdir(repo) : NULL;\n\n\tmemset(&path, 0, sizeof(path));\n\tmemset(&ignores, 0, sizeof(ignores));\n\n\tif ((error = git_attr_path__init(&path, pathname, workdir, GIT_DIR_FLAG_UNKNOWN)) < 0 ||\n\t\t(error = git_ignore__for_path(repo, path.path, &ignores)) < 0)\n\t\tgoto cleanup;\n\n\twhile (1) {\n\t\t/* first process builtins - success means path was found */\n\t\tif (ignore_lookup_in_rules(ignored, ignores.ign_internal, &path))\n\t\t\tgoto cleanup;\n\n\t\t/* next process files in the path */\n\t\tgit_vector_foreach(&ignores.ign_path, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* last process global ignores */\n\t\tgit_vector_foreach(&ignores.ign_global, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* move up one directory */\n\t\tif (path.basename == path.path)\n\t\t\tbreak;\n\t\tpath.basename[-1] = '\\0';\n\t\twhile (path.basename > path.path && *path.basename != '/')\n\t\t\tpath.basename--;\n\t\tif (path.basename > path.path)\n\t\t\tpath.basename++;\n\t\tpath.is_dir = 1;\n\n\t\tif ((error = git_ignore__pop_dir(&ignores)) < 0)\n\t\t\tbreak;\n\t}\n\n\t*ignored = 0;\n\ncleanup:\n\tgit_attr_path__free(&path);\n\tgit_ignore__free(&ignores);\n\treturn error;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_ignore__free",
          "args": [
            "&ignores"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "391-411",
          "snippet": "void git_ignore__free(git_ignores *ignores)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tgit_attr_file__free(ignores->ign_internal);\n\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_path.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_path);\n\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_global.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_global);\n\n\tgit_buf_free(&ignores->dir);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nvoid git_ignore__free(git_ignores *ignores)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tgit_attr_file__free(ignores->ign_internal);\n\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_path.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_path);\n\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_global.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_global);\n\n\tgit_buf_free(&ignores->dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_path__free",
          "args": [
            "&path"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "508-513",
          "snippet": "void git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_ignore__pop_dir",
          "args": [
            "&ignores"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__pop_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "356-389",
          "snippet": "int git_ignore__pop_dir(git_ignores *ign)\n{\n\tif (ign->ign_path.length > 0) {\n\t\tgit_attr_file *file = git_vector_last(&ign->ign_path);\n\t\tconst char *start = file->entry->path, *end;\n\n\t\t/* - ign->dir looks something like \"/home/user/a/b/\" (or \"a/b/c/d/\")\n\t\t * - file->path looks something like \"a/b/.gitignore\n\t\t *\n\t\t * We are popping the last directory off ign->dir.  We also want\n\t\t * to remove the file from the vector if the popped directory\n\t\t * matches the ignore path.  We need to test if the \"a/b\" part of\n\t\t * the file key matches the path we are about to pop.\n\t\t */\n\n\t\tif ((end = strrchr(start, '/')) != NULL) {\n\t\t\tsize_t dirlen = (end - start) + 1;\n\t\t\tconst char *relpath = ign->dir.ptr + ign->dir_root;\n\t\t\tsize_t pathlen = ign->dir.size - ign->dir_root;\n\n\t\t\tif (pathlen == dirlen && !memcmp(relpath, start, dirlen)) {\n\t\t\t\tgit_vector_pop(&ign->ign_path);\n\t\t\t\tgit_attr_file__free(file);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (--ign->depth > 0) {\n\t\tgit_buf_rtruncate_at_char(&ign->dir, '/');\n\t\tgit_path_to_dir(&ign->dir);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__pop_dir(git_ignores *ign)\n{\n\tif (ign->ign_path.length > 0) {\n\t\tgit_attr_file *file = git_vector_last(&ign->ign_path);\n\t\tconst char *start = file->entry->path, *end;\n\n\t\t/* - ign->dir looks something like \"/home/user/a/b/\" (or \"a/b/c/d/\")\n\t\t * - file->path looks something like \"a/b/.gitignore\n\t\t *\n\t\t * We are popping the last directory off ign->dir.  We also want\n\t\t * to remove the file from the vector if the popped directory\n\t\t * matches the ignore path.  We need to test if the \"a/b\" part of\n\t\t * the file key matches the path we are about to pop.\n\t\t */\n\n\t\tif ((end = strrchr(start, '/')) != NULL) {\n\t\t\tsize_t dirlen = (end - start) + 1;\n\t\t\tconst char *relpath = ign->dir.ptr + ign->dir_root;\n\t\t\tsize_t pathlen = ign->dir.size - ign->dir_root;\n\n\t\t\tif (pathlen == dirlen && !memcmp(relpath, start, dirlen)) {\n\t\t\t\tgit_vector_pop(&ign->ign_path);\n\t\t\t\tgit_attr_file__free(file);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (--ign->depth > 0) {\n\t\tgit_buf_rtruncate_at_char(&ign->dir, '/');\n\t\tgit_path_to_dir(&ign->dir);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_lookup_in_rules",
          "args": [
            "ignored",
            "file",
            "&path"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_lookup_in_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "413-428",
          "snippet": "static bool ignore_lookup_in_rules(\n\tint *ignored, git_attr_file *file, git_attr_path *path)\n{\n\tsize_t j;\n\tgit_attr_fnmatch *match;\n\n\tgit_vector_rforeach(&file->rules, j, match) {\n\t\tif (git_attr_fnmatch__match(match, path)) {\n\t\t\t*ignored = ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0) ?\n\t\t\t\tGIT_IGNORE_TRUE : GIT_IGNORE_FALSE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic bool ignore_lookup_in_rules(\n\tint *ignored, git_attr_file *file, git_attr_path *path)\n{\n\tsize_t j;\n\tgit_attr_fnmatch *match;\n\n\tgit_vector_rforeach(&file->rules, j, match) {\n\t\tif (git_attr_fnmatch__match(match, path)) {\n\t\t\t*ignored = ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0) ?\n\t\t\t\tGIT_IGNORE_TRUE : GIT_IGNORE_FALSE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&ignores.ign_global",
            "i",
            "file"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&ignores.ign_path",
            "i",
            "file"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_ignore__for_path",
          "args": [
            "repo",
            "path.path",
            "&ignores"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__for_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "273-343",
          "snippet": "int git_ignore__for_path(\n\tgit_repository *repo,\n\tconst char *path,\n\tgit_ignores *ignores)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\n\tassert(ignores && path);\n\n\tmemset(ignores, 0, sizeof(*ignores));\n\tignores->repo = repo;\n\n\t/* Read the ignore_case flag */\n\tif ((error = git_repository__cvar(\n\t\t\t&ignores->ignore_case, repo, GIT_CVAR_IGNORECASE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* given a unrooted path in a non-bare repo, resolve it */\n\tif (workdir && git_path_root(path) < 0) {\n\t\tgit_buf local = GIT_BUF_INIT;\n\n\t\tif ((error = git_path_dirname_r(&local, path)) < 0 ||\n\t\t    (error = git_path_resolve_relative(&local, 0)) < 0 ||\n\t\t    (error = git_path_to_dir(&local)) < 0 ||\n\t\t    (error = git_buf_joinpath(&ignores->dir, workdir, local.ptr)) < 0)\n\t\t{;} /* Nothing, we just want to stop on the first error */\n\t\tgit_buf_free(&local);\n\t} else {\n\t\terror = git_buf_joinpath(&ignores->dir, path, \"\");\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (workdir && !git__prefixcmp(ignores->dir.ptr, workdir))\n\t\tignores->dir_root = strlen(workdir);\n\n\t/* set up internals */\n\tif ((error = get_internal_ignores(&ignores->ign_internal, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* load .gitignore up the path */\n\tif (workdir != NULL) {\n\t\terror = git_path_walk_up(\n\t\t\t&ignores->dir, workdir, push_one_ignore, ignores);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* load .git/info/exclude */\n\terror = push_ignore_file(\n\t\tignores, &ignores->ign_global,\n\t\tgit_repository_path(repo), GIT_IGNORE_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* load core.excludesfile */\n\tif (git_repository_attr_cache(repo)->cfg_excl_file != NULL)\n\t\terror = push_ignore_file(\n\t\t\tignores, &ignores->ign_global, NULL,\n\t\t\tgit_repository_attr_cache(repo)->cfg_excl_file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_ignore__free(ignores);\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__for_path(\n\tgit_repository *repo,\n\tconst char *path,\n\tgit_ignores *ignores)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\n\tassert(ignores && path);\n\n\tmemset(ignores, 0, sizeof(*ignores));\n\tignores->repo = repo;\n\n\t/* Read the ignore_case flag */\n\tif ((error = git_repository__cvar(\n\t\t\t&ignores->ignore_case, repo, GIT_CVAR_IGNORECASE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* given a unrooted path in a non-bare repo, resolve it */\n\tif (workdir && git_path_root(path) < 0) {\n\t\tgit_buf local = GIT_BUF_INIT;\n\n\t\tif ((error = git_path_dirname_r(&local, path)) < 0 ||\n\t\t    (error = git_path_resolve_relative(&local, 0)) < 0 ||\n\t\t    (error = git_path_to_dir(&local)) < 0 ||\n\t\t    (error = git_buf_joinpath(&ignores->dir, workdir, local.ptr)) < 0)\n\t\t{;} /* Nothing, we just want to stop on the first error */\n\t\tgit_buf_free(&local);\n\t} else {\n\t\terror = git_buf_joinpath(&ignores->dir, path, \"\");\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (workdir && !git__prefixcmp(ignores->dir.ptr, workdir))\n\t\tignores->dir_root = strlen(workdir);\n\n\t/* set up internals */\n\tif ((error = get_internal_ignores(&ignores->ign_internal, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* load .gitignore up the path */\n\tif (workdir != NULL) {\n\t\terror = git_path_walk_up(\n\t\t\t&ignores->dir, workdir, push_one_ignore, ignores);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* load .git/info/exclude */\n\terror = push_ignore_file(\n\t\tignores, &ignores->ign_global,\n\t\tgit_repository_path(repo), GIT_IGNORE_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* load core.excludesfile */\n\tif (git_repository_attr_cache(repo)->cfg_excl_file != NULL)\n\t\terror = push_ignore_file(\n\t\t\tignores, &ignores->ign_global, NULL,\n\t\t\tgit_repository_attr_cache(repo)->cfg_excl_file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_ignore__free(ignores);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_path__init",
          "args": [
            "&path",
            "pathname",
            "workdir",
            "GIT_DIR_FLAG_UNKNOWN"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "457-506",
          "snippet": "int git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ignores",
            "0",
            "sizeof(ignores)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&path",
            "0",
            "sizeof(path)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ignored && pathname"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore_path_is_ignored(\n\tint *ignored,\n\tgit_repository *repo,\n\tconst char *pathname)\n{\n\tint error;\n\tconst char *workdir;\n\tgit_attr_path path;\n\tgit_ignores ignores;\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tassert(ignored && pathname);\n\n\tworkdir = repo ? git_repository_workdir(repo) : NULL;\n\n\tmemset(&path, 0, sizeof(path));\n\tmemset(&ignores, 0, sizeof(ignores));\n\n\tif ((error = git_attr_path__init(&path, pathname, workdir, GIT_DIR_FLAG_UNKNOWN)) < 0 ||\n\t\t(error = git_ignore__for_path(repo, path.path, &ignores)) < 0)\n\t\tgoto cleanup;\n\n\twhile (1) {\n\t\t/* first process builtins - success means path was found */\n\t\tif (ignore_lookup_in_rules(ignored, ignores.ign_internal, &path))\n\t\t\tgoto cleanup;\n\n\t\t/* next process files in the path */\n\t\tgit_vector_foreach(&ignores.ign_path, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* last process global ignores */\n\t\tgit_vector_foreach(&ignores.ign_global, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* move up one directory */\n\t\tif (path.basename == path.path)\n\t\t\tbreak;\n\t\tpath.basename[-1] = '\\0';\n\t\twhile (path.basename > path.path && *path.basename != '/')\n\t\t\tpath.basename--;\n\t\tif (path.basename > path.path)\n\t\t\tpath.basename++;\n\t\tpath.is_dir = 1;\n\n\t\tif ((error = git_ignore__pop_dir(&ignores)) < 0)\n\t\t\tbreak;\n\t}\n\n\t*ignored = 0;\n\ncleanup:\n\tgit_attr_path__free(&path);\n\tgit_ignore__free(&ignores);\n\treturn error;\n}"
  },
  {
    "function_name": "git_ignore_clear_internal_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "478-492",
    "snippet": "int git_ignore_clear_internal_rules(git_repository *repo)\n{\n\tint error;\n\tgit_attr_file *ign_internal;\n\n\tif ((error = get_internal_ignores(&ign_internal, repo)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_attr_file__clear_rules(ign_internal, true)))\n\t\terror = parse_ignore_file(\n\t\t\trepo, ign_internal, GIT_IGNORE_DEFAULT_RULES);\n\n\tgit_attr_file__free(ign_internal);\n\treturn error;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [
      "#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "ign_internal"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_ignore_file",
          "args": [
            "repo",
            "ign_internal",
            "GIT_IGNORE_DEFAULT_RULES"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ignore_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "160-224",
          "snippet": "static int parse_ignore_file(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tint ignore_case = false;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_fnmatch *match = NULL;\n\n\tif (git_repository__cvar(&ignore_case, repo, GIT_CVAR_IGNORECASE) < 0)\n\t\tgiterr_clear();\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_IGNORE_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock ignore file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\tint valid_rule = 1;\n\n\t\tif (!match && !(match = git__calloc(1, sizeof(*match)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE | GIT_ATTR_FNMATCH_ALLOWNEG;\n\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\tmatch, &attrs->pool, context, &scan)))\n\t\t{\n\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_IGNORE;\n\n\t\t\tif (ignore_case)\n\t\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_ICASE;\n\n\t\t\tscan = git__next_line(scan);\n\n\t\t\t/* if a negative match doesn't actually do anything, throw it away */\n\t\t\tif (match->flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\t\t\terror = does_negate_rule(&valid_rule, &attrs->rules, match);\n\n\t\t\tif (!error && valid_rule)\n\t\t\t\terror = git_vector_insert(&attrs->rules, match);\n\t\t}\n\n\t\tif (error != 0 || !valid_rule) {\n\t\t\tmatch->pattern = NULL;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\tmatch = NULL; /* vector now \"owns\" the match */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit__free(match);\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int parse_ignore_file(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tint ignore_case = false;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_fnmatch *match = NULL;\n\n\tif (git_repository__cvar(&ignore_case, repo, GIT_CVAR_IGNORECASE) < 0)\n\t\tgiterr_clear();\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_IGNORE_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock ignore file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\tint valid_rule = 1;\n\n\t\tif (!match && !(match = git__calloc(1, sizeof(*match)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE | GIT_ATTR_FNMATCH_ALLOWNEG;\n\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\tmatch, &attrs->pool, context, &scan)))\n\t\t{\n\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_IGNORE;\n\n\t\t\tif (ignore_case)\n\t\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_ICASE;\n\n\t\t\tscan = git__next_line(scan);\n\n\t\t\t/* if a negative match doesn't actually do anything, throw it away */\n\t\t\tif (match->flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\t\t\terror = does_negate_rule(&valid_rule, &attrs->rules, match);\n\n\t\t\tif (!error && valid_rule)\n\t\t\t\terror = git_vector_insert(&attrs->rules, match);\n\t\t}\n\n\t\tif (error != 0 || !valid_rule) {\n\t\t\tmatch->pattern = NULL;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\tmatch = NULL; /* vector now \"owns\" the match */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit__free(match);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__clear_rules",
          "args": [
            "ign_internal",
            "true"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__clear_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "46-64",
          "snippet": "int git_attr_file__clear_rules(git_attr_file *file, bool need_lock)\n{\n\tunsigned int i;\n\tgit_attr_rule *rule;\n\n\tif (need_lock && git_mutex_lock(&file->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&file->rules, i, rule)\n\t\tgit_attr_rule__free(rule);\n\tgit_vector_free(&file->rules);\n\n\tif (need_lock)\n\t\tgit_mutex_unlock(&file->lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nint git_attr_file__clear_rules(git_attr_file *file, bool need_lock)\n{\n\tunsigned int i;\n\tgit_attr_rule *rule;\n\n\tif (need_lock && git_mutex_lock(&file->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock attribute file\");\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&file->rules, i, rule)\n\t\tgit_attr_rule__free(rule);\n\tgit_vector_free(&file->rules);\n\n\tif (need_lock)\n\t\tgit_mutex_unlock(&file->lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_internal_ignores",
          "args": [
            "&ign_internal",
            "repo"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "get_internal_ignores",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "256-271",
          "snippet": "static int get_internal_ignores(git_attr_file **out, git_repository *repo)\n{\n\tint error;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__get(\n\t\tout, repo, NULL, GIT_ATTR_FILE__IN_MEMORY, NULL, GIT_IGNORE_INTERNAL, NULL);\n\n\t/* if internal rules list is empty, insert default rules */\n\tif (!error && !(*out)->rules.length)\n\t\terror = parse_ignore_file(repo, *out, GIT_IGNORE_DEFAULT_RULES);\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [
            "#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\"",
            "#define GIT_IGNORE_INTERNAL\t\t\"[internal]exclude\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\n#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\"\n#define GIT_IGNORE_INTERNAL\t\t\"[internal]exclude\"\n\nstatic int get_internal_ignores(git_attr_file **out, git_repository *repo)\n{\n\tint error;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__get(\n\t\tout, repo, NULL, GIT_ATTR_FILE__IN_MEMORY, NULL, GIT_IGNORE_INTERNAL, NULL);\n\n\t/* if internal rules list is empty, insert default rules */\n\tif (!error && !(*out)->rules.length)\n\t\terror = parse_ignore_file(repo, *out, GIT_IGNORE_DEFAULT_RULES);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\n#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\"\n\nint git_ignore_clear_internal_rules(git_repository *repo)\n{\n\tint error;\n\tgit_attr_file *ign_internal;\n\n\tif ((error = get_internal_ignores(&ign_internal, repo)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_attr_file__clear_rules(ign_internal, true)))\n\t\terror = parse_ignore_file(\n\t\t\trepo, ign_internal, GIT_IGNORE_DEFAULT_RULES);\n\n\tgit_attr_file__free(ign_internal);\n\treturn error;\n}"
  },
  {
    "function_name": "git_ignore_add_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "464-476",
    "snippet": "int git_ignore_add_rule(git_repository *repo, const char *rules)\n{\n\tint error;\n\tgit_attr_file *ign_internal = NULL;\n\n\tif ((error = get_internal_ignores(&ign_internal, repo)) < 0)\n\t\treturn error;\n\n\terror = parse_ignore_file(repo, ign_internal, rules);\n\tgit_attr_file__free(ign_internal);\n\n\treturn error;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "ign_internal"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_ignore_file",
          "args": [
            "repo",
            "ign_internal",
            "rules"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ignore_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "160-224",
          "snippet": "static int parse_ignore_file(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tint ignore_case = false;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_fnmatch *match = NULL;\n\n\tif (git_repository__cvar(&ignore_case, repo, GIT_CVAR_IGNORECASE) < 0)\n\t\tgiterr_clear();\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_IGNORE_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock ignore file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\tint valid_rule = 1;\n\n\t\tif (!match && !(match = git__calloc(1, sizeof(*match)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE | GIT_ATTR_FNMATCH_ALLOWNEG;\n\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\tmatch, &attrs->pool, context, &scan)))\n\t\t{\n\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_IGNORE;\n\n\t\t\tif (ignore_case)\n\t\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_ICASE;\n\n\t\t\tscan = git__next_line(scan);\n\n\t\t\t/* if a negative match doesn't actually do anything, throw it away */\n\t\t\tif (match->flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\t\t\terror = does_negate_rule(&valid_rule, &attrs->rules, match);\n\n\t\t\tif (!error && valid_rule)\n\t\t\t\terror = git_vector_insert(&attrs->rules, match);\n\t\t}\n\n\t\tif (error != 0 || !valid_rule) {\n\t\t\tmatch->pattern = NULL;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\tmatch = NULL; /* vector now \"owns\" the match */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit__free(match);\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int parse_ignore_file(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tint ignore_case = false;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_fnmatch *match = NULL;\n\n\tif (git_repository__cvar(&ignore_case, repo, GIT_CVAR_IGNORECASE) < 0)\n\t\tgiterr_clear();\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_IGNORE_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock ignore file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\tint valid_rule = 1;\n\n\t\tif (!match && !(match = git__calloc(1, sizeof(*match)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE | GIT_ATTR_FNMATCH_ALLOWNEG;\n\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\tmatch, &attrs->pool, context, &scan)))\n\t\t{\n\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_IGNORE;\n\n\t\t\tif (ignore_case)\n\t\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_ICASE;\n\n\t\t\tscan = git__next_line(scan);\n\n\t\t\t/* if a negative match doesn't actually do anything, throw it away */\n\t\t\tif (match->flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\t\t\terror = does_negate_rule(&valid_rule, &attrs->rules, match);\n\n\t\t\tif (!error && valid_rule)\n\t\t\t\terror = git_vector_insert(&attrs->rules, match);\n\t\t}\n\n\t\tif (error != 0 || !valid_rule) {\n\t\t\tmatch->pattern = NULL;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\tmatch = NULL; /* vector now \"owns\" the match */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit__free(match);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_internal_ignores",
          "args": [
            "&ign_internal",
            "repo"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "get_internal_ignores",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "256-271",
          "snippet": "static int get_internal_ignores(git_attr_file **out, git_repository *repo)\n{\n\tint error;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__get(\n\t\tout, repo, NULL, GIT_ATTR_FILE__IN_MEMORY, NULL, GIT_IGNORE_INTERNAL, NULL);\n\n\t/* if internal rules list is empty, insert default rules */\n\tif (!error && !(*out)->rules.length)\n\t\terror = parse_ignore_file(repo, *out, GIT_IGNORE_DEFAULT_RULES);\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [
            "#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\"",
            "#define GIT_IGNORE_INTERNAL\t\t\"[internal]exclude\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\n#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\"\n#define GIT_IGNORE_INTERNAL\t\t\"[internal]exclude\"\n\nstatic int get_internal_ignores(git_attr_file **out, git_repository *repo)\n{\n\tint error;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__get(\n\t\tout, repo, NULL, GIT_ATTR_FILE__IN_MEMORY, NULL, GIT_IGNORE_INTERNAL, NULL);\n\n\t/* if internal rules list is empty, insert default rules */\n\tif (!error && !(*out)->rules.length)\n\t\terror = parse_ignore_file(repo, *out, GIT_IGNORE_DEFAULT_RULES);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore_add_rule(git_repository *repo, const char *rules)\n{\n\tint error;\n\tgit_attr_file *ign_internal = NULL;\n\n\tif ((error = get_internal_ignores(&ign_internal, repo)) < 0)\n\t\treturn error;\n\n\terror = parse_ignore_file(repo, ign_internal, rules);\n\tgit_attr_file__free(ign_internal);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_ignore__lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "430-462",
    "snippet": "int git_ignore__lookup(\n\tint *out, git_ignores *ignores, const char *pathname, git_dir_flag dir_flag)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\tgit_attr_path path;\n\n\t*out = GIT_IGNORE_NOTFOUND;\n\n\tif (git_attr_path__init(\n\t\t&path, pathname, git_repository_workdir(ignores->repo), dir_flag) < 0)\n\t\treturn -1;\n\n\t/* first process builtins - success means path was found */\n\tif (ignore_lookup_in_rules(out, ignores->ign_internal, &path))\n\t\tgoto cleanup;\n\n\t/* next process files in the path */\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\n\t/* last process global ignores */\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_attr_path__free(&path);\n\treturn 0;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_path__free",
          "args": [
            "&path"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "508-513",
          "snippet": "void git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_lookup_in_rules",
          "args": [
            "out",
            "file",
            "&path"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_lookup_in_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "413-428",
          "snippet": "static bool ignore_lookup_in_rules(\n\tint *ignored, git_attr_file *file, git_attr_path *path)\n{\n\tsize_t j;\n\tgit_attr_fnmatch *match;\n\n\tgit_vector_rforeach(&file->rules, j, match) {\n\t\tif (git_attr_fnmatch__match(match, path)) {\n\t\t\t*ignored = ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0) ?\n\t\t\t\tGIT_IGNORE_TRUE : GIT_IGNORE_FALSE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic bool ignore_lookup_in_rules(\n\tint *ignored, git_attr_file *file, git_attr_path *path)\n{\n\tsize_t j;\n\tgit_attr_fnmatch *match;\n\n\tgit_vector_rforeach(&file->rules, j, match) {\n\t\tif (git_attr_fnmatch__match(match, path)) {\n\t\t\t*ignored = ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0) ?\n\t\t\t\tGIT_IGNORE_TRUE : GIT_IGNORE_FALSE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&ignores->ign_global",
            "i",
            "file"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&ignores->ign_path",
            "i",
            "file"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_attr_path__init",
          "args": [
            "&path",
            "pathname",
            "git_repository_workdir(ignores->repo)",
            "dir_flag"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "457-506",
          "snippet": "int git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "ignores->repo"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__lookup(\n\tint *out, git_ignores *ignores, const char *pathname, git_dir_flag dir_flag)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\tgit_attr_path path;\n\n\t*out = GIT_IGNORE_NOTFOUND;\n\n\tif (git_attr_path__init(\n\t\t&path, pathname, git_repository_workdir(ignores->repo), dir_flag) < 0)\n\t\treturn -1;\n\n\t/* first process builtins - success means path was found */\n\tif (ignore_lookup_in_rules(out, ignores->ign_internal, &path))\n\t\tgoto cleanup;\n\n\t/* next process files in the path */\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\n\t/* last process global ignores */\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_attr_path__free(&path);\n\treturn 0;\n}"
  },
  {
    "function_name": "ignore_lookup_in_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "413-428",
    "snippet": "static bool ignore_lookup_in_rules(\n\tint *ignored, git_attr_file *file, git_attr_path *path)\n{\n\tsize_t j;\n\tgit_attr_fnmatch *match;\n\n\tgit_vector_rforeach(&file->rules, j, match) {\n\t\tif (git_attr_fnmatch__match(match, path)) {\n\t\t\t*ignored = ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0) ?\n\t\t\t\tGIT_IGNORE_TRUE : GIT_IGNORE_FALSE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_fnmatch__match",
          "args": [
            "match",
            "path"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_fnmatch__match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "355-429",
          "snippet": "bool git_attr_fnmatch__match(\n\tgit_attr_fnmatch *match,\n\tgit_attr_path *path)\n{\n\tconst char *relpath = path->path;\n\tconst char *filename;\n\tint flags = 0;\n\n\t/*\n\t * If the rule was generated in a subdirectory, we must only\n\t * use it for paths inside that directory. We can thus return\n\t * a non-match if the prefixes don't match.\n\t */\n\tif (match->containing_dir) {\n\t\tif (match->flags & GIT_ATTR_FNMATCH_ICASE) {\n\t\t\tif (git__strncasecmp(path->path, match->containing_dir, match->containing_dir_length))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (git__prefixcmp(path->path, match->containing_dir))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trelpath += match->containing_dir_length;\n\t}\n\n\tif (match->flags & GIT_ATTR_FNMATCH_ICASE)\n\t\tflags |= FNM_CASEFOLD;\n\tif (match->flags & GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\tflags |= FNM_LEADING_DIR;\n\n\tif (match->flags & GIT_ATTR_FNMATCH_FULLPATH) {\n\t\tfilename = relpath;\n\t\tflags |= FNM_PATHNAME;\n\t} else {\n\t\tfilename = path->basename;\n\n\t\tif (path->is_dir)\n\t\t\tflags |= FNM_LEADING_DIR;\n\t}\n\n\tif ((match->flags & GIT_ATTR_FNMATCH_DIRECTORY) && !path->is_dir) {\n\t\tbool samename;\n\n\t\t/* for attribute checks or root ignore checks, fail match */\n\t\tif (!(match->flags & GIT_ATTR_FNMATCH_IGNORE) ||\n\t\t\tpath->basename == path->path)\n\t\t\treturn false;\n\n\t\tflags |= FNM_LEADING_DIR;\n\n\t\t/* fail match if this is a file with same name as ignored folder */\n\t\tsamename = (match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strcasecmp(match->pattern, relpath) :\n\t\t\t!strcmp(match->pattern, relpath);\n\n\t\tif (samename)\n\t\t\treturn false;\n\n\t\treturn (p_fnmatch(match->pattern, relpath, flags) != FNM_NOMATCH);\n\t}\n\n\t/* if path is a directory prefix of a negated pattern, then match */\n\tif ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) && path->is_dir) {\n\t\tsize_t pathlen = strlen(relpath);\n\t\tbool prefixed = (pathlen <= match->length) &&\n\t\t\t((match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strncasecmp(match->pattern, relpath, pathlen) :\n\t\t\t!strncmp(match->pattern, relpath, pathlen));\n\n\t\tif (prefixed && git_path_at_end_of_segment(&match->pattern[pathlen]))\n\t\t\treturn true;\n\t}\n\n\treturn (p_fnmatch(match->pattern, filename, flags) != FNM_NOMATCH);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);",
            "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nbool git_attr_fnmatch__match(\n\tgit_attr_fnmatch *match,\n\tgit_attr_path *path)\n{\n\tconst char *relpath = path->path;\n\tconst char *filename;\n\tint flags = 0;\n\n\t/*\n\t * If the rule was generated in a subdirectory, we must only\n\t * use it for paths inside that directory. We can thus return\n\t * a non-match if the prefixes don't match.\n\t */\n\tif (match->containing_dir) {\n\t\tif (match->flags & GIT_ATTR_FNMATCH_ICASE) {\n\t\t\tif (git__strncasecmp(path->path, match->containing_dir, match->containing_dir_length))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (git__prefixcmp(path->path, match->containing_dir))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trelpath += match->containing_dir_length;\n\t}\n\n\tif (match->flags & GIT_ATTR_FNMATCH_ICASE)\n\t\tflags |= FNM_CASEFOLD;\n\tif (match->flags & GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\tflags |= FNM_LEADING_DIR;\n\n\tif (match->flags & GIT_ATTR_FNMATCH_FULLPATH) {\n\t\tfilename = relpath;\n\t\tflags |= FNM_PATHNAME;\n\t} else {\n\t\tfilename = path->basename;\n\n\t\tif (path->is_dir)\n\t\t\tflags |= FNM_LEADING_DIR;\n\t}\n\n\tif ((match->flags & GIT_ATTR_FNMATCH_DIRECTORY) && !path->is_dir) {\n\t\tbool samename;\n\n\t\t/* for attribute checks or root ignore checks, fail match */\n\t\tif (!(match->flags & GIT_ATTR_FNMATCH_IGNORE) ||\n\t\t\tpath->basename == path->path)\n\t\t\treturn false;\n\n\t\tflags |= FNM_LEADING_DIR;\n\n\t\t/* fail match if this is a file with same name as ignored folder */\n\t\tsamename = (match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strcasecmp(match->pattern, relpath) :\n\t\t\t!strcmp(match->pattern, relpath);\n\n\t\tif (samename)\n\t\t\treturn false;\n\n\t\treturn (p_fnmatch(match->pattern, relpath, flags) != FNM_NOMATCH);\n\t}\n\n\t/* if path is a directory prefix of a negated pattern, then match */\n\tif ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) && path->is_dir) {\n\t\tsize_t pathlen = strlen(relpath);\n\t\tbool prefixed = (pathlen <= match->length) &&\n\t\t\t((match->flags & GIT_ATTR_FNMATCH_ICASE) ?\n\t\t\t!strncasecmp(match->pattern, relpath, pathlen) :\n\t\t\t!strncmp(match->pattern, relpath, pathlen));\n\n\t\tif (prefixed && git_path_at_end_of_segment(&match->pattern[pathlen]))\n\t\t\treturn true;\n\t}\n\n\treturn (p_fnmatch(match->pattern, filename, flags) != FNM_NOMATCH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_rforeach",
          "args": [
            "&file->rules",
            "j",
            "match"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic bool ignore_lookup_in_rules(\n\tint *ignored, git_attr_file *file, git_attr_path *path)\n{\n\tsize_t j;\n\tgit_attr_fnmatch *match;\n\n\tgit_vector_rforeach(&file->rules, j, match) {\n\t\tif (git_attr_fnmatch__match(match, path)) {\n\t\t\t*ignored = ((match->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0) ?\n\t\t\t\tGIT_IGNORE_TRUE : GIT_IGNORE_FALSE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "git_ignore__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "391-411",
    "snippet": "void git_ignore__free(git_ignores *ignores)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tgit_attr_file__free(ignores->ign_internal);\n\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_path.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_path);\n\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_global.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_global);\n\n\tgit_buf_free(&ignores->dir);\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ignores->dir"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&ignores->ign_global"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "file"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&ignores->ign_global",
            "i",
            "file"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&ignores->ign_path",
            "i",
            "file"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nvoid git_ignore__free(git_ignores *ignores)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tgit_attr_file__free(ignores->ign_internal);\n\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_path.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_path);\n\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_global.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_global);\n\n\tgit_buf_free(&ignores->dir);\n}"
  },
  {
    "function_name": "git_ignore__pop_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "356-389",
    "snippet": "int git_ignore__pop_dir(git_ignores *ign)\n{\n\tif (ign->ign_path.length > 0) {\n\t\tgit_attr_file *file = git_vector_last(&ign->ign_path);\n\t\tconst char *start = file->entry->path, *end;\n\n\t\t/* - ign->dir looks something like \"/home/user/a/b/\" (or \"a/b/c/d/\")\n\t\t * - file->path looks something like \"a/b/.gitignore\n\t\t *\n\t\t * We are popping the last directory off ign->dir.  We also want\n\t\t * to remove the file from the vector if the popped directory\n\t\t * matches the ignore path.  We need to test if the \"a/b\" part of\n\t\t * the file key matches the path we are about to pop.\n\t\t */\n\n\t\tif ((end = strrchr(start, '/')) != NULL) {\n\t\t\tsize_t dirlen = (end - start) + 1;\n\t\t\tconst char *relpath = ign->dir.ptr + ign->dir_root;\n\t\t\tsize_t pathlen = ign->dir.size - ign->dir_root;\n\n\t\t\tif (pathlen == dirlen && !memcmp(relpath, start, dirlen)) {\n\t\t\t\tgit_vector_pop(&ign->ign_path);\n\t\t\t\tgit_attr_file__free(file);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (--ign->depth > 0) {\n\t\tgit_buf_rtruncate_at_char(&ign->dir, '/');\n\t\tgit_path_to_dir(&ign->dir);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "&ign->dir"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rtruncate_at_char",
          "args": [
            "&ign->dir",
            "'/'"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rtruncate_at_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "464-468",
          "snippet": "void git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "file"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_pop",
          "args": [
            "&ign->ign_path"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "252-256",
          "snippet": "void git_vector_pop(git_vector *v)\n{\n\tif (v->length > 0)\n\t\tv->length--;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_pop(git_vector *v)\n{\n\tif (v->length > 0)\n\t\tv->length--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "relpath",
            "start",
            "dirlen"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "start",
            "'/'"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_last",
          "args": [
            "&ign->ign_path"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "72-75",
          "snippet": "GIT_INLINE(void *) git_vector_last(const git_vector *v)\n{\n\treturn (v->length > 0) ? git_vector_get(v, v->length - 1) : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_last(const git_vector *v)\n{\n\treturn (v->length > 0) ? git_vector_get(v, v->length - 1) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__pop_dir(git_ignores *ign)\n{\n\tif (ign->ign_path.length > 0) {\n\t\tgit_attr_file *file = git_vector_last(&ign->ign_path);\n\t\tconst char *start = file->entry->path, *end;\n\n\t\t/* - ign->dir looks something like \"/home/user/a/b/\" (or \"a/b/c/d/\")\n\t\t * - file->path looks something like \"a/b/.gitignore\n\t\t *\n\t\t * We are popping the last directory off ign->dir.  We also want\n\t\t * to remove the file from the vector if the popped directory\n\t\t * matches the ignore path.  We need to test if the \"a/b\" part of\n\t\t * the file key matches the path we are about to pop.\n\t\t */\n\n\t\tif ((end = strrchr(start, '/')) != NULL) {\n\t\t\tsize_t dirlen = (end - start) + 1;\n\t\t\tconst char *relpath = ign->dir.ptr + ign->dir_root;\n\t\t\tsize_t pathlen = ign->dir.size - ign->dir_root;\n\n\t\t\tif (pathlen == dirlen && !memcmp(relpath, start, dirlen)) {\n\t\t\t\tgit_vector_pop(&ign->ign_path);\n\t\t\t\tgit_attr_file__free(file);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (--ign->depth > 0) {\n\t\tgit_buf_rtruncate_at_char(&ign->dir, '/');\n\t\tgit_path_to_dir(&ign->dir);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_ignore__push_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "345-354",
    "snippet": "int git_ignore__push_dir(git_ignores *ign, const char *dir)\n{\n\tif (git_buf_joinpath(&ign->dir, ign->dir.ptr, dir) < 0)\n\t\treturn -1;\n\n\tign->depth++;\n\n\treturn push_ignore_file(\n\t\tign, &ign->ign_path, ign->dir.ptr, GIT_IGNORE_FILE);\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_ignore_file",
          "args": [
            "ign",
            "&ign->ign_path",
            "ign->dir.ptr",
            "GIT_IGNORE_FILE"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "push_ignore_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "226-247",
          "snippet": "static int push_ignore_file(\n\tgit_ignores *ignores,\n\tgit_vector *which_list,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(\n\t\t&file, ignores->repo, NULL, GIT_ATTR_FILE__FROM_FILE,\n\t\tbase, filename, parse_ignore_file);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(which_list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int push_ignore_file(\n\tgit_ignores *ignores,\n\tgit_vector *which_list,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(\n\t\t&file, ignores->repo, NULL, GIT_ATTR_FILE__FROM_FILE,\n\t\tbase, filename, parse_ignore_file);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(which_list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&ign->dir",
            "ign->dir.ptr",
            "dir"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__push_dir(git_ignores *ign, const char *dir)\n{\n\tif (git_buf_joinpath(&ign->dir, ign->dir.ptr, dir) < 0)\n\t\treturn -1;\n\n\tign->depth++;\n\n\treturn push_ignore_file(\n\t\tign, &ign->ign_path, ign->dir.ptr, GIT_IGNORE_FILE);\n}"
  },
  {
    "function_name": "git_ignore__for_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "273-343",
    "snippet": "int git_ignore__for_path(\n\tgit_repository *repo,\n\tconst char *path,\n\tgit_ignores *ignores)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\n\tassert(ignores && path);\n\n\tmemset(ignores, 0, sizeof(*ignores));\n\tignores->repo = repo;\n\n\t/* Read the ignore_case flag */\n\tif ((error = git_repository__cvar(\n\t\t\t&ignores->ignore_case, repo, GIT_CVAR_IGNORECASE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* given a unrooted path in a non-bare repo, resolve it */\n\tif (workdir && git_path_root(path) < 0) {\n\t\tgit_buf local = GIT_BUF_INIT;\n\n\t\tif ((error = git_path_dirname_r(&local, path)) < 0 ||\n\t\t    (error = git_path_resolve_relative(&local, 0)) < 0 ||\n\t\t    (error = git_path_to_dir(&local)) < 0 ||\n\t\t    (error = git_buf_joinpath(&ignores->dir, workdir, local.ptr)) < 0)\n\t\t{;} /* Nothing, we just want to stop on the first error */\n\t\tgit_buf_free(&local);\n\t} else {\n\t\terror = git_buf_joinpath(&ignores->dir, path, \"\");\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (workdir && !git__prefixcmp(ignores->dir.ptr, workdir))\n\t\tignores->dir_root = strlen(workdir);\n\n\t/* set up internals */\n\tif ((error = get_internal_ignores(&ignores->ign_internal, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* load .gitignore up the path */\n\tif (workdir != NULL) {\n\t\terror = git_path_walk_up(\n\t\t\t&ignores->dir, workdir, push_one_ignore, ignores);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* load .git/info/exclude */\n\terror = push_ignore_file(\n\t\tignores, &ignores->ign_global,\n\t\tgit_repository_path(repo), GIT_IGNORE_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* load core.excludesfile */\n\tif (git_repository_attr_cache(repo)->cfg_excl_file != NULL)\n\t\terror = push_ignore_file(\n\t\t\tignores, &ignores->ign_global, NULL,\n\t\t\tgit_repository_attr_cache(repo)->cfg_excl_file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_ignore__free(ignores);\n\n\treturn error;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_ignore__free",
          "args": [
            "ignores"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "391-411",
          "snippet": "void git_ignore__free(git_ignores *ignores)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tgit_attr_file__free(ignores->ign_internal);\n\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_path.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_path);\n\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_global.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_global);\n\n\tgit_buf_free(&ignores->dir);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nvoid git_ignore__free(git_ignores *ignores)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tgit_attr_file__free(ignores->ign_internal);\n\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_path.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_path);\n\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_global.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_global);\n\n\tgit_buf_free(&ignores->dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_ignore_file",
          "args": [
            "ignores",
            "&ignores->ign_global",
            "NULL",
            "git_repository_attr_cache(repo)->cfg_excl_file"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "push_ignore_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "226-247",
          "snippet": "static int push_ignore_file(\n\tgit_ignores *ignores,\n\tgit_vector *which_list,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(\n\t\t&file, ignores->repo, NULL, GIT_ATTR_FILE__FROM_FILE,\n\t\tbase, filename, parse_ignore_file);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(which_list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int push_ignore_file(\n\tgit_ignores *ignores,\n\tgit_vector *which_list,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(\n\t\t&file, ignores->repo, NULL, GIT_ATTR_FILE__FROM_FILE,\n\t\tbase, filename, parse_ignore_file);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(which_list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_attr_cache",
          "args": [
            "repo"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_attr_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "148-151",
          "snippet": "GIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)\n{\n\treturn repo->attrcache;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)\n{\n\treturn repo->attrcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_path",
          "args": [
            "repo"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1822-1826",
          "snippet": "const char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_walk_up",
          "args": [
            "&ignores->dir",
            "workdir",
            "push_one_ignore",
            "ignores"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_walk_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "439-501",
          "snippet": "int git_path_walk_up(\n\tgit_buf *path,\n\tconst char *ceiling,\n\tint (*cb)(void *data, const char *),\n\tvoid *data)\n{\n\tint error = 0;\n\tgit_buf iter;\n\tssize_t stop = 0, scan;\n\tchar oldc = '\\0';\n\n\tassert(path && cb);\n\n\tif (ceiling != NULL) {\n\t\tif (git__prefixcmp(path->ptr, ceiling) == 0)\n\t\t\tstop = (ssize_t)strlen(ceiling);\n\t\telse\n\t\t\tstop = git_buf_len(path);\n\t}\n\tscan = git_buf_len(path);\n\n\t/* empty path: yield only once */\n\tif (!scan) {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t\treturn error;\n\t}\n\n\titer.ptr = path->ptr;\n\titer.size = git_buf_len(path);\n\titer.asize = path->asize;\n\n\twhile (scan >= stop) {\n\t\terror = cb(data, iter.ptr);\n\t\titer.ptr[scan] = oldc;\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\n\t\tscan = git_buf_rfind_next(&iter, '/');\n\t\tif (scan >= 0) {\n\t\t\tscan++;\n\t\t\toldc = iter.ptr[scan];\n\t\t\titer.size = scan;\n\t\t\titer.ptr[scan] = '\\0';\n\t\t}\n\t}\n\n\tif (scan >= 0)\n\t\titer.ptr[scan] = oldc;\n\n\t/* relative path: yield for the last component */\n\tif (!error && stop == 0 && iter.ptr[0] != '/') {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_walk_up(\n\tgit_buf *path,\n\tconst char *ceiling,\n\tint (*cb)(void *data, const char *),\n\tvoid *data)\n{\n\tint error = 0;\n\tgit_buf iter;\n\tssize_t stop = 0, scan;\n\tchar oldc = '\\0';\n\n\tassert(path && cb);\n\n\tif (ceiling != NULL) {\n\t\tif (git__prefixcmp(path->ptr, ceiling) == 0)\n\t\t\tstop = (ssize_t)strlen(ceiling);\n\t\telse\n\t\t\tstop = git_buf_len(path);\n\t}\n\tscan = git_buf_len(path);\n\n\t/* empty path: yield only once */\n\tif (!scan) {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t\treturn error;\n\t}\n\n\titer.ptr = path->ptr;\n\titer.size = git_buf_len(path);\n\titer.asize = path->asize;\n\n\twhile (scan >= stop) {\n\t\terror = cb(data, iter.ptr);\n\t\titer.ptr[scan] = oldc;\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\n\t\tscan = git_buf_rfind_next(&iter, '/');\n\t\tif (scan >= 0) {\n\t\t\tscan++;\n\t\t\toldc = iter.ptr[scan];\n\t\t\titer.size = scan;\n\t\t\titer.ptr[scan] = '\\0';\n\t\t}\n\t}\n\n\tif (scan >= 0)\n\t\titer.ptr[scan] = oldc;\n\n\t/* relative path: yield for the last component */\n\tif (!error && stop == 0 && iter.ptr[0] != '/') {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_internal_ignores",
          "args": [
            "&ignores->ign_internal",
            "repo"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "get_internal_ignores",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "256-271",
          "snippet": "static int get_internal_ignores(git_attr_file **out, git_repository *repo)\n{\n\tint error;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__get(\n\t\tout, repo, NULL, GIT_ATTR_FILE__IN_MEMORY, NULL, GIT_IGNORE_INTERNAL, NULL);\n\n\t/* if internal rules list is empty, insert default rules */\n\tif (!error && !(*out)->rules.length)\n\t\terror = parse_ignore_file(repo, *out, GIT_IGNORE_DEFAULT_RULES);\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [
            "#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\"",
            "#define GIT_IGNORE_INTERNAL\t\t\"[internal]exclude\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\n#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\"\n#define GIT_IGNORE_INTERNAL\t\t\"[internal]exclude\"\n\nstatic int get_internal_ignores(git_attr_file **out, git_repository *repo)\n{\n\tint error;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__get(\n\t\tout, repo, NULL, GIT_ATTR_FILE__IN_MEMORY, NULL, GIT_IGNORE_INTERNAL, NULL);\n\n\t/* if internal rules list is empty, insert default rules */\n\tif (!error && !(*out)->rules.length)\n\t\terror = parse_ignore_file(repo, *out, GIT_IGNORE_DEFAULT_RULES);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "workdir"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ignores->dir.ptr",
            "workdir"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&ignores->dir",
            "path",
            "\"\""
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&local"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "&local"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_resolve_relative",
          "args": [
            "&local",
            "0"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_resolve_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "703-780",
          "snippet": "int git_path_resolve_relative(git_buf *path, size_t ceiling)\n{\n\tchar *base, *to, *from, *next;\n\tsize_t len;\n\n\tGITERR_CHECK_ALLOC_BUF(path);\n\n\tif (ceiling > path->size)\n\t\tceiling = path->size;\n\n\t/* recognize drive prefixes, etc. that should not be backed over */\n\tif (ceiling == 0)\n\t\tceiling = git_path_root(path->ptr) + 1;\n\n\t/* recognize URL prefixes that should not be backed over */\n\tif (ceiling == 0) {\n\t\tfor (next = path->ptr; *next && git__isalpha(*next); ++next);\n\t\tif (next[0] == ':' && next[1] == '/' && next[2] == '/')\n\t\t\tceiling = (next + 3) - path->ptr;\n\t}\n\n\tbase = to = from = path->ptr + ceiling;\n\n\twhile (*from) {\n\t\tfor (next = from; *next && *next != '/'; ++next);\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == '.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == '.' && from[1] == '.') {\n\t\t\t/* error out if trying to up one from a hard base */\n\t\t\tif (to == base && ceiling != 0) {\n\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\"Cannot strip root component off url\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* no more path segments to strip,\n\t\t\t * use '../' as a new base path */\n\t\t\tif (to == base) {\n\t\t\t\tif (*next == '/')\n\t\t\t\t\tlen++;\n\n\t\t\t\tif (to != from)\n\t\t\t\t\tmemmove(to, from, len);\n\n\t\t\t\tto += len;\n\t\t\t\t/* this is now the base, can't back up from a\n\t\t\t\t * relative prefix */\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == '/') to--;\n\t\t\t\twhile (to > base && to[-1] != '/') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == '/' && *from != '/')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == '/') from++;\n\t}\n\n\t*to = '\\0';\n\n\tpath->size = to - path->ptr;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_resolve_relative(git_buf *path, size_t ceiling)\n{\n\tchar *base, *to, *from, *next;\n\tsize_t len;\n\n\tGITERR_CHECK_ALLOC_BUF(path);\n\n\tif (ceiling > path->size)\n\t\tceiling = path->size;\n\n\t/* recognize drive prefixes, etc. that should not be backed over */\n\tif (ceiling == 0)\n\t\tceiling = git_path_root(path->ptr) + 1;\n\n\t/* recognize URL prefixes that should not be backed over */\n\tif (ceiling == 0) {\n\t\tfor (next = path->ptr; *next && git__isalpha(*next); ++next);\n\t\tif (next[0] == ':' && next[1] == '/' && next[2] == '/')\n\t\t\tceiling = (next + 3) - path->ptr;\n\t}\n\n\tbase = to = from = path->ptr + ceiling;\n\n\twhile (*from) {\n\t\tfor (next = from; *next && *next != '/'; ++next);\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == '.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == '.' && from[1] == '.') {\n\t\t\t/* error out if trying to up one from a hard base */\n\t\t\tif (to == base && ceiling != 0) {\n\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\"Cannot strip root component off url\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* no more path segments to strip,\n\t\t\t * use '../' as a new base path */\n\t\t\tif (to == base) {\n\t\t\t\tif (*next == '/')\n\t\t\t\t\tlen++;\n\n\t\t\t\tif (to != from)\n\t\t\t\t\tmemmove(to, from, len);\n\n\t\t\t\tto += len;\n\t\t\t\t/* this is now the base, can't back up from a\n\t\t\t\t * relative prefix */\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == '/') to--;\n\t\t\t\twhile (to > base && to[-1] != '/') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == '/' && *from != '/')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == '/') from++;\n\t}\n\n\t*to = '\\0';\n\n\tpath->size = to - path->ptr;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_dirname_r",
          "args": [
            "&local",
            "path"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_dirname_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "117-178",
          "snippet": "int git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "path"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__init",
          "args": [
            "repo"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&ignores->ignore_case",
            "repo",
            "GIT_CVAR_IGNORECASE"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ignores",
            "0",
            "sizeof(*ignores)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ignores && path"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__for_path(\n\tgit_repository *repo,\n\tconst char *path,\n\tgit_ignores *ignores)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\n\tassert(ignores && path);\n\n\tmemset(ignores, 0, sizeof(*ignores));\n\tignores->repo = repo;\n\n\t/* Read the ignore_case flag */\n\tif ((error = git_repository__cvar(\n\t\t\t&ignores->ignore_case, repo, GIT_CVAR_IGNORECASE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* given a unrooted path in a non-bare repo, resolve it */\n\tif (workdir && git_path_root(path) < 0) {\n\t\tgit_buf local = GIT_BUF_INIT;\n\n\t\tif ((error = git_path_dirname_r(&local, path)) < 0 ||\n\t\t    (error = git_path_resolve_relative(&local, 0)) < 0 ||\n\t\t    (error = git_path_to_dir(&local)) < 0 ||\n\t\t    (error = git_buf_joinpath(&ignores->dir, workdir, local.ptr)) < 0)\n\t\t{;} /* Nothing, we just want to stop on the first error */\n\t\tgit_buf_free(&local);\n\t} else {\n\t\terror = git_buf_joinpath(&ignores->dir, path, \"\");\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (workdir && !git__prefixcmp(ignores->dir.ptr, workdir))\n\t\tignores->dir_root = strlen(workdir);\n\n\t/* set up internals */\n\tif ((error = get_internal_ignores(&ignores->ign_internal, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* load .gitignore up the path */\n\tif (workdir != NULL) {\n\t\terror = git_path_walk_up(\n\t\t\t&ignores->dir, workdir, push_one_ignore, ignores);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* load .git/info/exclude */\n\terror = push_ignore_file(\n\t\tignores, &ignores->ign_global,\n\t\tgit_repository_path(repo), GIT_IGNORE_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* load core.excludesfile */\n\tif (git_repository_attr_cache(repo)->cfg_excl_file != NULL)\n\t\terror = push_ignore_file(\n\t\t\tignores, &ignores->ign_global, NULL,\n\t\t\tgit_repository_attr_cache(repo)->cfg_excl_file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_ignore__free(ignores);\n\n\treturn error;\n}"
  },
  {
    "function_name": "get_internal_ignores",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "256-271",
    "snippet": "static int get_internal_ignores(git_attr_file **out, git_repository *repo)\n{\n\tint error;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__get(\n\t\tout, repo, NULL, GIT_ATTR_FILE__IN_MEMORY, NULL, GIT_IGNORE_INTERNAL, NULL);\n\n\t/* if internal rules list is empty, insert default rules */\n\tif (!error && !(*out)->rules.length)\n\t\terror = parse_ignore_file(repo, *out, GIT_IGNORE_DEFAULT_RULES);\n\n\treturn error;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [
      "#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\"",
      "#define GIT_IGNORE_INTERNAL\t\t\"[internal]exclude\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_ignore_file",
          "args": [
            "repo",
            "*out",
            "GIT_IGNORE_DEFAULT_RULES"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ignore_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "160-224",
          "snippet": "static int parse_ignore_file(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tint ignore_case = false;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_fnmatch *match = NULL;\n\n\tif (git_repository__cvar(&ignore_case, repo, GIT_CVAR_IGNORECASE) < 0)\n\t\tgiterr_clear();\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_IGNORE_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock ignore file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\tint valid_rule = 1;\n\n\t\tif (!match && !(match = git__calloc(1, sizeof(*match)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE | GIT_ATTR_FNMATCH_ALLOWNEG;\n\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\tmatch, &attrs->pool, context, &scan)))\n\t\t{\n\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_IGNORE;\n\n\t\t\tif (ignore_case)\n\t\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_ICASE;\n\n\t\t\tscan = git__next_line(scan);\n\n\t\t\t/* if a negative match doesn't actually do anything, throw it away */\n\t\t\tif (match->flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\t\t\terror = does_negate_rule(&valid_rule, &attrs->rules, match);\n\n\t\t\tif (!error && valid_rule)\n\t\t\t\terror = git_vector_insert(&attrs->rules, match);\n\t\t}\n\n\t\tif (error != 0 || !valid_rule) {\n\t\t\tmatch->pattern = NULL;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\tmatch = NULL; /* vector now \"owns\" the match */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit__free(match);\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int parse_ignore_file(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tint ignore_case = false;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_fnmatch *match = NULL;\n\n\tif (git_repository__cvar(&ignore_case, repo, GIT_CVAR_IGNORECASE) < 0)\n\t\tgiterr_clear();\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_IGNORE_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock ignore file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\tint valid_rule = 1;\n\n\t\tif (!match && !(match = git__calloc(1, sizeof(*match)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE | GIT_ATTR_FNMATCH_ALLOWNEG;\n\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\tmatch, &attrs->pool, context, &scan)))\n\t\t{\n\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_IGNORE;\n\n\t\t\tif (ignore_case)\n\t\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_ICASE;\n\n\t\t\tscan = git__next_line(scan);\n\n\t\t\t/* if a negative match doesn't actually do anything, throw it away */\n\t\t\tif (match->flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\t\t\terror = does_negate_rule(&valid_rule, &attrs->rules, match);\n\n\t\t\tif (!error && valid_rule)\n\t\t\t\terror = git_vector_insert(&attrs->rules, match);\n\t\t}\n\n\t\tif (error != 0 || !valid_rule) {\n\t\t\tmatch->pattern = NULL;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\tmatch = NULL; /* vector now \"owns\" the match */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit__free(match);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__get",
          "args": [
            "out",
            "repo",
            "NULL",
            "GIT_ATTR_FILE__IN_MEMORY",
            "NULL",
            "GIT_IGNORE_INTERNAL",
            "NULL"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_cache__get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attrcache.c",
          "lines": "200-249",
          "snippet": "int git_attr_cache__get(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file_entry *entry = NULL;\n\tgit_attr_file *file = NULL, *updated = NULL;\n\n\tif ((error = attr_cache_lookup(\n\t\t\t&file, &entry, repo, attr_session, source, base, filename)) < 0)\n\t\treturn error;\n\n\t/* load file if we don't have one or if existing one is out of date */\n\tif (!file || (error = git_attr_file__out_of_date(repo, attr_session, file)) > 0)\n\t\terror = git_attr_file__load(&updated, repo, attr_session, entry, source, parser);\n\n\t/* if we loaded the file, insert into and/or update cache */\n\tif (updated) {\n\t\tif ((error = attr_cache_upsert(cache, updated)) < 0)\n\t\t\tgit_attr_file__free(updated);\n\t\telse {\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = updated;\n\t\t}\n\t}\n\n\t/* if file could not be loaded */\n\tif (error < 0) {\n\t\t/* remove existing entry */\n\t\tif (file) {\n\t\t\tattr_cache_remove(cache, file);\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = NULL;\n\t\t}\n\t\t/* no error if file simply doesn't exist */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t}\n\n\t*out = file;\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"sysdir.h\"",
            "#include \"config.h\"",
            "#include \"attr_file.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"sysdir.h\"\n#include \"config.h\"\n#include \"attr_file.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_cache__get(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file_entry *entry = NULL;\n\tgit_attr_file *file = NULL, *updated = NULL;\n\n\tif ((error = attr_cache_lookup(\n\t\t\t&file, &entry, repo, attr_session, source, base, filename)) < 0)\n\t\treturn error;\n\n\t/* load file if we don't have one or if existing one is out of date */\n\tif (!file || (error = git_attr_file__out_of_date(repo, attr_session, file)) > 0)\n\t\terror = git_attr_file__load(&updated, repo, attr_session, entry, source, parser);\n\n\t/* if we loaded the file, insert into and/or update cache */\n\tif (updated) {\n\t\tif ((error = attr_cache_upsert(cache, updated)) < 0)\n\t\t\tgit_attr_file__free(updated);\n\t\telse {\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = updated;\n\t\t}\n\t}\n\n\t/* if file could not be loaded */\n\tif (error < 0) {\n\t\t/* remove existing entry */\n\t\tif (file) {\n\t\t\tattr_cache_remove(cache, file);\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = NULL;\n\t\t}\n\t\t/* no error if file simply doesn't exist */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t}\n\n\t*out = file;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__init",
          "args": [
            "repo"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\n#define GIT_IGNORE_DEFAULT_RULES \".\\n..\\n.git\\n\"\n#define GIT_IGNORE_INTERNAL\t\t\"[internal]exclude\"\n\nstatic int get_internal_ignores(git_attr_file **out, git_repository *repo)\n{\n\tint error;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\terror = git_attr_cache__get(\n\t\tout, repo, NULL, GIT_ATTR_FILE__IN_MEMORY, NULL, GIT_IGNORE_INTERNAL, NULL);\n\n\t/* if internal rules list is empty, insert default rules */\n\tif (!error && !(*out)->rules.length)\n\t\terror = parse_ignore_file(repo, *out, GIT_IGNORE_DEFAULT_RULES);\n\n\treturn error;\n}"
  },
  {
    "function_name": "push_one_ignore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "249-254",
    "snippet": "static int push_one_ignore(void *payload, const char *path)\n{\n\tgit_ignores *ign = payload;\n\tign->depth++;\n\treturn push_ignore_file(ign, &ign->ign_path, path, GIT_IGNORE_FILE);\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_ignore_file",
          "args": [
            "ign",
            "&ign->ign_path",
            "path",
            "GIT_IGNORE_FILE"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "push_ignore_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "226-247",
          "snippet": "static int push_ignore_file(\n\tgit_ignores *ignores,\n\tgit_vector *which_list,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(\n\t\t&file, ignores->repo, NULL, GIT_ATTR_FILE__FROM_FILE,\n\t\tbase, filename, parse_ignore_file);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(which_list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int push_ignore_file(\n\tgit_ignores *ignores,\n\tgit_vector *which_list,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(\n\t\t&file, ignores->repo, NULL, GIT_ATTR_FILE__FROM_FILE,\n\t\tbase, filename, parse_ignore_file);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(which_list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int push_one_ignore(void *payload, const char *path)\n{\n\tgit_ignores *ign = payload;\n\tign->depth++;\n\treturn push_ignore_file(ign, &ign->ign_path, path, GIT_IGNORE_FILE);\n}"
  },
  {
    "function_name": "push_ignore_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "226-247",
    "snippet": "static int push_ignore_file(\n\tgit_ignores *ignores,\n\tgit_vector *which_list,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(\n\t\t&file, ignores->repo, NULL, GIT_ATTR_FILE__FROM_FILE,\n\t\tbase, filename, parse_ignore_file);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(which_list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "file"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "which_list",
            "file"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__get",
          "args": [
            "&file",
            "ignores->repo",
            "NULL",
            "GIT_ATTR_FILE__FROM_FILE",
            "base",
            "filename",
            "parse_ignore_file"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_cache__get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attrcache.c",
          "lines": "200-249",
          "snippet": "int git_attr_cache__get(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file_entry *entry = NULL;\n\tgit_attr_file *file = NULL, *updated = NULL;\n\n\tif ((error = attr_cache_lookup(\n\t\t\t&file, &entry, repo, attr_session, source, base, filename)) < 0)\n\t\treturn error;\n\n\t/* load file if we don't have one or if existing one is out of date */\n\tif (!file || (error = git_attr_file__out_of_date(repo, attr_session, file)) > 0)\n\t\terror = git_attr_file__load(&updated, repo, attr_session, entry, source, parser);\n\n\t/* if we loaded the file, insert into and/or update cache */\n\tif (updated) {\n\t\tif ((error = attr_cache_upsert(cache, updated)) < 0)\n\t\t\tgit_attr_file__free(updated);\n\t\telse {\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = updated;\n\t\t}\n\t}\n\n\t/* if file could not be loaded */\n\tif (error < 0) {\n\t\t/* remove existing entry */\n\t\tif (file) {\n\t\t\tattr_cache_remove(cache, file);\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = NULL;\n\t\t}\n\t\t/* no error if file simply doesn't exist */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t}\n\n\t*out = file;\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"sysdir.h\"",
            "#include \"config.h\"",
            "#include \"attr_file.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"sysdir.h\"\n#include \"config.h\"\n#include \"attr_file.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_cache__get(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file_entry *entry = NULL;\n\tgit_attr_file *file = NULL, *updated = NULL;\n\n\tif ((error = attr_cache_lookup(\n\t\t\t&file, &entry, repo, attr_session, source, base, filename)) < 0)\n\t\treturn error;\n\n\t/* load file if we don't have one or if existing one is out of date */\n\tif (!file || (error = git_attr_file__out_of_date(repo, attr_session, file)) > 0)\n\t\terror = git_attr_file__load(&updated, repo, attr_session, entry, source, parser);\n\n\t/* if we loaded the file, insert into and/or update cache */\n\tif (updated) {\n\t\tif ((error = attr_cache_upsert(cache, updated)) < 0)\n\t\t\tgit_attr_file__free(updated);\n\t\telse {\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = updated;\n\t\t}\n\t}\n\n\t/* if file could not be loaded */\n\tif (error < 0) {\n\t\t/* remove existing entry */\n\t\tif (file) {\n\t\t\tattr_cache_remove(cache, file);\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = NULL;\n\t\t}\n\t\t/* no error if file simply doesn't exist */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t}\n\n\t*out = file;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int push_ignore_file(\n\tgit_ignores *ignores,\n\tgit_vector *which_list,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(\n\t\t&file, ignores->repo, NULL, GIT_ATTR_FILE__FROM_FILE,\n\t\tbase, filename, parse_ignore_file);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(which_list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "parse_ignore_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "160-224",
    "snippet": "static int parse_ignore_file(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tint ignore_case = false;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_fnmatch *match = NULL;\n\n\tif (git_repository__cvar(&ignore_case, repo, GIT_CVAR_IGNORECASE) < 0)\n\t\tgiterr_clear();\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_IGNORE_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock ignore file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\tint valid_rule = 1;\n\n\t\tif (!match && !(match = git__calloc(1, sizeof(*match)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE | GIT_ATTR_FNMATCH_ALLOWNEG;\n\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\tmatch, &attrs->pool, context, &scan)))\n\t\t{\n\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_IGNORE;\n\n\t\t\tif (ignore_case)\n\t\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_ICASE;\n\n\t\t\tscan = git__next_line(scan);\n\n\t\t\t/* if a negative match doesn't actually do anything, throw it away */\n\t\t\tif (match->flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\t\t\terror = does_negate_rule(&valid_rule, &attrs->rules, match);\n\n\t\t\tif (!error && valid_rule)\n\t\t\t\terror = git_vector_insert(&attrs->rules, match);\n\t\t}\n\n\t\tif (error != 0 || !valid_rule) {\n\t\t\tmatch->pattern = NULL;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\tmatch = NULL; /* vector now \"owns\" the match */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit__free(match);\n\n\treturn error;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "match"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&attrs->lock"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&attrs->rules",
            "match"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "does_negate_rule",
          "args": [
            "&valid_rule",
            "&attrs->rules",
            "match"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "does_negate_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "90-158",
          "snippet": "static int does_negate_rule(int *out, git_vector *rules, git_attr_fnmatch *match)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_attr_fnmatch *rule;\n\tchar *path;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t*out = 0;\n\n\t/* path of the file relative to the workdir, so we match the rules in subdirs */\n\tif (match->containing_dir) {\n\t\tgit_buf_puts(&buf, match->containing_dir);\n\t}\n\tif (git_buf_puts(&buf, match->pattern) < 0)\n\t\treturn -1;\n\n\tpath = git_buf_detach(&buf);\n\n\tgit_vector_foreach(rules, i, rule) {\n\t\tif (!(rule->flags & GIT_ATTR_FNMATCH_HASWILD)) {\n\t\t\tif (does_negate_pattern(rule, match)) {\n\t\t\t\terror = 0;\n\t\t\t\t*out = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t/*\n\t * When dealing with a directory, we add '/<star>' so\n\t * p_fnmatch() honours FNM_PATHNAME. Checking for LEADINGDIR\n\t * alone isn't enough as that's also set for nagations, so we\n\t * need to check that NEGATIVE is off.\n\t */\n\t\tgit_buf_clear(&buf);\n\t\tif (rule->containing_dir) {\n\t\t\tgit_buf_puts(&buf, rule->containing_dir);\n\t\t}\n\n\t\terror = git_buf_puts(&buf, rule->pattern);\n\n\t\tif ((rule->flags & (GIT_ATTR_FNMATCH_LEADINGDIR | GIT_ATTR_FNMATCH_NEGATIVE)) == GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\t\terror = git_buf_PUTS(&buf, \"/*\");\n\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\tif ((error = p_fnmatch(git_buf_cstr(&buf), path, FNM_PATHNAME)) < 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"error matching pattern\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* if we found a match, we want to keep this rule */\n\t\tif (error != FNM_NOMATCH) {\n\t\t\t*out = 1;\n\t\t\terror = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = 0;\n\nout:\n\tgit__free(path);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int does_negate_rule(int *out, git_vector *rules, git_attr_fnmatch *match)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_attr_fnmatch *rule;\n\tchar *path;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t*out = 0;\n\n\t/* path of the file relative to the workdir, so we match the rules in subdirs */\n\tif (match->containing_dir) {\n\t\tgit_buf_puts(&buf, match->containing_dir);\n\t}\n\tif (git_buf_puts(&buf, match->pattern) < 0)\n\t\treturn -1;\n\n\tpath = git_buf_detach(&buf);\n\n\tgit_vector_foreach(rules, i, rule) {\n\t\tif (!(rule->flags & GIT_ATTR_FNMATCH_HASWILD)) {\n\t\t\tif (does_negate_pattern(rule, match)) {\n\t\t\t\terror = 0;\n\t\t\t\t*out = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t/*\n\t * When dealing with a directory, we add '/<star>' so\n\t * p_fnmatch() honours FNM_PATHNAME. Checking for LEADINGDIR\n\t * alone isn't enough as that's also set for nagations, so we\n\t * need to check that NEGATIVE is off.\n\t */\n\t\tgit_buf_clear(&buf);\n\t\tif (rule->containing_dir) {\n\t\t\tgit_buf_puts(&buf, rule->containing_dir);\n\t\t}\n\n\t\terror = git_buf_puts(&buf, rule->pattern);\n\n\t\tif ((rule->flags & (GIT_ATTR_FNMATCH_LEADINGDIR | GIT_ATTR_FNMATCH_NEGATIVE)) == GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\t\terror = git_buf_PUTS(&buf, \"/*\");\n\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\tif ((error = p_fnmatch(git_buf_cstr(&buf), path, FNM_PATHNAME)) < 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"error matching pattern\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* if we found a match, we want to keep this rule */\n\t\tif (error != FNM_NOMATCH) {\n\t\t\t*out = 1;\n\t\t\terror = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = 0;\n\nout:\n\tgit__free(path);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__next_line",
          "args": [
            "scan"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "git__next_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "293-298",
          "snippet": "GIT_INLINE(const char *) git__next_line(const char *s)\n{\n\twhile (*s && *s != '\\n') s++;\n\twhile (*s == '\\n' || *s == '\\r') s++;\n\treturn s;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(const char *) git__next_line(const char *s)\n{\n\twhile (*s && *s != '\\n') s++;\n\twhile (*s == '\\n' || *s == '\\r') s++;\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_fnmatch__parse",
          "args": [
            "match",
            "&attrs->pool",
            "context",
            "&scan"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_fnmatch__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "552-663",
          "snippet": "int git_attr_fnmatch__parse(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *context,\n\tconst char **base)\n{\n\tconst char *pattern, *scan;\n\tint slash_count, allow_space;\n\n\tassert(spec && base && *base);\n\n\tif (parse_optimized_patterns(spec, pool, *base))\n\t\treturn 0;\n\n\tspec->flags = (spec->flags & GIT_ATTR_FNMATCH__INCOMING);\n\tallow_space = ((spec->flags & GIT_ATTR_FNMATCH_ALLOWSPACE) != 0);\n\n\tpattern = *base;\n\n\twhile (git__isspace(*pattern)) pattern++;\n\tif (!*pattern || *pattern == '#') {\n\t\t*base = git__next_line(pattern);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (*pattern == '[' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWMACRO) != 0) {\n\t\tif (strncmp(pattern, \"[attr]\", 6) == 0) {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_MACRO;\n\t\t\tpattern += 6;\n\t\t}\n\t\t/* else a character range like [a-e]* which is accepted */\n\t}\n\n\tif (*pattern == '!' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWNEG) != 0) {\n\t\tspec->flags = spec->flags |\n\t\t\tGIT_ATTR_FNMATCH_NEGATIVE | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\tpattern++;\n\t}\n\n\tslash_count = 0;\n\tfor (scan = pattern; *scan != '\\0'; ++scan) {\n\t\t/* scan until (non-escaped) white space */\n\t\tif (git__isspace(*scan) && *(scan - 1) != '\\\\') {\n\t\t\tif (!allow_space || (*scan != ' ' && *scan != '\\t' && *scan != '\\r'))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (*scan == '/') {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_FULLPATH;\n\t\t\tslash_count++;\n\t\t\tif (pattern == scan)\n\t\t\t\tpattern++;\n\t\t}\n\t\t/* remember if we see an unescaped wildcard in pattern */\n\t\telse if (git__iswildcard(*scan) &&\n\t\t\t(scan == pattern || (*(scan - 1) != '\\\\')))\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_HASWILD;\n\t}\n\n\t*base = scan;\n\n\tif ((spec->length = scan - pattern) == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/*\n\t * Remove one trailing \\r in case this is a CRLF delimited\n\t * file, in the case of Icon\\r\\r\\n, we still leave the first\n\t * \\r there to match against.\n\t */\n\tif (pattern[spec->length - 1] == '\\r')\n\t\tif (--spec->length == 0)\n\t\t\treturn GIT_ENOTFOUND;\n\n\tif (pattern[spec->length - 1] == '/') {\n\t\tspec->length--;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_DIRECTORY;\n\t\tif (--slash_count <= 0)\n\t\t\tspec->flags = spec->flags & ~GIT_ATTR_FNMATCH_FULLPATH;\n\t}\n\tif ((spec->flags & GIT_ATTR_FNMATCH_NOLEADINGDIR) == 0 &&\n\t\tspec->length >= 2 &&\n\t\tpattern[spec->length - 1] == '*' &&\n\t\tpattern[spec->length - 2] == '/') {\n\t\tspec->length -= 2;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\t/* leave FULLPATH match on, however */\n\t}\n\n\tif (context) {\n\t\tchar *slash = strrchr(context, '/');\n\t\tsize_t len;\n\t\tif (slash) {\n\t\t\t/* include the slash for easier matching */\n\t\t\tlen = slash - context + 1;\n\t\t\tspec->containing_dir = git_pool_strndup(pool, context, len);\n\t\t\tspec->containing_dir_length = len;\n\t\t}\n\t}\n\n\tspec->pattern = git_pool_strndup(pool, pattern, spec->length);\n\n\tif (!spec->pattern) {\n\t\t*base = git__next_line(pattern);\n\t\treturn -1;\n\t} else {\n\t\t/* strip '\\' that might have be used for internal whitespace */\n\t\tspec->length = git__unescape(spec->pattern);\n\t\t/* TODO: convert remaining '\\' into '/' for POSIX ??? */\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic bool parse_optimized_patterns(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *pattern);\n\nint git_attr_fnmatch__parse(\n\tgit_attr_fnmatch *spec,\n\tgit_pool *pool,\n\tconst char *context,\n\tconst char **base)\n{\n\tconst char *pattern, *scan;\n\tint slash_count, allow_space;\n\n\tassert(spec && base && *base);\n\n\tif (parse_optimized_patterns(spec, pool, *base))\n\t\treturn 0;\n\n\tspec->flags = (spec->flags & GIT_ATTR_FNMATCH__INCOMING);\n\tallow_space = ((spec->flags & GIT_ATTR_FNMATCH_ALLOWSPACE) != 0);\n\n\tpattern = *base;\n\n\twhile (git__isspace(*pattern)) pattern++;\n\tif (!*pattern || *pattern == '#') {\n\t\t*base = git__next_line(pattern);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (*pattern == '[' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWMACRO) != 0) {\n\t\tif (strncmp(pattern, \"[attr]\", 6) == 0) {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_MACRO;\n\t\t\tpattern += 6;\n\t\t}\n\t\t/* else a character range like [a-e]* which is accepted */\n\t}\n\n\tif (*pattern == '!' && (spec->flags & GIT_ATTR_FNMATCH_ALLOWNEG) != 0) {\n\t\tspec->flags = spec->flags |\n\t\t\tGIT_ATTR_FNMATCH_NEGATIVE | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\tpattern++;\n\t}\n\n\tslash_count = 0;\n\tfor (scan = pattern; *scan != '\\0'; ++scan) {\n\t\t/* scan until (non-escaped) white space */\n\t\tif (git__isspace(*scan) && *(scan - 1) != '\\\\') {\n\t\t\tif (!allow_space || (*scan != ' ' && *scan != '\\t' && *scan != '\\r'))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (*scan == '/') {\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_FULLPATH;\n\t\t\tslash_count++;\n\t\t\tif (pattern == scan)\n\t\t\t\tpattern++;\n\t\t}\n\t\t/* remember if we see an unescaped wildcard in pattern */\n\t\telse if (git__iswildcard(*scan) &&\n\t\t\t(scan == pattern || (*(scan - 1) != '\\\\')))\n\t\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_HASWILD;\n\t}\n\n\t*base = scan;\n\n\tif ((spec->length = scan - pattern) == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/*\n\t * Remove one trailing \\r in case this is a CRLF delimited\n\t * file, in the case of Icon\\r\\r\\n, we still leave the first\n\t * \\r there to match against.\n\t */\n\tif (pattern[spec->length - 1] == '\\r')\n\t\tif (--spec->length == 0)\n\t\t\treturn GIT_ENOTFOUND;\n\n\tif (pattern[spec->length - 1] == '/') {\n\t\tspec->length--;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_DIRECTORY;\n\t\tif (--slash_count <= 0)\n\t\t\tspec->flags = spec->flags & ~GIT_ATTR_FNMATCH_FULLPATH;\n\t}\n\tif ((spec->flags & GIT_ATTR_FNMATCH_NOLEADINGDIR) == 0 &&\n\t\tspec->length >= 2 &&\n\t\tpattern[spec->length - 1] == '*' &&\n\t\tpattern[spec->length - 2] == '/') {\n\t\tspec->length -= 2;\n\t\tspec->flags = spec->flags | GIT_ATTR_FNMATCH_LEADINGDIR;\n\t\t/* leave FULLPATH match on, however */\n\t}\n\n\tif (context) {\n\t\tchar *slash = strrchr(context, '/');\n\t\tsize_t len;\n\t\tif (slash) {\n\t\t\t/* include the slash for easier matching */\n\t\t\tlen = slash - context + 1;\n\t\t\tspec->containing_dir = git_pool_strndup(pool, context, len);\n\t\t\tspec->containing_dir_length = len;\n\t\t}\n\t}\n\n\tspec->pattern = git_pool_strndup(pool, pattern, spec->length);\n\n\tif (!spec->pattern) {\n\t\t*base = git__next_line(pattern);\n\t\treturn -1;\n\t} else {\n\t\t/* strip '\\' that might have be used for internal whitespace */\n\t\tspec->length = git__unescape(spec->pattern);\n\t\t/* TODO: convert remaining '\\' into '/' for POSIX ??? */\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(*match)"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to lock ignore file\""
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&attrs->lock"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "git__suffixcmp",
          "args": [
            "attrs->entry->path",
            "\"/\" GIT_IGNORE_FILE"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "git__suffixcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "272-279",
          "snippet": "int git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "attrs->entry->path"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&ignore_case",
            "repo",
            "GIT_CVAR_IGNORECASE"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int parse_ignore_file(\n\tgit_repository *repo, git_attr_file *attrs, const char *data)\n{\n\tint error = 0;\n\tint ignore_case = false;\n\tconst char *scan = data, *context = NULL;\n\tgit_attr_fnmatch *match = NULL;\n\n\tif (git_repository__cvar(&ignore_case, repo, GIT_CVAR_IGNORECASE) < 0)\n\t\tgiterr_clear();\n\n\t/* if subdir file path, convert context for file paths */\n\tif (attrs->entry &&\n\t\tgit_path_root(attrs->entry->path) < 0 &&\n\t\t!git__suffixcmp(attrs->entry->path, \"/\" GIT_IGNORE_FILE))\n\t\tcontext = attrs->entry->path;\n\n\tif (git_mutex_lock(&attrs->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to lock ignore file\");\n\t\treturn -1;\n\t}\n\n\twhile (!error && *scan) {\n\t\tint valid_rule = 1;\n\n\t\tif (!match && !(match = git__calloc(1, sizeof(*match)))) {\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE | GIT_ATTR_FNMATCH_ALLOWNEG;\n\n\t\tif (!(error = git_attr_fnmatch__parse(\n\t\t\tmatch, &attrs->pool, context, &scan)))\n\t\t{\n\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_IGNORE;\n\n\t\t\tif (ignore_case)\n\t\t\t\tmatch->flags |= GIT_ATTR_FNMATCH_ICASE;\n\n\t\t\tscan = git__next_line(scan);\n\n\t\t\t/* if a negative match doesn't actually do anything, throw it away */\n\t\t\tif (match->flags & GIT_ATTR_FNMATCH_NEGATIVE)\n\t\t\t\terror = does_negate_rule(&valid_rule, &attrs->rules, match);\n\n\t\t\tif (!error && valid_rule)\n\t\t\t\terror = git_vector_insert(&attrs->rules, match);\n\t\t}\n\n\t\tif (error != 0 || !valid_rule) {\n\t\t\tmatch->pattern = NULL;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\terror = 0;\n\t\t} else {\n\t\t\tmatch = NULL; /* vector now \"owns\" the match */\n\t\t}\n\t}\n\n\tgit_mutex_unlock(&attrs->lock);\n\tgit__free(match);\n\n\treturn error;\n}"
  },
  {
    "function_name": "does_negate_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "90-158",
    "snippet": "static int does_negate_rule(int *out, git_vector *rules, git_attr_fnmatch *match)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_attr_fnmatch *rule;\n\tchar *path;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t*out = 0;\n\n\t/* path of the file relative to the workdir, so we match the rules in subdirs */\n\tif (match->containing_dir) {\n\t\tgit_buf_puts(&buf, match->containing_dir);\n\t}\n\tif (git_buf_puts(&buf, match->pattern) < 0)\n\t\treturn -1;\n\n\tpath = git_buf_detach(&buf);\n\n\tgit_vector_foreach(rules, i, rule) {\n\t\tif (!(rule->flags & GIT_ATTR_FNMATCH_HASWILD)) {\n\t\t\tif (does_negate_pattern(rule, match)) {\n\t\t\t\terror = 0;\n\t\t\t\t*out = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t/*\n\t * When dealing with a directory, we add '/<star>' so\n\t * p_fnmatch() honours FNM_PATHNAME. Checking for LEADINGDIR\n\t * alone isn't enough as that's also set for nagations, so we\n\t * need to check that NEGATIVE is off.\n\t */\n\t\tgit_buf_clear(&buf);\n\t\tif (rule->containing_dir) {\n\t\t\tgit_buf_puts(&buf, rule->containing_dir);\n\t\t}\n\n\t\terror = git_buf_puts(&buf, rule->pattern);\n\n\t\tif ((rule->flags & (GIT_ATTR_FNMATCH_LEADINGDIR | GIT_ATTR_FNMATCH_NEGATIVE)) == GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\t\terror = git_buf_PUTS(&buf, \"/*\");\n\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\tif ((error = p_fnmatch(git_buf_cstr(&buf), path, FNM_PATHNAME)) < 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"error matching pattern\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* if we found a match, we want to keep this rule */\n\t\tif (error != FNM_NOMATCH) {\n\t\t\t*out = 1;\n\t\t\terror = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = 0;\n\nout:\n\tgit__free(path);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "path"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"error matching pattern\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_fnmatch",
          "args": [
            "git_buf_cstr(&buf)",
            "path",
            "FNM_PATHNAME"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "230-234",
          "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_PUTS",
          "args": [
            "&buf",
            "\"/*\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&buf",
            "rule->pattern"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&buf"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "does_negate_pattern",
          "args": [
            "rule",
            "match"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "does_negate_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "41-75",
          "snippet": "static int does_negate_pattern(git_attr_fnmatch *rule, git_attr_fnmatch *neg)\n{\n\tgit_attr_fnmatch *longer, *shorter;\n\tchar *p;\n\n\tif ((rule->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0\n\t\t&& (neg->flags & GIT_ATTR_FNMATCH_NEGATIVE) != 0) {\n\n\t\t/* If lengths match we need to have an exact match */\n\t\tif (rule->length == neg->length) {\n\t\t\treturn strcmp(rule->pattern, neg->pattern) == 0;\n\t\t} else if (rule->length < neg->length) {\n\t\t\tshorter = rule;\n\t\t\tlonger = neg;\n\t\t} else {\n\t\t\tshorter = neg;\n\t\t\tlonger = rule;\n\t\t}\n\n\t\t/* Otherwise, we need to check if the shorter\n\t\t * rule is a basename only (that is, it contains\n\t\t * no path separator) and, if so, if it\n\t\t * matches the tail of the longer rule */\n\t\tp = longer->pattern + longer->length - shorter->length;\n\n\t\tif (p[-1] != '/')\n\t\t\treturn false;\n\t\tif (memchr(shorter->pattern, '/', shorter->length) != NULL)\n\t\t\treturn false;\n\n\t\treturn memcmp(p, shorter->pattern, shorter->length) == 0;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int does_negate_pattern(git_attr_fnmatch *rule, git_attr_fnmatch *neg)\n{\n\tgit_attr_fnmatch *longer, *shorter;\n\tchar *p;\n\n\tif ((rule->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0\n\t\t&& (neg->flags & GIT_ATTR_FNMATCH_NEGATIVE) != 0) {\n\n\t\t/* If lengths match we need to have an exact match */\n\t\tif (rule->length == neg->length) {\n\t\t\treturn strcmp(rule->pattern, neg->pattern) == 0;\n\t\t} else if (rule->length < neg->length) {\n\t\t\tshorter = rule;\n\t\t\tlonger = neg;\n\t\t} else {\n\t\t\tshorter = neg;\n\t\t\tlonger = rule;\n\t\t}\n\n\t\t/* Otherwise, we need to check if the shorter\n\t\t * rule is a basename only (that is, it contains\n\t\t * no path separator) and, if so, if it\n\t\t * matches the tail of the longer rule */\n\t\tp = longer->pattern + longer->length - shorter->length;\n\n\t\tif (p[-1] != '/')\n\t\t\treturn false;\n\t\tif (memchr(shorter->pattern, '/', shorter->length) != NULL)\n\t\t\treturn false;\n\n\t\treturn memcmp(p, shorter->pattern, shorter->length) == 0;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "rules",
            "i",
            "rule"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&buf"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int does_negate_rule(int *out, git_vector *rules, git_attr_fnmatch *match)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_attr_fnmatch *rule;\n\tchar *path;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t*out = 0;\n\n\t/* path of the file relative to the workdir, so we match the rules in subdirs */\n\tif (match->containing_dir) {\n\t\tgit_buf_puts(&buf, match->containing_dir);\n\t}\n\tif (git_buf_puts(&buf, match->pattern) < 0)\n\t\treturn -1;\n\n\tpath = git_buf_detach(&buf);\n\n\tgit_vector_foreach(rules, i, rule) {\n\t\tif (!(rule->flags & GIT_ATTR_FNMATCH_HASWILD)) {\n\t\t\tif (does_negate_pattern(rule, match)) {\n\t\t\t\terror = 0;\n\t\t\t\t*out = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t/*\n\t * When dealing with a directory, we add '/<star>' so\n\t * p_fnmatch() honours FNM_PATHNAME. Checking for LEADINGDIR\n\t * alone isn't enough as that's also set for nagations, so we\n\t * need to check that NEGATIVE is off.\n\t */\n\t\tgit_buf_clear(&buf);\n\t\tif (rule->containing_dir) {\n\t\t\tgit_buf_puts(&buf, rule->containing_dir);\n\t\t}\n\n\t\terror = git_buf_puts(&buf, rule->pattern);\n\n\t\tif ((rule->flags & (GIT_ATTR_FNMATCH_LEADINGDIR | GIT_ATTR_FNMATCH_NEGATIVE)) == GIT_ATTR_FNMATCH_LEADINGDIR)\n\t\t\terror = git_buf_PUTS(&buf, \"/*\");\n\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\tif ((error = p_fnmatch(git_buf_cstr(&buf), path, FNM_PATHNAME)) < 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"error matching pattern\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* if we found a match, we want to keep this rule */\n\t\tif (error != FNM_NOMATCH) {\n\t\t\t*out = 1;\n\t\t\terror = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = 0;\n\nout:\n\tgit__free(path);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
  },
  {
    "function_name": "does_negate_pattern",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
    "lines": "41-75",
    "snippet": "static int does_negate_pattern(git_attr_fnmatch *rule, git_attr_fnmatch *neg)\n{\n\tgit_attr_fnmatch *longer, *shorter;\n\tchar *p;\n\n\tif ((rule->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0\n\t\t&& (neg->flags & GIT_ATTR_FNMATCH_NEGATIVE) != 0) {\n\n\t\t/* If lengths match we need to have an exact match */\n\t\tif (rule->length == neg->length) {\n\t\t\treturn strcmp(rule->pattern, neg->pattern) == 0;\n\t\t} else if (rule->length < neg->length) {\n\t\t\tshorter = rule;\n\t\t\tlonger = neg;\n\t\t} else {\n\t\t\tshorter = neg;\n\t\t\tlonger = rule;\n\t\t}\n\n\t\t/* Otherwise, we need to check if the shorter\n\t\t * rule is a basename only (that is, it contains\n\t\t * no path separator) and, if so, if it\n\t\t * matches the tail of the longer rule */\n\t\tp = longer->pattern + longer->length - shorter->length;\n\n\t\tif (p[-1] != '/')\n\t\t\treturn false;\n\t\tif (memchr(shorter->pattern, '/', shorter->length) != NULL)\n\t\t\treturn false;\n\n\t\treturn memcmp(p, shorter->pattern, shorter->length) == 0;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include \"config.h\"",
      "#include \"path.h\"",
      "#include \"attrcache.h\"",
      "#include \"ignore.h\"",
      "#include \"common.h\"",
      "#include \"git2/ignore.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "p",
            "shorter->pattern",
            "shorter->length"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "shorter->pattern",
            "'/'",
            "shorter->length"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rule->pattern",
            "neg->pattern"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nstatic int does_negate_pattern(git_attr_fnmatch *rule, git_attr_fnmatch *neg)\n{\n\tgit_attr_fnmatch *longer, *shorter;\n\tchar *p;\n\n\tif ((rule->flags & GIT_ATTR_FNMATCH_NEGATIVE) == 0\n\t\t&& (neg->flags & GIT_ATTR_FNMATCH_NEGATIVE) != 0) {\n\n\t\t/* If lengths match we need to have an exact match */\n\t\tif (rule->length == neg->length) {\n\t\t\treturn strcmp(rule->pattern, neg->pattern) == 0;\n\t\t} else if (rule->length < neg->length) {\n\t\t\tshorter = rule;\n\t\t\tlonger = neg;\n\t\t} else {\n\t\t\tshorter = neg;\n\t\t\tlonger = rule;\n\t\t}\n\n\t\t/* Otherwise, we need to check if the shorter\n\t\t * rule is a basename only (that is, it contains\n\t\t * no path separator) and, if so, if it\n\t\t * matches the tail of the longer rule */\n\t\tp = longer->pattern + longer->length - shorter->length;\n\n\t\tif (p[-1] != '/')\n\t\t\treturn false;\n\t\tif (memchr(shorter->pattern, '/', shorter->length) != NULL)\n\t\t\treturn false;\n\n\t\treturn memcmp(p, shorter->pattern, shorter->length) == 0;\n\t}\n\n\treturn false;\n}"
  }
]