[
  {
    "function_name": "xdl_fall_back_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "374-403",
    "snippet": "int xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp,\n\t\tint line1, int count1, int line2, int count2)\n{\n\t/*\n\t * This probably does not work outside Git, since\n\t * we have a very simple mmfile structure.\n\t *\n\t * Note: ideally, we would reuse the prepared environment, but\n\t * the libxdiff interface does not (yet) allow for diffing only\n\t * ranges of lines instead of the whole files.\n\t */\n\tmmfile_t subfile1, subfile2;\n\txdfenv_t env;\n\n\tsubfile1.ptr = (char *)diff_env->xdf1.recs[line1 - 1]->ptr;\n\tsubfile1.size = diff_env->xdf1.recs[line1 + count1 - 2]->ptr +\n\t\tdiff_env->xdf1.recs[line1 + count1 - 2]->size - subfile1.ptr;\n\tsubfile2.ptr = (char *)diff_env->xdf2.recs[line2 - 1]->ptr;\n\tsubfile2.size = diff_env->xdf2.recs[line2 + count2 - 2]->ptr +\n\t\tdiff_env->xdf2.recs[line2 + count2 - 2]->size - subfile2.ptr;\n\tif (xdl_do_diff(&subfile1, &subfile2, xpp, &env) < 0)\n\t\treturn -1;\n\n\tmemcpy(diff_env->xdf1.rchg + line1 - 1, env.xdf1.rchg, count1);\n\tmemcpy(diff_env->xdf2.rchg + line2 - 1, env.xdf2.rchg, count2);\n\n\txdl_free_env(&env);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free_env",
          "args": [
            "&env"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "diff_env->xdf2.rchg + line2 - 1",
            "env.xdf2.rchg",
            "count2"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "diff_env->xdf1.rchg + line1 - 1",
            "env.xdf1.rchg",
            "count1"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_do_diff",
          "args": [
            "&subfile1",
            "&subfile2",
            "xpp",
            "&env"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_do_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "325-387",
          "snippet": "int xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_SNAKE_CNT 20",
            "#define XDL_HEUR_MIN_COST 256",
            "#define XDL_MAX_COST_MIN 256"
          ],
          "globals_used": [
            "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\n#define XDL_SNAKE_CNT 20\n#define XDL_HEUR_MIN_COST 256\n#define XDL_MAX_COST_MIN 256\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);\n\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp,\n\t\tint line1, int count1, int line2, int count2)\n{\n\t/*\n\t * This probably does not work outside Git, since\n\t * we have a very simple mmfile structure.\n\t *\n\t * Note: ideally, we would reuse the prepared environment, but\n\t * the libxdiff interface does not (yet) allow for diffing only\n\t * ranges of lines instead of the whole files.\n\t */\n\tmmfile_t subfile1, subfile2;\n\txdfenv_t env;\n\n\tsubfile1.ptr = (char *)diff_env->xdf1.recs[line1 - 1]->ptr;\n\tsubfile1.size = diff_env->xdf1.recs[line1 + count1 - 2]->ptr +\n\t\tdiff_env->xdf1.recs[line1 + count1 - 2]->size - subfile1.ptr;\n\tsubfile2.ptr = (char *)diff_env->xdf2.recs[line2 - 1]->ptr;\n\tsubfile2.size = diff_env->xdf2.recs[line2 + count2 - 2]->ptr +\n\t\tdiff_env->xdf2.recs[line2 + count2 - 2]->size - subfile2.ptr;\n\tif (xdl_do_diff(&subfile1, &subfile2, xpp, &env) < 0)\n\t\treturn -1;\n\n\tmemcpy(diff_env->xdf1.rchg + line1 - 1, env.xdf1.rchg, count1);\n\tmemcpy(diff_env->xdf2.rchg + line2 - 1, env.xdf2.rchg, count2);\n\n\txdl_free_env(&env);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_emit_hunk_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "325-372",
    "snippet": "int xdl_emit_hunk_hdr(long s1, long c1, long s2, long c2,\n\t\t      const char *func, long funclen, xdemitcb_t *ecb) {\n\tint nb = 0;\n\tmmbuffer_t mb;\n\tchar buf[128];\n\n\tmemcpy(buf, \"@@ -\", 4);\n\tnb += 4;\n\n\tnb += xdl_num_out(buf + nb, c1 ? s1: s1 - 1);\n\n\tif (c1 != 1) {\n\t\tmemcpy(buf + nb, \",\", 1);\n\t\tnb += 1;\n\n\t\tnb += xdl_num_out(buf + nb, c1);\n\t}\n\n\tmemcpy(buf + nb, \" +\", 2);\n\tnb += 2;\n\n\tnb += xdl_num_out(buf + nb, c2 ? s2: s2 - 1);\n\n\tif (c2 != 1) {\n\t\tmemcpy(buf + nb, \",\", 1);\n\t\tnb += 1;\n\n\t\tnb += xdl_num_out(buf + nb, c2);\n\t}\n\n\tmemcpy(buf + nb, \" @@\", 3);\n\tnb += 3;\n\tif (func && funclen) {\n\t\tbuf[nb++] = ' ';\n\t\tif (funclen > (long)sizeof(buf) - nb - 1)\n\t\t\tfunclen = (long)sizeof(buf) - nb - 1;\n\t\tmemcpy(buf + nb, func, funclen);\n\t\tnb += funclen;\n\t}\n\tbuf[nb++] = '\\n';\n\n\tmb.ptr = buf;\n\tmb.size = nb;\n\tif (ecb->outf(ecb->priv, &mb, 1) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecb->outf",
          "args": [
            "ecb->priv",
            "&mb",
            "1"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + nb",
            "func",
            "funclen"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + nb",
            "\" @@\"",
            "3"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_num_out",
          "args": [
            "buf + nb",
            "c2"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_num_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "289-309",
          "snippet": "int xdl_num_out(char *out, long val) {\n\tchar *ptr, *str = out;\n\tchar buf[32];\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\tif (val < 0) {\n\t\t*--ptr = '-';\n\t\tval = -val;\n\t}\n\tfor (; val && ptr > buf; val /= 10)\n\t\t*--ptr = \"0123456789\"[val % 10];\n\tif (*ptr)\n\t\tfor (; *ptr; ptr++, str++)\n\t\t\t*str = *ptr;\n\telse\n\t\t*str++ = '0';\n\t*str = '\\0';\n\n\treturn (int)(str - out);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_num_out(char *out, long val) {\n\tchar *ptr, *str = out;\n\tchar buf[32];\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\tif (val < 0) {\n\t\t*--ptr = '-';\n\t\tval = -val;\n\t}\n\tfor (; val && ptr > buf; val /= 10)\n\t\t*--ptr = \"0123456789\"[val % 10];\n\tif (*ptr)\n\t\tfor (; *ptr; ptr++, str++)\n\t\t\t*str = *ptr;\n\telse\n\t\t*str++ = '0';\n\t*str = '\\0';\n\n\treturn (int)(str - out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + nb",
            "\",\"",
            "1"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + nb",
            "\" +\"",
            "2"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + nb",
            "\",\"",
            "1"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "\"@@ -\"",
            "4"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_emit_hunk_hdr(long s1, long c1, long s2, long c2,\n\t\t      const char *func, long funclen, xdemitcb_t *ecb) {\n\tint nb = 0;\n\tmmbuffer_t mb;\n\tchar buf[128];\n\n\tmemcpy(buf, \"@@ -\", 4);\n\tnb += 4;\n\n\tnb += xdl_num_out(buf + nb, c1 ? s1: s1 - 1);\n\n\tif (c1 != 1) {\n\t\tmemcpy(buf + nb, \",\", 1);\n\t\tnb += 1;\n\n\t\tnb += xdl_num_out(buf + nb, c1);\n\t}\n\n\tmemcpy(buf + nb, \" +\", 2);\n\tnb += 2;\n\n\tnb += xdl_num_out(buf + nb, c2 ? s2: s2 - 1);\n\n\tif (c2 != 1) {\n\t\tmemcpy(buf + nb, \",\", 1);\n\t\tnb += 1;\n\n\t\tnb += xdl_num_out(buf + nb, c2);\n\t}\n\n\tmemcpy(buf + nb, \" @@\", 3);\n\tnb += 3;\n\tif (func && funclen) {\n\t\tbuf[nb++] = ' ';\n\t\tif (funclen > (long)sizeof(buf) - nb - 1)\n\t\t\tfunclen = (long)sizeof(buf) - nb - 1;\n\t\tmemcpy(buf + nb, func, funclen);\n\t\tnb += funclen;\n\t}\n\tbuf[nb++] = '\\n';\n\n\tmb.ptr = buf;\n\tmb.size = nb;\n\tif (ecb->outf(ecb->priv, &mb, 1) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_atol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "312-322",
    "snippet": "long xdl_atol(char const *str, char const **next) {\n\tlong val, base;\n\tchar const *top;\n\n\tfor (top = str; XDL_ISDIGIT(*top); top++);\n\tif (next)\n\t\t*next = top;\n\tfor (val = 0, base = 1, top--; top >= str; top--, base *= 10)\n\t\tval += base * (long)(*top - '0');\n\treturn val;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDL_ISDIGIT",
          "args": [
            "*top"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nlong xdl_atol(char const *str, char const **next) {\n\tlong val, base;\n\tchar const *top;\n\n\tfor (top = str; XDL_ISDIGIT(*top); top++);\n\tif (next)\n\t\t*next = top;\n\tfor (val = 0, base = 1, top--; top >= str; top--, base *= 10)\n\t\tval += base * (long)(*top - '0');\n\treturn val;\n}"
  },
  {
    "function_name": "xdl_num_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "289-309",
    "snippet": "int xdl_num_out(char *out, long val) {\n\tchar *ptr, *str = out;\n\tchar buf[32];\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\tif (val < 0) {\n\t\t*--ptr = '-';\n\t\tval = -val;\n\t}\n\tfor (; val && ptr > buf; val /= 10)\n\t\t*--ptr = \"0123456789\"[val % 10];\n\tif (*ptr)\n\t\tfor (; *ptr; ptr++, str++)\n\t\t\t*str = *ptr;\n\telse\n\t\t*str++ = '0';\n\t*str = '\\0';\n\n\treturn (int)(str - out);\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_num_out(char *out, long val) {\n\tchar *ptr, *str = out;\n\tchar buf[32];\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\tif (val < 0) {\n\t\t*--ptr = '-';\n\t\tval = -val;\n\t}\n\tfor (; val && ptr > buf; val /= 10)\n\t\t*--ptr = \"0123456789\"[val % 10];\n\tif (*ptr)\n\t\tfor (; *ptr; ptr++, str++)\n\t\t\t*str = *ptr;\n\telse\n\t\t*str++ = '0';\n\t*str = '\\0';\n\n\treturn (int)(str - out);\n}"
  },
  {
    "function_name": "xdl_hashbits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "281-286",
    "snippet": "unsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xinclude.h\"\n\nunsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}"
  },
  {
    "function_name": "xdl_hash_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "264-278",
    "snippet": "unsigned long xdl_hash_record(char const **data, char const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tif (flags & XDF_WHITESPACE_FLAGS)\n\t\treturn xdl_hash_record_with_whitespace(data, top, flags);\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_hash_record_with_whitespace",
          "args": [
            "data",
            "top",
            "flags"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_hash_record_with_whitespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "225-261",
          "snippet": "static unsigned long xdl_hash_record_with_whitespace(char const **data,\n\t\tchar const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tif (XDL_ISSPACE(*ptr)) {\n\t\t\tconst char *ptr2 = ptr;\n\t\t\tint at_eol;\n\t\t\twhile (ptr + 1 < top && XDL_ISSPACE(ptr[1])\n\t\t\t\t\t&& ptr[1] != '\\n')\n\t\t\t\tptr++;\n\t\t\tat_eol = (top <= ptr + 1 || ptr[1] == '\\n');\n\t\t\tif (flags & XDF_IGNORE_WHITESPACE)\n\t\t\t\t; /* already handled */\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_CHANGE\n\t\t\t\t && !at_eol) {\n\t\t\t\tha += (ha << 5);\n\t\t\t\tha ^= (unsigned long) ' ';\n\t\t\t}\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_AT_EOL\n\t\t\t\t && !at_eol) {\n\t\t\t\twhile (ptr2 != ptr + 1) {\n\t\t\t\t\tha += (ha << 5);\n\t\t\t\t\tha ^= (unsigned long) *ptr2;\n\t\t\t\t\tptr2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic unsigned long xdl_hash_record_with_whitespace(char const **data,\n\t\tchar const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tif (XDL_ISSPACE(*ptr)) {\n\t\t\tconst char *ptr2 = ptr;\n\t\t\tint at_eol;\n\t\t\twhile (ptr + 1 < top && XDL_ISSPACE(ptr[1])\n\t\t\t\t\t&& ptr[1] != '\\n')\n\t\t\t\tptr++;\n\t\t\tat_eol = (top <= ptr + 1 || ptr[1] == '\\n');\n\t\t\tif (flags & XDF_IGNORE_WHITESPACE)\n\t\t\t\t; /* already handled */\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_CHANGE\n\t\t\t\t && !at_eol) {\n\t\t\t\tha += (ha << 5);\n\t\t\t\tha ^= (unsigned long) ' ';\n\t\t\t}\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_AT_EOL\n\t\t\t\t && !at_eol) {\n\t\t\t\twhile (ptr2 != ptr + 1) {\n\t\t\t\t\tha += (ha << 5);\n\t\t\t\t\tha ^= (unsigned long) *ptr2;\n\t\t\t\t\tptr2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nunsigned long xdl_hash_record(char const **data, char const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tif (flags & XDF_WHITESPACE_FLAGS)\n\t\treturn xdl_hash_record_with_whitespace(data, top, flags);\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}"
  },
  {
    "function_name": "xdl_hash_record_with_whitespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "225-261",
    "snippet": "static unsigned long xdl_hash_record_with_whitespace(char const **data,\n\t\tchar const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tif (XDL_ISSPACE(*ptr)) {\n\t\t\tconst char *ptr2 = ptr;\n\t\t\tint at_eol;\n\t\t\twhile (ptr + 1 < top && XDL_ISSPACE(ptr[1])\n\t\t\t\t\t&& ptr[1] != '\\n')\n\t\t\t\tptr++;\n\t\t\tat_eol = (top <= ptr + 1 || ptr[1] == '\\n');\n\t\t\tif (flags & XDF_IGNORE_WHITESPACE)\n\t\t\t\t; /* already handled */\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_CHANGE\n\t\t\t\t && !at_eol) {\n\t\t\t\tha += (ha << 5);\n\t\t\t\tha ^= (unsigned long) ' ';\n\t\t\t}\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_AT_EOL\n\t\t\t\t && !at_eol) {\n\t\t\t\twhile (ptr2 != ptr + 1) {\n\t\t\t\t\tha += (ha << 5);\n\t\t\t\t\tha ^= (unsigned long) *ptr2;\n\t\t\t\t\tptr2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "ptr[1]"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "*ptr"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nstatic unsigned long xdl_hash_record_with_whitespace(char const **data,\n\t\tchar const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tif (XDL_ISSPACE(*ptr)) {\n\t\t\tconst char *ptr2 = ptr;\n\t\t\tint at_eol;\n\t\t\twhile (ptr + 1 < top && XDL_ISSPACE(ptr[1])\n\t\t\t\t\t&& ptr[1] != '\\n')\n\t\t\t\tptr++;\n\t\t\tat_eol = (top <= ptr + 1 || ptr[1] == '\\n');\n\t\t\tif (flags & XDF_IGNORE_WHITESPACE)\n\t\t\t\t; /* already handled */\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_CHANGE\n\t\t\t\t && !at_eol) {\n\t\t\t\tha += (ha << 5);\n\t\t\t\tha ^= (unsigned long) ' ';\n\t\t\t}\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_AT_EOL\n\t\t\t\t && !at_eol) {\n\t\t\t\twhile (ptr2 != ptr + 1) {\n\t\t\t\t\tha += (ha << 5);\n\t\t\t\t\tha ^= (unsigned long) *ptr2;\n\t\t\t\t\tptr2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}"
  },
  {
    "function_name": "xdl_recmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "157-223",
    "snippet": "int xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "l2[i2]"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "l1[i1]"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "l2[i2]"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "l1[i1]"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "l2[i2]"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "l1[i1]"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "l2[i2]"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "l1[i1]"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "l1",
            "l2",
            "s1"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "xdl_blankline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "144-155",
    "snippet": "int xdl_blankline(const char *line, long size, long flags)\n{\n\tlong i;\n\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn (size <= 1);\n\n\tfor (i = 0; i < size && XDL_ISSPACE(line[i]); i++)\n\t\t;\n\n\treturn (i == size);\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDL_ISSPACE",
          "args": [
            "line[i]"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_blankline(const char *line, long size, long flags)\n{\n\tlong i;\n\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn (size <= 1);\n\n\tfor (i = 0; i < size && XDL_ISSPACE(line[i]); i++)\n\t\t;\n\n\treturn (i == size);\n}"
  },
  {
    "function_name": "xdl_guess_lines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "123-142",
    "snippet": "long xdl_guess_lines(mmfile_t *mf, long sample) {\n\tlong nl = 0, size, tsize = 0;\n\tchar const *data, *cur, *top;\n\n\tif ((cur = data = xdl_mmfile_first(mf, &size)) != NULL) {\n\t\tfor (top = data + size; nl < sample && cur < top; ) {\n\t\t\tnl++;\n\t\t\tif (!(cur = memchr(cur, '\\n', top - cur)))\n\t\t\t\tcur = top;\n\t\t\telse\n\t\t\t\tcur++;\n\t\t}\n\t\ttsize += (long) (cur - data);\n\t}\n\n\tif (nl && tsize)\n\t\tnl = xdl_mmfile_size(mf) / (tsize / nl);\n\n\treturn nl + 1;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_mmfile_size",
          "args": [
            "mf"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_mmfile_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "70-73",
          "snippet": "long xdl_mmfile_size(mmfile_t *mmf)\n{\n\treturn (long)mmf->size;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nlong xdl_mmfile_size(mmfile_t *mmf)\n{\n\treturn (long)mmf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "cur",
            "'\\n'",
            "top - cur"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_mmfile_first",
          "args": [
            "mf",
            "&size"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_mmfile_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "63-67",
          "snippet": "void *xdl_mmfile_first(mmfile_t *mmf, long *size)\n{\n\t*size = (long)mmf->size;\n\treturn mmf->ptr;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size)\n{\n\t*size = (long)mmf->size;\n\treturn mmf->ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nlong xdl_guess_lines(mmfile_t *mf, long sample) {\n\tlong nl = 0, size, tsize = 0;\n\tchar const *data, *cur, *top;\n\n\tif ((cur = data = xdl_mmfile_first(mf, &size)) != NULL) {\n\t\tfor (top = data + size; nl < sample && cur < top; ) {\n\t\t\tnl++;\n\t\t\tif (!(cur = memchr(cur, '\\n', top - cur)))\n\t\t\t\tcur = top;\n\t\t\telse\n\t\t\t\tcur++;\n\t\t}\n\t\ttsize += (long) (cur - data);\n\t}\n\n\tif (nl && tsize)\n\t\tnl = xdl_mmfile_size(mf) / (tsize / nl);\n\n\treturn nl + 1;\n}"
  },
  {
    "function_name": "xdl_cha_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "98-121",
    "snippet": "void *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "sizeof(chanode_t) + cha->nsize"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nvoid *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}"
  },
  {
    "function_name": "xdl_cha_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "88-95",
    "snippet": "void xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "tmp"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nvoid xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}"
  },
  {
    "function_name": "xdl_cha_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "76-85",
    "snippet": "int xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_mmfile_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "70-73",
    "snippet": "long xdl_mmfile_size(mmfile_t *mmf)\n{\n\treturn (long)mmf->size;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xinclude.h\"\n\nlong xdl_mmfile_size(mmfile_t *mmf)\n{\n\treturn (long)mmf->size;\n}"
  },
  {
    "function_name": "xdl_mmfile_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "63-67",
    "snippet": "void *xdl_mmfile_first(mmfile_t *mmf, long *size)\n{\n\t*size = (long)mmf->size;\n\treturn mmf->ptr;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xinclude.h\"\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size)\n{\n\t*size = (long)mmf->size;\n\treturn mmf->ptr;\n}"
  },
  {
    "function_name": "xdl_emit_diffrec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "41-61",
    "snippet": "int xdl_emit_diffrec(char const *rec, long size, char const *pre, long psize,\n\t\t     xdemitcb_t *ecb) {\n\tint i = 2;\n\tmmbuffer_t mb[3];\n\n\tmb[0].ptr = (char *) pre;\n\tmb[0].size = psize;\n\tmb[1].ptr = (char *) rec;\n\tmb[1].size = size;\n\tif (size > 0 && rec[size - 1] != '\\n') {\n\t\tmb[2].ptr = (char *) \"\\n\\\\ No newline at end of file\\n\";\n\t\tmb[2].size = strlen(mb[2].ptr);\n\t\ti++;\n\t}\n\tif (ecb->outf(ecb->priv, mb, i) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecb->outf",
          "args": [
            "ecb->priv",
            "mb",
            "i"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mb[2].ptr"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_emit_diffrec(char const *rec, long size, char const *pre, long psize,\n\t\t     xdemitcb_t *ecb) {\n\tint i = 2;\n\tmmbuffer_t mb[3];\n\n\tmb[0].ptr = (char *) pre;\n\tmb[0].size = psize;\n\tmb[1].ptr = (char *) rec;\n\tmb[1].size = size;\n\tif (size > 0 && rec[size - 1] != '\\n') {\n\t\tmb[2].ptr = (char *) \"\\n\\\\ No newline at end of file\\n\";\n\t\tmb[2].size = strlen(mb[2].ptr);\n\t\ti++;\n\t}\n\tif (ecb->outf(ecb->priv, mb, i) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_bogosqrt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
    "lines": "28-38",
    "snippet": "long xdl_bogosqrt(long n) {\n\tlong i;\n\n\t/*\n\t * Classical integer square root approximation using shifts.\n\t */\n\tfor (i = 1; n > 0; n >>= 2)\n\t\ti <<= 1;\n\n\treturn i;\n}",
    "includes": [
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xinclude.h\"\n\nlong xdl_bogosqrt(long n) {\n\tlong i;\n\n\t/*\n\t * Classical integer square root approximation using shifts.\n\t */\n\tfor (i = 1; n > 0; n >>= 2)\n\t\ti <<= 1;\n\n\treturn i;\n}"
  }
]