[
  {
    "function_name": "apply_insteadof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2490-2549",
    "snippet": "char *apply_insteadof(git_config *config, const char *url, int direction)\n{\n\tsize_t match_length, prefix_length, suffix_length;\n\tchar *replacement = NULL;\n\tconst char *regexp;\n\n\tgit_buf result = GIT_BUF_INIT;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\n\tassert(config);\n\tassert(url);\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\t/* Add 1 to prefix/suffix length due to the additional escaped dot */\n\tprefix_length = strlen(PREFIX) + 1;\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_FETCH;\n\t\tsuffix_length = strlen(SUFFIX_FETCH) + 1;\n\t} else {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_PUSH;\n\t\tsuffix_length = strlen(SUFFIX_PUSH) + 1;\n\t}\n\n\tif (git_config_iterator_glob_new(&iter, config, regexp) < 0)\n\t\treturn NULL;\n\n\tmatch_length = 0;\n\twhile (git_config_next(&entry, iter) == 0) {\n\t\tsize_t n, replacement_length;\n\n\t\t/* Check if entry value is a prefix of URL */\n\t\tif (git__prefixcmp(url, entry->value))\n\t\t\tcontinue;\n\t\t/* Check if entry value is longer than previous\n\t\t * prefixes */\n\t\tif ((n = strlen(entry->value)) <= match_length)\n\t\t\tcontinue;\n\n\t\tgit__free(replacement);\n\t\tmatch_length = n;\n\n\t\t/* Cut off prefix and suffix of the value */\n\t\treplacement_length =\n\t\t    strlen(entry->name) - (prefix_length + suffix_length);\n\t\treplacement = git__strndup(entry->name + prefix_length,\n\t\t\t\treplacement_length);\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (match_length == 0)\n\t\treturn git__strdup(url);\n\n\tgit_buf_printf(&result, \"%s%s\", replacement, url + match_length);\n\n\tgit__free(replacement);\n\n\treturn result.ptr;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [
      "#define SUFFIX_PUSH \"pushinsteadof\"",
      "#define SUFFIX_FETCH \"insteadof\"",
      "#define PREFIX \"url\""
    ],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
      "char *apply_insteadof(git_config *config, const char *url, int direction);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "replacement"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&result",
            "\"%s%s\"",
            "replacement",
            "url + match_length"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "url"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_iterator_free",
          "args": [
            "iter"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1063-1069",
          "snippet": "void git_config_iterator_free(git_config_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_iterator_free(git_config_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "entry->name + prefix_length",
            "replacement_length"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry->name"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry->value"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "url",
            "entry->value"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_next",
          "args": [
            "&entry",
            "iter"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1058-1061",
          "snippet": "int git_config_next(git_config_entry **entry, git_config_iterator *iter)\n{\n\treturn iter->next(entry, iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_next(git_config_entry **entry, git_config_iterator *iter)\n{\n\treturn iter->next(entry, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_iterator_glob_new",
          "args": [
            "&iter",
            "config",
            "regexp"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_iterator_glob_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "470-495",
          "snippet": "int git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)\n{\n\tall_iter *iter;\n\tint result;\n\n\tif (regexp == NULL)\n\t\treturn git_config_iterator_new(out, cfg);\n\n\titer = git__calloc(1, sizeof(all_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\tif ((result = regcomp(&iter->regex, regexp, REG_EXTENDED)) != 0) {\n\t\tgiterr_set_regex(&iter->regex, result);\n\t\tgit__free(iter);\n\t\treturn -1;\n\t}\n\n\titer->parent.next = all_iter_glob_next;\n\titer->parent.free = all_iter_glob_free;\n\titer->i = cfg->files.length;\n\titer->cfg = cfg;\n\n\t*out = (git_config_iterator *) iter;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)\n{\n\tall_iter *iter;\n\tint result;\n\n\tif (regexp == NULL)\n\t\treturn git_config_iterator_new(out, cfg);\n\n\titer = git__calloc(1, sizeof(all_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\tif ((result = regcomp(&iter->regex, regexp, REG_EXTENDED)) != 0) {\n\t\tgiterr_set_regex(&iter->regex, result);\n\t\tgit__free(iter);\n\t\treturn -1;\n\t}\n\n\titer->parent.next = all_iter_glob_next;\n\titer->parent.free = all_iter_glob_free;\n\titer->i = cfg->files.length;\n\titer->cfg = cfg;\n\n\t*out = (git_config_iterator *) iter;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "SUFFIX_PUSH"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "SUFFIX_FETCH"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "PREFIX"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "url"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "config"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define SUFFIX_PUSH \"pushinsteadof\"\n#define SUFFIX_FETCH \"insteadof\"\n#define PREFIX \"url\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nchar *apply_insteadof(git_config *config, const char *url, int direction)\n{\n\tsize_t match_length, prefix_length, suffix_length;\n\tchar *replacement = NULL;\n\tconst char *regexp;\n\n\tgit_buf result = GIT_BUF_INIT;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\n\tassert(config);\n\tassert(url);\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\t/* Add 1 to prefix/suffix length due to the additional escaped dot */\n\tprefix_length = strlen(PREFIX) + 1;\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_FETCH;\n\t\tsuffix_length = strlen(SUFFIX_FETCH) + 1;\n\t} else {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_PUSH;\n\t\tsuffix_length = strlen(SUFFIX_PUSH) + 1;\n\t}\n\n\tif (git_config_iterator_glob_new(&iter, config, regexp) < 0)\n\t\treturn NULL;\n\n\tmatch_length = 0;\n\twhile (git_config_next(&entry, iter) == 0) {\n\t\tsize_t n, replacement_length;\n\n\t\t/* Check if entry value is a prefix of URL */\n\t\tif (git__prefixcmp(url, entry->value))\n\t\t\tcontinue;\n\t\t/* Check if entry value is longer than previous\n\t\t * prefixes */\n\t\tif ((n = strlen(entry->value)) <= match_length)\n\t\t\tcontinue;\n\n\t\tgit__free(replacement);\n\t\tmatch_length = n;\n\n\t\t/* Cut off prefix and suffix of the value */\n\t\treplacement_length =\n\t\t    strlen(entry->name) - (prefix_length + suffix_length);\n\t\treplacement = git__strndup(entry->name + prefix_length,\n\t\t\t\treplacement_length);\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (match_length == 0)\n\t\treturn git__strdup(url);\n\n\tgit_buf_printf(&result, \"%s%s\", replacement, url + match_length);\n\n\tgit__free(replacement);\n\n\treturn result.ptr;\n}"
  },
  {
    "function_name": "git_remote_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2460-2484",
    "snippet": "int git_remote_push(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)\n{\n\tint error;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tassert(remote && refspecs);\n\n\tif ((error = git_remote_connect(remote, GIT_DIRECTION_PUSH, cbs, custom_headers)) < 0)\n\t\treturn error;\n\n\tif ((error = git_remote_upload(remote, refspecs, opts)) < 0)\n\t\treturn error;\n\n\terror = git_remote_update_tips(remote, cbs, 0, 0, NULL);\n\n\tgit_remote_disconnect(remote);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_remote_disconnect",
          "args": [
            "remote"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1634-1640",
          "snippet": "void git_remote_disconnect(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (git_remote_connected(remote))\n\t\tremote->transport->close(remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nvoid git_remote_disconnect(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (git_remote_connected(remote))\n\t\tremote->transport->close(remote->transport);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_update_tips",
          "args": [
            "remote",
            "cbs",
            "0",
            "0",
            "NULL"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_update_tips",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1562-1613",
          "snippet": "int git_remote_update_tips(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t download_tags,\n\t\tconst char *reflog_message)\n{\n\tgit_refspec *spec, tagspec;\n\tgit_vector refs = GIT_VECTOR_INIT;\n\tgit_remote_autotag_option_t tagopt;\n\tint error;\n\tsize_t i;\n\n\t/* push has its own logic hidden away in the push object */\n\tif (remote->push) {\n\t\treturn git_push_update_tips(remote->push, callbacks);\n\t}\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\n\tif ((error = ls_to_vector(&refs, remote)) < 0)\n\t\tgoto out;\n\n\tif (download_tags == GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = remote->download_tags;\n\telse\n\t\ttagopt = download_tags;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, &tagspec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, spec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* only try to do opportunisitic updates if the refpec lists differ */\n\tif (remote->passed_refspecs)\n\t\terror = opportunistic_updates(remote, callbacks, &refs, reflog_message);\n\nout:\n\tgit_vector_free(&refs);\n\tgit_refspec__free(&tagspec);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nint git_remote_update_tips(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t download_tags,\n\t\tconst char *reflog_message)\n{\n\tgit_refspec *spec, tagspec;\n\tgit_vector refs = GIT_VECTOR_INIT;\n\tgit_remote_autotag_option_t tagopt;\n\tint error;\n\tsize_t i;\n\n\t/* push has its own logic hidden away in the push object */\n\tif (remote->push) {\n\t\treturn git_push_update_tips(remote->push, callbacks);\n\t}\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\n\tif ((error = ls_to_vector(&refs, remote)) < 0)\n\t\tgoto out;\n\n\tif (download_tags == GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = remote->download_tags;\n\telse\n\t\ttagopt = download_tags;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, &tagspec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, spec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* only try to do opportunisitic updates if the refpec lists differ */\n\tif (remote->passed_refspecs)\n\t\terror = opportunistic_updates(remote, callbacks, &refs, reflog_message);\n\nout:\n\tgit_vector_free(&refs);\n\tgit_refspec__free(&tagspec);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_upload",
          "args": [
            "remote",
            "refspecs",
            "opts"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_upload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2398-2458",
          "snippet": "int git_remote_upload(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)\n{\n\tsize_t i;\n\tint error;\n\tgit_push *push;\n\tgit_refspec *spec;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tassert(remote);\n\n\tif (opts) {\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tif (!git_remote_connected(remote) &&\n\t    (error = git_remote_connect(remote, GIT_DIRECTION_PUSH, cbs, custom_headers)) < 0)\n\t\tgoto cleanup;\n\n\tfree_refspecs(&remote->active_refspecs);\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\tif (remote->push) {\n\t\tgit_push_free(remote->push);\n\t\tremote->push = NULL;\n\t}\n\n\tif ((error = git_push_new(&remote->push, remote)) < 0)\n\t\treturn error;\n\n\tpush = remote->push;\n\n\tif (opts && (error = git_push_set_options(push, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif (refspecs && refspecs->count > 0) {\n\t\tfor (i = 0; i < refspecs->count; i++) {\n\t\t\tif ((error = git_push_add_refspec(push, refspecs->strings[i])) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\t\tif (!spec->push)\n\t\t\t\tcontinue;\n\t\t\tif ((error = git_push_add_refspec(push, spec->string)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif ((error = git_push_finish(push, cbs)) < 0)\n\t\tgoto cleanup;\n\n\tif (cbs && cbs->push_update_reference &&\n\t    (error = git_push_status_foreach(push, cbs->push_update_reference, cbs->payload)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nint git_remote_upload(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)\n{\n\tsize_t i;\n\tint error;\n\tgit_push *push;\n\tgit_refspec *spec;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tassert(remote);\n\n\tif (opts) {\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tif (!git_remote_connected(remote) &&\n\t    (error = git_remote_connect(remote, GIT_DIRECTION_PUSH, cbs, custom_headers)) < 0)\n\t\tgoto cleanup;\n\n\tfree_refspecs(&remote->active_refspecs);\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\tif (remote->push) {\n\t\tgit_push_free(remote->push);\n\t\tremote->push = NULL;\n\t}\n\n\tif ((error = git_push_new(&remote->push, remote)) < 0)\n\t\treturn error;\n\n\tpush = remote->push;\n\n\tif (opts && (error = git_push_set_options(push, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif (refspecs && refspecs->count > 0) {\n\t\tfor (i = 0; i < refspecs->count; i++) {\n\t\t\tif ((error = git_push_add_refspec(push, refspecs->strings[i])) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\t\tif (!spec->push)\n\t\t\t\tcontinue;\n\t\t\tif ((error = git_push_add_refspec(push, spec->string)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif ((error = git_push_finish(push, cbs)) < 0)\n\t\tgoto cleanup;\n\n\tif (cbs && cbs->push_update_reference &&\n\t    (error = git_push_status_foreach(push, cbs->push_update_reference, cbs->payload)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_connect",
          "args": [
            "remote",
            "GIT_DIRECTION_PUSH",
            "cbs",
            "custom_headers"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "698-755",
          "snippet": "int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
            "char *apply_insteadof(git_config *config, const char *url, int direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nint git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote && refspecs"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "&opts->callbacks",
            "GIT_REMOTE_CALLBACKS_VERSION",
            "\"git_remote_callbacks\""
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_push(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)\n{\n\tint error;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tassert(remote && refspecs);\n\n\tif ((error = git_remote_connect(remote, GIT_DIRECTION_PUSH, cbs, custom_headers)) < 0)\n\t\treturn error;\n\n\tif ((error = git_remote_upload(remote, refspecs, opts)) < 0)\n\t\treturn error;\n\n\terror = git_remote_update_tips(remote, cbs, 0, 0, NULL);\n\n\tgit_remote_disconnect(remote);\n\treturn error;\n}"
  },
  {
    "function_name": "git_remote_upload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2398-2458",
    "snippet": "int git_remote_upload(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)\n{\n\tsize_t i;\n\tint error;\n\tgit_push *push;\n\tgit_refspec *spec;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tassert(remote);\n\n\tif (opts) {\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tif (!git_remote_connected(remote) &&\n\t    (error = git_remote_connect(remote, GIT_DIRECTION_PUSH, cbs, custom_headers)) < 0)\n\t\tgoto cleanup;\n\n\tfree_refspecs(&remote->active_refspecs);\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\tif (remote->push) {\n\t\tgit_push_free(remote->push);\n\t\tremote->push = NULL;\n\t}\n\n\tif ((error = git_push_new(&remote->push, remote)) < 0)\n\t\treturn error;\n\n\tpush = remote->push;\n\n\tif (opts && (error = git_push_set_options(push, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif (refspecs && refspecs->count > 0) {\n\t\tfor (i = 0; i < refspecs->count; i++) {\n\t\t\tif ((error = git_push_add_refspec(push, refspecs->strings[i])) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\t\tif (!spec->push)\n\t\t\t\tcontinue;\n\t\t\tif ((error = git_push_add_refspec(push, spec->string)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif ((error = git_push_finish(push, cbs)) < 0)\n\t\tgoto cleanup;\n\n\tif (cbs && cbs->push_update_reference &&\n\t    (error = git_push_status_foreach(push, cbs->push_update_reference, cbs->payload)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_push_status_foreach",
          "args": [
            "push",
            "cbs->push_update_reference",
            "cbs->payload"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_status_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "657-671",
          "snippet": "int git_push_status_foreach(git_push *push,\n\t\tint (*cb)(const char *ref, const char *msg, void *data),\n\t\tvoid *data)\n{\n\tpush_status *status;\n\tunsigned int i;\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tint error = cb(status->ref, status->msg, data);\n\t\tif (error)\n\t\t\treturn giterr_set_after_callback(error);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_status_foreach(git_push *push,\n\t\tint (*cb)(const char *ref, const char *msg, void *data),\n\t\tvoid *data)\n{\n\tpush_status *status;\n\tunsigned int i;\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tint error = cb(status->ref, status->msg, data);\n\t\tif (error)\n\t\t\treturn giterr_set_after_callback(error);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_push_finish",
          "args": [
            "push",
            "cbs"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "637-655",
          "snippet": "int git_push_finish(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tint error;\n\n\tif (!git_remote_connected(push->remote) &&\n\t    (error = git_remote_connect(push->remote, GIT_DIRECTION_PUSH, callbacks, push->custom_headers)) < 0)\n\t\treturn error;\n\n\tif ((error = filter_refs(push->remote)) < 0 ||\n\t    (error = do_push(push, callbacks)) < 0)\n\t\treturn error;\n\n\tif (!push->unpack_ok) {\n\t\terror = -1;\n\t\tgiterr_set(GITERR_NET, \"unpacking the sent packfile failed on the remote\");\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_finish(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tint error;\n\n\tif (!git_remote_connected(push->remote) &&\n\t    (error = git_remote_connect(push->remote, GIT_DIRECTION_PUSH, callbacks, push->custom_headers)) < 0)\n\t\treturn error;\n\n\tif ((error = filter_refs(push->remote)) < 0 ||\n\t    (error = do_push(push, callbacks)) < 0)\n\t\treturn error;\n\n\tif (!push->unpack_ok) {\n\t\terror = -1;\n\t\tgiterr_set(GITERR_NET, \"unpacking the sent packfile failed on the remote\");\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_push_add_refspec",
          "args": [
            "push",
            "spec->string"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_add_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "148-157",
          "snippet": "int git_push_add_refspec(git_push *push, const char *refspec)\n{\n\tpush_spec *spec;\n\n\tif (parse_refspec(push, &spec, refspec) < 0 ||\n\t    git_vector_insert(&push->specs, spec) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_add_refspec(git_push *push, const char *refspec)\n{\n\tpush_spec *spec;\n\n\tif (parse_refspec(push, &spec, refspec) < 0 ||\n\t    git_vector_insert(&push->specs, spec) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&remote->refspecs",
            "i",
            "spec"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_push_set_options",
          "args": [
            "push",
            "opts"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "68-79",
          "snippet": "int git_push_set_options(git_push *push, const git_push_options *opts)\n{\n\tif (!push || !opts)\n\t\treturn -1;\n\n\tGITERR_CHECK_VERSION(opts, GIT_PUSH_OPTIONS_VERSION, \"git_push_options\");\n\n\tpush->pb_parallelism = opts->pb_parallelism;\n\tpush->custom_headers = &opts->custom_headers;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_set_options(git_push *push, const git_push_options *opts)\n{\n\tif (!push || !opts)\n\t\treturn -1;\n\n\tGITERR_CHECK_VERSION(opts, GIT_PUSH_OPTIONS_VERSION, \"git_push_options\");\n\n\tpush->pb_parallelism = opts->pb_parallelism;\n\tpush->custom_headers = &opts->custom_headers;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_push_new",
          "args": [
            "&remote->push",
            "remote"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "32-66",
          "snippet": "int git_push_new(git_push **out, git_remote *remote)\n{\n\tgit_push *p;\n\n\t*out = NULL;\n\n\tp = git__calloc(1, sizeof(*p));\n\tGITERR_CHECK_ALLOC(p);\n\n\tp->repo = remote->repo;\n\tp->remote = remote;\n\tp->report_status = 1;\n\tp->pb_parallelism = 1;\n\n\tif (git_vector_init(&p->specs, 0, push_spec_rref_cmp) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&p->status, 0, push_status_ref_cmp) < 0) {\n\t\tgit_vector_free(&p->specs);\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&p->updates, 0, NULL) < 0) {\n\t\tgit_vector_free(&p->status);\n\t\tgit_vector_free(&p->specs);\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*out = p;\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_new(git_push **out, git_remote *remote)\n{\n\tgit_push *p;\n\n\t*out = NULL;\n\n\tp = git__calloc(1, sizeof(*p));\n\tGITERR_CHECK_ALLOC(p);\n\n\tp->repo = remote->repo;\n\tp->remote = remote;\n\tp->report_status = 1;\n\tp->pb_parallelism = 1;\n\n\tif (git_vector_init(&p->specs, 0, push_spec_rref_cmp) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&p->status, 0, push_status_ref_cmp) < 0) {\n\t\tgit_vector_free(&p->specs);\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&p->updates, 0, NULL) < 0) {\n\t\tgit_vector_free(&p->status);\n\t\tgit_vector_free(&p->specs);\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*out = p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_push_free",
          "args": [
            "remote->push"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "683-711",
          "snippet": "void git_push_free(git_push *push)\n{\n\tpush_spec *spec;\n\tpush_status *status;\n\tgit_push_update *update;\n\tunsigned int i;\n\n\tif (push == NULL)\n\t\treturn;\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tfree_refspec(spec);\n\t}\n\tgit_vector_free(&push->specs);\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tgit_push_status_free(status);\n\t}\n\tgit_vector_free(&push->status);\n\n\tgit_vector_foreach(&push->updates, i, update) {\n\t\tgit__free(update->src_refname);\n\t\tgit__free(update->dst_refname);\n\t\tgit__free(update);\n\t}\n\tgit_vector_free(&push->updates);\n\n\tgit__free(push);\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nvoid git_push_free(git_push *push)\n{\n\tpush_spec *spec;\n\tpush_status *status;\n\tgit_push_update *update;\n\tunsigned int i;\n\n\tif (push == NULL)\n\t\treturn;\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tfree_refspec(spec);\n\t}\n\tgit_vector_free(&push->specs);\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tgit_push_status_free(status);\n\t}\n\tgit_vector_free(&push->status);\n\n\tgit_vector_foreach(&push->updates, i, update) {\n\t\tgit__free(update->src_refname);\n\t\tgit__free(update->dst_refname);\n\t\tgit__free(update);\n\t}\n\tgit_vector_free(&push->updates);\n\n\tgit__free(push);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dwim_refspecs",
          "args": [
            "&remote->active_refspecs",
            "&remote->refspecs",
            "&remote->refs"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "dwim_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "839-850",
          "snippet": "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_refspecs",
          "args": [
            "&remote->active_refspecs"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "free_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "852-863",
          "snippet": "static void free_refspecs(git_vector *vec)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(vec, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_clear(vec);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic void free_refspecs(git_vector *vec)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(vec, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_clear(vec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_connect",
          "args": [
            "remote",
            "GIT_DIRECTION_PUSH",
            "cbs",
            "custom_headers"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "698-755",
          "snippet": "int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
            "char *apply_insteadof(git_config *config, const char *url, int direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nint git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_connected",
          "args": [
            "remote"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_connected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1615-1624",
          "snippet": "int git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nint git_remote_upload(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)\n{\n\tsize_t i;\n\tint error;\n\tgit_push *push;\n\tgit_refspec *spec;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tassert(remote);\n\n\tif (opts) {\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tif (!git_remote_connected(remote) &&\n\t    (error = git_remote_connect(remote, GIT_DIRECTION_PUSH, cbs, custom_headers)) < 0)\n\t\tgoto cleanup;\n\n\tfree_refspecs(&remote->active_refspecs);\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\tif (remote->push) {\n\t\tgit_push_free(remote->push);\n\t\tremote->push = NULL;\n\t}\n\n\tif ((error = git_push_new(&remote->push, remote)) < 0)\n\t\treturn error;\n\n\tpush = remote->push;\n\n\tif (opts && (error = git_push_set_options(push, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif (refspecs && refspecs->count > 0) {\n\t\tfor (i = 0; i < refspecs->count; i++) {\n\t\t\tif ((error = git_push_add_refspec(push, refspecs->strings[i])) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\t\tif (!spec->push)\n\t\t\t\tcontinue;\n\t\t\tif ((error = git_push_add_refspec(push, spec->string)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif ((error = git_push_finish(push, cbs)) < 0)\n\t\tgoto cleanup;\n\n\tif (cbs && cbs->push_update_reference &&\n\t    (error = git_push_status_foreach(push, cbs->push_update_reference, cbs->payload)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\treturn error;\n}"
  },
  {
    "function_name": "git_remote_default_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2343-2396",
    "snippet": "int git_remote_default_branch(git_buf *out, git_remote *remote)\n{\n\tconst git_remote_head **heads;\n\tconst git_remote_head *guess = NULL;\n\tconst git_oid *head_id;\n\tsize_t heads_len, i;\n\tint error;\n\n\tassert(out);\n\n\tif ((error = git_remote_ls(&heads, &heads_len, remote)) < 0)\n\t\treturn error;\n\n\tif (heads_len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (strcmp(heads[0]->name, GIT_HEAD_FILE))\n\t\treturn GIT_ENOTFOUND;\n\n\tgit_buf_sanitize(out);\n\t/* the first one must be HEAD so if that has the symref info, we're done */\n\tif (heads[0]->symref_target)\n\t\treturn git_buf_puts(out, heads[0]->symref_target);\n\n\t/*\n\t * If there's no symref information, we have to look over them\n\t * and guess. We return the first match unless the master\n\t * branch is a candidate. Then we return the master branch.\n\t */\n\thead_id = &heads[0]->oid;\n\n\tfor (i = 1; i < heads_len; i++) {\n\t\tif (git_oid_cmp(head_id, &heads[i]->oid))\n\t\t\tcontinue;\n\n\t\tif (git__prefixcmp(heads[i]->name, GIT_REFS_HEADS_DIR))\n\t\t\tcontinue;\n\n\t\tif (!guess) {\n\t\t\tguess = heads[i];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__strcmp(GIT_REFS_HEADS_MASTER_FILE, heads[i]->name)) {\n\t\t\tguess = heads[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!guess)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_buf_puts(out, guess->name);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "out",
            "guess->name"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strcmp",
          "args": [
            "GIT_REFS_HEADS_MASTER_FILE",
            "heads[i]->name"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "heads[i]->name",
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "head_id",
            "&heads[i]->oid"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "out"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_ls",
          "args": [
            "&heads",
            "&heads_len",
            "remote"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "757-767",
          "snippet": "int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_default_branch(git_buf *out, git_remote *remote)\n{\n\tconst git_remote_head **heads;\n\tconst git_remote_head *guess = NULL;\n\tconst git_oid *head_id;\n\tsize_t heads_len, i;\n\tint error;\n\n\tassert(out);\n\n\tif ((error = git_remote_ls(&heads, &heads_len, remote)) < 0)\n\t\treturn error;\n\n\tif (heads_len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (strcmp(heads[0]->name, GIT_HEAD_FILE))\n\t\treturn GIT_ENOTFOUND;\n\n\tgit_buf_sanitize(out);\n\t/* the first one must be HEAD so if that has the symref info, we're done */\n\tif (heads[0]->symref_target)\n\t\treturn git_buf_puts(out, heads[0]->symref_target);\n\n\t/*\n\t * If there's no symref information, we have to look over them\n\t * and guess. We return the first match unless the master\n\t * branch is a candidate. Then we return the master branch.\n\t */\n\thead_id = &heads[0]->oid;\n\n\tfor (i = 1; i < heads_len; i++) {\n\t\tif (git_oid_cmp(head_id, &heads[i]->oid))\n\t\t\tcontinue;\n\n\t\tif (git__prefixcmp(heads[i]->name, GIT_REFS_HEADS_DIR))\n\t\t\tcontinue;\n\n\t\tif (!guess) {\n\t\t\tguess = heads[i];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__strcmp(GIT_REFS_HEADS_MASTER_FILE, heads[i]->name)) {\n\t\t\tguess = heads[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!guess)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_buf_puts(out, guess->name);\n}"
  },
  {
    "function_name": "git_remote_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2329-2341",
    "snippet": "int git_remote_delete(git_repository *repo, const char *name)\n{\n\tint error;\n\n\tassert(repo && name);\n\n\tif ((error = remove_branch_config_related_entries(repo, name)) < 0 ||\n\t    (error = remove_remote_tracking(repo, name)) < 0 ||\n\t    (error = rename_remote_config_section(repo, name, NULL)) < 0)\n\t\treturn error;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rename_remote_config_section",
          "args": [
            "repo",
            "name",
            "NULL"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "rename_remote_config_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1772-1798",
          "snippet": "static int rename_remote_config_section(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tgit_buf old_section_name = GIT_BUF_INIT,\n\t\tnew_section_name = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_buf_printf(&old_section_name, \"remote.%s\", old_name) < 0)\n\t\tgoto cleanup;\n\n\tif (new_name &&\n\t\t(git_buf_printf(&new_section_name, \"remote.%s\", new_name) < 0))\n\t\t\tgoto cleanup;\n\n\terror = git_config_rename_section(\n\t\trepo,\n\t\tgit_buf_cstr(&old_section_name),\n\t\tnew_name ? git_buf_cstr(&new_section_name) : NULL);\n\ncleanup:\n\tgit_buf_free(&old_section_name);\n\tgit_buf_free(&new_section_name);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int rename_remote_config_section(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tgit_buf old_section_name = GIT_BUF_INIT,\n\t\tnew_section_name = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_buf_printf(&old_section_name, \"remote.%s\", old_name) < 0)\n\t\tgoto cleanup;\n\n\tif (new_name &&\n\t\t(git_buf_printf(&new_section_name, \"remote.%s\", new_name) < 0))\n\t\t\tgoto cleanup;\n\n\terror = git_config_rename_section(\n\t\trepo,\n\t\tgit_buf_cstr(&old_section_name),\n\t\tnew_name ? git_buf_cstr(&new_section_name) : NULL);\n\ncleanup:\n\tgit_buf_free(&old_section_name);\n\tgit_buf_free(&new_section_name);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_remote_tracking",
          "args": [
            "repo",
            "name"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "remove_remote_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2303-2327",
          "snippet": "static int remove_remote_tracking(git_repository *repo, const char *remote_name)\n{\n\tgit_remote *remote;\n\tint error;\n\tsize_t i, count;\n\n\t/* we want to use what's on the config, regardless of changes to the instance in memory */\n\tif ((error = git_remote_lookup(&remote, repo, remote_name)) < 0)\n\t\treturn error;\n\n\tcount = git_remote_refspec_count(remote);\n\tfor (i = 0; i < count; i++) {\n\t\tconst git_refspec *refspec = git_remote_get_refspec(remote, i);\n\n\t\t/* shouldn't ever actually happen */\n\t\tif (refspec == NULL)\n\t\t\tcontinue;\n\n\t\tif ((error = remove_refs(repo, refspec)) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_remote_free(remote);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int remove_remote_tracking(git_repository *repo, const char *remote_name)\n{\n\tgit_remote *remote;\n\tint error;\n\tsize_t i, count;\n\n\t/* we want to use what's on the config, regardless of changes to the instance in memory */\n\tif ((error = git_remote_lookup(&remote, repo, remote_name)) < 0)\n\t\treturn error;\n\n\tcount = git_remote_refspec_count(remote);\n\tfor (i = 0; i < count; i++) {\n\t\tconst git_refspec *refspec = git_remote_get_refspec(remote, i);\n\n\t\t/* shouldn't ever actually happen */\n\t\tif (refspec == NULL)\n\t\t\tcontinue;\n\n\t\tif ((error = remove_refs(repo, refspec)) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_remote_free(remote);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_branch_config_related_entries",
          "args": [
            "repo",
            "name"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "remove_branch_config_related_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2201-2254",
          "snippet": "static int remove_branch_config_related_entries(\n\tgit_repository *repo,\n\tconst char *remote_name)\n{\n\tint error;\n\tgit_config *config;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, config, \"branch\\\\..+\\\\.remote\")) < 0)\n\t\treturn error;\n\n\t/* find any branches with us as upstream and remove that config */\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *branch;\n\t\tsize_t branch_len;\n\n\t\tif (strcmp(remote_name, entry->value))\n\t\t\tcontinue;\n\n\t\tbranch = name_offset(&branch_len, entry->name);\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf, \"branch.%.*s.merge\", (int)branch_len, branch) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_delete_entry(config, git_buf_cstr(&buf))) < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tbreak;\n\t\t\tgiterr_clear();\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf, \"branch.%.*s.remote\", (int)branch_len, branch) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_delete_entry(config, git_buf_cstr(&buf))) < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tbreak;\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_buf_free(&buf);\n\tgit_config_iterator_free(iter);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int remove_branch_config_related_entries(\n\tgit_repository *repo,\n\tconst char *remote_name)\n{\n\tint error;\n\tgit_config *config;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, config, \"branch\\\\..+\\\\.remote\")) < 0)\n\t\treturn error;\n\n\t/* find any branches with us as upstream and remove that config */\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *branch;\n\t\tsize_t branch_len;\n\n\t\tif (strcmp(remote_name, entry->value))\n\t\t\tcontinue;\n\n\t\tbranch = name_offset(&branch_len, entry->name);\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf, \"branch.%.*s.merge\", (int)branch_len, branch) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_delete_entry(config, git_buf_cstr(&buf))) < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tbreak;\n\t\t\tgiterr_clear();\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf, \"branch.%.*s.remote\", (int)branch_len, branch) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_delete_entry(config, git_buf_cstr(&buf))) < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tbreak;\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_buf_free(&buf);\n\tgit_config_iterator_free(iter);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && name"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_delete(git_repository *repo, const char *name)\n{\n\tint error;\n\n\tassert(repo && name);\n\n\tif ((error = remove_branch_config_related_entries(repo, name)) < 0 ||\n\t    (error = remove_remote_tracking(repo, name)) < 0 ||\n\t    (error = rename_remote_config_section(repo, name, NULL)) < 0)\n\t\treturn error;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "remove_remote_tracking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2303-2327",
    "snippet": "static int remove_remote_tracking(git_repository *repo, const char *remote_name)\n{\n\tgit_remote *remote;\n\tint error;\n\tsize_t i, count;\n\n\t/* we want to use what's on the config, regardless of changes to the instance in memory */\n\tif ((error = git_remote_lookup(&remote, repo, remote_name)) < 0)\n\t\treturn error;\n\n\tcount = git_remote_refspec_count(remote);\n\tfor (i = 0; i < count; i++) {\n\t\tconst git_refspec *refspec = git_remote_get_refspec(remote, i);\n\n\t\t/* shouldn't ever actually happen */\n\t\tif (refspec == NULL)\n\t\t\tcontinue;\n\n\t\tif ((error = remove_refs(repo, refspec)) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_remote_free(remote);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_refs",
          "args": [
            "repo",
            "refspec"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "remove_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2256-2301",
          "snippet": "static int remove_refs(git_repository *repo, const git_refspec *spec)\n{\n\tgit_reference_iterator *iter = NULL;\n\tgit_vector refs;\n\tconst char *name;\n\tchar *dup;\n\tint error;\n\tsize_t i;\n\n\tif ((error = git_vector_init(&refs, 8, NULL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\tgoto cleanup;\n\n\twhile ((error = git_reference_next_name(&name, iter)) == 0) {\n\t\tif (!git_refspec_dst_matches(spec, name))\n\t\t\tcontinue;\n\n\t\tdup = git__strdup(name);\n\t\tif (!dup) {\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&refs, dup)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_foreach(&refs, i, name) {\n\t\tif ((error = git_reference_remove(repo, name)) < 0)\n\t\t\tbreak;\n\t}\n\ncleanup:\n\tgit_reference_iterator_free(iter);\n\tgit_vector_foreach(&refs, i, dup) {\n\t\tgit__free(dup);\n\t}\n\tgit_vector_free(&refs);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int remove_refs(git_repository *repo, const git_refspec *spec)\n{\n\tgit_reference_iterator *iter = NULL;\n\tgit_vector refs;\n\tconst char *name;\n\tchar *dup;\n\tint error;\n\tsize_t i;\n\n\tif ((error = git_vector_init(&refs, 8, NULL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\tgoto cleanup;\n\n\twhile ((error = git_reference_next_name(&name, iter)) == 0) {\n\t\tif (!git_refspec_dst_matches(spec, name))\n\t\t\tcontinue;\n\n\t\tdup = git__strdup(name);\n\t\tif (!dup) {\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&refs, dup)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_foreach(&refs, i, name) {\n\t\tif ((error = git_reference_remove(repo, name)) < 0)\n\t\t\tbreak;\n\t}\n\ncleanup:\n\tgit_reference_iterator_free(iter);\n\tgit_vector_foreach(&refs, i, dup) {\n\t\tgit__free(dup);\n\t}\n\tgit_vector_free(&refs);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_get_refspec",
          "args": [
            "remote",
            "i"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_get_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2174-2177",
          "snippet": "const git_refspec *git_remote_get_refspec(const git_remote *remote, size_t n)\n{\n\treturn git_vector_get(&remote->refspecs, n);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nconst git_refspec *git_remote_get_refspec(const git_remote *remote, size_t n)\n{\n\treturn git_vector_get(&remote->refspecs, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_refspec_count",
          "args": [
            "remote"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_refspec_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2169-2172",
          "snippet": "size_t git_remote_refspec_count(const git_remote *remote)\n{\n\treturn remote->refspecs.length;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nsize_t git_remote_refspec_count(const git_remote *remote)\n{\n\treturn remote->refspecs.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_lookup",
          "args": [
            "&remote",
            "repo",
            "remote_name"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "420-524",
          "snippet": "int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int remove_remote_tracking(git_repository *repo, const char *remote_name)\n{\n\tgit_remote *remote;\n\tint error;\n\tsize_t i, count;\n\n\t/* we want to use what's on the config, regardless of changes to the instance in memory */\n\tif ((error = git_remote_lookup(&remote, repo, remote_name)) < 0)\n\t\treturn error;\n\n\tcount = git_remote_refspec_count(remote);\n\tfor (i = 0; i < count; i++) {\n\t\tconst git_refspec *refspec = git_remote_get_refspec(remote, i);\n\n\t\t/* shouldn't ever actually happen */\n\t\tif (refspec == NULL)\n\t\t\tcontinue;\n\n\t\tif ((error = remove_refs(repo, refspec)) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_remote_free(remote);\n\treturn error;\n}"
  },
  {
    "function_name": "remove_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2256-2301",
    "snippet": "static int remove_refs(git_repository *repo, const git_refspec *spec)\n{\n\tgit_reference_iterator *iter = NULL;\n\tgit_vector refs;\n\tconst char *name;\n\tchar *dup;\n\tint error;\n\tsize_t i;\n\n\tif ((error = git_vector_init(&refs, 8, NULL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\tgoto cleanup;\n\n\twhile ((error = git_reference_next_name(&name, iter)) == 0) {\n\t\tif (!git_refspec_dst_matches(spec, name))\n\t\t\tcontinue;\n\n\t\tdup = git__strdup(name);\n\t\tif (!dup) {\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&refs, dup)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_foreach(&refs, i, name) {\n\t\tif ((error = git_reference_remove(repo, name)) < 0)\n\t\t\tbreak;\n\t}\n\ncleanup:\n\tgit_reference_iterator_free(iter);\n\tgit_vector_foreach(&refs, i, dup) {\n\t\tgit__free(dup);\n\t}\n\tgit_vector_free(&refs);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&refs"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "dup"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&refs",
            "i",
            "dup"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_iterator_free",
          "args": [
            "iter"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "742-748",
          "snippet": "void git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_remove",
          "args": [
            "repo",
            "name"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "135-144",
          "snippet": "int git_reference_remove(git_repository *repo, const char *name)\n{\n\tgit_refdb *db;\n\tint error;\n\n\tif ((error = git_repository_refdb__weakptr(&db, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_delete(db, name, NULL, NULL);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_remove(git_repository *repo, const char *name)\n{\n\tgit_refdb *db;\n\tint error;\n\n\tif ((error = git_repository_refdb__weakptr(&db, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_delete(db, name, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&refs",
            "i",
            "name"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&refs",
            "dup"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "name"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_dst_matches",
          "args": [
            "spec",
            "name"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_dst_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "193-199",
          "snippet": "int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_next_name",
          "args": [
            "&name",
            "iter"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_next_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "737-740",
          "snippet": "int git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_iterator_new",
          "args": [
            "&iter",
            "repo"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "711-719",
          "snippet": "int git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&refs",
            "8",
            "NULL"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int remove_refs(git_repository *repo, const git_refspec *spec)\n{\n\tgit_reference_iterator *iter = NULL;\n\tgit_vector refs;\n\tconst char *name;\n\tchar *dup;\n\tint error;\n\tsize_t i;\n\n\tif ((error = git_vector_init(&refs, 8, NULL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_iterator_new(&iter, repo)) < 0)\n\t\tgoto cleanup;\n\n\twhile ((error = git_reference_next_name(&name, iter)) == 0) {\n\t\tif (!git_refspec_dst_matches(spec, name))\n\t\t\tcontinue;\n\n\t\tdup = git__strdup(name);\n\t\tif (!dup) {\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&refs, dup)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_foreach(&refs, i, name) {\n\t\tif ((error = git_reference_remove(repo, name)) < 0)\n\t\t\tbreak;\n\t}\n\ncleanup:\n\tgit_reference_iterator_free(iter);\n\tgit_vector_foreach(&refs, i, dup) {\n\t\tgit__free(dup);\n\t}\n\tgit_vector_free(&refs);\n\treturn error;\n}"
  },
  {
    "function_name": "remove_branch_config_related_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2201-2254",
    "snippet": "static int remove_branch_config_related_entries(\n\tgit_repository *repo,\n\tconst char *remote_name)\n{\n\tint error;\n\tgit_config *config;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, config, \"branch\\\\..+\\\\.remote\")) < 0)\n\t\treturn error;\n\n\t/* find any branches with us as upstream and remove that config */\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *branch;\n\t\tsize_t branch_len;\n\n\t\tif (strcmp(remote_name, entry->value))\n\t\t\tcontinue;\n\n\t\tbranch = name_offset(&branch_len, entry->name);\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf, \"branch.%.*s.merge\", (int)branch_len, branch) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_delete_entry(config, git_buf_cstr(&buf))) < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tbreak;\n\t\t\tgiterr_clear();\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf, \"branch.%.*s.remote\", (int)branch_len, branch) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_delete_entry(config, git_buf_cstr(&buf))) < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tbreak;\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_buf_free(&buf);\n\tgit_config_iterator_free(iter);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_iterator_free",
          "args": [
            "iter"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1063-1069",
          "snippet": "void git_config_iterator_free(git_config_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_iterator_free(git_config_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_delete_entry",
          "args": [
            "config",
            "git_buf_cstr(&buf)"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "586-597",
          "snippet": "int git_config_delete_entry(git_config *cfg, const char *name)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del(file, name);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_delete_entry(git_config *cfg, const char *name)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del(file, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"branch.%.*s.remote\"",
            "(int)branch_len",
            "branch"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&buf"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_offset",
          "args": [
            "&branch_len",
            "entry->name"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "name_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2187-2199",
          "snippet": "static const char *name_offset(size_t *len_out, const char *name)\n{\n\tsize_t prefix_len;\n\tconst char *dot;\n\n\tprefix_len = strlen(\"remote.\");\n\tdot = strchr(name + prefix_len, '.');\n\n\tassert(dot);\n\n\t*len_out = dot - name - prefix_len;\n\treturn name + prefix_len;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic const char *name_offset(size_t *len_out, const char *name)\n{\n\tsize_t prefix_len;\n\tconst char *dot;\n\n\tprefix_len = strlen(\"remote.\");\n\tdot = strchr(name + prefix_len, '.');\n\n\tassert(dot);\n\n\t*len_out = dot - name - prefix_len;\n\treturn name + prefix_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "remote_name",
            "entry->value"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_next",
          "args": [
            "&entry",
            "iter"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1058-1061",
          "snippet": "int git_config_next(git_config_entry **entry, git_config_iterator *iter)\n{\n\treturn iter->next(entry, iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_next(git_config_entry **entry, git_config_iterator *iter)\n{\n\treturn iter->next(entry, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_iterator_glob_new",
          "args": [
            "&iter",
            "config",
            "\"branch\\\\..+\\\\.remote\""
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_iterator_glob_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "470-495",
          "snippet": "int git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)\n{\n\tall_iter *iter;\n\tint result;\n\n\tif (regexp == NULL)\n\t\treturn git_config_iterator_new(out, cfg);\n\n\titer = git__calloc(1, sizeof(all_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\tif ((result = regcomp(&iter->regex, regexp, REG_EXTENDED)) != 0) {\n\t\tgiterr_set_regex(&iter->regex, result);\n\t\tgit__free(iter);\n\t\treturn -1;\n\t}\n\n\titer->parent.next = all_iter_glob_next;\n\titer->parent.free = all_iter_glob_free;\n\titer->i = cfg->files.length;\n\titer->cfg = cfg;\n\n\t*out = (git_config_iterator *) iter;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)\n{\n\tall_iter *iter;\n\tint result;\n\n\tif (regexp == NULL)\n\t\treturn git_config_iterator_new(out, cfg);\n\n\titer = git__calloc(1, sizeof(all_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\tif ((result = regcomp(&iter->regex, regexp, REG_EXTENDED)) != 0) {\n\t\tgiterr_set_regex(&iter->regex, result);\n\t\tgit__free(iter);\n\t\treturn -1;\n\t}\n\n\titer->parent.next = all_iter_glob_next;\n\titer->parent.free = all_iter_glob_free;\n\titer->i = cfg->files.length;\n\titer->cfg = cfg;\n\n\t*out = (git_config_iterator *) iter;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&config",
            "repo"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int remove_branch_config_related_entries(\n\tgit_repository *repo,\n\tconst char *remote_name)\n{\n\tint error;\n\tgit_config *config;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, config, \"branch\\\\..+\\\\.remote\")) < 0)\n\t\treturn error;\n\n\t/* find any branches with us as upstream and remove that config */\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *branch;\n\t\tsize_t branch_len;\n\n\t\tif (strcmp(remote_name, entry->value))\n\t\t\tcontinue;\n\n\t\tbranch = name_offset(&branch_len, entry->name);\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf, \"branch.%.*s.merge\", (int)branch_len, branch) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_delete_entry(config, git_buf_cstr(&buf))) < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tbreak;\n\t\t\tgiterr_clear();\n\t\t}\n\n\t\tgit_buf_clear(&buf);\n\t\tif (git_buf_printf(&buf, \"branch.%.*s.remote\", (int)branch_len, branch) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_delete_entry(config, git_buf_cstr(&buf))) < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tbreak;\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\tgit_buf_free(&buf);\n\tgit_config_iterator_free(iter);\n\treturn error;\n}"
  },
  {
    "function_name": "name_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2187-2199",
    "snippet": "static const char *name_offset(size_t *len_out, const char *name)\n{\n\tsize_t prefix_len;\n\tconst char *dot;\n\n\tprefix_len = strlen(\"remote.\");\n\tdot = strchr(name + prefix_len, '.');\n\n\tassert(dot);\n\n\t*len_out = dot - name - prefix_len;\n\treturn name + prefix_len;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dot"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name + prefix_len",
            "'.'"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"remote.\""
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic const char *name_offset(size_t *len_out, const char *name)\n{\n\tsize_t prefix_len;\n\tconst char *dot;\n\n\tprefix_len = strlen(\"remote.\");\n\tdot = strchr(name + prefix_len, '.');\n\n\tassert(dot);\n\n\t*len_out = dot - name - prefix_len;\n\treturn name + prefix_len;\n}"
  },
  {
    "function_name": "git_remote_init_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2179-2184",
    "snippet": "int git_remote_init_callbacks(git_remote_callbacks *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_remote_callbacks, GIT_REMOTE_CALLBACKS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_remote_callbacks",
            "GIT_REMOTE_CALLBACKS_INIT"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_init_callbacks(git_remote_callbacks *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_remote_callbacks, GIT_REMOTE_CALLBACKS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_remote_get_refspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2174-2177",
    "snippet": "const git_refspec *git_remote_get_refspec(const git_remote *remote, size_t n)\n{\n\treturn git_vector_get(&remote->refspecs, n);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&remote->refspecs",
            "n"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nconst git_refspec *git_remote_get_refspec(const git_remote *remote, size_t n)\n{\n\treturn git_vector_get(&remote->refspecs, n);\n}"
  },
  {
    "function_name": "git_remote_refspec_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2169-2172",
    "snippet": "size_t git_remote_refspec_count(const git_remote *remote)\n{\n\treturn remote->refspecs.length;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nsize_t git_remote_refspec_count(const git_remote *remote)\n{\n\treturn remote->refspecs.length;\n}"
  },
  {
    "function_name": "git_remote_get_push_refspecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2164-2167",
    "snippet": "int git_remote_get_push_refspecs(git_strarray *array, const git_remote *remote)\n{\n\treturn copy_refspecs(array, remote, true);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_refspecs",
          "args": [
            "array",
            "remote",
            "true"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "copy_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2125-2157",
          "snippet": "static int copy_refspecs(git_strarray *array, const git_remote *remote, unsigned int push)\n{\n\tsize_t i;\n\tgit_vector refspecs;\n\tgit_refspec *spec;\n\tchar *dup;\n\n\tif (git_vector_init(&refspecs, remote->refspecs.length, NULL) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\tif ((dup = git__strdup(spec->string)) == NULL)\n\t\t\tgoto on_error;\n\n\t\tif (git_vector_insert(&refspecs, dup) < 0) {\n\t\t\tgit__free(dup);\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tarray->strings = (char **)refspecs.contents;\n\tarray->count = refspecs.length;\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&refspecs);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int copy_refspecs(git_strarray *array, const git_remote *remote, unsigned int push)\n{\n\tsize_t i;\n\tgit_vector refspecs;\n\tgit_refspec *spec;\n\tchar *dup;\n\n\tif (git_vector_init(&refspecs, remote->refspecs.length, NULL) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\tif ((dup = git__strdup(spec->string)) == NULL)\n\t\t\tgoto on_error;\n\n\t\tif (git_vector_insert(&refspecs, dup) < 0) {\n\t\t\tgit__free(dup);\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tarray->strings = (char **)refspecs.contents;\n\tarray->count = refspecs.length;\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&refspecs);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_get_push_refspecs(git_strarray *array, const git_remote *remote)\n{\n\treturn copy_refspecs(array, remote, true);\n}"
  },
  {
    "function_name": "git_remote_get_fetch_refspecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2159-2162",
    "snippet": "int git_remote_get_fetch_refspecs(git_strarray *array, const git_remote *remote)\n{\n\treturn copy_refspecs(array, remote, false);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_refspecs",
          "args": [
            "array",
            "remote",
            "false"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "copy_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2125-2157",
          "snippet": "static int copy_refspecs(git_strarray *array, const git_remote *remote, unsigned int push)\n{\n\tsize_t i;\n\tgit_vector refspecs;\n\tgit_refspec *spec;\n\tchar *dup;\n\n\tif (git_vector_init(&refspecs, remote->refspecs.length, NULL) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\tif ((dup = git__strdup(spec->string)) == NULL)\n\t\t\tgoto on_error;\n\n\t\tif (git_vector_insert(&refspecs, dup) < 0) {\n\t\t\tgit__free(dup);\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tarray->strings = (char **)refspecs.contents;\n\tarray->count = refspecs.length;\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&refspecs);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int copy_refspecs(git_strarray *array, const git_remote *remote, unsigned int push)\n{\n\tsize_t i;\n\tgit_vector refspecs;\n\tgit_refspec *spec;\n\tchar *dup;\n\n\tif (git_vector_init(&refspecs, remote->refspecs.length, NULL) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\tif ((dup = git__strdup(spec->string)) == NULL)\n\t\t\tgoto on_error;\n\n\t\tif (git_vector_insert(&refspecs, dup) < 0) {\n\t\t\tgit__free(dup);\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tarray->strings = (char **)refspecs.contents;\n\tarray->count = refspecs.length;\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&refspecs);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_get_fetch_refspecs(git_strarray *array, const git_remote *remote)\n{\n\treturn copy_refspecs(array, remote, false);\n}"
  },
  {
    "function_name": "copy_refspecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2125-2157",
    "snippet": "static int copy_refspecs(git_strarray *array, const git_remote *remote, unsigned int push)\n{\n\tsize_t i;\n\tgit_vector refspecs;\n\tgit_refspec *spec;\n\tchar *dup;\n\n\tif (git_vector_init(&refspecs, remote->refspecs.length, NULL) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\tif ((dup = git__strdup(spec->string)) == NULL)\n\t\t\tgoto on_error;\n\n\t\tif (git_vector_insert(&refspecs, dup) < 0) {\n\t\t\tgit__free(dup);\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tarray->strings = (char **)refspecs.contents;\n\tarray->count = refspecs.length;\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&refspecs);\n\n\treturn -1;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&refspecs"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "dup"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&refspecs",
            "dup"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "spec->string"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&remote->refspecs",
            "i",
            "spec"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&refspecs",
            "remote->refspecs.length",
            "NULL"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int copy_refspecs(git_strarray *array, const git_remote *remote, unsigned int push)\n{\n\tsize_t i;\n\tgit_vector refspecs;\n\tgit_refspec *spec;\n\tchar *dup;\n\n\tif (git_vector_init(&refspecs, remote->refspecs.length, NULL) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\tif ((dup = git__strdup(spec->string)) == NULL)\n\t\t\tgoto on_error;\n\n\t\tif (git_vector_insert(&refspecs, dup) < 0) {\n\t\t\tgit__free(dup);\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tarray->strings = (char **)refspecs.contents;\n\tarray->count = refspecs.length;\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&refspecs);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "set_refspecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2097-2123",
    "snippet": "static int set_refspecs(git_remote *remote, git_strarray *array, int push)\n{\n\tgit_vector *vec = &remote->refspecs;\n\tgit_refspec *spec;\n\tsize_t i;\n\n\t/* Start by removing any refspecs of the same type */\n\tfor (i = 0; i < vec->length; i++) {\n\t\tspec = git_vector_get(vec, i);\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t\tgit_vector_remove(vec, i);\n\t\ti--;\n\t}\n\n\t/* And now we add the new ones */\n\n\tfor (i = 0; i < array->count; i++) {\n\t\tif (add_refspec(remote, array->strings[i], !push) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_refspec",
          "args": [
            "remote",
            "array->strings[i]",
            "!push"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "add_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "55-58",
          "snippet": "static int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_remove",
          "args": [
            "vec",
            "i"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "233-250",
          "snippet": "int git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "spec"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "spec"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "vec",
            "i"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int set_refspecs(git_remote *remote, git_strarray *array, int push)\n{\n\tgit_vector *vec = &remote->refspecs;\n\tgit_refspec *spec;\n\tsize_t i;\n\n\t/* Start by removing any refspecs of the same type */\n\tfor (i = 0; i < vec->length; i++) {\n\t\tspec = git_vector_get(vec, i);\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t\tgit_vector_remove(vec, i);\n\t\ti--;\n\t}\n\n\t/* And now we add the new ones */\n\n\tfor (i = 0; i < array->count; i++) {\n\t\tif (add_refspec(remote, array->strings[i], !push) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_remote_add_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2092-2095",
    "snippet": "int git_remote_add_push(git_repository *repo, const char *remote, const char *refspec)\n{\n\treturn write_add_refspec(repo, remote, refspec, false);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_add_refspec",
          "args": [
            "repo",
            "remote",
            "refspec",
            "false"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "write_add_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "97-137",
          "snippet": "static int write_add_refspec(git_repository *repo, const char *name, const char *refspec, bool fetch)\n{\n\tgit_config *cfg;\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_refspec spec;\n\tconst char *fmt;\n\tint error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t    return error;\n\n\tfmt = fetch ? CONFIG_FETCH_FMT : CONFIG_PUSH_FMT;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_refspec__parse(&spec, refspec, fetch)) < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\terror = GIT_EINVALIDSPEC;\n\n\t\treturn error;\n\t}\n\n\tgit_refspec__free(&spec);\n\n\tif ((error = git_buf_printf(&var, fmt, name)) < 0)\n\t\treturn error;\n\n\t/*\n\t * \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t * all values will be considered new and we will not replace any\n\t * present value.\n\t */\n\tif ((error = git_config_set_multivar(cfg, var.ptr, \"$^\", refspec)) < 0) {\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&var);\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [
            "#define CONFIG_PUSH_FMT \"remote.%s.push\"",
            "#define CONFIG_FETCH_FMT \"remote.%s.fetch\""
          ],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_PUSH_FMT \"remote.%s.push\"\n#define CONFIG_FETCH_FMT \"remote.%s.fetch\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int write_add_refspec(git_repository *repo, const char *name, const char *refspec, bool fetch)\n{\n\tgit_config *cfg;\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_refspec spec;\n\tconst char *fmt;\n\tint error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t    return error;\n\n\tfmt = fetch ? CONFIG_FETCH_FMT : CONFIG_PUSH_FMT;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_refspec__parse(&spec, refspec, fetch)) < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\terror = GIT_EINVALIDSPEC;\n\n\t\treturn error;\n\t}\n\n\tgit_refspec__free(&spec);\n\n\tif ((error = git_buf_printf(&var, fmt, name)) < 0)\n\t\treturn error;\n\n\t/*\n\t * \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t * all values will be considered new and we will not replace any\n\t * present value.\n\t */\n\tif ((error = git_config_set_multivar(cfg, var.ptr, \"$^\", refspec)) < 0) {\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&var);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_add_push(git_repository *repo, const char *remote, const char *refspec)\n{\n\treturn write_add_refspec(repo, remote, refspec, false);\n}"
  },
  {
    "function_name": "git_remote_add_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2087-2090",
    "snippet": "int git_remote_add_fetch(git_repository *repo, const char *remote, const char *refspec)\n{\n\treturn write_add_refspec(repo, remote, refspec, true);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_add_refspec",
          "args": [
            "repo",
            "remote",
            "refspec",
            "true"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "write_add_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "97-137",
          "snippet": "static int write_add_refspec(git_repository *repo, const char *name, const char *refspec, bool fetch)\n{\n\tgit_config *cfg;\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_refspec spec;\n\tconst char *fmt;\n\tint error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t    return error;\n\n\tfmt = fetch ? CONFIG_FETCH_FMT : CONFIG_PUSH_FMT;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_refspec__parse(&spec, refspec, fetch)) < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\terror = GIT_EINVALIDSPEC;\n\n\t\treturn error;\n\t}\n\n\tgit_refspec__free(&spec);\n\n\tif ((error = git_buf_printf(&var, fmt, name)) < 0)\n\t\treturn error;\n\n\t/*\n\t * \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t * all values will be considered new and we will not replace any\n\t * present value.\n\t */\n\tif ((error = git_config_set_multivar(cfg, var.ptr, \"$^\", refspec)) < 0) {\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&var);\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [
            "#define CONFIG_PUSH_FMT \"remote.%s.push\"",
            "#define CONFIG_FETCH_FMT \"remote.%s.fetch\""
          ],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_PUSH_FMT \"remote.%s.push\"\n#define CONFIG_FETCH_FMT \"remote.%s.fetch\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int write_add_refspec(git_repository *repo, const char *name, const char *refspec, bool fetch)\n{\n\tgit_config *cfg;\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_refspec spec;\n\tconst char *fmt;\n\tint error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t    return error;\n\n\tfmt = fetch ? CONFIG_FETCH_FMT : CONFIG_PUSH_FMT;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_refspec__parse(&spec, refspec, fetch)) < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\terror = GIT_EINVALIDSPEC;\n\n\t\treturn error;\n\t}\n\n\tgit_refspec__free(&spec);\n\n\tif ((error = git_buf_printf(&var, fmt, name)) < 0)\n\t\treturn error;\n\n\t/*\n\t * \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t * all values will be considered new and we will not replace any\n\t * present value.\n\t */\n\tif ((error = git_config_set_multivar(cfg, var.ptr, \"$^\", refspec)) < 0) {\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&var);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_add_fetch(git_repository *repo, const char *remote, const char *refspec)\n{\n\treturn write_add_refspec(repo, remote, refspec, true);\n}"
  },
  {
    "function_name": "git_remote__matching_dst_refspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2071-2085",
    "snippet": "git_refspec *git_remote__matching_dst_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_dst_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refspec_dst_matches",
          "args": [
            "spec",
            "refname"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_dst_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "193-199",
          "snippet": "int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&remote->active_refspecs",
            "i",
            "spec"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_refspec *git_remote__matching_dst_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_dst_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "git_remote__matching_refspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2055-2069",
    "snippet": "git_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refspec_src_matches",
          "args": [
            "spec",
            "refname"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_src_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "185-191",
          "snippet": "int git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&remote->active_refspecs",
            "i",
            "spec"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_src_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "git_remote_is_valid_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "2035-2053",
    "snippet": "int git_remote_is_valid_name(\n\tconst char *remote_name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec refspec;\n\tint error = -1;\n\n\tif (!remote_name || *remote_name == '\\0')\n\t\treturn 0;\n\n\tgit_buf_printf(&buf, \"refs/heads/test:refs/remotes/%s/test\", remote_name);\n\terror = git_refspec__parse(&refspec, git_buf_cstr(&buf), true);\n\n\tgit_buf_free(&buf);\n\tgit_refspec__free(&refspec);\n\n\tgiterr_clear();\n\treturn error == 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "&refspec"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__parse",
          "args": [
            "&refspec",
            "git_buf_cstr(&buf)",
            "true"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "17-149",
          "snippet": "int git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"refs/heads/test:refs/remotes/%s/test\"",
            "remote_name"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nint git_remote_is_valid_name(\n\tconst char *remote_name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec refspec;\n\tint error = -1;\n\n\tif (!remote_name || *remote_name == '\\0')\n\t\treturn 0;\n\n\tgit_buf_printf(&buf, \"refs/heads/test:refs/remotes/%s/test\", remote_name);\n\terror = git_refspec__parse(&refspec, git_buf_cstr(&buf), true);\n\n\tgit_buf_free(&buf);\n\tgit_refspec__free(&refspec);\n\n\tgiterr_clear();\n\treturn error == 0;\n}"
  },
  {
    "function_name": "git_remote_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1995-2033",
    "snippet": "int git_remote_rename(git_strarray *out, git_repository *repo, const char *name, const char *new_name)\n{\n\tint error;\n\tgit_vector problem_refspecs = GIT_VECTOR_INIT;\n\tgit_remote *remote = NULL;\n\n\tassert(out && repo && name && new_name);\n\n\tif ((error = git_remote_lookup(&remote, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = ensure_remote_name_is_valid(new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = ensure_remote_doesnot_exist(repo, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = rename_remote_config_section(repo, name, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = update_branch_remote_config_entry(repo, name, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = rename_remote_references(repo, name, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = rename_fetch_refspecs(&problem_refspecs, remote, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tout->count = problem_refspecs.length;\n\tout->strings = (char **) problem_refspecs.contents;\n\ncleanup:\n\tif (error < 0)\n\t\tgit_vector_free(&problem_refspecs);\n\n\tgit_remote_free(remote);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&problem_refspecs"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename_fetch_refspecs",
          "args": [
            "&problem_refspecs",
            "remote",
            "new_name"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "rename_fetch_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1927-1993",
          "snippet": "static int rename_fetch_refspecs(git_vector *problems, git_remote *remote, const char *new_name)\n{\n\tgit_config *config;\n\tgit_buf base = GIT_BUF_INIT, var = GIT_BUF_INIT, val = GIT_BUF_INIT;\n\tconst git_refspec *spec;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_repository_config__weakptr(&config, remote->repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_vector_init(problems, 1, NULL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(\n\t\t\t&base, \"+refs/heads/*:refs/remotes/%s/*\", remote->name)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\t/* Does the dst part of the refspec follow the expected format? */\n\t\tif (strcmp(git_buf_cstr(&base), spec->string)) {\n\t\t\tchar *dup;\n\n\t\t\tdup = git__strdup(spec->string);\n\t\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\t\tif ((error = git_vector_insert(problems, dup)) < 0)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If we do want to move it to the new section */\n\n\t\tgit_buf_clear(&val);\n\t\tgit_buf_clear(&var);\n\n\t\tif (git_buf_printf(\n\t\t\t\t&val, \"+refs/heads/*:refs/remotes/%s/*\", new_name) < 0 ||\n\t\t\tgit_buf_printf(&var, \"remote.%s.fetch\", new_name) < 0)\n\t\t{\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = git_config_set_string(\n\t\t\t\tconfig, git_buf_cstr(&var), git_buf_cstr(&val))) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_buf_free(&base);\n\tgit_buf_free(&var);\n\tgit_buf_free(&val);\n\n\tif (error < 0) {\n\t\tchar *str;\n\t\tgit_vector_foreach(problems, i, str)\n\t\t\tgit__free(str);\n\n\t\tgit_vector_free(problems);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int rename_fetch_refspecs(git_vector *problems, git_remote *remote, const char *new_name)\n{\n\tgit_config *config;\n\tgit_buf base = GIT_BUF_INIT, var = GIT_BUF_INIT, val = GIT_BUF_INIT;\n\tconst git_refspec *spec;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_repository_config__weakptr(&config, remote->repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_vector_init(problems, 1, NULL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(\n\t\t\t&base, \"+refs/heads/*:refs/remotes/%s/*\", remote->name)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\t/* Does the dst part of the refspec follow the expected format? */\n\t\tif (strcmp(git_buf_cstr(&base), spec->string)) {\n\t\t\tchar *dup;\n\n\t\t\tdup = git__strdup(spec->string);\n\t\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\t\tif ((error = git_vector_insert(problems, dup)) < 0)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If we do want to move it to the new section */\n\n\t\tgit_buf_clear(&val);\n\t\tgit_buf_clear(&var);\n\n\t\tif (git_buf_printf(\n\t\t\t\t&val, \"+refs/heads/*:refs/remotes/%s/*\", new_name) < 0 ||\n\t\t\tgit_buf_printf(&var, \"remote.%s.fetch\", new_name) < 0)\n\t\t{\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = git_config_set_string(\n\t\t\t\tconfig, git_buf_cstr(&var), git_buf_cstr(&val))) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_buf_free(&base);\n\tgit_buf_free(&var);\n\tgit_buf_free(&val);\n\n\tif (error < 0) {\n\t\tchar *str;\n\t\tgit_vector_foreach(problems, i, str)\n\t\t\tgit__free(str);\n\n\t\tgit_vector_free(problems);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename_remote_references",
          "args": [
            "repo",
            "name",
            "new_name"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "rename_remote_references",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1898-1925",
          "snippet": "static int rename_remote_references(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tint error;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_reference *ref;\n\tgit_reference_iterator *iter;\n\n\tif ((error = git_buf_printf(&buf, GIT_REFS_REMOTES_DIR \"%s/*\", old_name)) < 0)\n\t\treturn error;\n\n\terror = git_reference_iterator_glob_new(&iter, repo, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\treturn error;\n\n\twhile ((error = git_reference_next(&ref, iter)) == 0) {\n\t\tif ((error = rename_one_remote_reference(ref, old_name, new_name)) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_reference_iterator_free(iter);\n\n\treturn (error == GIT_ITEROVER) ? 0 : error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int rename_remote_references(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tint error;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_reference *ref;\n\tgit_reference_iterator *iter;\n\n\tif ((error = git_buf_printf(&buf, GIT_REFS_REMOTES_DIR \"%s/*\", old_name)) < 0)\n\t\treturn error;\n\n\terror = git_reference_iterator_glob_new(&iter, repo, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\treturn error;\n\n\twhile ((error = git_reference_next(&ref, iter)) == 0) {\n\t\tif ((error = rename_one_remote_reference(ref, old_name, new_name)) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_reference_iterator_free(iter);\n\n\treturn (error == GIT_ITEROVER) ? 0 : error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_branch_remote_config_entry",
          "args": [
            "repo",
            "name",
            "new_name"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "update_branch_remote_config_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1819-1835",
          "snippet": "static int update_branch_remote_config_entry(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tint error;\n\tstruct update_data data = { NULL };\n\n\tif ((error = git_repository_config__weakptr(&data.config, repo)) < 0)\n\t\treturn error;\n\n\tdata.old_remote_name = old_name;\n\tdata.new_remote_name = new_name;\n\n\treturn git_config_foreach_match(\n\t\tdata.config, \"branch\\\\..+\\\\.remote\", update_config_entries_cb, &data);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int update_branch_remote_config_entry(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tint error;\n\tstruct update_data data = { NULL };\n\n\tif ((error = git_repository_config__weakptr(&data.config, repo)) < 0)\n\t\treturn error;\n\n\tdata.old_remote_name = old_name;\n\tdata.new_remote_name = new_name;\n\n\treturn git_config_foreach_match(\n\t\tdata.config, \"branch\\\\..+\\\\.remote\", update_config_entries_cb, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename_remote_config_section",
          "args": [
            "repo",
            "name",
            "new_name"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "rename_remote_config_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1772-1798",
          "snippet": "static int rename_remote_config_section(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tgit_buf old_section_name = GIT_BUF_INIT,\n\t\tnew_section_name = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_buf_printf(&old_section_name, \"remote.%s\", old_name) < 0)\n\t\tgoto cleanup;\n\n\tif (new_name &&\n\t\t(git_buf_printf(&new_section_name, \"remote.%s\", new_name) < 0))\n\t\t\tgoto cleanup;\n\n\terror = git_config_rename_section(\n\t\trepo,\n\t\tgit_buf_cstr(&old_section_name),\n\t\tnew_name ? git_buf_cstr(&new_section_name) : NULL);\n\ncleanup:\n\tgit_buf_free(&old_section_name);\n\tgit_buf_free(&new_section_name);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int rename_remote_config_section(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tgit_buf old_section_name = GIT_BUF_INIT,\n\t\tnew_section_name = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_buf_printf(&old_section_name, \"remote.%s\", old_name) < 0)\n\t\tgoto cleanup;\n\n\tif (new_name &&\n\t\t(git_buf_printf(&new_section_name, \"remote.%s\", new_name) < 0))\n\t\t\tgoto cleanup;\n\n\terror = git_config_rename_section(\n\t\trepo,\n\t\tgit_buf_cstr(&old_section_name),\n\t\tnew_name ? git_buf_cstr(&new_section_name) : NULL);\n\ncleanup:\n\tgit_buf_free(&old_section_name);\n\tgit_buf_free(&new_section_name);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_remote_doesnot_exist",
          "args": [
            "repo",
            "new_name"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_remote_doesnot_exist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "269-289",
          "snippet": "static int ensure_remote_doesnot_exist(git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_remote *remote;\n\n\terror = git_remote_lookup(&remote, repo, name);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (error < 0)\n\t\treturn error;\n\n\tgit_remote_free(remote);\n\n\tgiterr_set(\n\t\tGITERR_CONFIG,\n\t\t\"Remote '%s' already exists.\", name);\n\n\treturn GIT_EEXISTS;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_doesnot_exist(git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_remote *remote;\n\n\terror = git_remote_lookup(&remote, repo, name);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (error < 0)\n\t\treturn error;\n\n\tgit_remote_free(remote);\n\n\tgiterr_set(\n\t\tGITERR_CONFIG,\n\t\t\"Remote '%s' already exists.\", name);\n\n\treturn GIT_EEXISTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_remote_name_is_valid",
          "args": [
            "new_name"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_remote_name_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "83-95",
          "snippet": "static int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_lookup",
          "args": [
            "&remote",
            "repo",
            "name"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "420-524",
          "snippet": "int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && name && new_name"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_rename(git_strarray *out, git_repository *repo, const char *name, const char *new_name)\n{\n\tint error;\n\tgit_vector problem_refspecs = GIT_VECTOR_INIT;\n\tgit_remote *remote = NULL;\n\n\tassert(out && repo && name && new_name);\n\n\tif ((error = git_remote_lookup(&remote, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = ensure_remote_name_is_valid(new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = ensure_remote_doesnot_exist(repo, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = rename_remote_config_section(repo, name, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = update_branch_remote_config_entry(repo, name, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = rename_remote_references(repo, name, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = rename_fetch_refspecs(&problem_refspecs, remote, new_name)) < 0)\n\t\tgoto cleanup;\n\n\tout->count = problem_refspecs.length;\n\tout->strings = (char **) problem_refspecs.contents;\n\ncleanup:\n\tif (error < 0)\n\t\tgit_vector_free(&problem_refspecs);\n\n\tgit_remote_free(remote);\n\treturn error;\n}"
  },
  {
    "function_name": "rename_fetch_refspecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1927-1993",
    "snippet": "static int rename_fetch_refspecs(git_vector *problems, git_remote *remote, const char *new_name)\n{\n\tgit_config *config;\n\tgit_buf base = GIT_BUF_INIT, var = GIT_BUF_INIT, val = GIT_BUF_INIT;\n\tconst git_refspec *spec;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_repository_config__weakptr(&config, remote->repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_vector_init(problems, 1, NULL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(\n\t\t\t&base, \"+refs/heads/*:refs/remotes/%s/*\", remote->name)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\t/* Does the dst part of the refspec follow the expected format? */\n\t\tif (strcmp(git_buf_cstr(&base), spec->string)) {\n\t\t\tchar *dup;\n\n\t\t\tdup = git__strdup(spec->string);\n\t\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\t\tif ((error = git_vector_insert(problems, dup)) < 0)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If we do want to move it to the new section */\n\n\t\tgit_buf_clear(&val);\n\t\tgit_buf_clear(&var);\n\n\t\tif (git_buf_printf(\n\t\t\t\t&val, \"+refs/heads/*:refs/remotes/%s/*\", new_name) < 0 ||\n\t\t\tgit_buf_printf(&var, \"remote.%s.fetch\", new_name) < 0)\n\t\t{\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = git_config_set_string(\n\t\t\t\tconfig, git_buf_cstr(&var), git_buf_cstr(&val))) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_buf_free(&base);\n\tgit_buf_free(&var);\n\tgit_buf_free(&val);\n\n\tif (error < 0) {\n\t\tchar *str;\n\t\tgit_vector_foreach(problems, i, str)\n\t\t\tgit__free(str);\n\n\t\tgit_vector_free(problems);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "problems"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "str"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "problems",
            "i",
            "str"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&val"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_set_string",
          "args": [
            "config",
            "git_buf_cstr(&var)",
            "git_buf_cstr(&val)"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "616-638",
          "snippet": "int git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&val"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&var",
            "\"remote.%s.fetch\"",
            "new_name"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&var"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "problems",
            "dup"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "dup"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "spec->string"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "git_buf_cstr(&base)",
            "spec->string"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&remote->refspecs",
            "i",
            "spec"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "problems",
            "1",
            "NULL"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&config",
            "remote->repo"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int rename_fetch_refspecs(git_vector *problems, git_remote *remote, const char *new_name)\n{\n\tgit_config *config;\n\tgit_buf base = GIT_BUF_INIT, var = GIT_BUF_INIT, val = GIT_BUF_INIT;\n\tconst git_refspec *spec;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_repository_config__weakptr(&config, remote->repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_vector_init(problems, 1, NULL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(\n\t\t\t&base, \"+refs/heads/*:refs/remotes/%s/*\", remote->name)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&remote->refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\t/* Does the dst part of the refspec follow the expected format? */\n\t\tif (strcmp(git_buf_cstr(&base), spec->string)) {\n\t\t\tchar *dup;\n\n\t\t\tdup = git__strdup(spec->string);\n\t\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\t\tif ((error = git_vector_insert(problems, dup)) < 0)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If we do want to move it to the new section */\n\n\t\tgit_buf_clear(&val);\n\t\tgit_buf_clear(&var);\n\n\t\tif (git_buf_printf(\n\t\t\t\t&val, \"+refs/heads/*:refs/remotes/%s/*\", new_name) < 0 ||\n\t\t\tgit_buf_printf(&var, \"remote.%s.fetch\", new_name) < 0)\n\t\t{\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = git_config_set_string(\n\t\t\t\tconfig, git_buf_cstr(&var), git_buf_cstr(&val))) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_buf_free(&base);\n\tgit_buf_free(&var);\n\tgit_buf_free(&val);\n\n\tif (error < 0) {\n\t\tchar *str;\n\t\tgit_vector_foreach(problems, i, str)\n\t\t\tgit__free(str);\n\n\t\tgit_vector_free(problems);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "rename_remote_references",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1898-1925",
    "snippet": "static int rename_remote_references(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tint error;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_reference *ref;\n\tgit_reference_iterator *iter;\n\n\tif ((error = git_buf_printf(&buf, GIT_REFS_REMOTES_DIR \"%s/*\", old_name)) < 0)\n\t\treturn error;\n\n\terror = git_reference_iterator_glob_new(&iter, repo, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\treturn error;\n\n\twhile ((error = git_reference_next(&ref, iter)) == 0) {\n\t\tif ((error = rename_one_remote_reference(ref, old_name, new_name)) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_reference_iterator_free(iter);\n\n\treturn (error == GIT_ITEROVER) ? 0 : error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_iterator_free",
          "args": [
            "iter"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "742-748",
          "snippet": "void git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_iterator_free(git_reference_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\tgit_refdb_iterator_free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename_one_remote_reference",
          "args": [
            "ref",
            "old_name",
            "new_name"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "rename_one_remote_reference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1837-1896",
          "snippet": "static int rename_one_remote_reference(\n\tgit_reference *reference_in,\n\tconst char *old_remote_name,\n\tconst char *new_remote_name)\n{\n\tint error;\n\tgit_reference *ref = NULL, *dummy = NULL;\n\tgit_buf namespace = GIT_BUF_INIT, old_namespace = GIT_BUF_INIT;\n\tgit_buf new_name = GIT_BUF_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\tsize_t pfx_len;\n\tconst char *target;\n\n\tif ((error = git_buf_printf(&namespace, GIT_REFS_REMOTES_DIR \"%s/\", new_remote_name)) < 0)\n\t\treturn error;\n\n\tpfx_len = strlen(GIT_REFS_REMOTES_DIR) + strlen(old_remote_name) + 1;\n\tgit_buf_puts(&new_name, namespace.ptr);\n\tif ((error = git_buf_puts(&new_name, git_reference_name(reference_in) + pfx_len)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&log_message,\n\t\t\t\t\t\"renamed remote %s to %s\",\n\t\t\t\t\told_remote_name, new_remote_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_rename(&ref, reference_in, git_buf_cstr(&new_name), 1,\n\t\t\t\t\t  git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reference_type(ref) != GIT_REF_SYMBOLIC)\n\t\tgoto cleanup;\n\n\t/* Handle refs like origin/HEAD -> origin/master */\n\ttarget = git_reference_symbolic_target(ref);\n\tif ((error = git_buf_printf(&old_namespace, GIT_REFS_REMOTES_DIR \"%s/\", old_remote_name)) < 0)\n\t\tgoto cleanup;\n\n\tif (git__prefixcmp(target, old_namespace.ptr))\n\t\tgoto cleanup;\n\n\tgit_buf_clear(&new_name);\n\tgit_buf_puts(&new_name, namespace.ptr);\n\tif ((error = git_buf_puts(&new_name, target + pfx_len)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_symbolic_set_target(&dummy, ref, git_buf_cstr(&new_name),\n\t\t\t\t\t\t  git_buf_cstr(&log_message));\n\n\tgit_reference_free(dummy);\n\ncleanup:\n\tgit_reference_free(reference_in);\n\tgit_reference_free(ref);\n\tgit_buf_free(&namespace);\n\tgit_buf_free(&old_namespace);\n\tgit_buf_free(&new_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nstatic int rename_one_remote_reference(\n\tgit_reference *reference_in,\n\tconst char *old_remote_name,\n\tconst char *new_remote_name)\n{\n\tint error;\n\tgit_reference *ref = NULL, *dummy = NULL;\n\tgit_buf namespace = GIT_BUF_INIT, old_namespace = GIT_BUF_INIT;\n\tgit_buf new_name = GIT_BUF_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\tsize_t pfx_len;\n\tconst char *target;\n\n\tif ((error = git_buf_printf(&namespace, GIT_REFS_REMOTES_DIR \"%s/\", new_remote_name)) < 0)\n\t\treturn error;\n\n\tpfx_len = strlen(GIT_REFS_REMOTES_DIR) + strlen(old_remote_name) + 1;\n\tgit_buf_puts(&new_name, namespace.ptr);\n\tif ((error = git_buf_puts(&new_name, git_reference_name(reference_in) + pfx_len)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&log_message,\n\t\t\t\t\t\"renamed remote %s to %s\",\n\t\t\t\t\told_remote_name, new_remote_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_rename(&ref, reference_in, git_buf_cstr(&new_name), 1,\n\t\t\t\t\t  git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reference_type(ref) != GIT_REF_SYMBOLIC)\n\t\tgoto cleanup;\n\n\t/* Handle refs like origin/HEAD -> origin/master */\n\ttarget = git_reference_symbolic_target(ref);\n\tif ((error = git_buf_printf(&old_namespace, GIT_REFS_REMOTES_DIR \"%s/\", old_remote_name)) < 0)\n\t\tgoto cleanup;\n\n\tif (git__prefixcmp(target, old_namespace.ptr))\n\t\tgoto cleanup;\n\n\tgit_buf_clear(&new_name);\n\tgit_buf_puts(&new_name, namespace.ptr);\n\tif ((error = git_buf_puts(&new_name, target + pfx_len)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_symbolic_set_target(&dummy, ref, git_buf_cstr(&new_name),\n\t\t\t\t\t\t  git_buf_cstr(&log_message));\n\n\tgit_reference_free(dummy);\n\ncleanup:\n\tgit_reference_free(reference_in);\n\tgit_reference_free(ref);\n\tgit_buf_free(&namespace);\n\tgit_buf_free(&old_namespace);\n\tgit_buf_free(&new_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_next",
          "args": [
            "&ref",
            "iter"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_next_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "737-740",
          "snippet": "int git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_next_name(const char **out, git_reference_iterator *iter)\n{\n\treturn git_refdb_iterator_next_name(out, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_iterator_glob_new",
          "args": [
            "&iter",
            "repo",
            "git_buf_cstr(&buf)"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_iterator_glob_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "721-730",
          "snippet": "int git_reference_iterator_glob_new(\n\tgit_reference_iterator **out, git_repository *repo, const char *glob)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, glob);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_iterator_glob_new(\n\tgit_reference_iterator **out, git_repository *repo, const char *glob)\n{\n\tgit_refdb *refdb;\n\n\tif (git_repository_refdb__weakptr(&refdb, repo) < 0)\n\t\treturn -1;\n\n\treturn git_refdb_iterator(out, refdb, glob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "GIT_REFS_REMOTES_DIR \"%s/*\"",
            "old_name"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int rename_remote_references(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tint error;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_reference *ref;\n\tgit_reference_iterator *iter;\n\n\tif ((error = git_buf_printf(&buf, GIT_REFS_REMOTES_DIR \"%s/*\", old_name)) < 0)\n\t\treturn error;\n\n\terror = git_reference_iterator_glob_new(&iter, repo, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\treturn error;\n\n\twhile ((error = git_reference_next(&ref, iter)) == 0) {\n\t\tif ((error = rename_one_remote_reference(ref, old_name, new_name)) < 0)\n\t\t\tbreak;\n\t}\n\n\tgit_reference_iterator_free(iter);\n\n\treturn (error == GIT_ITEROVER) ? 0 : error;\n}"
  },
  {
    "function_name": "rename_one_remote_reference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1837-1896",
    "snippet": "static int rename_one_remote_reference(\n\tgit_reference *reference_in,\n\tconst char *old_remote_name,\n\tconst char *new_remote_name)\n{\n\tint error;\n\tgit_reference *ref = NULL, *dummy = NULL;\n\tgit_buf namespace = GIT_BUF_INIT, old_namespace = GIT_BUF_INIT;\n\tgit_buf new_name = GIT_BUF_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\tsize_t pfx_len;\n\tconst char *target;\n\n\tif ((error = git_buf_printf(&namespace, GIT_REFS_REMOTES_DIR \"%s/\", new_remote_name)) < 0)\n\t\treturn error;\n\n\tpfx_len = strlen(GIT_REFS_REMOTES_DIR) + strlen(old_remote_name) + 1;\n\tgit_buf_puts(&new_name, namespace.ptr);\n\tif ((error = git_buf_puts(&new_name, git_reference_name(reference_in) + pfx_len)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&log_message,\n\t\t\t\t\t\"renamed remote %s to %s\",\n\t\t\t\t\told_remote_name, new_remote_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_rename(&ref, reference_in, git_buf_cstr(&new_name), 1,\n\t\t\t\t\t  git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reference_type(ref) != GIT_REF_SYMBOLIC)\n\t\tgoto cleanup;\n\n\t/* Handle refs like origin/HEAD -> origin/master */\n\ttarget = git_reference_symbolic_target(ref);\n\tif ((error = git_buf_printf(&old_namespace, GIT_REFS_REMOTES_DIR \"%s/\", old_remote_name)) < 0)\n\t\tgoto cleanup;\n\n\tif (git__prefixcmp(target, old_namespace.ptr))\n\t\tgoto cleanup;\n\n\tgit_buf_clear(&new_name);\n\tgit_buf_puts(&new_name, namespace.ptr);\n\tif ((error = git_buf_puts(&new_name, target + pfx_len)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_symbolic_set_target(&dummy, ref, git_buf_cstr(&new_name),\n\t\t\t\t\t\t  git_buf_cstr(&log_message));\n\n\tgit_reference_free(dummy);\n\ncleanup:\n\tgit_reference_free(reference_in);\n\tgit_reference_free(ref);\n\tgit_buf_free(&namespace);\n\tgit_buf_free(&old_namespace);\n\tgit_buf_free(&new_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&log_message"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_symbolic_set_target",
          "args": [
            "&dummy",
            "ref",
            "git_buf_cstr(&new_name)",
            "git_buf_cstr(&log_message)"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_symbolic_set_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "547-562",
          "snippet": "int git_reference_symbolic_set_target(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *target,\n\tconst char *log_message)\n{\n\tint error;\n\n\tassert(out && ref && target);\n\n\tif ((error = ensure_is_an_updatable_symbolic_reference(ref)) < 0)\n\t\treturn error;\n\n\treturn git_reference_symbolic_create_matching(\n\t\tout, ref->db->repo, ref->name, target, 1, ref->target.symbolic, log_message);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_symbolic_set_target(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *target,\n\tconst char *log_message)\n{\n\tint error;\n\n\tassert(out && ref && target);\n\n\tif ((error = ensure_is_an_updatable_symbolic_reference(ref)) < 0)\n\t\treturn error;\n\n\treturn git_reference_symbolic_create_matching(\n\t\tout, ref->db->repo, ref->name, target, 1, ref->target.symbolic, log_message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&log_message"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&new_name",
            "target + pfx_len"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&new_name"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "target",
            "old_namespace.ptr"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&old_namespace",
            "GIT_REFS_REMOTES_DIR \"%s/\"",
            "old_remote_name"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_symbolic_target",
          "args": [
            "ref"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_symbolic_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "341-349",
          "snippet": "const char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_type",
          "args": [
            "ref"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "303-307",
          "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_rename",
          "args": [
            "&ref",
            "reference_in",
            "git_buf_cstr(&new_name)",
            "1",
            "git_buf_cstr(&log_message)"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "598-615",
          "snippet": "int git_reference_rename(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *new_name,\n\tint force,\n\tconst char *log_message)\n{\n\tgit_signature *who;\n\tint error;\n\n\tif ((error = git_reference__log_signature(&who, ref->db->repo)) < 0)\n\t\treturn error;\n\n\terror = reference__rename(out, ref, new_name, force, who, log_message);\n\tgit_signature_free(who);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_rename(\n\tgit_reference **out,\n\tgit_reference *ref,\n\tconst char *new_name,\n\tint force,\n\tconst char *log_message)\n{\n\tgit_signature *who;\n\tint error;\n\n\tif ((error = git_reference__log_signature(&who, ref->db->repo)) < 0)\n\t\treturn error;\n\n\terror = reference__rename(out, ref, new_name, force, who, log_message);\n\tgit_signature_free(who);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "reference_in"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "old_remote_name"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_REMOTES_DIR"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nstatic int rename_one_remote_reference(\n\tgit_reference *reference_in,\n\tconst char *old_remote_name,\n\tconst char *new_remote_name)\n{\n\tint error;\n\tgit_reference *ref = NULL, *dummy = NULL;\n\tgit_buf namespace = GIT_BUF_INIT, old_namespace = GIT_BUF_INIT;\n\tgit_buf new_name = GIT_BUF_INIT;\n\tgit_buf log_message = GIT_BUF_INIT;\n\tsize_t pfx_len;\n\tconst char *target;\n\n\tif ((error = git_buf_printf(&namespace, GIT_REFS_REMOTES_DIR \"%s/\", new_remote_name)) < 0)\n\t\treturn error;\n\n\tpfx_len = strlen(GIT_REFS_REMOTES_DIR) + strlen(old_remote_name) + 1;\n\tgit_buf_puts(&new_name, namespace.ptr);\n\tif ((error = git_buf_puts(&new_name, git_reference_name(reference_in) + pfx_len)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&log_message,\n\t\t\t\t\t\"renamed remote %s to %s\",\n\t\t\t\t\told_remote_name, new_remote_name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_rename(&ref, reference_in, git_buf_cstr(&new_name), 1,\n\t\t\t\t\t  git_buf_cstr(&log_message))) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reference_type(ref) != GIT_REF_SYMBOLIC)\n\t\tgoto cleanup;\n\n\t/* Handle refs like origin/HEAD -> origin/master */\n\ttarget = git_reference_symbolic_target(ref);\n\tif ((error = git_buf_printf(&old_namespace, GIT_REFS_REMOTES_DIR \"%s/\", old_remote_name)) < 0)\n\t\tgoto cleanup;\n\n\tif (git__prefixcmp(target, old_namespace.ptr))\n\t\tgoto cleanup;\n\n\tgit_buf_clear(&new_name);\n\tgit_buf_puts(&new_name, namespace.ptr);\n\tif ((error = git_buf_puts(&new_name, target + pfx_len)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_reference_symbolic_set_target(&dummy, ref, git_buf_cstr(&new_name),\n\t\t\t\t\t\t  git_buf_cstr(&log_message));\n\n\tgit_reference_free(dummy);\n\ncleanup:\n\tgit_reference_free(reference_in);\n\tgit_reference_free(ref);\n\tgit_buf_free(&namespace);\n\tgit_buf_free(&old_namespace);\n\tgit_buf_free(&new_name);\n\tgit_buf_free(&log_message);\n\treturn error;\n}"
  },
  {
    "function_name": "update_branch_remote_config_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1819-1835",
    "snippet": "static int update_branch_remote_config_entry(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tint error;\n\tstruct update_data data = { NULL };\n\n\tif ((error = git_repository_config__weakptr(&data.config, repo)) < 0)\n\t\treturn error;\n\n\tdata.old_remote_name = old_name;\n\tdata.new_remote_name = new_name;\n\n\treturn git_config_foreach_match(\n\t\tdata.config, \"branch\\\\..+\\\\.remote\", update_config_entries_cb, &data);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_foreach_match",
          "args": [
            "data.config",
            "\"branch\\\\..+\\\\.remote\"",
            "update_config_entries_cb",
            "&data"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_foreach_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "547-573",
          "snippet": "int git_config_foreach_match(\n\tconst git_config *cfg,\n\tconst char *regexp,\n\tgit_config_foreach_cb cb,\n\tvoid *payload)\n{\n\tint error;\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, regexp)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_config_next(&entry, iter))) {\n\t\tif ((error = cb(entry, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_foreach_match(\n\tconst git_config *cfg,\n\tconst char *regexp,\n\tgit_config_foreach_cb cb,\n\tvoid *payload)\n{\n\tint error;\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, regexp)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_config_next(&entry, iter))) {\n\t\tif ((error = cb(entry, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&data.config",
            "repo"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int update_branch_remote_config_entry(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tint error;\n\tstruct update_data data = { NULL };\n\n\tif ((error = git_repository_config__weakptr(&data.config, repo)) < 0)\n\t\treturn error;\n\n\tdata.old_remote_name = old_name;\n\tdata.new_remote_name = new_name;\n\n\treturn git_config_foreach_match(\n\t\tdata.config, \"branch\\\\..+\\\\.remote\", update_config_entries_cb, &data);\n}"
  },
  {
    "function_name": "update_config_entries_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1806-1817",
    "snippet": "static int update_config_entries_cb(\n\tconst git_config_entry *entry,\n\tvoid *payload)\n{\n\tstruct update_data *data = (struct update_data *)payload;\n\n\tif (strcmp(entry->value, data->old_remote_name))\n\t\treturn 0;\n\n\treturn git_config_set_string(\n\t\tdata->config, entry->name, data->new_remote_name);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_set_string",
          "args": [
            "data->config",
            "entry->name",
            "data->new_remote_name"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "616-638",
          "snippet": "int git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->value",
            "data->old_remote_name"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int update_config_entries_cb(\n\tconst git_config_entry *entry,\n\tvoid *payload)\n{\n\tstruct update_data *data = (struct update_data *)payload;\n\n\tif (strcmp(entry->value, data->old_remote_name))\n\t\treturn 0;\n\n\treturn git_config_set_string(\n\t\tdata->config, entry->name, data->new_remote_name);\n}"
  },
  {
    "function_name": "rename_remote_config_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1772-1798",
    "snippet": "static int rename_remote_config_section(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tgit_buf old_section_name = GIT_BUF_INIT,\n\t\tnew_section_name = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_buf_printf(&old_section_name, \"remote.%s\", old_name) < 0)\n\t\tgoto cleanup;\n\n\tif (new_name &&\n\t\t(git_buf_printf(&new_section_name, \"remote.%s\", new_name) < 0))\n\t\t\tgoto cleanup;\n\n\terror = git_config_rename_section(\n\t\trepo,\n\t\tgit_buf_cstr(&old_section_name),\n\t\tnew_name ? git_buf_cstr(&new_section_name) : NULL);\n\ncleanup:\n\tgit_buf_free(&old_section_name);\n\tgit_buf_free(&new_section_name);\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&new_section_name"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_rename_section",
          "args": [
            "repo",
            "git_buf_cstr(&old_section_name)",
            "new_name ? git_buf_cstr(&new_section_name) : NULL"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_rename_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1434-1476",
          "snippet": "int git_config_rename_section(\n\tgit_repository *repo,\n\tconst char *old_section_name,\n\tconst char *new_section_name)\n{\n\tgit_config *config;\n\tgit_buf pattern = GIT_BUF_INIT, replace = GIT_BUF_INIT;\n\tint error = 0;\n\tstruct rename_data data;\n\n\tgit_buf_text_puts_escape_regex(&pattern, old_section_name);\n\n\tif ((error = git_buf_puts(&pattern, \"\\\\..+\")) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\tgoto cleanup;\n\n\tdata.config  = config;\n\tdata.name    = &replace;\n\tdata.old_len = strlen(old_section_name) + 1;\n\n\tif ((error = git_buf_join(&replace, '.', new_section_name, \"\")) < 0)\n\t\tgoto cleanup;\n\n\tif (new_section_name != NULL &&\n\t\t(error = git_config_file_normalize_section(\n\t\t\treplace.ptr, strchr(replace.ptr, '.'))) < 0)\n\t{\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG, \"Invalid config section '%s'\", new_section_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = git_config_foreach_match(\n\t\tconfig, git_buf_cstr(&pattern), rename_config_entries_cb, &data);\n\ncleanup:\n\tgit_buf_free(&pattern);\n\tgit_buf_free(&replace);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_rename_section(\n\tgit_repository *repo,\n\tconst char *old_section_name,\n\tconst char *new_section_name)\n{\n\tgit_config *config;\n\tgit_buf pattern = GIT_BUF_INIT, replace = GIT_BUF_INIT;\n\tint error = 0;\n\tstruct rename_data data;\n\n\tgit_buf_text_puts_escape_regex(&pattern, old_section_name);\n\n\tif ((error = git_buf_puts(&pattern, \"\\\\..+\")) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\tgoto cleanup;\n\n\tdata.config  = config;\n\tdata.name    = &replace;\n\tdata.old_len = strlen(old_section_name) + 1;\n\n\tif ((error = git_buf_join(&replace, '.', new_section_name, \"\")) < 0)\n\t\tgoto cleanup;\n\n\tif (new_section_name != NULL &&\n\t\t(error = git_config_file_normalize_section(\n\t\t\treplace.ptr, strchr(replace.ptr, '.'))) < 0)\n\t{\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG, \"Invalid config section '%s'\", new_section_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = git_config_foreach_match(\n\t\tconfig, git_buf_cstr(&pattern), rename_config_entries_cb, &data);\n\ncleanup:\n\tgit_buf_free(&pattern);\n\tgit_buf_free(&replace);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&new_section_name"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&new_section_name",
            "\"remote.%s\"",
            "new_name"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int rename_remote_config_section(\n\tgit_repository *repo,\n\tconst char *old_name,\n\tconst char *new_name)\n{\n\tgit_buf old_section_name = GIT_BUF_INIT,\n\t\tnew_section_name = GIT_BUF_INIT;\n\tint error = -1;\n\n\tif (git_buf_printf(&old_section_name, \"remote.%s\", old_name) < 0)\n\t\tgoto cleanup;\n\n\tif (new_name &&\n\t\t(git_buf_printf(&new_section_name, \"remote.%s\", new_name) < 0))\n\t\t\tgoto cleanup;\n\n\terror = git_config_rename_section(\n\t\trepo,\n\t\tgit_buf_cstr(&old_section_name),\n\t\tnew_name ? git_buf_cstr(&new_section_name) : NULL);\n\ncleanup:\n\tgit_buf_free(&old_section_name);\n\tgit_buf_free(&new_section_name);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_remote_prune_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1767-1770",
    "snippet": "int git_remote_prune_refs(const git_remote *remote)\n{\n\treturn remote->prune_refs;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_prune_refs(const git_remote *remote)\n{\n\treturn remote->prune_refs;\n}"
  },
  {
    "function_name": "git_remote_set_autotag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1729-1765",
    "snippet": "int git_remote_set_autotag(git_repository *repo, const char *remote, git_remote_autotag_option_t value)\n{\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_config *config;\n\tint error;\n\n\tassert(repo && remote);\n\n\tif ((error = ensure_remote_name_is_valid(remote)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(&var, CONFIG_TAGOPT_FMT, remote)))\n\t\treturn error;\n\n\tswitch (value) {\n\tcase GIT_REMOTE_DOWNLOAD_TAGS_NONE:\n\t\terror = git_config_set_string(config, var.ptr, \"--no-tags\");\n\t\tbreak;\n\tcase GIT_REMOTE_DOWNLOAD_TAGS_ALL:\n\t\terror = git_config_set_string(config, var.ptr, \"--tags\");\n\t\tbreak;\n\tcase GIT_REMOTE_DOWNLOAD_TAGS_AUTO:\n\t\terror = git_config_delete_entry(config, var.ptr);\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"Invalid value for the tagopt setting\");\n\t\terror = -1;\n\t}\n\n\tgit_buf_free(&var);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [
      "#define CONFIG_TAGOPT_FMT \"remote.%s.tagopt\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&var"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Invalid value for the tagopt setting\""
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_delete_entry",
          "args": [
            "config",
            "var.ptr"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "586-597",
          "snippet": "int git_config_delete_entry(git_config *cfg, const char *name)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del(file, name);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_delete_entry(git_config *cfg, const char *name)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del(file, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_set_string",
          "args": [
            "config",
            "var.ptr",
            "\"--tags\""
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "616-638",
          "snippet": "int git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&var",
            "CONFIG_TAGOPT_FMT",
            "remote"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&config",
            "repo"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_remote_name_is_valid",
          "args": [
            "remote"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_remote_name_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "83-95",
          "snippet": "static int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && remote"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_TAGOPT_FMT \"remote.%s.tagopt\"\n\nint git_remote_set_autotag(git_repository *repo, const char *remote, git_remote_autotag_option_t value)\n{\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_config *config;\n\tint error;\n\n\tassert(repo && remote);\n\n\tif ((error = ensure_remote_name_is_valid(remote)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(&var, CONFIG_TAGOPT_FMT, remote)))\n\t\treturn error;\n\n\tswitch (value) {\n\tcase GIT_REMOTE_DOWNLOAD_TAGS_NONE:\n\t\terror = git_config_set_string(config, var.ptr, \"--no-tags\");\n\t\tbreak;\n\tcase GIT_REMOTE_DOWNLOAD_TAGS_ALL:\n\t\terror = git_config_set_string(config, var.ptr, \"--tags\");\n\t\tbreak;\n\tcase GIT_REMOTE_DOWNLOAD_TAGS_AUTO:\n\t\terror = git_config_delete_entry(config, var.ptr);\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\tgiterr_set(GITERR_INVALID, \"Invalid value for the tagopt setting\");\n\t\terror = -1;\n\t}\n\n\tgit_buf_free(&var);\n\treturn error;\n}"
  },
  {
    "function_name": "git_remote_autotag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1724-1727",
    "snippet": "git_remote_autotag_option_t git_remote_autotag(const git_remote *remote)\n{\n\treturn remote->download_tags;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_remote_autotag_option_t git_remote_autotag(const git_remote *remote)\n{\n\treturn remote->download_tags;\n}"
  },
  {
    "function_name": "git_remote_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1718-1722",
    "snippet": "const git_transfer_progress* git_remote_stats(git_remote *remote)\n{\n\tassert(remote);\n\treturn &remote->stats;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nconst git_transfer_progress* git_remote_stats(git_remote *remote)\n{\n\tassert(remote);\n\treturn &remote->stats;\n}"
  },
  {
    "function_name": "git_remote_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1690-1716",
    "snippet": "int git_remote_list(git_strarray *remotes_list, git_repository *repo)\n{\n\tint error;\n\tgit_config *cfg;\n\tgit_vector list = GIT_VECTOR_INIT;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_vector_init(&list, 4, git__strcmp_cb)) < 0)\n\t\treturn error;\n\n\terror = git_config_foreach_match(\n\t\tcfg, \"^remote\\\\..*\\\\.(push)?url$\", remote_list_cb, &list);\n\n\tif (error < 0) {\n\t\tgit_vector_free_deep(&list);\n\t\treturn error;\n\t}\n\n\tgit_vector_uniq(&list, git__free);\n\n\tremotes_list->strings =\n\t\t(char **)git_vector_detach(&remotes_list->count, NULL, &list);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_detach",
          "args": [
            "&remotes_list->count",
            "NULL",
            "&list"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "110-124",
          "snippet": "void **git_vector_detach(size_t *size, size_t *asize, git_vector *v)\n{\n\tvoid **data = v->contents;\n\n\tif (size)\n\t\t*size = v->length;\n\tif (asize)\n\t\t*asize = v->_alloc_size;\n\n\tv->_alloc_size = 0;\n\tv->length   = 0;\n\tv->contents = NULL;\n\n\treturn data;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid **git_vector_detach(size_t *size, size_t *asize, git_vector *v)\n{\n\tvoid **data = v->contents;\n\n\tif (size)\n\t\t*size = v->length;\n\tif (asize)\n\t\t*asize = v->_alloc_size;\n\n\tv->_alloc_size = 0;\n\tv->length   = 0;\n\tv->contents = NULL;\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_uniq",
          "args": [
            "&list",
            "git__free"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_uniq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "258-279",
          "snippet": "void git_vector_uniq(git_vector *v, void  (*git_free_cb)(void *))\n{\n\tgit_vector_cmp cmp;\n\tsize_t i, j;\n\n\tif (v->length <= 1)\n\t\treturn;\n\n\tgit_vector_sort(v);\n\tcmp = v->_cmp ? v->_cmp : strict_comparison;\n\n\tfor (i = 0, j = 1 ; j < v->length; ++j)\n\t\tif (!cmp(v->contents[i], v->contents[j])) {\n\t\t\tif (git_free_cb)\n\t\t\t\tgit_free_cb(v->contents[i]);\n\n\t\t\tv->contents[i] = v->contents[j];\n\t\t} else\n\t\t\tv->contents[++i] = v->contents[j];\n\n\tv->length -= j - i - 1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_uniq(git_vector *v, void  (*git_free_cb)(void *))\n{\n\tgit_vector_cmp cmp;\n\tsize_t i, j;\n\n\tif (v->length <= 1)\n\t\treturn;\n\n\tgit_vector_sort(v);\n\tcmp = v->_cmp ? v->_cmp : strict_comparison;\n\n\tfor (i = 0, j = 1 ; j < v->length; ++j)\n\t\tif (!cmp(v->contents[i], v->contents[j])) {\n\t\t\tif (git_free_cb)\n\t\t\t\tgit_free_cb(v->contents[i]);\n\n\t\t\tv->contents[i] = v->contents[j];\n\t\t} else\n\t\t\tv->contents[++i] = v->contents[j];\n\n\tv->length -= j - i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&list"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_foreach_match",
          "args": [
            "cfg",
            "\"^remote\\\\..*\\\\.(push)?url$\"",
            "remote_list_cb",
            "&list"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_foreach_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "547-573",
          "snippet": "int git_config_foreach_match(\n\tconst git_config *cfg,\n\tconst char *regexp,\n\tgit_config_foreach_cb cb,\n\tvoid *payload)\n{\n\tint error;\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, regexp)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_config_next(&entry, iter))) {\n\t\tif ((error = cb(entry, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_foreach_match(\n\tconst git_config *cfg,\n\tconst char *regexp,\n\tgit_config_foreach_cb cb,\n\tvoid *payload)\n{\n\tint error;\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, regexp)) < 0)\n\t\treturn error;\n\n\twhile (!(error = git_config_next(&entry, iter))) {\n\t\tif ((error = cb(entry, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&list",
            "4",
            "git__strcmp_cb"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "repo"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_list(git_strarray *remotes_list, git_repository *repo)\n{\n\tint error;\n\tgit_config *cfg;\n\tgit_vector list = GIT_VECTOR_INIT;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_vector_init(&list, 4, git__strcmp_cb)) < 0)\n\t\treturn error;\n\n\terror = git_config_foreach_match(\n\t\tcfg, \"^remote\\\\..*\\\\.(push)?url$\", remote_list_cb, &list);\n\n\tif (error < 0) {\n\t\tgit_vector_free_deep(&list);\n\t\treturn error;\n\t}\n\n\tgit_vector_uniq(&list, git__free);\n\n\tremotes_list->strings =\n\t\t(char **)git_vector_detach(&remotes_list->count, NULL, &list);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "remote_list_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1672-1688",
    "snippet": "static int remote_list_cb(const git_config_entry *entry, void *payload)\n{\n\tgit_vector *list = payload;\n\tconst char *name = entry->name + strlen(\"remote.\");\n\tsize_t namelen = strlen(name);\n\tchar *remote_name;\n\n\t/* we know name matches \"remote.<stuff>.(push)?url\" */\n\n\tif (!strcmp(&name[namelen - 4], \".url\"))\n\t\tremote_name = git__strndup(name, namelen - 4); /* strip \".url\" */\n\telse\n\t\tremote_name = git__strndup(name, namelen - 8); /* strip \".pushurl\" */\n\tGITERR_CHECK_ALLOC(remote_name);\n\n\treturn git_vector_insert(list, remote_name);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "list",
            "remote_name"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote_name"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "name",
            "namelen - 8"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "&name[namelen - 4]",
            "\".url\""
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"remote.\""
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int remote_list_cb(const git_config_entry *entry, void *payload)\n{\n\tgit_vector *list = payload;\n\tconst char *name = entry->name + strlen(\"remote.\");\n\tsize_t namelen = strlen(name);\n\tchar *remote_name;\n\n\t/* we know name matches \"remote.<stuff>.(push)?url\" */\n\n\tif (!strcmp(&name[namelen - 4], \".url\"))\n\t\tremote_name = git__strndup(name, namelen - 4); /* strip \".url\" */\n\telse\n\t\tremote_name = git__strndup(name, namelen - 8); /* strip \".pushurl\" */\n\tGITERR_CHECK_ALLOC(remote_name);\n\n\treturn git_vector_insert(list, remote_name);\n}"
  },
  {
    "function_name": "git_remote_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1642-1670",
    "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "remote"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_push_free",
          "args": [
            "remote->push"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "683-711",
          "snippet": "void git_push_free(git_push *push)\n{\n\tpush_spec *spec;\n\tpush_status *status;\n\tgit_push_update *update;\n\tunsigned int i;\n\n\tif (push == NULL)\n\t\treturn;\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tfree_refspec(spec);\n\t}\n\tgit_vector_free(&push->specs);\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tgit_push_status_free(status);\n\t}\n\tgit_vector_free(&push->status);\n\n\tgit_vector_foreach(&push->updates, i, update) {\n\t\tgit__free(update->src_refname);\n\t\tgit__free(update->dst_refname);\n\t\tgit__free(update);\n\t}\n\tgit_vector_free(&push->updates);\n\n\tgit__free(push);\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nvoid git_push_free(git_push *push)\n{\n\tpush_spec *spec;\n\tpush_status *status;\n\tgit_push_update *update;\n\tunsigned int i;\n\n\tif (push == NULL)\n\t\treturn;\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tfree_refspec(spec);\n\t}\n\tgit_vector_free(&push->specs);\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tgit_push_status_free(status);\n\t}\n\tgit_vector_free(&push->status);\n\n\tgit_vector_foreach(&push->updates, i, update) {\n\t\tgit__free(update->src_refname);\n\t\tgit__free(update->dst_refname);\n\t\tgit__free(update);\n\t}\n\tgit_vector_free(&push->updates);\n\n\tgit__free(push);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&remote->passive_refspecs"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_refspecs",
          "args": [
            "&remote->passive_refspecs"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "free_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "852-863",
          "snippet": "static void free_refspecs(git_vector *vec)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(vec, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_clear(vec);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic void free_refspecs(git_vector *vec)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(vec, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_clear(vec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote->transport->free",
          "args": [
            "remote->transport"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_remote_disconnect",
          "args": [
            "remote"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1634-1640",
          "snippet": "void git_remote_disconnect(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (git_remote_connected(remote))\n\t\tremote->transport->close(remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nvoid git_remote_disconnect(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (git_remote_connected(remote))\n\t\tremote->transport->close(remote->transport);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
  },
  {
    "function_name": "git_remote_disconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1634-1640",
    "snippet": "void git_remote_disconnect(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (git_remote_connected(remote))\n\t\tremote->transport->close(remote->transport);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remote->transport->close",
          "args": [
            "remote->transport"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_remote_connected",
          "args": [
            "remote"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_connected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1615-1624",
          "snippet": "int git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nvoid git_remote_disconnect(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (git_remote_connected(remote))\n\t\tremote->transport->close(remote->transport);\n}"
  },
  {
    "function_name": "git_remote_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1626-1632",
    "snippet": "void git_remote_stop(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (remote->transport && remote->transport->cancel)\n\t\tremote->transport->cancel(remote->transport);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remote->transport->cancel",
          "args": [
            "remote->transport"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nvoid git_remote_stop(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (remote->transport && remote->transport->cancel)\n\t\tremote->transport->cancel(remote->transport);\n}"
  },
  {
    "function_name": "git_remote_connected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1615-1624",
    "snippet": "int git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remote->transport->is_connected",
          "args": [
            "remote->transport"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}"
  },
  {
    "function_name": "git_remote_update_tips",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1562-1613",
    "snippet": "int git_remote_update_tips(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t download_tags,\n\t\tconst char *reflog_message)\n{\n\tgit_refspec *spec, tagspec;\n\tgit_vector refs = GIT_VECTOR_INIT;\n\tgit_remote_autotag_option_t tagopt;\n\tint error;\n\tsize_t i;\n\n\t/* push has its own logic hidden away in the push object */\n\tif (remote->push) {\n\t\treturn git_push_update_tips(remote->push, callbacks);\n\t}\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\n\tif ((error = ls_to_vector(&refs, remote)) < 0)\n\t\tgoto out;\n\n\tif (download_tags == GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = remote->download_tags;\n\telse\n\t\ttagopt = download_tags;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, &tagspec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, spec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* only try to do opportunisitic updates if the refpec lists differ */\n\tif (remote->passed_refspecs)\n\t\terror = opportunistic_updates(remote, callbacks, &refs, reflog_message);\n\nout:\n\tgit_vector_free(&refs);\n\tgit_refspec__free(&tagspec);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "&tagspec"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&refs"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opportunistic_updates",
          "args": [
            "remote",
            "callbacks",
            "&refs",
            "reflog_message"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "opportunistic_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1506-1560",
          "snippet": "static int opportunistic_updates(const git_remote *remote, const git_remote_callbacks *callbacks,\n\t\t\t\t git_vector *refs, const char *msg)\n{\n\tsize_t i, j, k;\n\tgit_refspec *spec;\n\tgit_remote_head *head;\n\tgit_reference *ref;\n\tgit_buf refname = GIT_BUF_INIT;\n\tint error = 0;\n\n\ti = j = k = 0;\n\n\twhile ((error = next_head(remote, refs, &spec, &head, &i, &j, &k)) == 0) {\n\t\tgit_oid old = {{ 0 }};\n\t\t/*\n\t\t * If we got here, there is a refspec which was used\n\t\t * for fetching which matches the source of one of the\n\t\t * passive refspecs, so we should update that\n\t\t * remote-tracking branch, but not add it to\n\t\t * FETCH_HEAD\n\t\t */\n\n\t\tgit_buf_clear(&refname);\n\t\tif ((error = git_refspec_transform(&refname, spec, head->name)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_reference_name_to_id(&old, remote->repo, refname.ptr);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_oid_cmp(&old, &head->oid))\n\t\t\tcontinue;\n\n\t\t/* If we did find a current reference, make sure we haven't lost a race */\n\t\tif (error)\n\t\t\terror = git_reference_create(&ref, remote->repo, refname.ptr, &head->oid, true, msg);\n\t\telse\n\t\t\terror = git_reference_create_matching(&ref, remote->repo, refname.ptr, &head->oid, true, &old, msg);\n\t\tgit_reference_free(ref);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (callbacks && callbacks->update_tips != NULL) {\n\t\t\tif (callbacks->update_tips(refname.ptr, &old, &head->oid, callbacks->payload) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\ncleanup:\n\tgit_buf_free(&refname);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int opportunistic_updates(const git_remote *remote, const git_remote_callbacks *callbacks,\n\t\t\t\t git_vector *refs, const char *msg)\n{\n\tsize_t i, j, k;\n\tgit_refspec *spec;\n\tgit_remote_head *head;\n\tgit_reference *ref;\n\tgit_buf refname = GIT_BUF_INIT;\n\tint error = 0;\n\n\ti = j = k = 0;\n\n\twhile ((error = next_head(remote, refs, &spec, &head, &i, &j, &k)) == 0) {\n\t\tgit_oid old = {{ 0 }};\n\t\t/*\n\t\t * If we got here, there is a refspec which was used\n\t\t * for fetching which matches the source of one of the\n\t\t * passive refspecs, so we should update that\n\t\t * remote-tracking branch, but not add it to\n\t\t * FETCH_HEAD\n\t\t */\n\n\t\tgit_buf_clear(&refname);\n\t\tif ((error = git_refspec_transform(&refname, spec, head->name)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_reference_name_to_id(&old, remote->repo, refname.ptr);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_oid_cmp(&old, &head->oid))\n\t\t\tcontinue;\n\n\t\t/* If we did find a current reference, make sure we haven't lost a race */\n\t\tif (error)\n\t\t\terror = git_reference_create(&ref, remote->repo, refname.ptr, &head->oid, true, msg);\n\t\telse\n\t\t\terror = git_reference_create_matching(&ref, remote->repo, refname.ptr, &head->oid, true, &old, msg);\n\t\tgit_reference_free(ref);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (callbacks && callbacks->update_tips != NULL) {\n\t\t\tif (callbacks->update_tips(refname.ptr, &old, &head->oid, callbacks->payload) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\ncleanup:\n\tgit_buf_free(&refname);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_tips_for_spec",
          "args": [
            "remote",
            "callbacks",
            "update_fetchhead",
            "tagopt",
            "spec",
            "&refs",
            "reflog_message"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "update_tips_for_spec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1318-1447",
          "snippet": "static int update_tips_for_spec(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t tagopt,\n\t\tgit_refspec *spec,\n\t\tgit_vector *refs,\n\t\tconst char *log_message)\n{\n\tint error = 0, autotag;\n\tunsigned int i = 0;\n\tgit_buf refname = GIT_BUF_INIT;\n\tgit_oid old;\n\tgit_odb *odb;\n\tgit_remote_head *head;\n\tgit_reference *ref;\n\tgit_refspec tagspec;\n\tgit_vector update_heads;\n\n\tassert(remote);\n\n\tif (git_repository_odb__weakptr(&odb, remote->repo) < 0)\n\t\treturn -1;\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\t/* Make a copy of the transport's refs */\n\tif (git_vector_init(&update_heads, 16, NULL) < 0)\n\t\treturn -1;\n\n\tfor (; i < refs->length; ++i) {\n\t\thead = git_vector_get(refs, i);\n\t\tautotag = 0;\n\t\tgit_buf_clear(&refname);\n\n\t\t/* Ignore malformed ref names (which also saves us from tag^{} */\n\t\tif (!git_reference_is_valid_name(head->name))\n\t\t\tcontinue;\n\n\t\t/* If we have a tag, see if the auto-follow rules say to update it */\n\t\tif (git_refspec_src_matches(&tagspec, head->name)) {\n\t\t\tif (tagopt != GIT_REMOTE_DOWNLOAD_TAGS_NONE) {\n\n\t\t\t\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_AUTO)\n\t\t\t\t\tautotag = 1;\n\n\t\t\t\tgit_buf_clear(&refname);\n\t\t\t\tif (git_buf_puts(&refname, head->name) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\t/* If we didn't want to auto-follow the tag, check if the refspec matches */\n\t\tif (!autotag && git_refspec_src_matches(spec, head->name)) {\n\t\t\tif (spec->dst) {\n\t\t\t\tif (git_refspec_transform(&refname, spec, head->name) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no rhs mans store it in FETCH_HEAD, even if we don't\n\t\t\t\t update anything else.\n\t\t\t\t */\n\t\t\t\tif ((error = git_vector_insert(&update_heads, head)) < 0)\n\t\t\t\t\tgoto on_error;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* If we still don't have a refname, we don't want it */\n\t\tif (git_buf_len(&refname) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In autotag mode, only create tags for objects already in db */\n\t\tif (autotag && !git_odb_exists(odb, &head->oid))\n\t\t\tcontinue;\n\n\t\tif (!autotag && git_vector_insert(&update_heads, head) < 0)\n\t\t\tgoto on_error;\n\n\t\terror = git_reference_name_to_id(&old, remote->repo, refname.ptr);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto on_error;\n\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tmemset(&old, 0, GIT_OID_RAWSZ);\n\n\t\t\tif (autotag && git_vector_insert(&update_heads, head) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!git_oid__cmp(&old, &head->oid))\n\t\t\tcontinue;\n\n\t\t/* In autotag mode, don't overwrite any locally-existing tags */\n\t\terror = git_reference_create(&ref, remote->repo, refname.ptr, &head->oid, !autotag, \n\t\t\t\tlog_message);\n\n\t\tif (error == GIT_EEXISTS)\n\t\t\tcontinue;\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\n\t\tif (callbacks && callbacks->update_tips != NULL) {\n\t\t\tif (callbacks->update_tips(refname.ptr, &old, &head->oid, callbacks->payload) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif (update_fetchhead &&\n\t    (error = git_remote_write_fetchhead(remote, spec, &update_heads)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_free(&update_heads);\n\tgit_refspec__free(&tagspec);\n\tgit_buf_free(&refname);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&update_heads);\n\tgit_refspec__free(&tagspec);\n\tgit_buf_free(&refname);\n\treturn -1;\n\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int update_tips_for_spec(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t tagopt,\n\t\tgit_refspec *spec,\n\t\tgit_vector *refs,\n\t\tconst char *log_message)\n{\n\tint error = 0, autotag;\n\tunsigned int i = 0;\n\tgit_buf refname = GIT_BUF_INIT;\n\tgit_oid old;\n\tgit_odb *odb;\n\tgit_remote_head *head;\n\tgit_reference *ref;\n\tgit_refspec tagspec;\n\tgit_vector update_heads;\n\n\tassert(remote);\n\n\tif (git_repository_odb__weakptr(&odb, remote->repo) < 0)\n\t\treturn -1;\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\t/* Make a copy of the transport's refs */\n\tif (git_vector_init(&update_heads, 16, NULL) < 0)\n\t\treturn -1;\n\n\tfor (; i < refs->length; ++i) {\n\t\thead = git_vector_get(refs, i);\n\t\tautotag = 0;\n\t\tgit_buf_clear(&refname);\n\n\t\t/* Ignore malformed ref names (which also saves us from tag^{} */\n\t\tif (!git_reference_is_valid_name(head->name))\n\t\t\tcontinue;\n\n\t\t/* If we have a tag, see if the auto-follow rules say to update it */\n\t\tif (git_refspec_src_matches(&tagspec, head->name)) {\n\t\t\tif (tagopt != GIT_REMOTE_DOWNLOAD_TAGS_NONE) {\n\n\t\t\t\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_AUTO)\n\t\t\t\t\tautotag = 1;\n\n\t\t\t\tgit_buf_clear(&refname);\n\t\t\t\tif (git_buf_puts(&refname, head->name) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\t/* If we didn't want to auto-follow the tag, check if the refspec matches */\n\t\tif (!autotag && git_refspec_src_matches(spec, head->name)) {\n\t\t\tif (spec->dst) {\n\t\t\t\tif (git_refspec_transform(&refname, spec, head->name) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no rhs mans store it in FETCH_HEAD, even if we don't\n\t\t\t\t update anything else.\n\t\t\t\t */\n\t\t\t\tif ((error = git_vector_insert(&update_heads, head)) < 0)\n\t\t\t\t\tgoto on_error;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* If we still don't have a refname, we don't want it */\n\t\tif (git_buf_len(&refname) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In autotag mode, only create tags for objects already in db */\n\t\tif (autotag && !git_odb_exists(odb, &head->oid))\n\t\t\tcontinue;\n\n\t\tif (!autotag && git_vector_insert(&update_heads, head) < 0)\n\t\t\tgoto on_error;\n\n\t\terror = git_reference_name_to_id(&old, remote->repo, refname.ptr);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto on_error;\n\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tmemset(&old, 0, GIT_OID_RAWSZ);\n\n\t\t\tif (autotag && git_vector_insert(&update_heads, head) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!git_oid__cmp(&old, &head->oid))\n\t\t\tcontinue;\n\n\t\t/* In autotag mode, don't overwrite any locally-existing tags */\n\t\terror = git_reference_create(&ref, remote->repo, refname.ptr, &head->oid, !autotag, \n\t\t\t\tlog_message);\n\n\t\tif (error == GIT_EEXISTS)\n\t\t\tcontinue;\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\n\t\tif (callbacks && callbacks->update_tips != NULL) {\n\t\t\tif (callbacks->update_tips(refname.ptr, &old, &head->oid, callbacks->payload) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif (update_fetchhead &&\n\t    (error = git_remote_write_fetchhead(remote, spec, &update_heads)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_free(&update_heads);\n\tgit_refspec__free(&tagspec);\n\tgit_buf_free(&refname);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&update_heads);\n\tgit_refspec__free(&tagspec);\n\tgit_buf_free(&refname);\n\treturn -1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&remote->active_refspecs",
            "i",
            "spec"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ls_to_vector",
          "args": [
            "&refs",
            "remote"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "ls_to_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "873-890",
          "snippet": "static int ls_to_vector(git_vector *out, git_remote *remote)\n{\n\tgit_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tif (git_vector_init(out, heads_len, remote_head_cmp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(out, heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int ls_to_vector(git_vector *out, git_remote *remote)\n{\n\tgit_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tif (git_vector_init(out, heads_len, remote_head_cmp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(out, heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__parse",
          "args": [
            "&tagspec",
            "GIT_REFSPEC_TAGS",
            "true"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "17-149",
          "snippet": "int git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_push_update_tips",
          "args": [
            "remote->push",
            "callbacks"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_update_tips",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "159-230",
          "snippet": "int git_push_update_tips(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tgit_buf remote_ref_name = GIT_BUF_INIT;\n\tsize_t i, j;\n\tgit_refspec *fetch_spec;\n\tpush_spec *push_spec = NULL;\n\tgit_reference *remote_ref;\n\tpush_status *status;\n\tint error = 0;\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tint fire_callback = 1;\n\n\t\t/* Skip unsuccessful updates which have non-empty messages */\n\t\tif (status->msg)\n\t\t\tcontinue;\n\n\t\t/* Find the corresponding remote ref */\n\t\tfetch_spec = git_remote__matching_refspec(push->remote, status->ref);\n\t\tif (!fetch_spec)\n\t\t\tcontinue;\n\n\t\tif ((error = git_refspec_transform(&remote_ref_name, fetch_spec, status->ref)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Find matching  push ref spec */\n\t\tgit_vector_foreach(&push->specs, j, push_spec) {\n\t\t\tif (!strcmp(push_spec->refspec.dst, status->ref))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Could not find the corresponding push ref spec for this push update */\n\t\tif (j == push->specs.length)\n\t\t\tcontinue;\n\n\t\t/* Update the remote ref */\n\t\tif (git_oid_iszero(&push_spec->loid)) {\n\t\t\terror = git_reference_lookup(&remote_ref, push->remote->repo, git_buf_cstr(&remote_ref_name));\n\n\t\t\tif (error >= 0) {\n\t\t\t\terror = git_reference_delete(remote_ref);\n\t\t\t\tgit_reference_free(remote_ref);\n\t\t\t}\n\t\t} else {\n\t\t\terror = git_reference_create(NULL, push->remote->repo,\n\t\t\t\t\t\tgit_buf_cstr(&remote_ref_name), &push_spec->loid, 1,\n\t\t\t\t\t\t\"update by push\");\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tfire_callback = 0;\n\t\t}\n\n\t\tif (fire_callback && callbacks && callbacks->update_tips) {\n\t\t\terror = callbacks->update_tips(git_buf_cstr(&remote_ref_name),\n\t\t\t\t\t\t&push_spec->roid, &push_spec->loid, callbacks->payload);\n\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\terror = 0;\n\non_error:\n\tgit_buf_free(&remote_ref_name);\n\treturn error;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nint git_push_update_tips(git_push *push, const git_remote_callbacks *callbacks)\n{\n\tgit_buf remote_ref_name = GIT_BUF_INIT;\n\tsize_t i, j;\n\tgit_refspec *fetch_spec;\n\tpush_spec *push_spec = NULL;\n\tgit_reference *remote_ref;\n\tpush_status *status;\n\tint error = 0;\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tint fire_callback = 1;\n\n\t\t/* Skip unsuccessful updates which have non-empty messages */\n\t\tif (status->msg)\n\t\t\tcontinue;\n\n\t\t/* Find the corresponding remote ref */\n\t\tfetch_spec = git_remote__matching_refspec(push->remote, status->ref);\n\t\tif (!fetch_spec)\n\t\t\tcontinue;\n\n\t\tif ((error = git_refspec_transform(&remote_ref_name, fetch_spec, status->ref)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Find matching  push ref spec */\n\t\tgit_vector_foreach(&push->specs, j, push_spec) {\n\t\t\tif (!strcmp(push_spec->refspec.dst, status->ref))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Could not find the corresponding push ref spec for this push update */\n\t\tif (j == push->specs.length)\n\t\t\tcontinue;\n\n\t\t/* Update the remote ref */\n\t\tif (git_oid_iszero(&push_spec->loid)) {\n\t\t\terror = git_reference_lookup(&remote_ref, push->remote->repo, git_buf_cstr(&remote_ref_name));\n\n\t\t\tif (error >= 0) {\n\t\t\t\terror = git_reference_delete(remote_ref);\n\t\t\t\tgit_reference_free(remote_ref);\n\t\t\t}\n\t\t} else {\n\t\t\terror = git_reference_create(NULL, push->remote->repo,\n\t\t\t\t\t\tgit_buf_cstr(&remote_ref_name), &push_spec->loid, 1,\n\t\t\t\t\t\t\"update by push\");\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tfire_callback = 0;\n\t\t}\n\n\t\tif (fire_callback && callbacks && callbacks->update_tips) {\n\t\t\terror = callbacks->update_tips(git_buf_cstr(&remote_ref_name),\n\t\t\t\t\t\t&push_spec->roid, &push_spec->loid, callbacks->payload);\n\n\t\t\tif (error < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\terror = 0;\n\non_error:\n\tgit_buf_free(&remote_ref_name);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nint git_remote_update_tips(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t download_tags,\n\t\tconst char *reflog_message)\n{\n\tgit_refspec *spec, tagspec;\n\tgit_vector refs = GIT_VECTOR_INIT;\n\tgit_remote_autotag_option_t tagopt;\n\tint error;\n\tsize_t i;\n\n\t/* push has its own logic hidden away in the push object */\n\tif (remote->push) {\n\t\treturn git_push_update_tips(remote->push, callbacks);\n\t}\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\n\tif ((error = ls_to_vector(&refs, remote)) < 0)\n\t\tgoto out;\n\n\tif (download_tags == GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = remote->download_tags;\n\telse\n\t\ttagopt = download_tags;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, &tagspec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, spec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* only try to do opportunisitic updates if the refpec lists differ */\n\tif (remote->passed_refspecs)\n\t\terror = opportunistic_updates(remote, callbacks, &refs, reflog_message);\n\nout:\n\tgit_vector_free(&refs);\n\tgit_refspec__free(&tagspec);\n\treturn error;\n}"
  },
  {
    "function_name": "opportunistic_updates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1506-1560",
    "snippet": "static int opportunistic_updates(const git_remote *remote, const git_remote_callbacks *callbacks,\n\t\t\t\t git_vector *refs, const char *msg)\n{\n\tsize_t i, j, k;\n\tgit_refspec *spec;\n\tgit_remote_head *head;\n\tgit_reference *ref;\n\tgit_buf refname = GIT_BUF_INIT;\n\tint error = 0;\n\n\ti = j = k = 0;\n\n\twhile ((error = next_head(remote, refs, &spec, &head, &i, &j, &k)) == 0) {\n\t\tgit_oid old = {{ 0 }};\n\t\t/*\n\t\t * If we got here, there is a refspec which was used\n\t\t * for fetching which matches the source of one of the\n\t\t * passive refspecs, so we should update that\n\t\t * remote-tracking branch, but not add it to\n\t\t * FETCH_HEAD\n\t\t */\n\n\t\tgit_buf_clear(&refname);\n\t\tif ((error = git_refspec_transform(&refname, spec, head->name)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_reference_name_to_id(&old, remote->repo, refname.ptr);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_oid_cmp(&old, &head->oid))\n\t\t\tcontinue;\n\n\t\t/* If we did find a current reference, make sure we haven't lost a race */\n\t\tif (error)\n\t\t\terror = git_reference_create(&ref, remote->repo, refname.ptr, &head->oid, true, msg);\n\t\telse\n\t\t\terror = git_reference_create_matching(&ref, remote->repo, refname.ptr, &head->oid, true, &old, msg);\n\t\tgit_reference_free(ref);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (callbacks && callbacks->update_tips != NULL) {\n\t\t\tif (callbacks->update_tips(refname.ptr, &old, &head->oid, callbacks->payload) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\ncleanup:\n\tgit_buf_free(&refname);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&refname"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "callbacks->update_tips",
          "args": [
            "refname.ptr",
            "&old",
            "&head->oid",
            "callbacks->payload"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_create_matching",
          "args": [
            "&ref",
            "remote->repo",
            "refname.ptr",
            "&head->oid",
            "true",
            "&old",
            "msg"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create_matching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "439-462",
          "snippet": "int git_reference_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst git_oid *old_id,\n\tconst char *log_message)\n\n{\n\tint error;\n\tgit_signature *who = NULL;\n\t\n\tassert(id);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, id, NULL, force, who, log_message, old_id, NULL);\n\n\tgit_signature_free(who);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create_matching(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst git_oid *old_id,\n\tconst char *log_message)\n\n{\n\tint error;\n\tgit_signature *who = NULL;\n\t\n\tassert(id);\n\n\tif ((error = git_reference__log_signature(&who, repo)) < 0)\n\t\treturn error;\n\n\terror = reference__create(\n\t\tref_out, repo, name, id, NULL, force, who, log_message, old_id, NULL);\n\n\tgit_signature_free(who);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_create",
          "args": [
            "&ref",
            "remote->repo",
            "refname.ptr",
            "&head->oid",
            "true",
            "msg"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "464-473",
          "snippet": "int git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "&old",
            "&head->oid"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name_to_id",
          "args": [
            "&old",
            "remote->repo",
            "refname.ptr"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name_to_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "152-164",
          "snippet": "int git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_transform",
          "args": [
            "&refname",
            "spec",
            "head->name"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "244-258",
          "snippet": "int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&refname"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_head",
          "args": [
            "remote",
            "refs",
            "&spec",
            "&head",
            "&i",
            "&j",
            "&k"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "next_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1456-1504",
          "snippet": "static int next_head(const git_remote *remote, git_vector *refs,\n\t\t     git_refspec **out_spec, git_remote_head **out_head,\n\t\t     size_t *out_i, size_t *out_j, size_t *out_k)\n{\n\tconst git_vector *active, *passive;\n\tgit_remote_head *head;\n\tgit_refspec *spec, *passive_spec;\n\tsize_t i, j, k;\n\n\tactive = &remote->active_refspecs;\n\tpassive = &remote->passive_refspecs;\n\n\ti = *out_i;\n\tj = *out_j;\n\tk = *out_k;\n\n\tfor (; i < refs->length; i++) {\n\t\thead = git_vector_get(refs, i);\n\n\t\tif (!git_reference_is_valid_name(head->name))\n\t\t\tcontinue;\n\n\t\tfor (; j < active->length; j++) {\n\t\t\tspec = git_vector_get(active, j);\n\n\t\t\tif (!git_refspec_src_matches(spec, head->name))\n\t\t\t\tcontinue;\n\n\t\t\tfor (; k < passive->length; k++) {\n\t\t\t\tpassive_spec = git_vector_get(passive, k);\n\n\t\t\t\tif (!git_refspec_src_matches(passive_spec, head->name))\n\t\t\t\t    continue;\n\n\t\t\t\t*out_spec = passive_spec;\n\t\t\t\t*out_head = head;\n\t\t\t\t*out_i = i;\n\t\t\t\t*out_j = j;\n\t\t\t\t*out_k = k + 1;\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tk = 0;\n\t\t}\n\t\tj = 0;\n\t}\n\n\treturn GIT_ITEROVER;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int next_head(const git_remote *remote, git_vector *refs,\n\t\t     git_refspec **out_spec, git_remote_head **out_head,\n\t\t     size_t *out_i, size_t *out_j, size_t *out_k)\n{\n\tconst git_vector *active, *passive;\n\tgit_remote_head *head;\n\tgit_refspec *spec, *passive_spec;\n\tsize_t i, j, k;\n\n\tactive = &remote->active_refspecs;\n\tpassive = &remote->passive_refspecs;\n\n\ti = *out_i;\n\tj = *out_j;\n\tk = *out_k;\n\n\tfor (; i < refs->length; i++) {\n\t\thead = git_vector_get(refs, i);\n\n\t\tif (!git_reference_is_valid_name(head->name))\n\t\t\tcontinue;\n\n\t\tfor (; j < active->length; j++) {\n\t\t\tspec = git_vector_get(active, j);\n\n\t\t\tif (!git_refspec_src_matches(spec, head->name))\n\t\t\t\tcontinue;\n\n\t\t\tfor (; k < passive->length; k++) {\n\t\t\t\tpassive_spec = git_vector_get(passive, k);\n\n\t\t\t\tif (!git_refspec_src_matches(passive_spec, head->name))\n\t\t\t\t    continue;\n\n\t\t\t\t*out_spec = passive_spec;\n\t\t\t\t*out_head = head;\n\t\t\t\t*out_i = i;\n\t\t\t\t*out_j = j;\n\t\t\t\t*out_k = k + 1;\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tk = 0;\n\t\t}\n\t\tj = 0;\n\t}\n\n\treturn GIT_ITEROVER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int opportunistic_updates(const git_remote *remote, const git_remote_callbacks *callbacks,\n\t\t\t\t git_vector *refs, const char *msg)\n{\n\tsize_t i, j, k;\n\tgit_refspec *spec;\n\tgit_remote_head *head;\n\tgit_reference *ref;\n\tgit_buf refname = GIT_BUF_INIT;\n\tint error = 0;\n\n\ti = j = k = 0;\n\n\twhile ((error = next_head(remote, refs, &spec, &head, &i, &j, &k)) == 0) {\n\t\tgit_oid old = {{ 0 }};\n\t\t/*\n\t\t * If we got here, there is a refspec which was used\n\t\t * for fetching which matches the source of one of the\n\t\t * passive refspecs, so we should update that\n\t\t * remote-tracking branch, but not add it to\n\t\t * FETCH_HEAD\n\t\t */\n\n\t\tgit_buf_clear(&refname);\n\t\tif ((error = git_refspec_transform(&refname, spec, head->name)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_reference_name_to_id(&old, remote->repo, refname.ptr);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_oid_cmp(&old, &head->oid))\n\t\t\tcontinue;\n\n\t\t/* If we did find a current reference, make sure we haven't lost a race */\n\t\tif (error)\n\t\t\terror = git_reference_create(&ref, remote->repo, refname.ptr, &head->oid, true, msg);\n\t\telse\n\t\t\terror = git_reference_create_matching(&ref, remote->repo, refname.ptr, &head->oid, true, &old, msg);\n\t\tgit_reference_free(ref);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (callbacks && callbacks->update_tips != NULL) {\n\t\t\tif (callbacks->update_tips(refname.ptr, &old, &head->oid, callbacks->payload) < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\ncleanup:\n\tgit_buf_free(&refname);\n\treturn error;\n}"
  },
  {
    "function_name": "next_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1456-1504",
    "snippet": "static int next_head(const git_remote *remote, git_vector *refs,\n\t\t     git_refspec **out_spec, git_remote_head **out_head,\n\t\t     size_t *out_i, size_t *out_j, size_t *out_k)\n{\n\tconst git_vector *active, *passive;\n\tgit_remote_head *head;\n\tgit_refspec *spec, *passive_spec;\n\tsize_t i, j, k;\n\n\tactive = &remote->active_refspecs;\n\tpassive = &remote->passive_refspecs;\n\n\ti = *out_i;\n\tj = *out_j;\n\tk = *out_k;\n\n\tfor (; i < refs->length; i++) {\n\t\thead = git_vector_get(refs, i);\n\n\t\tif (!git_reference_is_valid_name(head->name))\n\t\t\tcontinue;\n\n\t\tfor (; j < active->length; j++) {\n\t\t\tspec = git_vector_get(active, j);\n\n\t\t\tif (!git_refspec_src_matches(spec, head->name))\n\t\t\t\tcontinue;\n\n\t\t\tfor (; k < passive->length; k++) {\n\t\t\t\tpassive_spec = git_vector_get(passive, k);\n\n\t\t\t\tif (!git_refspec_src_matches(passive_spec, head->name))\n\t\t\t\t    continue;\n\n\t\t\t\t*out_spec = passive_spec;\n\t\t\t\t*out_head = head;\n\t\t\t\t*out_i = i;\n\t\t\t\t*out_j = j;\n\t\t\t\t*out_k = k + 1;\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tk = 0;\n\t\t}\n\t\tj = 0;\n\t}\n\n\treturn GIT_ITEROVER;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refspec_src_matches",
          "args": [
            "passive_spec",
            "head->name"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_src_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "185-191",
          "snippet": "int git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "passive",
            "k"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_valid_name",
          "args": [
            "head->name"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1279-1282",
          "snippet": "int git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int next_head(const git_remote *remote, git_vector *refs,\n\t\t     git_refspec **out_spec, git_remote_head **out_head,\n\t\t     size_t *out_i, size_t *out_j, size_t *out_k)\n{\n\tconst git_vector *active, *passive;\n\tgit_remote_head *head;\n\tgit_refspec *spec, *passive_spec;\n\tsize_t i, j, k;\n\n\tactive = &remote->active_refspecs;\n\tpassive = &remote->passive_refspecs;\n\n\ti = *out_i;\n\tj = *out_j;\n\tk = *out_k;\n\n\tfor (; i < refs->length; i++) {\n\t\thead = git_vector_get(refs, i);\n\n\t\tif (!git_reference_is_valid_name(head->name))\n\t\t\tcontinue;\n\n\t\tfor (; j < active->length; j++) {\n\t\t\tspec = git_vector_get(active, j);\n\n\t\t\tif (!git_refspec_src_matches(spec, head->name))\n\t\t\t\tcontinue;\n\n\t\t\tfor (; k < passive->length; k++) {\n\t\t\t\tpassive_spec = git_vector_get(passive, k);\n\n\t\t\t\tif (!git_refspec_src_matches(passive_spec, head->name))\n\t\t\t\t    continue;\n\n\t\t\t\t*out_spec = passive_spec;\n\t\t\t\t*out_head = head;\n\t\t\t\t*out_i = i;\n\t\t\t\t*out_j = j;\n\t\t\t\t*out_k = k + 1;\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tk = 0;\n\t\t}\n\t\tj = 0;\n\t}\n\n\treturn GIT_ITEROVER;\n}"
  },
  {
    "function_name": "update_tips_for_spec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1318-1447",
    "snippet": "static int update_tips_for_spec(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t tagopt,\n\t\tgit_refspec *spec,\n\t\tgit_vector *refs,\n\t\tconst char *log_message)\n{\n\tint error = 0, autotag;\n\tunsigned int i = 0;\n\tgit_buf refname = GIT_BUF_INIT;\n\tgit_oid old;\n\tgit_odb *odb;\n\tgit_remote_head *head;\n\tgit_reference *ref;\n\tgit_refspec tagspec;\n\tgit_vector update_heads;\n\n\tassert(remote);\n\n\tif (git_repository_odb__weakptr(&odb, remote->repo) < 0)\n\t\treturn -1;\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\t/* Make a copy of the transport's refs */\n\tif (git_vector_init(&update_heads, 16, NULL) < 0)\n\t\treturn -1;\n\n\tfor (; i < refs->length; ++i) {\n\t\thead = git_vector_get(refs, i);\n\t\tautotag = 0;\n\t\tgit_buf_clear(&refname);\n\n\t\t/* Ignore malformed ref names (which also saves us from tag^{} */\n\t\tif (!git_reference_is_valid_name(head->name))\n\t\t\tcontinue;\n\n\t\t/* If we have a tag, see if the auto-follow rules say to update it */\n\t\tif (git_refspec_src_matches(&tagspec, head->name)) {\n\t\t\tif (tagopt != GIT_REMOTE_DOWNLOAD_TAGS_NONE) {\n\n\t\t\t\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_AUTO)\n\t\t\t\t\tautotag = 1;\n\n\t\t\t\tgit_buf_clear(&refname);\n\t\t\t\tif (git_buf_puts(&refname, head->name) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\t/* If we didn't want to auto-follow the tag, check if the refspec matches */\n\t\tif (!autotag && git_refspec_src_matches(spec, head->name)) {\n\t\t\tif (spec->dst) {\n\t\t\t\tif (git_refspec_transform(&refname, spec, head->name) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no rhs mans store it in FETCH_HEAD, even if we don't\n\t\t\t\t update anything else.\n\t\t\t\t */\n\t\t\t\tif ((error = git_vector_insert(&update_heads, head)) < 0)\n\t\t\t\t\tgoto on_error;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* If we still don't have a refname, we don't want it */\n\t\tif (git_buf_len(&refname) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In autotag mode, only create tags for objects already in db */\n\t\tif (autotag && !git_odb_exists(odb, &head->oid))\n\t\t\tcontinue;\n\n\t\tif (!autotag && git_vector_insert(&update_heads, head) < 0)\n\t\t\tgoto on_error;\n\n\t\terror = git_reference_name_to_id(&old, remote->repo, refname.ptr);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto on_error;\n\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tmemset(&old, 0, GIT_OID_RAWSZ);\n\n\t\t\tif (autotag && git_vector_insert(&update_heads, head) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!git_oid__cmp(&old, &head->oid))\n\t\t\tcontinue;\n\n\t\t/* In autotag mode, don't overwrite any locally-existing tags */\n\t\terror = git_reference_create(&ref, remote->repo, refname.ptr, &head->oid, !autotag, \n\t\t\t\tlog_message);\n\n\t\tif (error == GIT_EEXISTS)\n\t\t\tcontinue;\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\n\t\tif (callbacks && callbacks->update_tips != NULL) {\n\t\t\tif (callbacks->update_tips(refname.ptr, &old, &head->oid, callbacks->payload) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif (update_fetchhead &&\n\t    (error = git_remote_write_fetchhead(remote, spec, &update_heads)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_free(&update_heads);\n\tgit_refspec__free(&tagspec);\n\tgit_buf_free(&refname);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&update_heads);\n\tgit_refspec__free(&tagspec);\n\tgit_buf_free(&refname);\n\treturn -1;\n\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&refname"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "&tagspec"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&update_heads"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_write_fetchhead",
          "args": [
            "remote",
            "spec",
            "&update_heads"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_write_fetchhead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1111-1174",
          "snippet": "static int git_remote_write_fetchhead(git_remote *remote, git_refspec *spec, git_vector *update_heads)\n{\n\tgit_reference *head_ref = NULL;\n\tgit_fetchhead_ref *fetchhead_ref;\n\tgit_remote_head *remote_ref, *merge_remote_ref;\n\tgit_vector fetchhead_refs;\n\tbool include_all_fetchheads;\n\tunsigned int i = 0;\n\tint error = 0;\n\n\tassert(remote);\n\n\t/* no heads, nothing to do */\n\tif (update_heads->length == 0)\n\t\treturn 0;\n\n\tif (git_vector_init(&fetchhead_refs, update_heads->length, git_fetchhead_ref_cmp) < 0)\n\t\treturn -1;\n\n\t/* Iff refspec is * (but not subdir slash star), include tags */\n\tinclude_all_fetchheads = (strcmp(GIT_REFS_HEADS_DIR \"*\", git_refspec_src(spec)) == 0);\n\n\t/* Determine what to merge: if refspec was a wildcard, just use HEAD */\n\tif (git_refspec_is_wildcard(spec)) {\n\t\tif ((error = git_reference_lookup(&head_ref, remote->repo, GIT_HEAD_FILE)) < 0 ||\n\t\t\t(error = remote_head_for_ref(&merge_remote_ref, remote, spec, update_heads, head_ref)) < 0)\n\t\t\t\tgoto cleanup;\n\t} else {\n\t\t/* If we're fetching a single refspec, that's the only thing that should be in FETCH_HEAD. */\n\t\tif ((error = remote_head_for_fetchspec_src(&merge_remote_ref, update_heads, git_refspec_src(spec))) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Create the FETCH_HEAD file */\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tint merge_this_fetchhead = (merge_remote_ref == remote_ref);\n\n\t\tif (!include_all_fetchheads &&\n\t\t\t!git_refspec_src_matches(spec, remote_ref->name) &&\n\t\t\t!merge_this_fetchhead)\n\t\t\tcontinue;\n\n\t\tif (git_fetchhead_ref_create(&fetchhead_ref,\n\t\t\t&remote_ref->oid,\n\t\t\tmerge_this_fetchhead,\n\t\t\tremote_ref->name,\n\t\t\tgit_remote_url(remote)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_vector_insert(&fetchhead_refs, fetchhead_ref) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tgit_fetchhead_write(remote->repo, &fetchhead_refs);\n\ncleanup:\n\tfor (i = 0; i < fetchhead_refs.length; ++i)\n\t\tgit_fetchhead_ref_free(fetchhead_refs.contents[i]);\n\n\tgit_vector_free(&fetchhead_refs);\n\tgit_reference_free(head_ref);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int git_remote_write_fetchhead(git_remote *remote, git_refspec *spec, git_vector *update_heads)\n{\n\tgit_reference *head_ref = NULL;\n\tgit_fetchhead_ref *fetchhead_ref;\n\tgit_remote_head *remote_ref, *merge_remote_ref;\n\tgit_vector fetchhead_refs;\n\tbool include_all_fetchheads;\n\tunsigned int i = 0;\n\tint error = 0;\n\n\tassert(remote);\n\n\t/* no heads, nothing to do */\n\tif (update_heads->length == 0)\n\t\treturn 0;\n\n\tif (git_vector_init(&fetchhead_refs, update_heads->length, git_fetchhead_ref_cmp) < 0)\n\t\treturn -1;\n\n\t/* Iff refspec is * (but not subdir slash star), include tags */\n\tinclude_all_fetchheads = (strcmp(GIT_REFS_HEADS_DIR \"*\", git_refspec_src(spec)) == 0);\n\n\t/* Determine what to merge: if refspec was a wildcard, just use HEAD */\n\tif (git_refspec_is_wildcard(spec)) {\n\t\tif ((error = git_reference_lookup(&head_ref, remote->repo, GIT_HEAD_FILE)) < 0 ||\n\t\t\t(error = remote_head_for_ref(&merge_remote_ref, remote, spec, update_heads, head_ref)) < 0)\n\t\t\t\tgoto cleanup;\n\t} else {\n\t\t/* If we're fetching a single refspec, that's the only thing that should be in FETCH_HEAD. */\n\t\tif ((error = remote_head_for_fetchspec_src(&merge_remote_ref, update_heads, git_refspec_src(spec))) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Create the FETCH_HEAD file */\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tint merge_this_fetchhead = (merge_remote_ref == remote_ref);\n\n\t\tif (!include_all_fetchheads &&\n\t\t\t!git_refspec_src_matches(spec, remote_ref->name) &&\n\t\t\t!merge_this_fetchhead)\n\t\t\tcontinue;\n\n\t\tif (git_fetchhead_ref_create(&fetchhead_ref,\n\t\t\t&remote_ref->oid,\n\t\t\tmerge_this_fetchhead,\n\t\t\tremote_ref->name,\n\t\t\tgit_remote_url(remote)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_vector_insert(&fetchhead_refs, fetchhead_ref) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tgit_fetchhead_write(remote->repo, &fetchhead_refs);\n\ncleanup:\n\tfor (i = 0; i < fetchhead_refs.length; ++i)\n\t\tgit_fetchhead_ref_free(fetchhead_refs.contents[i]);\n\n\tgit_vector_free(&fetchhead_refs);\n\tgit_reference_free(head_ref);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "callbacks->update_tips",
          "args": [
            "refname.ptr",
            "&old",
            "&head->oid",
            "callbacks->payload"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_create",
          "args": [
            "&ref",
            "remote->repo",
            "refname.ptr",
            "&head->oid",
            "!autotag",
            "log_message"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "464-473",
          "snippet": "int git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&old",
            "&head->oid"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&update_heads",
            "head"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&old",
            "0",
            "GIT_OID_RAWSZ"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_name_to_id",
          "args": [
            "&old",
            "remote->repo",
            "refname.ptr"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name_to_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "152-164",
          "snippet": "int git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_exists",
          "args": [
            "odb",
            "&head->oid"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "646-665",
          "snippet": "int git_odb_exists(git_odb *db, const git_oid *id)\n{\n\tgit_odb_object *object;\n\n\tassert(db && id);\n\n\tif ((object = git_cache_get_raw(odb_cache(db), id)) != NULL) {\n\t\tgit_odb_object_free(object);\n\t\treturn (int)true;\n\t}\n\n\tif (odb_exists_1(db, id, false))\n\t\treturn 1;\n\n\tif (!git_odb_refresh(db))\n\t\treturn odb_exists_1(db, id, true);\n\n\t/* Failed to refresh, hence not found */\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_exists(git_odb *db, const git_oid *id)\n{\n\tgit_odb_object *object;\n\n\tassert(db && id);\n\n\tif ((object = git_cache_get_raw(odb_cache(db), id)) != NULL) {\n\t\tgit_odb_object_free(object);\n\t\treturn (int)true;\n\t}\n\n\tif (odb_exists_1(db, id, false))\n\t\treturn 1;\n\n\tif (!git_odb_refresh(db))\n\t\treturn odb_exists_1(db, id, true);\n\n\t/* Failed to refresh, hence not found */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&refname"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_transform",
          "args": [
            "&refname",
            "spec",
            "head->name"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "244-258",
          "snippet": "int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_src_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the source\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->dst);\n\n\treturn refspec_transform(out, spec->src, spec->dst, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_src_matches",
          "args": [
            "spec",
            "head->name"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_src_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "185-191",
          "snippet": "int git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&refname",
            "head->name"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&refname"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_valid_name",
          "args": [
            "head->name"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1279-1282",
          "snippet": "int git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_valid_name(const char *refname)\n{\n\treturn git_reference__is_valid_name(refname, GIT_REF_FORMAT_ALLOW_ONELEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "refs",
            "i"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&update_heads",
            "16",
            "NULL"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__parse",
          "args": [
            "&tagspec",
            "GIT_REFSPEC_TAGS",
            "true"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "17-149",
          "snippet": "int git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "remote->repo"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int update_tips_for_spec(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t tagopt,\n\t\tgit_refspec *spec,\n\t\tgit_vector *refs,\n\t\tconst char *log_message)\n{\n\tint error = 0, autotag;\n\tunsigned int i = 0;\n\tgit_buf refname = GIT_BUF_INIT;\n\tgit_oid old;\n\tgit_odb *odb;\n\tgit_remote_head *head;\n\tgit_reference *ref;\n\tgit_refspec tagspec;\n\tgit_vector update_heads;\n\n\tassert(remote);\n\n\tif (git_repository_odb__weakptr(&odb, remote->repo) < 0)\n\t\treturn -1;\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\t/* Make a copy of the transport's refs */\n\tif (git_vector_init(&update_heads, 16, NULL) < 0)\n\t\treturn -1;\n\n\tfor (; i < refs->length; ++i) {\n\t\thead = git_vector_get(refs, i);\n\t\tautotag = 0;\n\t\tgit_buf_clear(&refname);\n\n\t\t/* Ignore malformed ref names (which also saves us from tag^{} */\n\t\tif (!git_reference_is_valid_name(head->name))\n\t\t\tcontinue;\n\n\t\t/* If we have a tag, see if the auto-follow rules say to update it */\n\t\tif (git_refspec_src_matches(&tagspec, head->name)) {\n\t\t\tif (tagopt != GIT_REMOTE_DOWNLOAD_TAGS_NONE) {\n\n\t\t\t\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_AUTO)\n\t\t\t\t\tautotag = 1;\n\n\t\t\t\tgit_buf_clear(&refname);\n\t\t\t\tif (git_buf_puts(&refname, head->name) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\t/* If we didn't want to auto-follow the tag, check if the refspec matches */\n\t\tif (!autotag && git_refspec_src_matches(spec, head->name)) {\n\t\t\tif (spec->dst) {\n\t\t\t\tif (git_refspec_transform(&refname, spec, head->name) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no rhs mans store it in FETCH_HEAD, even if we don't\n\t\t\t\t update anything else.\n\t\t\t\t */\n\t\t\t\tif ((error = git_vector_insert(&update_heads, head)) < 0)\n\t\t\t\t\tgoto on_error;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* If we still don't have a refname, we don't want it */\n\t\tif (git_buf_len(&refname) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In autotag mode, only create tags for objects already in db */\n\t\tif (autotag && !git_odb_exists(odb, &head->oid))\n\t\t\tcontinue;\n\n\t\tif (!autotag && git_vector_insert(&update_heads, head) < 0)\n\t\t\tgoto on_error;\n\n\t\terror = git_reference_name_to_id(&old, remote->repo, refname.ptr);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto on_error;\n\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tmemset(&old, 0, GIT_OID_RAWSZ);\n\n\t\t\tif (autotag && git_vector_insert(&update_heads, head) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (!git_oid__cmp(&old, &head->oid))\n\t\t\tcontinue;\n\n\t\t/* In autotag mode, don't overwrite any locally-existing tags */\n\t\terror = git_reference_create(&ref, remote->repo, refname.ptr, &head->oid, !autotag, \n\t\t\t\tlog_message);\n\n\t\tif (error == GIT_EEXISTS)\n\t\t\tcontinue;\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\n\t\tif (callbacks && callbacks->update_tips != NULL) {\n\t\t\tif (callbacks->update_tips(refname.ptr, &old, &head->oid, callbacks->payload) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif (update_fetchhead &&\n\t    (error = git_remote_write_fetchhead(remote, spec, &update_heads)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_free(&update_heads);\n\tgit_refspec__free(&tagspec);\n\tgit_buf_free(&refname);\n\treturn 0;\n\non_error:\n\tgit_vector_free(&update_heads);\n\tgit_refspec__free(&tagspec);\n\tgit_buf_free(&refname);\n\treturn -1;\n\n}"
  },
  {
    "function_name": "git_remote_prune",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1216-1316",
    "snippet": "int git_remote_prune(git_remote *remote, const git_remote_callbacks *callbacks)\n{\n\tsize_t i, j;\n\tgit_vector remote_refs = GIT_VECTOR_INIT;\n\tgit_vector candidates = GIT_VECTOR_INIT;\n\tconst git_refspec *spec;\n\tconst char *refname;\n\tint error;\n\tgit_oid zero_id = {{ 0 }};\n\n\tif (callbacks)\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\n\tif ((error = ls_to_vector(&remote_refs, remote)) < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_set_cmp(&remote_refs, find_head);\n\n\tif ((error = prune_candidates(&candidates, remote)) < 0)\n\t\tgoto cleanup;\n\n\t/*\n\t * Remove those entries from the candidate list for which we\n\t * can find a remote reference in at least one refspec.\n\t */\n\tgit_vector_foreach(&candidates, i, refname) {\n\t\tgit_vector_foreach(&remote->active_refspecs, j, spec) {\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t pos;\n\t\t\tchar *src_name;\n\t\t\tgit_remote_head key = {0};\n\n\t\t\tif (!git_refspec_dst_matches(spec, refname))\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_refspec_rtransform(&buf, spec, refname)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\terror = git_vector_search(&pos, &remote_refs, &key);\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\tcontinue;\n\n\t\t\t/* if we did find a source, remove it from the candiates */\n\t\t\tif ((error = git_vector_set((void **) &src_name, &candidates, i, NULL)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit__free(src_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * For those candidates still left in the list, we need to\n\t * remove them. We do not remove symrefs, as those are for\n\t * stuff like origin/HEAD which will never match, but we do\n\t * not want to remove them.\n\t */\n\tgit_vector_foreach(&candidates, i, refname) {\n\t\tgit_reference *ref;\n\t\tgit_oid id;\n\n\t\tif (refname == NULL)\n\t\t\tcontinue;\n\n\t\terror = git_reference_lookup(&ref, remote->repo, refname);\n\t\t/* as we want it gone, let's not consider this an error */\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tcontinue;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC) {\n\t\t\tgit_reference_free(ref);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgit_oid_cpy(&id, git_reference_target(ref));\n\t\terror = git_reference_delete(ref);\n\t\tgit_reference_free(ref);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (callbacks && callbacks->update_tips)\n\t\t\terror = callbacks->update_tips(refname, &id, &zero_id, callbacks->payload);\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_vector_free(&remote_refs);\n\tgit_vector_free_deep(&candidates);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&candidates"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "callbacks->update_tips",
          "args": [
            "refname",
            "&id",
            "&zero_id",
            "callbacks->payload"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_delete",
          "args": [
            "ref"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "122-133",
          "snippet": "int git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_delete(git_reference *ref)\n{\n\tconst git_oid *old_id = NULL;\n\tconst char *old_target = NULL;\n\n\tif (ref->type == GIT_REF_OID)\n\t\told_id = &ref->target.oid;\n\telse\n\t\told_target = ref->target.symbolic;\n\n\treturn git_refdb_delete(ref->db, ref->name, old_id, old_target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&id",
            "git_reference_target(ref)"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "ref"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_type",
          "args": [
            "ref"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "303-307",
          "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&ref",
            "remote->repo",
            "refname"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&candidates",
            "i",
            "refname"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "src_name"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set",
          "args": [
            "(void **) &src_name",
            "&candidates",
            "i",
            "NULL"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "333-346",
          "snippet": "int git_vector_set(void **old, git_vector *v, size_t position, void *value)\n{\n\tif (position + 1 > v->length) {\n\t\tif (git_vector_resize_to(v, position + 1) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (old != NULL)\n\t\t*old = v->contents[position];\n\n\tv->contents[position] = value;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_set(void **old, git_vector *v, size_t position, void *value)\n{\n\tif (position + 1 > v->length) {\n\t\tif (git_vector_resize_to(v, position + 1) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (old != NULL)\n\t\t*old = v->contents[position];\n\n\tv->contents[position] = value;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_search",
          "args": [
            "&pos",
            "&remote_refs",
            "&key"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "228-231",
          "snippet": "int git_vector_search(size_t *at_pos, const git_vector *v, const void *entry)\n{\n\treturn git_vector_search2(at_pos, v, v->_cmp ? v->_cmp : strict_comparison, entry);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_search(size_t *at_pos, const git_vector *v, const void *entry)\n{\n\treturn git_vector_search2(at_pos, v, v->_cmp ? v->_cmp : strict_comparison, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_rtransform",
          "args": [
            "&buf",
            "spec",
            "refname"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_rtransform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "260-274",
          "snippet": "int git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_dst_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the destination\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->src);\n\n\treturn refspec_transform(out, spec->dst, spec->src, name);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_dst_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the destination\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->src);\n\n\treturn refspec_transform(out, spec->dst, spec->src, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_dst_matches",
          "args": [
            "spec",
            "refname"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_dst_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "193-199",
          "snippet": "int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&remote->active_refspecs",
            "j",
            "spec"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&candidates",
            "i",
            "refname"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prune_candidates",
          "args": [
            "&candidates",
            "remote"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "prune_candidates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1180-1206",
          "snippet": "static int prune_candidates(git_vector *candidates, git_remote *remote)\n{\n\tgit_strarray arr = { 0 };\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_reference_list(&arr, remote->repo)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < arr.count; i++) {\n\t\tconst char *refname = arr.strings[i];\n\t\tchar *refname_dup;\n\n\t\tif (!git_remote__matching_dst_refspec(remote, refname))\n\t\t\tcontinue;\n\n\t\trefname_dup = git__strdup(refname);\n\t\tGITERR_CHECK_ALLOC(refname_dup);\n\n\t\tif ((error = git_vector_insert(candidates, refname_dup)) < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tgit_strarray_free(&arr);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int prune_candidates(git_vector *candidates, git_remote *remote)\n{\n\tgit_strarray arr = { 0 };\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_reference_list(&arr, remote->repo)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < arr.count; i++) {\n\t\tconst char *refname = arr.strings[i];\n\t\tchar *refname_dup;\n\n\t\tif (!git_remote__matching_dst_refspec(remote, refname))\n\t\t\tcontinue;\n\n\t\trefname_dup = git__strdup(refname);\n\t\tGITERR_CHECK_ALLOC(refname_dup);\n\n\t\tif ((error = git_vector_insert(candidates, refname_dup)) < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tgit_strarray_free(&arr);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_cmp",
          "args": [
            "&remote_refs",
            "find_head"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "107-113",
          "snippet": "GIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_to_vector",
          "args": [
            "&remote_refs",
            "remote"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ls_to_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "873-890",
          "snippet": "static int ls_to_vector(git_vector *out, git_remote *remote)\n{\n\tgit_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tif (git_vector_init(out, heads_len, remote_head_cmp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(out, heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int ls_to_vector(git_vector *out, git_remote *remote)\n{\n\tgit_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tif (git_vector_init(out, heads_len, remote_head_cmp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(out, heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "callbacks",
            "GIT_REMOTE_CALLBACKS_VERSION",
            "\"git_remote_callbacks\""
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_prune(git_remote *remote, const git_remote_callbacks *callbacks)\n{\n\tsize_t i, j;\n\tgit_vector remote_refs = GIT_VECTOR_INIT;\n\tgit_vector candidates = GIT_VECTOR_INIT;\n\tconst git_refspec *spec;\n\tconst char *refname;\n\tint error;\n\tgit_oid zero_id = {{ 0 }};\n\n\tif (callbacks)\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\n\tif ((error = ls_to_vector(&remote_refs, remote)) < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_set_cmp(&remote_refs, find_head);\n\n\tif ((error = prune_candidates(&candidates, remote)) < 0)\n\t\tgoto cleanup;\n\n\t/*\n\t * Remove those entries from the candidate list for which we\n\t * can find a remote reference in at least one refspec.\n\t */\n\tgit_vector_foreach(&candidates, i, refname) {\n\t\tgit_vector_foreach(&remote->active_refspecs, j, spec) {\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t pos;\n\t\t\tchar *src_name;\n\t\t\tgit_remote_head key = {0};\n\n\t\t\tif (!git_refspec_dst_matches(spec, refname))\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_refspec_rtransform(&buf, spec, refname)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\terror = git_vector_search(&pos, &remote_refs, &key);\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\tcontinue;\n\n\t\t\t/* if we did find a source, remove it from the candiates */\n\t\t\tif ((error = git_vector_set((void **) &src_name, &candidates, i, NULL)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit__free(src_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * For those candidates still left in the list, we need to\n\t * remove them. We do not remove symrefs, as those are for\n\t * stuff like origin/HEAD which will never match, but we do\n\t * not want to remove them.\n\t */\n\tgit_vector_foreach(&candidates, i, refname) {\n\t\tgit_reference *ref;\n\t\tgit_oid id;\n\n\t\tif (refname == NULL)\n\t\t\tcontinue;\n\n\t\terror = git_reference_lookup(&ref, remote->repo, refname);\n\t\t/* as we want it gone, let's not consider this an error */\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tcontinue;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC) {\n\t\t\tgit_reference_free(ref);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgit_oid_cpy(&id, git_reference_target(ref));\n\t\terror = git_reference_delete(ref);\n\t\tgit_reference_free(ref);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (callbacks && callbacks->update_tips)\n\t\t\terror = callbacks->update_tips(refname, &id, &zero_id, callbacks->payload);\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_vector_free(&remote_refs);\n\tgit_vector_free_deep(&candidates);\n\treturn error;\n}"
  },
  {
    "function_name": "find_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1208-1214",
    "snippet": "static int find_head(const void *_a, const void *_b)\n{\n\tgit_remote_head *a = (git_remote_head *) _a;\n\tgit_remote_head *b = (git_remote_head *) _b;\n\n\treturn strcmp(a->name, b->name);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->name",
            "b->name"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int find_head(const void *_a, const void *_b)\n{\n\tgit_remote_head *a = (git_remote_head *) _a;\n\tgit_remote_head *b = (git_remote_head *) _b;\n\n\treturn strcmp(a->name, b->name);\n}"
  },
  {
    "function_name": "prune_candidates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1180-1206",
    "snippet": "static int prune_candidates(git_vector *candidates, git_remote *remote)\n{\n\tgit_strarray arr = { 0 };\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_reference_list(&arr, remote->repo)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < arr.count; i++) {\n\t\tconst char *refname = arr.strings[i];\n\t\tchar *refname_dup;\n\n\t\tif (!git_remote__matching_dst_refspec(remote, refname))\n\t\t\tcontinue;\n\n\t\trefname_dup = git__strdup(refname);\n\t\tGITERR_CHECK_ALLOC(refname_dup);\n\n\t\tif ((error = git_vector_insert(candidates, refname_dup)) < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tgit_strarray_free(&arr);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strarray_free",
          "args": [
            "&arr"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "git_strarray_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "21-34",
          "snippet": "void git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nvoid git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "candidates",
            "refname_dup"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "refname_dup"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "refname"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__matching_dst_refspec",
          "args": [
            "remote",
            "refname"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__matching_dst_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2071-2085",
          "snippet": "git_refspec *git_remote__matching_dst_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_dst_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_refspec *git_remote__matching_dst_refspec(git_remote *remote, const char *refname)\n{\n\tgit_refspec *spec;\n\tsize_t i;\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif (git_refspec_dst_matches(spec, refname))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_list",
          "args": [
            "&arr",
            "remote->repo"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "757-780",
          "snippet": "int git_reference_list(\n\tgit_strarray *array,\n\tgit_repository *repo)\n{\n\tgit_vector ref_list;\n\n\tassert(array && repo);\n\n\tarray->strings = NULL;\n\tarray->count = 0;\n\n\tif (git_vector_init(&ref_list, 8, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_reference_foreach_name(\n\t\t\trepo, &cb__reflist_add, (void *)&ref_list) < 0) {\n\t\tgit_vector_free(&ref_list);\n\t\treturn -1;\n\t}\n\n\tarray->strings = (char **)git_vector_detach(&array->count, NULL, &ref_list);\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_list(\n\tgit_strarray *array,\n\tgit_repository *repo)\n{\n\tgit_vector ref_list;\n\n\tassert(array && repo);\n\n\tarray->strings = NULL;\n\tarray->count = 0;\n\n\tif (git_vector_init(&ref_list, 8, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_reference_foreach_name(\n\t\t\trepo, &cb__reflist_add, (void *)&ref_list) < 0) {\n\t\tgit_vector_free(&ref_list);\n\t\treturn -1;\n\t}\n\n\tarray->strings = (char **)git_vector_detach(&array->count, NULL, &ref_list);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int prune_candidates(git_vector *candidates, git_remote *remote)\n{\n\tgit_strarray arr = { 0 };\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_reference_list(&arr, remote->repo)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < arr.count; i++) {\n\t\tconst char *refname = arr.strings[i];\n\t\tchar *refname_dup;\n\n\t\tif (!git_remote__matching_dst_refspec(remote, refname))\n\t\t\tcontinue;\n\n\t\trefname_dup = git__strdup(refname);\n\t\tGITERR_CHECK_ALLOC(refname_dup);\n\n\t\tif ((error = git_vector_insert(candidates, refname_dup)) < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tgit_strarray_free(&arr);\n\treturn error;\n}"
  },
  {
    "function_name": "git_remote_write_fetchhead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1111-1174",
    "snippet": "static int git_remote_write_fetchhead(git_remote *remote, git_refspec *spec, git_vector *update_heads)\n{\n\tgit_reference *head_ref = NULL;\n\tgit_fetchhead_ref *fetchhead_ref;\n\tgit_remote_head *remote_ref, *merge_remote_ref;\n\tgit_vector fetchhead_refs;\n\tbool include_all_fetchheads;\n\tunsigned int i = 0;\n\tint error = 0;\n\n\tassert(remote);\n\n\t/* no heads, nothing to do */\n\tif (update_heads->length == 0)\n\t\treturn 0;\n\n\tif (git_vector_init(&fetchhead_refs, update_heads->length, git_fetchhead_ref_cmp) < 0)\n\t\treturn -1;\n\n\t/* Iff refspec is * (but not subdir slash star), include tags */\n\tinclude_all_fetchheads = (strcmp(GIT_REFS_HEADS_DIR \"*\", git_refspec_src(spec)) == 0);\n\n\t/* Determine what to merge: if refspec was a wildcard, just use HEAD */\n\tif (git_refspec_is_wildcard(spec)) {\n\t\tif ((error = git_reference_lookup(&head_ref, remote->repo, GIT_HEAD_FILE)) < 0 ||\n\t\t\t(error = remote_head_for_ref(&merge_remote_ref, remote, spec, update_heads, head_ref)) < 0)\n\t\t\t\tgoto cleanup;\n\t} else {\n\t\t/* If we're fetching a single refspec, that's the only thing that should be in FETCH_HEAD. */\n\t\tif ((error = remote_head_for_fetchspec_src(&merge_remote_ref, update_heads, git_refspec_src(spec))) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Create the FETCH_HEAD file */\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tint merge_this_fetchhead = (merge_remote_ref == remote_ref);\n\n\t\tif (!include_all_fetchheads &&\n\t\t\t!git_refspec_src_matches(spec, remote_ref->name) &&\n\t\t\t!merge_this_fetchhead)\n\t\t\tcontinue;\n\n\t\tif (git_fetchhead_ref_create(&fetchhead_ref,\n\t\t\t&remote_ref->oid,\n\t\t\tmerge_this_fetchhead,\n\t\t\tremote_ref->name,\n\t\t\tgit_remote_url(remote)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_vector_insert(&fetchhead_refs, fetchhead_ref) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tgit_fetchhead_write(remote->repo, &fetchhead_refs);\n\ncleanup:\n\tfor (i = 0; i < fetchhead_refs.length; ++i)\n\t\tgit_fetchhead_ref_free(fetchhead_refs.contents[i]);\n\n\tgit_vector_free(&fetchhead_refs);\n\tgit_reference_free(head_ref);\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "head_ref"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&fetchhead_refs"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_fetchhead_ref_free",
          "args": [
            "fetchhead_refs.contents[i]"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "git_fetchhead_ref_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
          "lines": "293-301",
          "snippet": "void git_fetchhead_ref_free(git_fetchhead_ref *fetchhead_ref)\n{\n\tif (fetchhead_ref == NULL)\n\t\treturn;\n\n\tgit__free(fetchhead_ref->remote_url);\n\tgit__free(fetchhead_ref->ref_name);\n\tgit__free(fetchhead_ref);\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include \"fetchhead.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nvoid git_fetchhead_ref_free(git_fetchhead_ref *fetchhead_ref)\n{\n\tif (fetchhead_ref == NULL)\n\t\treturn;\n\n\tgit__free(fetchhead_ref->remote_url);\n\tgit__free(fetchhead_ref->ref_name);\n\tgit__free(fetchhead_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_fetchhead_write",
          "args": [
            "remote->repo",
            "&fetchhead_refs"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "git_fetchhead_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
          "lines": "109-134",
          "snippet": "int git_fetchhead_write(git_repository *repo, git_vector *fetchhead_refs)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int i;\n\tgit_fetchhead_ref *fetchhead_ref;\n\n\tassert(repo && fetchhead_refs);\n\n\tif (git_buf_joinpath(&path, repo->path_repository, GIT_FETCH_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif (git_filebuf_open(&file, path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE) < 0) {\n\t\tgit_buf_free(&path);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&path);\n\n\tgit_vector_sort(fetchhead_refs);\n\n\tgit_vector_foreach(fetchhead_refs, i, fetchhead_ref)\n\t\tfetchhead_ref_write(&file, fetchhead_ref);\n\n\treturn git_filebuf_commit(&file);\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include \"fetchhead.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nint git_fetchhead_write(git_repository *repo, git_vector *fetchhead_refs)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int i;\n\tgit_fetchhead_ref *fetchhead_ref;\n\n\tassert(repo && fetchhead_refs);\n\n\tif (git_buf_joinpath(&path, repo->path_repository, GIT_FETCH_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif (git_filebuf_open(&file, path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE) < 0) {\n\t\tgit_buf_free(&path);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&path);\n\n\tgit_vector_sort(fetchhead_refs);\n\n\tgit_vector_foreach(fetchhead_refs, i, fetchhead_ref)\n\t\tfetchhead_ref_write(&file, fetchhead_ref);\n\n\treturn git_filebuf_commit(&file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&fetchhead_refs",
            "fetchhead_ref"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_fetchhead_ref_create",
          "args": [
            "&fetchhead_ref",
            "&remote_ref->oid",
            "merge_this_fetchhead",
            "remote_ref->name",
            "git_remote_url(remote)"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "git_fetchhead_ref_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
          "lines": "39-69",
          "snippet": "int git_fetchhead_ref_create(\n\tgit_fetchhead_ref **out,\n\tgit_oid *oid,\n\tunsigned int is_merge,\n\tconst char *ref_name,\n\tconst char *remote_url)\n{\n\tgit_fetchhead_ref *fetchhead_ref;\n\n\tassert(out && oid);\n\n\t*out = NULL;\n\n\tfetchhead_ref = git__malloc(sizeof(git_fetchhead_ref));\n\tGITERR_CHECK_ALLOC(fetchhead_ref);\n\n\tmemset(fetchhead_ref, 0x0, sizeof(git_fetchhead_ref));\n\n\tgit_oid_cpy(&fetchhead_ref->oid, oid);\n\tfetchhead_ref->is_merge = is_merge;\n\n\tif (ref_name)\n\t\tfetchhead_ref->ref_name = git__strdup(ref_name);\n\n\tif (remote_url)\n\t\tfetchhead_ref->remote_url = git__strdup(remote_url);\n\n\t*out = fetchhead_ref;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include \"fetchhead.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nint git_fetchhead_ref_create(\n\tgit_fetchhead_ref **out,\n\tgit_oid *oid,\n\tunsigned int is_merge,\n\tconst char *ref_name,\n\tconst char *remote_url)\n{\n\tgit_fetchhead_ref *fetchhead_ref;\n\n\tassert(out && oid);\n\n\t*out = NULL;\n\n\tfetchhead_ref = git__malloc(sizeof(git_fetchhead_ref));\n\tGITERR_CHECK_ALLOC(fetchhead_ref);\n\n\tmemset(fetchhead_ref, 0x0, sizeof(git_fetchhead_ref));\n\n\tgit_oid_cpy(&fetchhead_ref->oid, oid);\n\tfetchhead_ref->is_merge = is_merge;\n\n\tif (ref_name)\n\t\tfetchhead_ref->ref_name = git__strdup(ref_name);\n\n\tif (remote_url)\n\t\tfetchhead_ref->remote_url = git__strdup(remote_url);\n\n\t*out = fetchhead_ref;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_url",
          "args": [
            "remote"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "609-613",
          "snippet": "const char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nconst char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_src_matches",
          "args": [
            "spec",
            "remote_ref->name"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_src_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "185-191",
          "snippet": "int git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_src_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->src == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->src, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "update_heads",
            "i",
            "remote_ref"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remote_head_for_fetchspec_src",
          "args": [
            "&merge_remote_ref",
            "update_heads",
            "git_refspec_src(spec)"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "remote_head_for_fetchspec_src",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1025-1042",
          "snippet": "static int remote_head_for_fetchspec_src(git_remote_head **out, git_vector *update_heads, const char *fetchspec_src)\n{\n\tunsigned int i;\n\tgit_remote_head *remote_ref;\n\n\tassert(update_heads && fetchspec_src);\n\n\t*out = NULL;\n\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tif (strcmp(remote_ref->name, fetchspec_src) == 0) {\n\t\t\t*out = remote_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int remote_head_for_fetchspec_src(git_remote_head **out, git_vector *update_heads, const char *fetchspec_src)\n{\n\tunsigned int i;\n\tgit_remote_head *remote_ref;\n\n\tassert(update_heads && fetchspec_src);\n\n\t*out = NULL;\n\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tif (strcmp(remote_ref->name, fetchspec_src) == 0) {\n\t\t\t*out = remote_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_src",
          "args": [
            "spec"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_src",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "163-166",
          "snippet": "const char *git_refspec_src(const git_refspec *refspec)\n{\n\treturn refspec == NULL ? NULL : refspec->src;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nconst char *git_refspec_src(const git_refspec *refspec)\n{\n\treturn refspec == NULL ? NULL : refspec->src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote_head_for_ref",
          "args": [
            "&merge_remote_ref",
            "remote",
            "spec",
            "update_heads",
            "head_ref"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "remote_head_for_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1076-1109",
          "snippet": "static int remote_head_for_ref(git_remote_head **out, git_remote *remote, git_refspec *spec, git_vector *update_heads, git_reference *ref)\n{\n\tgit_reference *resolved_ref = NULL;\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_config *config = NULL;\n\tconst char *ref_name;\n\tint error = 0, update;\n\n\tassert(out && spec && ref);\n\n\t*out = NULL;\n\n\terror = git_reference_resolve(&resolved_ref, ref);\n\n\t/* If we're in an unborn branch, let's pretend nothing happened */\n\tif (error == GIT_ENOTFOUND && git_reference_type(ref) == GIT_REF_SYMBOLIC) {\n\t\tref_name = git_reference_symbolic_target(ref);\n\t\terror = 0;\n\t} else {\n\t\tref_name = git_reference_name(resolved_ref);\n\t}\n\n\tif ((error = ref_to_update(&update, &remote_name, remote, spec, ref_name)) < 0)\n\t\tgoto cleanup;\n\n\tif (update)\n\t\terror = remote_head_for_fetchspec_src(out, update_heads, git_buf_cstr(&remote_name));\n\ncleanup:\n\tgit_buf_free(&remote_name);\n\tgit_reference_free(resolved_ref);\n\tgit_config_free(config);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int remote_head_for_ref(git_remote_head **out, git_remote *remote, git_refspec *spec, git_vector *update_heads, git_reference *ref)\n{\n\tgit_reference *resolved_ref = NULL;\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_config *config = NULL;\n\tconst char *ref_name;\n\tint error = 0, update;\n\n\tassert(out && spec && ref);\n\n\t*out = NULL;\n\n\terror = git_reference_resolve(&resolved_ref, ref);\n\n\t/* If we're in an unborn branch, let's pretend nothing happened */\n\tif (error == GIT_ENOTFOUND && git_reference_type(ref) == GIT_REF_SYMBOLIC) {\n\t\tref_name = git_reference_symbolic_target(ref);\n\t\terror = 0;\n\t} else {\n\t\tref_name = git_reference_name(resolved_ref);\n\t}\n\n\tif ((error = ref_to_update(&update, &remote_name, remote, spec, ref_name)) < 0)\n\t\tgoto cleanup;\n\n\tif (update)\n\t\terror = remote_head_for_fetchspec_src(out, update_heads, git_buf_cstr(&remote_name));\n\ncleanup:\n\tgit_buf_free(&remote_name);\n\tgit_reference_free(resolved_ref);\n\tgit_config_free(config);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&head_ref",
            "remote->repo",
            "GIT_HEAD_FILE"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_is_wildcard",
          "args": [
            "spec"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_is_wildcard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "288-293",
          "snippet": "int git_refspec_is_wildcard(const git_refspec *spec)\n{\n\tassert(spec && spec->src);\n\n\treturn (spec->src[strlen(spec->src) - 1] == '*');\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_is_wildcard(const git_refspec *spec)\n{\n\tassert(spec && spec->src);\n\n\treturn (spec->src[strlen(spec->src) - 1] == '*');\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "GIT_REFS_HEADS_DIR \"*\"",
            "git_refspec_src(spec)"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&fetchhead_refs",
            "update_heads->length",
            "git_fetchhead_ref_cmp"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int git_remote_write_fetchhead(git_remote *remote, git_refspec *spec, git_vector *update_heads)\n{\n\tgit_reference *head_ref = NULL;\n\tgit_fetchhead_ref *fetchhead_ref;\n\tgit_remote_head *remote_ref, *merge_remote_ref;\n\tgit_vector fetchhead_refs;\n\tbool include_all_fetchheads;\n\tunsigned int i = 0;\n\tint error = 0;\n\n\tassert(remote);\n\n\t/* no heads, nothing to do */\n\tif (update_heads->length == 0)\n\t\treturn 0;\n\n\tif (git_vector_init(&fetchhead_refs, update_heads->length, git_fetchhead_ref_cmp) < 0)\n\t\treturn -1;\n\n\t/* Iff refspec is * (but not subdir slash star), include tags */\n\tinclude_all_fetchheads = (strcmp(GIT_REFS_HEADS_DIR \"*\", git_refspec_src(spec)) == 0);\n\n\t/* Determine what to merge: if refspec was a wildcard, just use HEAD */\n\tif (git_refspec_is_wildcard(spec)) {\n\t\tif ((error = git_reference_lookup(&head_ref, remote->repo, GIT_HEAD_FILE)) < 0 ||\n\t\t\t(error = remote_head_for_ref(&merge_remote_ref, remote, spec, update_heads, head_ref)) < 0)\n\t\t\t\tgoto cleanup;\n\t} else {\n\t\t/* If we're fetching a single refspec, that's the only thing that should be in FETCH_HEAD. */\n\t\tif ((error = remote_head_for_fetchspec_src(&merge_remote_ref, update_heads, git_refspec_src(spec))) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Create the FETCH_HEAD file */\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tint merge_this_fetchhead = (merge_remote_ref == remote_ref);\n\n\t\tif (!include_all_fetchheads &&\n\t\t\t!git_refspec_src_matches(spec, remote_ref->name) &&\n\t\t\t!merge_this_fetchhead)\n\t\t\tcontinue;\n\n\t\tif (git_fetchhead_ref_create(&fetchhead_ref,\n\t\t\t&remote_ref->oid,\n\t\t\tmerge_this_fetchhead,\n\t\t\tremote_ref->name,\n\t\t\tgit_remote_url(remote)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_vector_insert(&fetchhead_refs, fetchhead_ref) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tgit_fetchhead_write(remote->repo, &fetchhead_refs);\n\ncleanup:\n\tfor (i = 0; i < fetchhead_refs.length; ++i)\n\t\tgit_fetchhead_ref_free(fetchhead_refs.contents[i]);\n\n\tgit_vector_free(&fetchhead_refs);\n\tgit_reference_free(head_ref);\n\n\treturn error;\n}"
  },
  {
    "function_name": "remote_head_for_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1076-1109",
    "snippet": "static int remote_head_for_ref(git_remote_head **out, git_remote *remote, git_refspec *spec, git_vector *update_heads, git_reference *ref)\n{\n\tgit_reference *resolved_ref = NULL;\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_config *config = NULL;\n\tconst char *ref_name;\n\tint error = 0, update;\n\n\tassert(out && spec && ref);\n\n\t*out = NULL;\n\n\terror = git_reference_resolve(&resolved_ref, ref);\n\n\t/* If we're in an unborn branch, let's pretend nothing happened */\n\tif (error == GIT_ENOTFOUND && git_reference_type(ref) == GIT_REF_SYMBOLIC) {\n\t\tref_name = git_reference_symbolic_target(ref);\n\t\terror = 0;\n\t} else {\n\t\tref_name = git_reference_name(resolved_ref);\n\t}\n\n\tif ((error = ref_to_update(&update, &remote_name, remote, spec, ref_name)) < 0)\n\t\tgoto cleanup;\n\n\tif (update)\n\t\terror = remote_head_for_fetchspec_src(out, update_heads, git_buf_cstr(&remote_name));\n\ncleanup:\n\tgit_buf_free(&remote_name);\n\tgit_reference_free(resolved_ref);\n\tgit_config_free(config);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "config"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "resolved_ref"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&remote_name"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote_head_for_fetchspec_src",
          "args": [
            "out",
            "update_heads",
            "git_buf_cstr(&remote_name)"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "remote_head_for_fetchspec_src",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1025-1042",
          "snippet": "static int remote_head_for_fetchspec_src(git_remote_head **out, git_vector *update_heads, const char *fetchspec_src)\n{\n\tunsigned int i;\n\tgit_remote_head *remote_ref;\n\n\tassert(update_heads && fetchspec_src);\n\n\t*out = NULL;\n\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tif (strcmp(remote_ref->name, fetchspec_src) == 0) {\n\t\t\t*out = remote_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int remote_head_for_fetchspec_src(git_remote_head **out, git_vector *update_heads, const char *fetchspec_src)\n{\n\tunsigned int i;\n\tgit_remote_head *remote_ref;\n\n\tassert(update_heads && fetchspec_src);\n\n\t*out = NULL;\n\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tif (strcmp(remote_ref->name, fetchspec_src) == 0) {\n\t\t\t*out = remote_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&remote_name"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref_to_update",
          "args": [
            "&update",
            "&remote_name",
            "remote",
            "spec",
            "ref_name"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "ref_to_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1044-1074",
          "snippet": "static int ref_to_update(int *update, git_buf *remote_name, git_remote *remote, git_refspec *spec, const char *ref_name)\n{\n\tint error = 0;\n\tgit_repository *repo;\n\tgit_buf upstream_remote = GIT_BUF_INIT;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\trepo = git_remote_owner(remote);\n\n\tif ((!git_reference__is_branch(ref_name)) ||\n\t    !git_remote_name(remote) ||\n\t    (error = git_branch_upstream_remote(&upstream_remote, repo, ref_name) < 0) ||\n\t    git__strcmp(git_remote_name(remote), git_buf_cstr(&upstream_remote)) ||\n\t    (error = git_branch_upstream_name(&upstream_name, repo, ref_name)) < 0 ||\n\t    !git_refspec_dst_matches(spec, git_buf_cstr(&upstream_name)) ||\n\t    (error = git_refspec_rtransform(remote_name, spec, upstream_name.ptr)) < 0) {\n\t\t/* Not an error if there is no upstream */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\t*update = 0;\n\t} else {\n\t\t*update = 1;\n\t}\n\n\tgit_buf_free(&upstream_remote);\n\tgit_buf_free(&upstream_name);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int ref_to_update(int *update, git_buf *remote_name, git_remote *remote, git_refspec *spec, const char *ref_name)\n{\n\tint error = 0;\n\tgit_repository *repo;\n\tgit_buf upstream_remote = GIT_BUF_INIT;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\trepo = git_remote_owner(remote);\n\n\tif ((!git_reference__is_branch(ref_name)) ||\n\t    !git_remote_name(remote) ||\n\t    (error = git_branch_upstream_remote(&upstream_remote, repo, ref_name) < 0) ||\n\t    git__strcmp(git_remote_name(remote), git_buf_cstr(&upstream_remote)) ||\n\t    (error = git_branch_upstream_name(&upstream_name, repo, ref_name)) < 0 ||\n\t    !git_refspec_dst_matches(spec, git_buf_cstr(&upstream_name)) ||\n\t    (error = git_refspec_rtransform(remote_name, spec, upstream_name.ptr)) < 0) {\n\t\t/* Not an error if there is no upstream */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\t*update = 0;\n\t} else {\n\t\t*update = 1;\n\t}\n\n\tgit_buf_free(&upstream_remote);\n\tgit_buf_free(&upstream_name);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "resolved_ref"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_symbolic_target",
          "args": [
            "ref"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_symbolic_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "341-349",
          "snippet": "const char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_type",
          "args": [
            "ref"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "303-307",
          "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_resolve",
          "args": [
            "&resolved_ref",
            "ref"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "617-630",
          "snippet": "int git_reference_resolve(git_reference **ref_out, const git_reference *ref)\n{\n\tswitch (git_reference_type(ref)) {\n\tcase GIT_REF_OID:\n\t\treturn git_reference_lookup(ref_out, ref->db->repo, ref->name);\n\n\tcase GIT_REF_SYMBOLIC:\n\t\treturn git_reference_lookup_resolved(ref_out, ref->db->repo, ref->target.symbolic, -1);\n\n\tdefault:\n\t\tgiterr_set(GITERR_REFERENCE, \"Invalid reference\");\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_resolve(git_reference **ref_out, const git_reference *ref)\n{\n\tswitch (git_reference_type(ref)) {\n\tcase GIT_REF_OID:\n\t\treturn git_reference_lookup(ref_out, ref->db->repo, ref->name);\n\n\tcase GIT_REF_SYMBOLIC:\n\t\treturn git_reference_lookup_resolved(ref_out, ref->db->repo, ref->target.symbolic, -1);\n\n\tdefault:\n\t\tgiterr_set(GITERR_REFERENCE, \"Invalid reference\");\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && spec && ref"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int remote_head_for_ref(git_remote_head **out, git_remote *remote, git_refspec *spec, git_vector *update_heads, git_reference *ref)\n{\n\tgit_reference *resolved_ref = NULL;\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_config *config = NULL;\n\tconst char *ref_name;\n\tint error = 0, update;\n\n\tassert(out && spec && ref);\n\n\t*out = NULL;\n\n\terror = git_reference_resolve(&resolved_ref, ref);\n\n\t/* If we're in an unborn branch, let's pretend nothing happened */\n\tif (error == GIT_ENOTFOUND && git_reference_type(ref) == GIT_REF_SYMBOLIC) {\n\t\tref_name = git_reference_symbolic_target(ref);\n\t\terror = 0;\n\t} else {\n\t\tref_name = git_reference_name(resolved_ref);\n\t}\n\n\tif ((error = ref_to_update(&update, &remote_name, remote, spec, ref_name)) < 0)\n\t\tgoto cleanup;\n\n\tif (update)\n\t\terror = remote_head_for_fetchspec_src(out, update_heads, git_buf_cstr(&remote_name));\n\ncleanup:\n\tgit_buf_free(&remote_name);\n\tgit_reference_free(resolved_ref);\n\tgit_config_free(config);\n\treturn error;\n}"
  },
  {
    "function_name": "ref_to_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1044-1074",
    "snippet": "static int ref_to_update(int *update, git_buf *remote_name, git_remote *remote, git_refspec *spec, const char *ref_name)\n{\n\tint error = 0;\n\tgit_repository *repo;\n\tgit_buf upstream_remote = GIT_BUF_INIT;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\trepo = git_remote_owner(remote);\n\n\tif ((!git_reference__is_branch(ref_name)) ||\n\t    !git_remote_name(remote) ||\n\t    (error = git_branch_upstream_remote(&upstream_remote, repo, ref_name) < 0) ||\n\t    git__strcmp(git_remote_name(remote), git_buf_cstr(&upstream_remote)) ||\n\t    (error = git_branch_upstream_name(&upstream_name, repo, ref_name)) < 0 ||\n\t    !git_refspec_dst_matches(spec, git_buf_cstr(&upstream_name)) ||\n\t    (error = git_refspec_rtransform(remote_name, spec, upstream_name.ptr)) < 0) {\n\t\t/* Not an error if there is no upstream */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\t*update = 0;\n\t} else {\n\t\t*update = 1;\n\t}\n\n\tgit_buf_free(&upstream_remote);\n\tgit_buf_free(&upstream_name);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&upstream_name"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_rtransform",
          "args": [
            "remote_name",
            "spec",
            "upstream_name.ptr"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_rtransform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "260-274",
          "snippet": "int git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_dst_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the destination\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->src);\n\n\treturn refspec_transform(out, spec->dst, spec->src, name);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)\n{\n\tassert(out && spec && name);\n\tgit_buf_sanitize(out);\n\n\tif (!git_refspec_dst_matches(spec, name)) {\n\t\tgiterr_set(GITERR_INVALID, \"ref '%s' doesn't match the destination\", name);\n\t\treturn -1;\n\t}\n\n\tif (!spec->pattern)\n\t\treturn git_buf_puts(out, spec->src);\n\n\treturn refspec_transform(out, spec->dst, spec->src, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec_dst_matches",
          "args": [
            "spec",
            "git_buf_cstr(&upstream_name)"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec_dst_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "193-199",
          "snippet": "int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec_dst_matches(const git_refspec *refspec, const char *refname)\n{\n\tif (refspec == NULL || refspec->dst == NULL)\n\t\treturn false;\n\n\treturn (p_fnmatch(refspec->dst, refname, 0) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&upstream_name"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_upstream_name",
          "args": [
            "&upstream_name",
            "repo",
            "ref_name"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_upstream_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "332-395",
          "snippet": "int git_branch_upstream_name(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tconst char *refname)\n{\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_buf merge_name = GIT_BUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = -1;\n\tgit_remote *remote = NULL;\n\tconst git_refspec *refspec;\n\tgit_config *config;\n\n\tassert(out && refname);\n\n\tgit_buf_sanitize(out);\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&remote_name, config, refname, \"branch.%s.remote\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&merge_name, config, refname, \"branch.%s.merge\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif (git_buf_len(&remote_name) == 0 || git_buf_len(&merge_name) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"branch '%s' does not have an upstream\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tif (strcmp(\".\", git_buf_cstr(&remote_name)) != 0) {\n\t\tif ((error = git_remote_lookup(&remote, repo, git_buf_cstr(&remote_name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&merge_name));\n\t\tif (!refspec) {\n\t\t\terror = GIT_ENOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (git_refspec_transform(&buf, refspec, git_buf_cstr(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\t} else\n\t\tif (git_buf_set(&buf, git_buf_cstr(&merge_name), git_buf_len(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = git_buf_set(out, git_buf_cstr(&buf), git_buf_len(&buf));\n\ncleanup:\n\tgit_config_free(config);\n\tgit_remote_free(remote);\n\tgit_buf_free(&remote_name);\n\tgit_buf_free(&merge_name);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_upstream_name(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tconst char *refname)\n{\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_buf merge_name = GIT_BUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = -1;\n\tgit_remote *remote = NULL;\n\tconst git_refspec *refspec;\n\tgit_config *config;\n\n\tassert(out && refname);\n\n\tgit_buf_sanitize(out);\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&remote_name, config, refname, \"branch.%s.remote\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&merge_name, config, refname, \"branch.%s.merge\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif (git_buf_len(&remote_name) == 0 || git_buf_len(&merge_name) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"branch '%s' does not have an upstream\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tif (strcmp(\".\", git_buf_cstr(&remote_name)) != 0) {\n\t\tif ((error = git_remote_lookup(&remote, repo, git_buf_cstr(&remote_name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&merge_name));\n\t\tif (!refspec) {\n\t\t\terror = GIT_ENOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (git_refspec_transform(&buf, refspec, git_buf_cstr(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\t} else\n\t\tif (git_buf_set(&buf, git_buf_cstr(&merge_name), git_buf_len(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = git_buf_set(out, git_buf_cstr(&buf), git_buf_len(&buf));\n\ncleanup:\n\tgit_config_free(config);\n\tgit_remote_free(remote);\n\tgit_buf_free(&remote_name);\n\tgit_buf_free(&merge_name);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strcmp",
          "args": [
            "git_remote_name(remote)",
            "git_buf_cstr(&upstream_remote)"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_name",
          "args": [
            "remote"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "597-601",
          "snippet": "const char *git_remote_name(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->name;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nconst char *git_remote_name(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_upstream_remote",
          "args": [
            "&upstream_remote",
            "repo",
            "ref_name"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_upstream_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "397-420",
          "snippet": "int git_branch_upstream_remote(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_config *cfg;\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tgit_buf_sanitize(buf);\n\n\tif ((error = retrieve_upstream_configuration(buf, cfg, refname, \"branch.%s.remote\")) < 0)\n\t\treturn error;\n\n\tif (git_buf_len(buf) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE, \"branch '%s' does not have an upstream remote\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgit_buf_clear(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_upstream_remote(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_config *cfg;\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tgit_buf_sanitize(buf);\n\n\tif ((error = retrieve_upstream_configuration(buf, cfg, refname, \"branch.%s.remote\")) < 0)\n\t\treturn error;\n\n\tif (git_buf_len(buf) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE, \"branch '%s' does not have an upstream remote\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgit_buf_clear(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__is_branch",
          "args": [
            "ref_name"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1172-1175",
          "snippet": "int git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__is_branch(const char *ref_name)\n{\n\treturn git__prefixcmp(ref_name, GIT_REFS_HEADS_DIR) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_owner",
          "args": [
            "remote"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "603-607",
          "snippet": "git_repository *git_remote_owner(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->repo;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_repository *git_remote_owner(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->repo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int ref_to_update(int *update, git_buf *remote_name, git_remote *remote, git_refspec *spec, const char *ref_name)\n{\n\tint error = 0;\n\tgit_repository *repo;\n\tgit_buf upstream_remote = GIT_BUF_INIT;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\trepo = git_remote_owner(remote);\n\n\tif ((!git_reference__is_branch(ref_name)) ||\n\t    !git_remote_name(remote) ||\n\t    (error = git_branch_upstream_remote(&upstream_remote, repo, ref_name) < 0) ||\n\t    git__strcmp(git_remote_name(remote), git_buf_cstr(&upstream_remote)) ||\n\t    (error = git_branch_upstream_name(&upstream_name, repo, ref_name)) < 0 ||\n\t    !git_refspec_dst_matches(spec, git_buf_cstr(&upstream_name)) ||\n\t    (error = git_refspec_rtransform(remote_name, spec, upstream_name.ptr)) < 0) {\n\t\t/* Not an error if there is no upstream */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\t*update = 0;\n\t} else {\n\t\t*update = 1;\n\t}\n\n\tgit_buf_free(&upstream_remote);\n\tgit_buf_free(&upstream_name);\n\treturn error;\n}"
  },
  {
    "function_name": "remote_head_for_fetchspec_src",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "1025-1042",
    "snippet": "static int remote_head_for_fetchspec_src(git_remote_head **out, git_vector *update_heads, const char *fetchspec_src)\n{\n\tunsigned int i;\n\tgit_remote_head *remote_ref;\n\n\tassert(update_heads && fetchspec_src);\n\n\t*out = NULL;\n\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tif (strcmp(remote_ref->name, fetchspec_src) == 0) {\n\t\t\t*out = remote_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "remote_ref->name",
            "fetchspec_src"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "update_heads",
            "i",
            "remote_ref"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "update_heads && fetchspec_src"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int remote_head_for_fetchspec_src(git_remote_head **out, git_vector *update_heads, const char *fetchspec_src)\n{\n\tunsigned int i;\n\tgit_remote_head *remote_ref;\n\n\tassert(update_heads && fetchspec_src);\n\n\t*out = NULL;\n\n\tgit_vector_foreach(update_heads, i, remote_ref) {\n\t\tif (strcmp(remote_ref->name, fetchspec_src) == 0) {\n\t\t\t*out = remote_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_remote_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "962-1023",
    "snippet": "int git_remote_fetch(\n\t\tgit_remote *remote,\n\t\tconst git_strarray *refspecs,\n\t\tconst git_fetch_options *opts,\n\t\tconst char *reflog_message)\n{\n\tint error, update_fetchhead = 1;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\tbool prune = false;\n\tgit_buf reflog_msg_buf = GIT_BUF_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t\tupdate_fetchhead = opts->update_fetchhead;\n\t\ttagopt = opts->download_tags;\n\t}\n\n\t/* Connect and download everything */\n\tif ((error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) != 0)\n\t\treturn error;\n\n\terror = git_remote_download(remote, refspecs, opts);\n\n\t/* We don't need to be connected anymore */\n\tgit_remote_disconnect(remote);\n\n\t/* If the download failed, return the error */\n\tif (error != 0)\n\t\treturn error;\n\n\t/* Default reflog message */\n\tif (reflog_message)\n\t\tgit_buf_sets(&reflog_msg_buf, reflog_message);\n\telse {\n\t\tgit_buf_printf(&reflog_msg_buf, \"fetch %s\",\n\t\t\t\tremote->name ? remote->name : remote->url);\n\t}\n\n\t/* Create \"remote/foo\" branches for all remote branches */\n\terror = git_remote_update_tips(remote, cbs, update_fetchhead, tagopt, git_buf_cstr(&reflog_msg_buf));\n\tgit_buf_free(&reflog_msg_buf);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (opts && opts->prune == GIT_FETCH_PRUNE)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_PRUNE_UNSPECIFIED && remote->prune_refs)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_NO_PRUNE)\n\t\tprune = false;\n\telse\n\t\tprune = remote->prune_refs;\n\n\tif (prune)\n\t\terror = git_remote_prune(remote, cbs);\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_remote_prune",
          "args": [
            "remote",
            "cbs"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1216-1316",
          "snippet": "int git_remote_prune(git_remote *remote, const git_remote_callbacks *callbacks)\n{\n\tsize_t i, j;\n\tgit_vector remote_refs = GIT_VECTOR_INIT;\n\tgit_vector candidates = GIT_VECTOR_INIT;\n\tconst git_refspec *spec;\n\tconst char *refname;\n\tint error;\n\tgit_oid zero_id = {{ 0 }};\n\n\tif (callbacks)\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\n\tif ((error = ls_to_vector(&remote_refs, remote)) < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_set_cmp(&remote_refs, find_head);\n\n\tif ((error = prune_candidates(&candidates, remote)) < 0)\n\t\tgoto cleanup;\n\n\t/*\n\t * Remove those entries from the candidate list for which we\n\t * can find a remote reference in at least one refspec.\n\t */\n\tgit_vector_foreach(&candidates, i, refname) {\n\t\tgit_vector_foreach(&remote->active_refspecs, j, spec) {\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t pos;\n\t\t\tchar *src_name;\n\t\t\tgit_remote_head key = {0};\n\n\t\t\tif (!git_refspec_dst_matches(spec, refname))\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_refspec_rtransform(&buf, spec, refname)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\terror = git_vector_search(&pos, &remote_refs, &key);\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\tcontinue;\n\n\t\t\t/* if we did find a source, remove it from the candiates */\n\t\t\tif ((error = git_vector_set((void **) &src_name, &candidates, i, NULL)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit__free(src_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * For those candidates still left in the list, we need to\n\t * remove them. We do not remove symrefs, as those are for\n\t * stuff like origin/HEAD which will never match, but we do\n\t * not want to remove them.\n\t */\n\tgit_vector_foreach(&candidates, i, refname) {\n\t\tgit_reference *ref;\n\t\tgit_oid id;\n\n\t\tif (refname == NULL)\n\t\t\tcontinue;\n\n\t\terror = git_reference_lookup(&ref, remote->repo, refname);\n\t\t/* as we want it gone, let's not consider this an error */\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tcontinue;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC) {\n\t\t\tgit_reference_free(ref);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgit_oid_cpy(&id, git_reference_target(ref));\n\t\terror = git_reference_delete(ref);\n\t\tgit_reference_free(ref);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (callbacks && callbacks->update_tips)\n\t\t\terror = callbacks->update_tips(refname, &id, &zero_id, callbacks->payload);\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_vector_free(&remote_refs);\n\tgit_vector_free_deep(&candidates);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_prune(git_remote *remote, const git_remote_callbacks *callbacks)\n{\n\tsize_t i, j;\n\tgit_vector remote_refs = GIT_VECTOR_INIT;\n\tgit_vector candidates = GIT_VECTOR_INIT;\n\tconst git_refspec *spec;\n\tconst char *refname;\n\tint error;\n\tgit_oid zero_id = {{ 0 }};\n\n\tif (callbacks)\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\n\tif ((error = ls_to_vector(&remote_refs, remote)) < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_set_cmp(&remote_refs, find_head);\n\n\tif ((error = prune_candidates(&candidates, remote)) < 0)\n\t\tgoto cleanup;\n\n\t/*\n\t * Remove those entries from the candidate list for which we\n\t * can find a remote reference in at least one refspec.\n\t */\n\tgit_vector_foreach(&candidates, i, refname) {\n\t\tgit_vector_foreach(&remote->active_refspecs, j, spec) {\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t pos;\n\t\t\tchar *src_name;\n\t\t\tgit_remote_head key = {0};\n\n\t\t\tif (!git_refspec_dst_matches(spec, refname))\n\t\t\t\tcontinue;\n\n\t\t\tif ((error = git_refspec_rtransform(&buf, spec, refname)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\terror = git_vector_search(&pos, &remote_refs, &key);\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\tcontinue;\n\n\t\t\t/* if we did find a source, remove it from the candiates */\n\t\t\tif ((error = git_vector_set((void **) &src_name, &candidates, i, NULL)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit__free(src_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * For those candidates still left in the list, we need to\n\t * remove them. We do not remove symrefs, as those are for\n\t * stuff like origin/HEAD which will never match, but we do\n\t * not want to remove them.\n\t */\n\tgit_vector_foreach(&candidates, i, refname) {\n\t\tgit_reference *ref;\n\t\tgit_oid id;\n\n\t\tif (refname == NULL)\n\t\t\tcontinue;\n\n\t\terror = git_reference_lookup(&ref, remote->repo, refname);\n\t\t/* as we want it gone, let's not consider this an error */\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tcontinue;\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC) {\n\t\t\tgit_reference_free(ref);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgit_oid_cpy(&id, git_reference_target(ref));\n\t\terror = git_reference_delete(ref);\n\t\tgit_reference_free(ref);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (callbacks && callbacks->update_tips)\n\t\t\terror = callbacks->update_tips(refname, &id, &zero_id, callbacks->payload);\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_vector_free(&remote_refs);\n\tgit_vector_free_deep(&candidates);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&reflog_msg_buf"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_update_tips",
          "args": [
            "remote",
            "cbs",
            "update_fetchhead",
            "tagopt",
            "git_buf_cstr(&reflog_msg_buf)"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_update_tips",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1562-1613",
          "snippet": "int git_remote_update_tips(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t download_tags,\n\t\tconst char *reflog_message)\n{\n\tgit_refspec *spec, tagspec;\n\tgit_vector refs = GIT_VECTOR_INIT;\n\tgit_remote_autotag_option_t tagopt;\n\tint error;\n\tsize_t i;\n\n\t/* push has its own logic hidden away in the push object */\n\tif (remote->push) {\n\t\treturn git_push_update_tips(remote->push, callbacks);\n\t}\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\n\tif ((error = ls_to_vector(&refs, remote)) < 0)\n\t\tgoto out;\n\n\tif (download_tags == GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = remote->download_tags;\n\telse\n\t\ttagopt = download_tags;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, &tagspec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, spec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* only try to do opportunisitic updates if the refpec lists differ */\n\tif (remote->passed_refspecs)\n\t\terror = opportunistic_updates(remote, callbacks, &refs, reflog_message);\n\nout:\n\tgit_vector_free(&refs);\n\tgit_refspec__free(&tagspec);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nint git_remote_update_tips(\n\t\tgit_remote *remote,\n\t\tconst git_remote_callbacks *callbacks,\n\t\tint update_fetchhead,\n\t\tgit_remote_autotag_option_t download_tags,\n\t\tconst char *reflog_message)\n{\n\tgit_refspec *spec, tagspec;\n\tgit_vector refs = GIT_VECTOR_INIT;\n\tgit_remote_autotag_option_t tagopt;\n\tint error;\n\tsize_t i;\n\n\t/* push has its own logic hidden away in the push object */\n\tif (remote->push) {\n\t\treturn git_push_update_tips(remote->push, callbacks);\n\t}\n\n\tif (git_refspec__parse(&tagspec, GIT_REFSPEC_TAGS, true) < 0)\n\t\treturn -1;\n\n\n\tif ((error = ls_to_vector(&refs, remote)) < 0)\n\t\tgoto out;\n\n\tif (download_tags == GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED)\n\t\ttagopt = remote->download_tags;\n\telse\n\t\ttagopt = download_tags;\n\n\tif (tagopt == GIT_REMOTE_DOWNLOAD_TAGS_ALL) {\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, &tagspec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\tgit_vector_foreach(&remote->active_refspecs, i, spec) {\n\t\tif (spec->push)\n\t\t\tcontinue;\n\n\t\tif ((error = update_tips_for_spec(remote, callbacks, update_fetchhead, tagopt, spec, &refs, reflog_message)) < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* only try to do opportunisitic updates if the refpec lists differ */\n\tif (remote->passed_refspecs)\n\t\terror = opportunistic_updates(remote, callbacks, &refs, reflog_message);\n\nout:\n\tgit_vector_free(&refs);\n\tgit_refspec__free(&tagspec);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&reflog_msg_buf"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&reflog_msg_buf",
            "\"fetch %s\"",
            "remote->name ? remote->name : remote->url"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&reflog_msg_buf",
            "reflog_message"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_disconnect",
          "args": [
            "remote"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1634-1640",
          "snippet": "void git_remote_disconnect(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (git_remote_connected(remote))\n\t\tremote->transport->close(remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nvoid git_remote_disconnect(git_remote *remote)\n{\n\tassert(remote);\n\n\tif (git_remote_connected(remote))\n\t\tremote->transport->close(remote->transport);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_download",
          "args": [
            "remote",
            "refspecs",
            "opts"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_download",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "892-960",
          "snippet": "int git_remote_download(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts)\n{\n\tint error = -1;\n\tsize_t i;\n\tgit_vector *to_active, specs = GIT_VECTOR_INIT, refs = GIT_VECTOR_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tassert(remote);\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tif (!git_remote_connected(remote) &&\n\t    (error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) < 0)\n\t\tgoto on_error;\n\n\tif (ls_to_vector(&refs, remote) < 0)\n\t\treturn -1;\n\n\tif ((git_vector_init(&specs, 0, NULL)) < 0)\n\t\tgoto on_error;\n\n\tremote->passed_refspecs = 0;\n\tif (!refspecs || !refspecs->count) {\n\t\tto_active = &remote->refspecs;\n\t} else {\n\t\tfor (i = 0; i < refspecs->count; i++) {\n\t\t\tif ((error = add_refspec_to(&specs, refspecs->strings[i], true)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tto_active = &specs;\n\t\tremote->passed_refspecs = 1;\n\t}\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tif ((error = dwim_refspecs(&remote->passive_refspecs, &remote->refspecs, &refs)) < 0)\n\t\tgoto on_error;\n\n\tfree_refspecs(&remote->active_refspecs);\n\terror = dwim_refspecs(&remote->active_refspecs, to_active, &refs);\n\n\tgit_vector_free(&refs);\n\tfree_refspecs(&specs);\n\tgit_vector_free(&specs);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (remote->push) {\n\t\tgit_push_free(remote->push);\n\t\tremote->push = NULL;\n\t}\n\n\tif ((error = git_fetch_negotiate(remote, opts)) < 0)\n\t\treturn error;\n\n\treturn git_fetch_download_pack(remote, cbs);\n\non_error:\n\tgit_vector_free(&refs);\n\tfree_refspecs(&specs);\n\tgit_vector_free(&specs);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nint git_remote_download(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts)\n{\n\tint error = -1;\n\tsize_t i;\n\tgit_vector *to_active, specs = GIT_VECTOR_INIT, refs = GIT_VECTOR_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tassert(remote);\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tif (!git_remote_connected(remote) &&\n\t    (error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) < 0)\n\t\tgoto on_error;\n\n\tif (ls_to_vector(&refs, remote) < 0)\n\t\treturn -1;\n\n\tif ((git_vector_init(&specs, 0, NULL)) < 0)\n\t\tgoto on_error;\n\n\tremote->passed_refspecs = 0;\n\tif (!refspecs || !refspecs->count) {\n\t\tto_active = &remote->refspecs;\n\t} else {\n\t\tfor (i = 0; i < refspecs->count; i++) {\n\t\t\tif ((error = add_refspec_to(&specs, refspecs->strings[i], true)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tto_active = &specs;\n\t\tremote->passed_refspecs = 1;\n\t}\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tif ((error = dwim_refspecs(&remote->passive_refspecs, &remote->refspecs, &refs)) < 0)\n\t\tgoto on_error;\n\n\tfree_refspecs(&remote->active_refspecs);\n\terror = dwim_refspecs(&remote->active_refspecs, to_active, &refs);\n\n\tgit_vector_free(&refs);\n\tfree_refspecs(&specs);\n\tgit_vector_free(&specs);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (remote->push) {\n\t\tgit_push_free(remote->push);\n\t\tremote->push = NULL;\n\t}\n\n\tif ((error = git_fetch_negotiate(remote, opts)) < 0)\n\t\treturn error;\n\n\treturn git_fetch_download_pack(remote, cbs);\n\non_error:\n\tgit_vector_free(&refs);\n\tfree_refspecs(&specs);\n\tgit_vector_free(&specs);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_connect",
          "args": [
            "remote",
            "GIT_DIRECTION_FETCH",
            "cbs",
            "custom_headers"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "698-755",
          "snippet": "int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
            "char *apply_insteadof(git_config *config, const char *url, int direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nint git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "&opts->callbacks",
            "GIT_REMOTE_CALLBACKS_VERSION",
            "\"git_remote_callbacks\""
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_fetch(\n\t\tgit_remote *remote,\n\t\tconst git_strarray *refspecs,\n\t\tconst git_fetch_options *opts,\n\t\tconst char *reflog_message)\n{\n\tint error, update_fetchhead = 1;\n\tgit_remote_autotag_option_t tagopt = remote->download_tags;\n\tbool prune = false;\n\tgit_buf reflog_msg_buf = GIT_BUF_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t\tupdate_fetchhead = opts->update_fetchhead;\n\t\ttagopt = opts->download_tags;\n\t}\n\n\t/* Connect and download everything */\n\tif ((error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) != 0)\n\t\treturn error;\n\n\terror = git_remote_download(remote, refspecs, opts);\n\n\t/* We don't need to be connected anymore */\n\tgit_remote_disconnect(remote);\n\n\t/* If the download failed, return the error */\n\tif (error != 0)\n\t\treturn error;\n\n\t/* Default reflog message */\n\tif (reflog_message)\n\t\tgit_buf_sets(&reflog_msg_buf, reflog_message);\n\telse {\n\t\tgit_buf_printf(&reflog_msg_buf, \"fetch %s\",\n\t\t\t\tremote->name ? remote->name : remote->url);\n\t}\n\n\t/* Create \"remote/foo\" branches for all remote branches */\n\terror = git_remote_update_tips(remote, cbs, update_fetchhead, tagopt, git_buf_cstr(&reflog_msg_buf));\n\tgit_buf_free(&reflog_msg_buf);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (opts && opts->prune == GIT_FETCH_PRUNE)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_PRUNE_UNSPECIFIED && remote->prune_refs)\n\t\tprune = true;\n\telse if (opts && opts->prune == GIT_FETCH_NO_PRUNE)\n\t\tprune = false;\n\telse\n\t\tprune = remote->prune_refs;\n\n\tif (prune)\n\t\terror = git_remote_prune(remote, cbs);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_remote_download",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "892-960",
    "snippet": "int git_remote_download(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts)\n{\n\tint error = -1;\n\tsize_t i;\n\tgit_vector *to_active, specs = GIT_VECTOR_INIT, refs = GIT_VECTOR_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tassert(remote);\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tif (!git_remote_connected(remote) &&\n\t    (error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) < 0)\n\t\tgoto on_error;\n\n\tif (ls_to_vector(&refs, remote) < 0)\n\t\treturn -1;\n\n\tif ((git_vector_init(&specs, 0, NULL)) < 0)\n\t\tgoto on_error;\n\n\tremote->passed_refspecs = 0;\n\tif (!refspecs || !refspecs->count) {\n\t\tto_active = &remote->refspecs;\n\t} else {\n\t\tfor (i = 0; i < refspecs->count; i++) {\n\t\t\tif ((error = add_refspec_to(&specs, refspecs->strings[i], true)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tto_active = &specs;\n\t\tremote->passed_refspecs = 1;\n\t}\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tif ((error = dwim_refspecs(&remote->passive_refspecs, &remote->refspecs, &refs)) < 0)\n\t\tgoto on_error;\n\n\tfree_refspecs(&remote->active_refspecs);\n\terror = dwim_refspecs(&remote->active_refspecs, to_active, &refs);\n\n\tgit_vector_free(&refs);\n\tfree_refspecs(&specs);\n\tgit_vector_free(&specs);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (remote->push) {\n\t\tgit_push_free(remote->push);\n\t\tremote->push = NULL;\n\t}\n\n\tif ((error = git_fetch_negotiate(remote, opts)) < 0)\n\t\treturn error;\n\n\treturn git_fetch_download_pack(remote, cbs);\n\non_error:\n\tgit_vector_free(&refs);\n\tfree_refspecs(&specs);\n\tgit_vector_free(&specs);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&specs"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_refspecs",
          "args": [
            "&specs"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "free_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "852-863",
          "snippet": "static void free_refspecs(git_vector *vec)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(vec, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_clear(vec);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic void free_refspecs(git_vector *vec)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(vec, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_clear(vec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_fetch_download_pack",
          "args": [
            "remote",
            "cbs"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "git_fetch_download_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetch.c",
          "lines": "134-149",
          "snippet": "int git_fetch_download_pack(git_remote *remote, const git_remote_callbacks *callbacks)\n{\n\tgit_transport *t = remote->transport;\n\tgit_transfer_progress_cb progress = NULL;\n\tvoid *payload = NULL;\n\n\tif (!remote->need_pack)\n\t\treturn 0;\n\n\tif (callbacks) {\n\t\tprogress = callbacks->transfer_progress;\n\t\tpayload  = callbacks->payload;\n\t}\n\n\treturn t->download_pack(t, remote->repo, &remote->stats, progress, payload);\n}",
          "includes": [
            "#include \"refs.h\"",
            "#include \"repository.h\"",
            "#include \"netops.h\"",
            "#include \"fetch.h\"",
            "#include \"pack.h\"",
            "#include \"refspec.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refs.h\"\n#include \"repository.h\"\n#include \"netops.h\"\n#include \"fetch.h\"\n#include \"pack.h\"\n#include \"refspec.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/transport.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/oid.h\"\n\nint git_fetch_download_pack(git_remote *remote, const git_remote_callbacks *callbacks)\n{\n\tgit_transport *t = remote->transport;\n\tgit_transfer_progress_cb progress = NULL;\n\tvoid *payload = NULL;\n\n\tif (!remote->need_pack)\n\t\treturn 0;\n\n\tif (callbacks) {\n\t\tprogress = callbacks->transfer_progress;\n\t\tpayload  = callbacks->payload;\n\t}\n\n\treturn t->download_pack(t, remote->repo, &remote->stats, progress, payload);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_fetch_negotiate",
          "args": [
            "remote",
            "opts"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "git_fetch_negotiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetch.c",
          "lines": "109-132",
          "snippet": "int git_fetch_negotiate(git_remote *remote, const git_fetch_options *opts)\n{\n\tgit_transport *t = remote->transport;\n\n\tremote->need_pack = 0;\n\n\tif (filter_wants(remote, opts) < 0) {\n\t\tgiterr_set(GITERR_NET, \"Failed to filter the reference list for wants\");\n\t\treturn -1;\n\t}\n\n\t/* Don't try to negotiate when we don't want anything */\n\tif (!remote->need_pack)\n\t\treturn 0;\n\n\t/*\n\t * Now we have everything set up so we can start tell the\n\t * server what we want and what we have.\n\t */\n\treturn t->negotiate_fetch(t,\n\t\tremote->repo,\n\t\t(const git_remote_head * const *)remote->refs.contents,\n\t\tremote->refs.length);\n}",
          "includes": [
            "#include \"refs.h\"",
            "#include \"repository.h\"",
            "#include \"netops.h\"",
            "#include \"fetch.h\"",
            "#include \"pack.h\"",
            "#include \"refspec.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refs.h\"\n#include \"repository.h\"\n#include \"netops.h\"\n#include \"fetch.h\"\n#include \"pack.h\"\n#include \"refspec.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/transport.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/oid.h\"\n\nint git_fetch_negotiate(git_remote *remote, const git_fetch_options *opts)\n{\n\tgit_transport *t = remote->transport;\n\n\tremote->need_pack = 0;\n\n\tif (filter_wants(remote, opts) < 0) {\n\t\tgiterr_set(GITERR_NET, \"Failed to filter the reference list for wants\");\n\t\treturn -1;\n\t}\n\n\t/* Don't try to negotiate when we don't want anything */\n\tif (!remote->need_pack)\n\t\treturn 0;\n\n\t/*\n\t * Now we have everything set up so we can start tell the\n\t * server what we want and what we have.\n\t */\n\treturn t->negotiate_fetch(t,\n\t\tremote->repo,\n\t\t(const git_remote_head * const *)remote->refs.contents,\n\t\tremote->refs.length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_push_free",
          "args": [
            "remote->push"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "683-711",
          "snippet": "void git_push_free(git_push *push)\n{\n\tpush_spec *spec;\n\tpush_status *status;\n\tgit_push_update *update;\n\tunsigned int i;\n\n\tif (push == NULL)\n\t\treturn;\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tfree_refspec(spec);\n\t}\n\tgit_vector_free(&push->specs);\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tgit_push_status_free(status);\n\t}\n\tgit_vector_free(&push->status);\n\n\tgit_vector_foreach(&push->updates, i, update) {\n\t\tgit__free(update->src_refname);\n\t\tgit__free(update->dst_refname);\n\t\tgit__free(update);\n\t}\n\tgit_vector_free(&push->updates);\n\n\tgit__free(push);\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nvoid git_push_free(git_push *push)\n{\n\tpush_spec *spec;\n\tpush_status *status;\n\tgit_push_update *update;\n\tunsigned int i;\n\n\tif (push == NULL)\n\t\treturn;\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tfree_refspec(spec);\n\t}\n\tgit_vector_free(&push->specs);\n\n\tgit_vector_foreach(&push->status, i, status) {\n\t\tgit_push_status_free(status);\n\t}\n\tgit_vector_free(&push->status);\n\n\tgit_vector_foreach(&push->updates, i, update) {\n\t\tgit__free(update->src_refname);\n\t\tgit__free(update->dst_refname);\n\t\tgit__free(update);\n\t}\n\tgit_vector_free(&push->updates);\n\n\tgit__free(push);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dwim_refspecs",
          "args": [
            "&remote->active_refspecs",
            "to_active",
            "&refs"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "dwim_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "839-850",
          "snippet": "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_refspec_to",
          "args": [
            "&specs",
            "refspecs->strings[i]",
            "true"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "add_refspec_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "33-53",
          "snippet": "static int add_refspec_to(git_vector *vector, const char *string, bool is_fetch)\n{\n\tgit_refspec *spec;\n\n\tspec = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(spec);\n\n\tif (git_refspec__parse(spec, string, is_fetch) < 0) {\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\tspec->push = !is_fetch;\n\tif (git_vector_insert(vector, spec) < 0) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int add_refspec_to(git_vector *vector, const char *string, bool is_fetch)\n{\n\tgit_refspec *spec;\n\n\tspec = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(spec);\n\n\tif (git_refspec__parse(spec, string, is_fetch) < 0) {\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\tspec->push = !is_fetch;\n\tif (git_vector_insert(vector, spec) < 0) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&specs",
            "0",
            "NULL"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_to_vector",
          "args": [
            "&refs",
            "remote"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "ls_to_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "873-890",
          "snippet": "static int ls_to_vector(git_vector *out, git_remote *remote)\n{\n\tgit_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tif (git_vector_init(out, heads_len, remote_head_cmp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(out, heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int ls_to_vector(git_vector *out, git_remote *remote)\n{\n\tgit_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tif (git_vector_init(out, heads_len, remote_head_cmp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(out, heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_connect",
          "args": [
            "remote",
            "GIT_DIRECTION_FETCH",
            "cbs",
            "custom_headers"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "698-755",
          "snippet": "int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
            "char *apply_insteadof(git_config *config, const char *url, int direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nint git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_connected",
          "args": [
            "remote"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_connected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1615-1624",
          "snippet": "int git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_connected(const git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport || !remote->transport->is_connected)\n\t\treturn 0;\n\n\t/* Ask the transport if it's connected. */\n\treturn remote->transport->is_connected(remote->transport);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "&opts->callbacks",
            "GIT_REMOTE_CALLBACKS_VERSION",
            "\"git_remote_callbacks\""
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nint git_remote_download(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts)\n{\n\tint error = -1;\n\tsize_t i;\n\tgit_vector *to_active, specs = GIT_VECTOR_INIT, refs = GIT_VECTOR_INIT;\n\tconst git_remote_callbacks *cbs = NULL;\n\tconst git_strarray *custom_headers = NULL;\n\n\tassert(remote);\n\n\tif (opts) {\n\t\tGITERR_CHECK_VERSION(&opts->callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcbs = &opts->callbacks;\n\t\tcustom_headers = &opts->custom_headers;\n\t}\n\n\tif (!git_remote_connected(remote) &&\n\t    (error = git_remote_connect(remote, GIT_DIRECTION_FETCH, cbs, custom_headers)) < 0)\n\t\tgoto on_error;\n\n\tif (ls_to_vector(&refs, remote) < 0)\n\t\treturn -1;\n\n\tif ((git_vector_init(&specs, 0, NULL)) < 0)\n\t\tgoto on_error;\n\n\tremote->passed_refspecs = 0;\n\tif (!refspecs || !refspecs->count) {\n\t\tto_active = &remote->refspecs;\n\t} else {\n\t\tfor (i = 0; i < refspecs->count; i++) {\n\t\t\tif ((error = add_refspec_to(&specs, refspecs->strings[i], true)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tto_active = &specs;\n\t\tremote->passed_refspecs = 1;\n\t}\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tif ((error = dwim_refspecs(&remote->passive_refspecs, &remote->refspecs, &refs)) < 0)\n\t\tgoto on_error;\n\n\tfree_refspecs(&remote->active_refspecs);\n\terror = dwim_refspecs(&remote->active_refspecs, to_active, &refs);\n\n\tgit_vector_free(&refs);\n\tfree_refspecs(&specs);\n\tgit_vector_free(&specs);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (remote->push) {\n\t\tgit_push_free(remote->push);\n\t\tremote->push = NULL;\n\t}\n\n\tif ((error = git_fetch_negotiate(remote, opts)) < 0)\n\t\treturn error;\n\n\treturn git_fetch_download_pack(remote, cbs);\n\non_error:\n\tgit_vector_free(&refs);\n\tfree_refspecs(&specs);\n\tgit_vector_free(&specs);\n\treturn error;\n}"
  },
  {
    "function_name": "ls_to_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "873-890",
    "snippet": "static int ls_to_vector(git_vector *out, git_remote *remote)\n{\n\tgit_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tif (git_vector_init(out, heads_len, remote_head_cmp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(out, heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "out",
            "heads[i]"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "out",
            "heads_len",
            "remote_head_cmp"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_ls",
          "args": [
            "(const git_remote_head ***)&heads",
            "&heads_len",
            "remote"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "757-767",
          "snippet": "int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int ls_to_vector(git_vector *out, git_remote *remote)\n{\n\tgit_remote_head **heads;\n\tsize_t heads_len, i;\n\n\tif (git_remote_ls((const git_remote_head ***)&heads, &heads_len, remote) < 0)\n\t\treturn -1;\n\n\tif (git_vector_init(out, heads_len, remote_head_cmp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < heads_len; i++) {\n\t\tif (git_vector_insert(out, heads[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "remote_head_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "865-871",
    "snippet": "static int remote_head_cmp(const void *_a, const void *_b)\n{\n\tconst git_remote_head *a = (git_remote_head *) _a;\n\tconst git_remote_head *b = (git_remote_head *) _b;\n\n\treturn git__strcmp_cb(a->name, b->name);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strcmp_cb",
          "args": [
            "a->name",
            "b->name"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int remote_head_cmp(const void *_a, const void *_b)\n{\n\tconst git_remote_head *a = (git_remote_head *) _a;\n\tconst git_remote_head *b = (git_remote_head *) _b;\n\n\treturn git__strcmp_cb(a->name, b->name);\n}"
  },
  {
    "function_name": "free_refspecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "852-863",
    "snippet": "static void free_refspecs(git_vector *vec)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(vec, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_clear(vec);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "vec"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "spec"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "spec"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "vec",
            "i",
            "spec"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic void free_refspecs(git_vector *vec)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(vec, i, spec) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t}\n\n\tgit_vector_clear(vec);\n}"
  },
  {
    "function_name": "dwim_refspecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "839-850",
    "snippet": "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_refspec__dwim_one",
          "args": [
            "out",
            "spec",
            "refs"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__dwim_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "302-367",
          "snippet": "int git_refspec__dwim_one(git_vector *out, git_refspec *spec, git_vector *refs)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t j, pos;\n\tgit_remote_head key;\n\n\tconst char* formatters[] = {\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tNULL\n\t};\n\n\tgit_refspec *cur = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(cur);\n\n\tcur->force = spec->force;\n\tcur->push = spec->push;\n\tcur->pattern = spec->pattern;\n\tcur->matching = spec->matching;\n\tcur->string = git__strdup(spec->string);\n\n\t/* shorthand on the lhs */\n\tif (git__prefixcmp(spec->src, GIT_REFS_DIR)) {\n\t\tfor (j = 0; formatters[j]; j++) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_printf(&buf, formatters[j], spec->src);\n\t\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\tif (!git_vector_search(&pos, refs, &key)) {\n\t\t\t\t/* we found something to match the shorthand, set src to that */\n\t\t\t\tcur->src = git_buf_detach(&buf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* No shorthands found, copy over the name */\n\tif (cur->src == NULL && spec->src != NULL) {\n\t\tcur->src = git__strdup(spec->src);\n\t\tGITERR_CHECK_ALLOC(cur->src);\n\t}\n\n\tif (spec->dst && git__prefixcmp(spec->dst, GIT_REFS_DIR)) {\n\t\t/* if it starts with \"remotes\" then we just prepend \"refs/\" */\n\t\tif (!git__prefixcmp(spec->dst, \"remotes/\")) {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_DIR);\n\t\t} else {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_HEADS_DIR);\n\t\t}\n\n\t\tgit_buf_puts(&buf, spec->dst);\n\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\tcur->dst = git_buf_detach(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\n\tif (cur->dst == NULL && spec->dst != NULL) {\n\t\tcur->dst = git__strdup(spec->dst);\n\t\tGITERR_CHECK_ALLOC(cur->dst);\n\t}\n\n\treturn git_vector_insert(out, cur);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__dwim_one(git_vector *out, git_refspec *spec, git_vector *refs)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tsize_t j, pos;\n\tgit_remote_head key;\n\n\tconst char* formatters[] = {\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tNULL\n\t};\n\n\tgit_refspec *cur = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(cur);\n\n\tcur->force = spec->force;\n\tcur->push = spec->push;\n\tcur->pattern = spec->pattern;\n\tcur->matching = spec->matching;\n\tcur->string = git__strdup(spec->string);\n\n\t/* shorthand on the lhs */\n\tif (git__prefixcmp(spec->src, GIT_REFS_DIR)) {\n\t\tfor (j = 0; formatters[j]; j++) {\n\t\t\tgit_buf_clear(&buf);\n\t\t\tgit_buf_printf(&buf, formatters[j], spec->src);\n\t\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\t\tkey.name = (char *) git_buf_cstr(&buf);\n\t\t\tif (!git_vector_search(&pos, refs, &key)) {\n\t\t\t\t/* we found something to match the shorthand, set src to that */\n\t\t\t\tcur->src = git_buf_detach(&buf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* No shorthands found, copy over the name */\n\tif (cur->src == NULL && spec->src != NULL) {\n\t\tcur->src = git__strdup(spec->src);\n\t\tGITERR_CHECK_ALLOC(cur->src);\n\t}\n\n\tif (spec->dst && git__prefixcmp(spec->dst, GIT_REFS_DIR)) {\n\t\t/* if it starts with \"remotes\" then we just prepend \"refs/\" */\n\t\tif (!git__prefixcmp(spec->dst, \"remotes/\")) {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_DIR);\n\t\t} else {\n\t\t\tgit_buf_puts(&buf, GIT_REFS_HEADS_DIR);\n\t\t}\n\n\t\tgit_buf_puts(&buf, spec->dst);\n\t\tGITERR_CHECK_ALLOC_BUF(&buf);\n\n\t\tcur->dst = git_buf_detach(&buf);\n\t}\n\n\tgit_buf_free(&buf);\n\n\tif (cur->dst == NULL && spec->dst != NULL) {\n\t\tcur->dst = git__strdup(spec->dst);\n\t\tGITERR_CHECK_ALLOC(cur->dst);\n\t}\n\n\treturn git_vector_insert(out, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "refspecs",
            "i",
            "spec"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_remote__get_http_proxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "769-836",
    "snippet": "int git_remote__get_http_proxy(git_remote *remote, bool use_ssl, char **proxy_url)\n{\n\tgit_config *cfg;\n\tgit_config_entry *ce = NULL;\n\tgit_buf val = GIT_BUF_INIT;\n\tint error;\n\n\tassert(remote);\n\n\tif (!proxy_url || !remote->repo)\n\t\treturn -1;\n\n\t*proxy_url = NULL;\n\n\tif ((error = git_repository_config__weakptr(&cfg, remote->repo)) < 0)\n\t\treturn error;\n\n\t/* Go through the possible sources for proxy configuration, from most specific\n\t * to least specific. */\n\n\t/* remote.<name>.proxy config setting */\n\tif (remote->name && remote->name[0]) {\n\t\tgit_buf buf = GIT_BUF_INIT;\n\n\t\tif ((error = git_buf_printf(&buf, \"remote.%s.proxy\", remote->name)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\t\tgit_buf_free(&buf);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ce && ce->value) {\n\t\t\t*proxy_url = git__strdup(ce->value);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* http.proxy config setting */\n\tif ((error = git_config__lookup_entry(&ce, cfg, \"http.proxy\", false)) < 0)\n\t\treturn error;\n\n\tif (ce && ce->value) {\n\t\t*proxy_url = git__strdup(ce->value);\n\t\tgoto found;\n\t}\n\n\t/* HTTP_PROXY / HTTPS_PROXY environment variables */\n\terror = git__getenv(&val, use_ssl ? \"HTTPS_PROXY\" : \"HTTP_PROXY\");\n\n\tif (error < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\treturn error;\n\t}\n\n\t*proxy_url = git_buf_detach(&val);\n\nfound:\n\tGITERR_CHECK_ALLOC(*proxy_url);\n\tgit_config_entry_free(ce);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_entry_free",
          "args": [
            "ce"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "23-29",
          "snippet": "void git_config_entry_free(git_config_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->free(entry);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_entry_free(git_config_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "*proxy_url"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&val"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__getenv",
          "args": [
            "&val",
            "use_ssl ? \"HTTPS_PROXY\" : \"HTTP_PROXY\""
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "git__getenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "799-809",
          "snippet": "int git__getenv(git_buf *out, const char *name)\n{\n\tconst char *val = getenv(name);\n\n\tgit_buf_clear(out);\n\n\tif (!val)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_buf_puts(out, val);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__getenv(git_buf *out, const char *name)\n{\n\tconst char *val = getenv(name);\n\n\tgit_buf_clear(out);\n\n\tif (!val)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_buf_puts(out, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "ce->value"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__lookup_entry",
          "args": [
            "&ce",
            "cfg",
            "\"http.proxy\"",
            "false"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__lookup_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "737-745",
          "snippet": "int git_config__lookup_entry(\n\tgit_config_entry **out,\n\tconst git_config *cfg,\n\tconst char *key,\n\tbool no_errors)\n{\n\treturn get_entry(\n\t\tout, cfg, key, false, no_errors ? GET_NO_ERRORS : GET_NO_MISSING);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__lookup_entry(\n\tgit_config_entry **out,\n\tconst git_config *cfg,\n\tconst char *key,\n\tbool no_errors)\n{\n\treturn get_entry(\n\t\tout, cfg, key, false, no_errors ? GET_NO_ERRORS : GET_NO_MISSING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"remote.%s.proxy\"",
            "remote->name"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "remote->repo"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote__get_http_proxy(git_remote *remote, bool use_ssl, char **proxy_url)\n{\n\tgit_config *cfg;\n\tgit_config_entry *ce = NULL;\n\tgit_buf val = GIT_BUF_INIT;\n\tint error;\n\n\tassert(remote);\n\n\tif (!proxy_url || !remote->repo)\n\t\treturn -1;\n\n\t*proxy_url = NULL;\n\n\tif ((error = git_repository_config__weakptr(&cfg, remote->repo)) < 0)\n\t\treturn error;\n\n\t/* Go through the possible sources for proxy configuration, from most specific\n\t * to least specific. */\n\n\t/* remote.<name>.proxy config setting */\n\tif (remote->name && remote->name[0]) {\n\t\tgit_buf buf = GIT_BUF_INIT;\n\n\t\tif ((error = git_buf_printf(&buf, \"remote.%s.proxy\", remote->name)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\t\tgit_buf_free(&buf);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ce && ce->value) {\n\t\t\t*proxy_url = git__strdup(ce->value);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* http.proxy config setting */\n\tif ((error = git_config__lookup_entry(&ce, cfg, \"http.proxy\", false)) < 0)\n\t\treturn error;\n\n\tif (ce && ce->value) {\n\t\t*proxy_url = git__strdup(ce->value);\n\t\tgoto found;\n\t}\n\n\t/* HTTP_PROXY / HTTPS_PROXY environment variables */\n\terror = git__getenv(&val, use_ssl ? \"HTTPS_PROXY\" : \"HTTP_PROXY\");\n\n\tif (error < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\treturn error;\n\t}\n\n\t*proxy_url = git_buf_detach(&val);\n\nfound:\n\tGITERR_CHECK_ALLOC(*proxy_url);\n\tgit_config_entry_free(ce);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_remote_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "757-767",
    "snippet": "int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remote->transport->ls",
          "args": [
            "out",
            "size",
            "remote->transport"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"this remote has never connected\""
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)\n{\n\tassert(remote);\n\n\tif (!remote->transport) {\n\t\tgiterr_set(GITERR_NET, \"this remote has never connected\");\n\t\treturn -1;\n\t}\n\n\treturn remote->transport->ls(out, size, remote->transport);\n}"
  },
  {
    "function_name": "git_remote_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "698-755",
    "snippet": "int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
      "char *apply_insteadof(git_config *config, const char *url, int direction);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->free",
          "args": [
            "t"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->connect",
          "args": [
            "t",
            "url",
            "credentials",
            "payload",
            "direction",
            "flags"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_transport_callbacks",
          "args": [
            "t",
            "callbacks"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "set_transport_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "681-688",
          "snippet": "int set_transport_callbacks(git_transport *t, const git_remote_callbacks *cbs)\n{\n\tif (!t->set_callbacks || !cbs)\n\t\treturn 0;\n\n\treturn t->set_callbacks(t, cbs->sideband_progress, NULL,\n\t\t\t\tcbs->certificate_check, cbs->payload);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint set_transport_callbacks(git_transport *t, const git_remote_callbacks *cbs)\n{\n\tif (!t->set_callbacks || !cbs)\n\t\treturn 0;\n\n\treturn t->set_callbacks(t, cbs->sideband_progress, NULL,\n\t\t\t\tcbs->certificate_check, cbs->payload);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_transport_custom_headers",
          "args": [
            "t",
            "custom_headers"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "set_transport_custom_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "690-696",
          "snippet": "static int set_transport_custom_headers(git_transport *t, const git_strarray *custom_headers)\n{\n\tif (!t->set_custom_headers)\n\t\treturn 0;\n\n\treturn t->set_custom_headers(t, custom_headers);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int set_transport_custom_headers(git_transport *t, const git_strarray *custom_headers)\n{\n\tif (!t->set_custom_headers)\n\t\treturn 0;\n\n\treturn t->set_custom_headers(t, custom_headers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_transport_new",
          "args": [
            "&t",
            "remote",
            "url"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "git_transport_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
          "lines": "118-139",
          "snippet": "int git_transport_new(git_transport **out, git_remote *owner, const char *url)\n{\n\tgit_transport_cb fn;\n\tgit_transport *transport;\n\tvoid *param;\n\tint error;\n\n\tif ((error = transport_find_fn(&fn, url, &param)) == GIT_ENOTFOUND) {\n\t\tgiterr_set(GITERR_NET, \"Unsupported URL protocol\");\n\t\treturn -1;\n\t} else if (error < 0)\n\t\treturn error;\n\n\tif ((error = fn(&transport, owner, param)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(transport, GIT_TRANSPORT_VERSION, \"git_transport\");\n\n\t*out = transport;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"path.h\"",
            "#include \"git2/sys/transport.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nint git_transport_new(git_transport **out, git_remote *owner, const char *url)\n{\n\tgit_transport_cb fn;\n\tgit_transport *transport;\n\tvoid *param;\n\tint error;\n\n\tif ((error = transport_find_fn(&fn, url, &param)) == GIT_ENOTFOUND) {\n\t\tgiterr_set(GITERR_NET, \"Unsupported URL protocol\");\n\t\treturn -1;\n\t} else if (error < 0)\n\t\treturn error;\n\n\tif ((error = fn(&transport, owner, param)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(transport, GIT_TRANSPORT_VERSION, \"git_transport\");\n\n\t*out = transport;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transport",
          "args": [
            "&t",
            "remote",
            "payload"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "git_transport_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
          "lines": "141-180",
          "snippet": "int git_transport_register(\n\tconst char *scheme,\n\tgit_transport_cb cb,\n\tvoid *param)\n{\n\tgit_buf prefix = GIT_BUF_INIT;\n\ttransport_definition *d, *definition = NULL;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(scheme);\n\tassert(cb);\n\n\tif ((error = git_buf_printf(&prefix, \"%s://\", scheme)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strcasecmp(d->prefix, prefix.ptr) == 0) {\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tdefinition = git__calloc(1, sizeof(transport_definition));\n\tGITERR_CHECK_ALLOC(definition);\n\n\tdefinition->prefix = git_buf_detach(&prefix);\n\tdefinition->fn = cb;\n\tdefinition->param = param;\n\n\tif (git_vector_insert(&custom_transports, definition) < 0)\n\t\tgoto on_error;\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&prefix);\n\tgit__free(definition);\n\treturn error;\n}",
          "includes": [
            "#include \"path.h\"",
            "#include \"git2/sys/transport.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_vector custom_transports = GIT_VECTOR_INIT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nstatic git_vector custom_transports = GIT_VECTOR_INIT;\n\nint git_transport_register(\n\tconst char *scheme,\n\tgit_transport_cb cb,\n\tvoid *param)\n{\n\tgit_buf prefix = GIT_BUF_INIT;\n\ttransport_definition *d, *definition = NULL;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(scheme);\n\tassert(cb);\n\n\tif ((error = git_buf_printf(&prefix, \"%s://\", scheme)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strcasecmp(d->prefix, prefix.ptr) == 0) {\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tdefinition = git__calloc(1, sizeof(transport_definition));\n\tGITERR_CHECK_ALLOC(definition);\n\n\tdefinition->prefix = git_buf_detach(&prefix);\n\tdefinition->fn = cb;\n\tdefinition->param = param;\n\n\tif (git_vector_insert(&custom_transports, definition) < 0)\n\t\tgoto on_error;\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&prefix);\n\tgit__free(definition);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Malformed remote '%s' - missing URL\"",
            "remote->name"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote__urlfordirection",
          "args": [
            "remote",
            "direction"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote__urlfordirection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "664-679",
          "snippet": "const char* git_remote__urlfordirection(git_remote *remote, int direction)\n{\n\tassert(remote);\n\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\treturn remote->url;\n\t}\n\n\tif (direction == GIT_DIRECTION_PUSH) {\n\t\treturn remote->pushurl ? remote->pushurl : remote->url;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *apply_insteadof(git_config *config, const char *url, int direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nconst char* git_remote__urlfordirection(git_remote *remote, int direction)\n{\n\tassert(remote);\n\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\treturn remote->url;\n\t}\n\n\tif (direction == GIT_DIRECTION_PUSH) {\n\t\treturn remote->pushurl ? remote->pushurl : remote->url;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "callbacks",
            "GIT_REMOTE_CALLBACKS_VERSION",
            "\"git_remote_callbacks\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nint git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_strarray *custom_headers)\n{\n\tgit_transport *t;\n\tconst char *url;\n\tint flags = GIT_TRANSPORTFLAGS_NONE;\n\tint error;\n\tvoid *payload = NULL;\n\tgit_cred_acquire_cb credentials = NULL;\n\tgit_transport_cb transport = NULL;\n\n\tassert(remote);\n\n\tif (callbacks) {\n\t\tGITERR_CHECK_VERSION(callbacks, GIT_REMOTE_CALLBACKS_VERSION, \"git_remote_callbacks\");\n\t\tcredentials = callbacks->credentials;\n\t\ttransport   = callbacks->transport;\n\t\tpayload     = callbacks->payload;\n\t}\n\n\tt = remote->transport;\n\n\turl = git_remote__urlfordirection(remote, direction);\n\tif (url == NULL) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Malformed remote '%s' - missing URL\", remote->name);\n\t\treturn -1;\n\t}\n\n\t/* If we don't have a transport object yet, and the caller specified a\n\t * custom transport factory, use that */\n\tif (!t && transport &&\n\t\t(error = transport(&t, remote, payload)) < 0)\n\t\treturn error;\n\n\t/* If we still don't have a transport, then use the global\n\t * transport registrations which map URI schemes to transport factories */\n\tif (!t && (error = git_transport_new(&t, remote, url)) < 0)\n\t\treturn error;\n\n\tif ((error = set_transport_custom_headers(t, custom_headers)) != 0)\n\t\tgoto on_error;\n\n\tif ((error = set_transport_callbacks(t, callbacks)) < 0 ||\n\t    (error = t->connect(t, url, credentials, payload, direction, flags)) != 0)\n\t\tgoto on_error;\n\n\tremote->transport = t;\n\n\treturn 0;\n\non_error:\n\tt->free(t);\n\n\tif (t == remote->transport)\n\t\tremote->transport = NULL;\n\n\treturn error;\n}"
  },
  {
    "function_name": "set_transport_custom_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "690-696",
    "snippet": "static int set_transport_custom_headers(git_transport *t, const git_strarray *custom_headers)\n{\n\tif (!t->set_custom_headers)\n\t\treturn 0;\n\n\treturn t->set_custom_headers(t, custom_headers);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->set_custom_headers",
          "args": [
            "t",
            "custom_headers"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int set_transport_custom_headers(git_transport *t, const git_strarray *custom_headers)\n{\n\tif (!t->set_custom_headers)\n\t\treturn 0;\n\n\treturn t->set_custom_headers(t, custom_headers);\n}"
  },
  {
    "function_name": "set_transport_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "681-688",
    "snippet": "int set_transport_callbacks(git_transport *t, const git_remote_callbacks *cbs)\n{\n\tif (!t->set_callbacks || !cbs)\n\t\treturn 0;\n\n\treturn t->set_callbacks(t, cbs->sideband_progress, NULL,\n\t\t\t\tcbs->certificate_check, cbs->payload);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->set_callbacks",
          "args": [
            "t",
            "cbs->sideband_progress",
            "NULL",
            "cbs->certificate_check",
            "cbs->payload"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint set_transport_callbacks(git_transport *t, const git_remote_callbacks *cbs)\n{\n\tif (!t->set_callbacks || !cbs)\n\t\treturn 0;\n\n\treturn t->set_callbacks(t, cbs->sideband_progress, NULL,\n\t\t\t\tcbs->certificate_check, cbs->payload);\n}"
  },
  {
    "function_name": "git_remote__urlfordirection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "664-679",
    "snippet": "const char* git_remote__urlfordirection(git_remote *remote, int direction)\n{\n\tassert(remote);\n\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\treturn remote->url;\n\t}\n\n\tif (direction == GIT_DIRECTION_PUSH) {\n\t\treturn remote->pushurl ? remote->pushurl : remote->url;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *apply_insteadof(git_config *config, const char *url, int direction);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nconst char* git_remote__urlfordirection(git_remote *remote, int direction)\n{\n\tassert(remote);\n\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\treturn remote->url;\n\t}\n\n\tif (direction == GIT_DIRECTION_PUSH) {\n\t\treturn remote->pushurl ? remote->pushurl : remote->url;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "git_remote_set_pushurl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "659-662",
    "snippet": "int git_remote_set_pushurl(git_repository *repo, const char *remote, const char* url)\n{\n\treturn set_url(repo, remote, CONFIG_PUSHURL_FMT, url);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [
      "#define CONFIG_PUSHURL_FMT \"remote.%s.pushurl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_url",
          "args": [
            "repo",
            "remote",
            "CONFIG_PUSHURL_FMT",
            "url"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "set_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "615-646",
          "snippet": "static int set_url(git_repository *repo, const char *remote, const char *pattern, const char *url)\n{\n\tgit_config *cfg;\n\tgit_buf buf = GIT_BUF_INIT, canonical_url = GIT_BUF_INIT;\n\tint error;\n\n\tassert(repo && remote);\n\n\tif ((error = ensure_remote_name_is_valid(remote)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(&buf, pattern, remote)) < 0)\n\t\treturn error;\n\n\tif (url) {\n\t\tif ((error = canonicalize_url(&canonical_url, url)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_config_set_string(cfg, buf.ptr, url);\n\t} else {\n\t\terror = git_config_delete_entry(cfg, buf.ptr);\n\t}\n\ncleanup:\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int set_url(git_repository *repo, const char *remote, const char *pattern, const char *url)\n{\n\tgit_config *cfg;\n\tgit_buf buf = GIT_BUF_INIT, canonical_url = GIT_BUF_INIT;\n\tint error;\n\n\tassert(repo && remote);\n\n\tif ((error = ensure_remote_name_is_valid(remote)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(&buf, pattern, remote)) < 0)\n\t\treturn error;\n\n\tif (url) {\n\t\tif ((error = canonicalize_url(&canonical_url, url)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_config_set_string(cfg, buf.ptr, url);\n\t} else {\n\t\terror = git_config_delete_entry(cfg, buf.ptr);\n\t}\n\ncleanup:\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_PUSHURL_FMT \"remote.%s.pushurl\"\n\nint git_remote_set_pushurl(git_repository *repo, const char *remote, const char* url)\n{\n\treturn set_url(repo, remote, CONFIG_PUSHURL_FMT, url);\n}"
  },
  {
    "function_name": "git_remote_pushurl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "653-657",
    "snippet": "const char *git_remote_pushurl(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->pushurl;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nconst char *git_remote_pushurl(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->pushurl;\n}"
  },
  {
    "function_name": "git_remote_set_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "648-651",
    "snippet": "int git_remote_set_url(git_repository *repo, const char *remote, const char *url)\n{\n\treturn set_url(repo, remote, CONFIG_URL_FMT, url);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [
      "#define CONFIG_URL_FMT \"remote.%s.url\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_url",
          "args": [
            "repo",
            "remote",
            "CONFIG_URL_FMT",
            "url"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "set_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "615-646",
          "snippet": "static int set_url(git_repository *repo, const char *remote, const char *pattern, const char *url)\n{\n\tgit_config *cfg;\n\tgit_buf buf = GIT_BUF_INIT, canonical_url = GIT_BUF_INIT;\n\tint error;\n\n\tassert(repo && remote);\n\n\tif ((error = ensure_remote_name_is_valid(remote)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(&buf, pattern, remote)) < 0)\n\t\treturn error;\n\n\tif (url) {\n\t\tif ((error = canonicalize_url(&canonical_url, url)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_config_set_string(cfg, buf.ptr, url);\n\t} else {\n\t\terror = git_config_delete_entry(cfg, buf.ptr);\n\t}\n\ncleanup:\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int set_url(git_repository *repo, const char *remote, const char *pattern, const char *url)\n{\n\tgit_config *cfg;\n\tgit_buf buf = GIT_BUF_INIT, canonical_url = GIT_BUF_INIT;\n\tint error;\n\n\tassert(repo && remote);\n\n\tif ((error = ensure_remote_name_is_valid(remote)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(&buf, pattern, remote)) < 0)\n\t\treturn error;\n\n\tif (url) {\n\t\tif ((error = canonicalize_url(&canonical_url, url)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_config_set_string(cfg, buf.ptr, url);\n\t} else {\n\t\terror = git_config_delete_entry(cfg, buf.ptr);\n\t}\n\ncleanup:\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_URL_FMT \"remote.%s.url\"\n\nint git_remote_set_url(git_repository *repo, const char *remote, const char *url)\n{\n\treturn set_url(repo, remote, CONFIG_URL_FMT, url);\n}"
  },
  {
    "function_name": "set_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "615-646",
    "snippet": "static int set_url(git_repository *repo, const char *remote, const char *pattern, const char *url)\n{\n\tgit_config *cfg;\n\tgit_buf buf = GIT_BUF_INIT, canonical_url = GIT_BUF_INIT;\n\tint error;\n\n\tassert(repo && remote);\n\n\tif ((error = ensure_remote_name_is_valid(remote)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(&buf, pattern, remote)) < 0)\n\t\treturn error;\n\n\tif (url) {\n\t\tif ((error = canonicalize_url(&canonical_url, url)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_config_set_string(cfg, buf.ptr, url);\n\t} else {\n\t\terror = git_config_delete_entry(cfg, buf.ptr);\n\t}\n\ncleanup:\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_delete_entry",
          "args": [
            "cfg",
            "buf.ptr"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "586-597",
          "snippet": "int git_config_delete_entry(git_config *cfg, const char *name)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del(file, name);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_delete_entry(git_config *cfg, const char *name)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del(file, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_set_string",
          "args": [
            "cfg",
            "buf.ptr",
            "url"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "616-638",
          "snippet": "int git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalize_url",
          "args": [
            "&canonical_url",
            "url"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "canonicalize_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "168-190",
          "snippet": "static int canonicalize_url(git_buf *out, const char *in)\n{\n\tif (in == NULL || strlen(in) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot set empty URL\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n#ifdef GIT_WIN32\n\t/* Given a UNC path like \\\\server\\path, we need to convert this\n\t * to //server/path for compatibility with core git.\n\t */\n\tif (in[0] == '\\\\' && in[1] == '\\\\' &&\n\t\t(git__isalpha(in[2]) || git__isdigit(in[2]))) {\n\t\tconst char *c;\n\t\tfor (c = in; *c; c++)\n\t\t\tgit_buf_putc(out, *c == '\\\\' ? '/' : *c);\n\n\t\treturn git_buf_oom(out) ? -1 : 0;\n\t}\n#endif\n\n\treturn git_buf_puts(out, in);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int canonicalize_url(git_buf *out, const char *in)\n{\n\tif (in == NULL || strlen(in) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot set empty URL\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n#ifdef GIT_WIN32\n\t/* Given a UNC path like \\\\server\\path, we need to convert this\n\t * to //server/path for compatibility with core git.\n\t */\n\tif (in[0] == '\\\\' && in[1] == '\\\\' &&\n\t\t(git__isalpha(in[2]) || git__isdigit(in[2]))) {\n\t\tconst char *c;\n\t\tfor (c = in; *c; c++)\n\t\t\tgit_buf_putc(out, *c == '\\\\' ? '/' : *c);\n\n\t\treturn git_buf_oom(out) ? -1 : 0;\n\t}\n#endif\n\n\treturn git_buf_puts(out, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "pattern",
            "remote"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "repo"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_remote_name_is_valid",
          "args": [
            "remote"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_remote_name_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "83-95",
          "snippet": "static int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && remote"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int set_url(git_repository *repo, const char *remote, const char *pattern, const char *url)\n{\n\tgit_config *cfg;\n\tgit_buf buf = GIT_BUF_INIT, canonical_url = GIT_BUF_INIT;\n\tint error;\n\n\tassert(repo && remote);\n\n\tif ((error = ensure_remote_name_is_valid(remote)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_buf_printf(&buf, pattern, remote)) < 0)\n\t\treturn error;\n\n\tif (url) {\n\t\tif ((error = canonicalize_url(&canonical_url, url)) < 0)\n\t\t\tgoto cleanup;\n\n\t\terror = git_config_set_string(cfg, buf.ptr, url);\n\t} else {\n\t\terror = git_config_delete_entry(cfg, buf.ptr);\n\t}\n\ncleanup:\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_remote_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "609-613",
    "snippet": "const char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nconst char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}"
  },
  {
    "function_name": "git_remote_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "603-607",
    "snippet": "git_repository *git_remote_owner(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->repo;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\ngit_repository *git_remote_owner(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->repo;\n}"
  },
  {
    "function_name": "git_remote_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "597-601",
    "snippet": "const char *git_remote_name(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->name;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "remote"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nconst char *git_remote_name(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->name;\n}"
  },
  {
    "function_name": "update_config_refspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "550-595",
    "snippet": "static int update_config_refspec(const git_remote *remote, git_config *config, int direction)\n{\n\tgit_buf name = GIT_BUF_INIT;\n\tunsigned int push;\n\tconst char *dir;\n\tsize_t i;\n\tint error = 0;\n\tconst char *cname;\n\n\tpush = direction == GIT_DIRECTION_PUSH;\n\tdir = push ? \"push\" : \"fetch\";\n\n\tif (git_buf_printf(&name, \"remote.%s.%s\", remote->name, dir) < 0)\n\t\treturn -1;\n\tcname = git_buf_cstr(&name);\n\n\t/* Clear out the existing config */\n\twhile (!error)\n\t\terror = git_config_delete_multivar(config, cname, \".*\");\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tfor (i = 0; i < remote->refspecs.length; i++) {\n\t\tgit_refspec *spec = git_vector_get(&remote->refspecs, i);\n\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\t// \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t\t// all values will be considered new and we will not replace any\n\t\t// present value.\n\t\tif ((error = git_config_set_multivar(\n\t\t\t\tconfig, cname, \"$^\", spec->string)) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&name);\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
      "char *apply_insteadof(git_config *config, const char *url, int direction);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&name"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_set_multivar",
          "args": [
            "config",
            "cname",
            "\"$^\"",
            "spec->string"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_set_multivar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1032-1043",
          "snippet": "int git_config_set_multivar(git_config *cfg, const char *name, const char *regexp, const char *value)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->set_multivar(file, name, regexp, value);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_set_multivar(git_config *cfg, const char *name, const char *regexp, const char *value)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->set_multivar(file, name, regexp, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&remote->refspecs",
            "i"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_delete_multivar",
          "args": [
            "config",
            "cname",
            "\".*\""
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_delete_multivar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1045-1056",
          "snippet": "int git_config_delete_multivar(git_config *cfg, const char *name, const char *regexp)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del_multivar(file, name, regexp);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_delete_multivar(git_config *cfg, const char *name, const char *regexp)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->del_multivar(file, name, regexp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&name"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&name",
            "\"remote.%s.%s\"",
            "remote->name",
            "dir"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nstatic int update_config_refspec(const git_remote *remote, git_config *config, int direction)\n{\n\tgit_buf name = GIT_BUF_INIT;\n\tunsigned int push;\n\tconst char *dir;\n\tsize_t i;\n\tint error = 0;\n\tconst char *cname;\n\n\tpush = direction == GIT_DIRECTION_PUSH;\n\tdir = push ? \"push\" : \"fetch\";\n\n\tif (git_buf_printf(&name, \"remote.%s.%s\", remote->name, dir) < 0)\n\t\treturn -1;\n\tcname = git_buf_cstr(&name);\n\n\t/* Clear out the existing config */\n\twhile (!error)\n\t\terror = git_config_delete_multivar(config, cname, \".*\");\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tfor (i = 0; i < remote->refspecs.length; i++) {\n\t\tgit_refspec *spec = git_vector_get(&remote->refspecs, i);\n\n\t\tif (spec->push != push)\n\t\t\tcontinue;\n\n\t\t// \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t\t// all values will be considered new and we will not replace any\n\t\t// present value.\n\t\tif ((error = git_config_set_multivar(\n\t\t\t\tconfig, cname, \"$^\", spec->string)) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tgiterr_clear();\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&name);\n\n\treturn error;\n}"
  },
  {
    "function_name": "lookup_remote_prune_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "526-548",
    "snippet": "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0;\n\n\tgit_buf_printf(&buf, \"remote.%s.prune\", name);\n\n\tif ((error = git_config_get_bool(&remote->prune_refs, config, git_buf_cstr(&buf))) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\n\t\t\tif ((error = git_config_get_bool(&remote->prune_refs, config, \"fetch.prune\")) < 0) {\n\t\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t\tgiterr_clear();\n\t\t\t\t\terror = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_get_bool",
          "args": [
            "&remote->prune_refs",
            "config",
            "\"fetch.prune\""
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_get_bool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "794-806",
          "snippet": "int git_config_get_bool(int *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\n\tif ((ret = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS)) < 0)\n\t\treturn ret;\n\n\tret = git_config_parse_bool(out, entry->value);\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_get_bool(int *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\n\tif ((ret = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS)) < 0)\n\t\treturn ret;\n\n\tret = git_config_parse_bool(out, entry->value);\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"remote.%s.prune\"",
            "name"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0;\n\n\tgit_buf_printf(&buf, \"remote.%s.prune\", name);\n\n\tif ((error = git_config_get_bool(&remote->prune_refs, config, git_buf_cstr(&buf))) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\n\t\t\tif ((error = git_config_get_bool(&remote->prune_refs, config, \"fetch.prune\")) < 0) {\n\t\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t\tgiterr_clear();\n\t\t\t\t\terror = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}"
  },
  {
    "function_name": "git_remote_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "420-524",
    "snippet": "int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "config"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dwim_refspecs",
          "args": [
            "&remote->active_refspecs",
            "&remote->refspecs",
            "&remote->refs"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "dwim_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "839-850",
          "snippet": "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_remote_prune_config",
          "args": [
            "remote",
            "config",
            "name"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_remote_prune_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "526-548",
          "snippet": "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0;\n\n\tgit_buf_printf(&buf, \"remote.%s.prune\", name);\n\n\tif ((error = git_config_get_bool(&remote->prune_refs, config, git_buf_cstr(&buf))) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\n\t\t\tif ((error = git_config_get_bool(&remote->prune_refs, config, \"fetch.prune\")) < 0) {\n\t\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t\tgiterr_clear();\n\t\t\t\t\terror = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0;\n\n\tgit_buf_printf(&buf, \"remote.%s.prune\", name);\n\n\tif ((error = git_config_get_bool(&remote->prune_refs, config, git_buf_cstr(&buf))) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\n\t\t\tif ((error = git_config_get_bool(&remote->prune_refs, config, \"fetch.prune\")) < 0) {\n\t\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t\tgiterr_clear();\n\t\t\t\t\terror = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "download_tags_value",
          "args": [
            "remote",
            "config"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "download_tags_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "60-81",
          "snippet": "static int download_tags_value(git_remote *remote, git_config *cfg)\n{\n\tgit_config_entry *ce;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, \"remote.%s.tagopt\", remote->name) < 0)\n\t\treturn -1;\n\n\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\tgit_buf_free(&buf);\n\n\tif (!error && ce && ce->value) {\n\t\tif (!strcmp(ce->value, \"--no-tags\"))\n\t\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\t\telse if (!strcmp(ce->value, \"--tags\"))\n\t\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;\n\t}\n\n\tgit_config_entry_free(ce);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int download_tags_value(git_remote *remote, git_config *cfg)\n{\n\tgit_config_entry *ce;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, \"remote.%s.tagopt\", remote->name) < 0)\n\t\treturn -1;\n\n\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\tgit_buf_free(&buf);\n\n\tif (!error && ce && ce->value) {\n\t\tif (!strcmp(ce->value, \"--no-tags\"))\n\t\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\t\telse if (!strcmp(ce->value, \"--tags\"))\n\t\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;\n\t}\n\n\tgit_config_entry_free(ce);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_optional_config",
          "args": [
            "NULL",
            "config",
            "&buf",
            "refspec_cb",
            "&data"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "get_optional_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "394-418",
          "snippet": "static int get_optional_config(\n\tbool *found, git_config *config, git_buf *buf,\n\tgit_config_foreach_cb cb, void *payload)\n{\n\tint error = 0;\n\tconst char *key = git_buf_cstr(buf);\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\tif (cb != NULL)\n\t\terror = git_config_get_multivar_foreach(config, key, NULL, cb, payload);\n\telse\n\t\terror = git_config_get_string(payload, config, key);\n\n\tif (found)\n\t\t*found = !error;\n\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int get_optional_config(\n\tbool *found, git_config *config, git_buf *buf,\n\tgit_config_foreach_cb cb, void *payload)\n{\n\tint error = 0;\n\tconst char *key = git_buf_cstr(buf);\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\tif (cb != NULL)\n\t\terror = git_config_get_multivar_foreach(config, key, NULL, cb, payload);\n\telse\n\t\terror = git_config_get_string(payload, config, key);\n\n\tif (found)\n\t\t*found = !error;\n\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"remote.%s.push\"",
            "name"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&buf"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote->pushurl"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_insteadof",
          "args": [
            "config",
            "val",
            "GIT_DIRECTION_PUSH"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "apply_insteadof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2490-2549",
          "snippet": "char *apply_insteadof(git_config *config, const char *url, int direction)\n{\n\tsize_t match_length, prefix_length, suffix_length;\n\tchar *replacement = NULL;\n\tconst char *regexp;\n\n\tgit_buf result = GIT_BUF_INIT;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\n\tassert(config);\n\tassert(url);\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\t/* Add 1 to prefix/suffix length due to the additional escaped dot */\n\tprefix_length = strlen(PREFIX) + 1;\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_FETCH;\n\t\tsuffix_length = strlen(SUFFIX_FETCH) + 1;\n\t} else {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_PUSH;\n\t\tsuffix_length = strlen(SUFFIX_PUSH) + 1;\n\t}\n\n\tif (git_config_iterator_glob_new(&iter, config, regexp) < 0)\n\t\treturn NULL;\n\n\tmatch_length = 0;\n\twhile (git_config_next(&entry, iter) == 0) {\n\t\tsize_t n, replacement_length;\n\n\t\t/* Check if entry value is a prefix of URL */\n\t\tif (git__prefixcmp(url, entry->value))\n\t\t\tcontinue;\n\t\t/* Check if entry value is longer than previous\n\t\t * prefixes */\n\t\tif ((n = strlen(entry->value)) <= match_length)\n\t\t\tcontinue;\n\n\t\tgit__free(replacement);\n\t\tmatch_length = n;\n\n\t\t/* Cut off prefix and suffix of the value */\n\t\treplacement_length =\n\t\t    strlen(entry->name) - (prefix_length + suffix_length);\n\t\treplacement = git__strndup(entry->name + prefix_length,\n\t\t\t\treplacement_length);\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (match_length == 0)\n\t\treturn git__strdup(url);\n\n\tgit_buf_printf(&result, \"%s%s\", replacement, url + match_length);\n\n\tgit__free(replacement);\n\n\treturn result.ptr;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [
            "#define SUFFIX_PUSH \"pushinsteadof\"",
            "#define SUFFIX_FETCH \"insteadof\"",
            "#define PREFIX \"url\""
          ],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
            "char *apply_insteadof(git_config *config, const char *url, int direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define SUFFIX_PUSH \"pushinsteadof\"\n#define SUFFIX_FETCH \"insteadof\"\n#define PREFIX \"url\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nchar *apply_insteadof(git_config *config, const char *url, int direction)\n{\n\tsize_t match_length, prefix_length, suffix_length;\n\tchar *replacement = NULL;\n\tconst char *regexp;\n\n\tgit_buf result = GIT_BUF_INIT;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\n\tassert(config);\n\tassert(url);\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\t/* Add 1 to prefix/suffix length due to the additional escaped dot */\n\tprefix_length = strlen(PREFIX) + 1;\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_FETCH;\n\t\tsuffix_length = strlen(SUFFIX_FETCH) + 1;\n\t} else {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_PUSH;\n\t\tsuffix_length = strlen(SUFFIX_PUSH) + 1;\n\t}\n\n\tif (git_config_iterator_glob_new(&iter, config, regexp) < 0)\n\t\treturn NULL;\n\n\tmatch_length = 0;\n\twhile (git_config_next(&entry, iter) == 0) {\n\t\tsize_t n, replacement_length;\n\n\t\t/* Check if entry value is a prefix of URL */\n\t\tif (git__prefixcmp(url, entry->value))\n\t\t\tcontinue;\n\t\t/* Check if entry value is longer than previous\n\t\t * prefixes */\n\t\tif ((n = strlen(entry->value)) <= match_length)\n\t\t\tcontinue;\n\n\t\tgit__free(replacement);\n\t\tmatch_length = n;\n\n\t\t/* Cut off prefix and suffix of the value */\n\t\treplacement_length =\n\t\t    strlen(entry->name) - (prefix_length + suffix_length);\n\t\treplacement = git__strndup(entry->name + prefix_length,\n\t\t\t\treplacement_length);\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (match_length == 0)\n\t\treturn git__strdup(url);\n\n\tgit_buf_printf(&result, \"%s%s\", replacement, url + match_length);\n\n\tgit__free(replacement);\n\n\treturn result.ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "val"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"Remote '%s' does not exist.\"",
            "name"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote->url"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "val"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&remote->active_refspecs",
            "2",
            "NULL"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote->name"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "name"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_remote)"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config_snapshot",
          "args": [
            "&config",
            "repo"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "716-725",
          "snippet": "int git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_remote_name_is_valid",
          "args": [
            "name"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_remote_name_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "83-95",
          "snippet": "static int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && name"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}"
  },
  {
    "function_name": "get_optional_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "394-418",
    "snippet": "static int get_optional_config(\n\tbool *found, git_config *config, git_buf *buf,\n\tgit_config_foreach_cb cb, void *payload)\n{\n\tint error = 0;\n\tconst char *key = git_buf_cstr(buf);\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\tif (cb != NULL)\n\t\terror = git_config_get_multivar_foreach(config, key, NULL, cb, payload);\n\telse\n\t\terror = git_config_get_string(payload, config, key);\n\n\tif (found)\n\t\t*found = !error;\n\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_get_string",
          "args": [
            "payload",
            "config",
            "key"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_get_string_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "857-875",
          "snippet": "int git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_get_multivar_foreach",
          "args": [
            "config",
            "key",
            "NULL",
            "cb",
            "payload"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_get_multivar_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "920-949",
          "snippet": "int git_config_get_multivar_foreach(\n\tconst git_config *cfg, const char *name, const char *regexp,\n\tgit_config_foreach_cb cb, void *payload)\n{\n\tint err, found;\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\n\tif ((err = git_config_multivar_iterator_new(&iter, cfg, name, regexp)) < 0)\n\t\treturn err;\n\n\tfound = 0;\n\twhile ((err = iter->next(&entry, iter)) == 0) {\n\t\tfound = 1;\n\n\t\tif ((err = cb(entry, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(err);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\titer->free(iter);\n\tif (err == GIT_ITEROVER)\n\t\terr = 0;\n\n\tif (found == 0 && err == 0)\n\t\terr = config_error_notfound(name);\n\n\treturn err;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_get_multivar_foreach(\n\tconst git_config *cfg, const char *name, const char *regexp,\n\tgit_config_foreach_cb cb, void *payload)\n{\n\tint err, found;\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\n\tif ((err = git_config_multivar_iterator_new(&iter, cfg, name, regexp)) < 0)\n\t\treturn err;\n\n\tfound = 0;\n\twhile ((err = iter->next(&entry, iter)) == 0) {\n\t\tfound = 1;\n\n\t\tif ((err = cb(entry, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(err);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\titer->free(iter);\n\tif (err == GIT_ITEROVER)\n\t\terr = 0;\n\n\tif (found == 0 && err == 0)\n\t\terr = config_error_notfound(name);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "buf"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "buf"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int get_optional_config(\n\tbool *found, git_config *config, git_buf *buf,\n\tgit_config_foreach_cb cb, void *payload)\n{\n\tint error = 0;\n\tconst char *key = git_buf_cstr(buf);\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\tif (cb != NULL)\n\t\terror = git_config_get_multivar_foreach(config, key, NULL, cb, payload);\n\telse\n\t\terror = git_config_get_string(payload, config, key);\n\n\tif (found)\n\t\t*found = !error;\n\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "refspec_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "388-392",
    "snippet": "static int refspec_cb(const git_config_entry *entry, void *payload)\n{\n\tstruct refspec_cb_data *data = (struct refspec_cb_data *)payload;\n\treturn add_refspec(data->remote, entry->value, data->fetch);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_refspec",
          "args": [
            "data->remote",
            "entry->value",
            "data->fetch"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "add_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "55-58",
          "snippet": "static int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int refspec_cb(const git_config_entry *entry, void *payload)\n{\n\tstruct refspec_cb_data *data = (struct refspec_cb_data *)payload;\n\treturn add_refspec(data->remote, entry->value, data->fetch);\n}"
  },
  {
    "function_name": "git_remote_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "334-381",
    "snippet": "int git_remote_dup(git_remote **dest, git_remote *source)\n{\n\tsize_t i;\n\tint error = 0;\n\tgit_refspec *spec;\n\tgit_remote *remote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tif (source->name != NULL) {\n\t\tremote->name = git__strdup(source->name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\t}\n\n\tif (source->url != NULL) {\n\t\tremote->url = git__strdup(source->url);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tif (source->pushurl != NULL) {\n\t\tremote->pushurl = git__strdup(source->pushurl);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tremote->repo = source->repo;\n\tremote->download_tags = source->download_tags;\n\tremote->prune_refs = source->prune_refs;\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tgit_vector_foreach(&source->refspecs, i, spec) {\n\t\tif ((error = add_refspec(remote, spec->string, !spec->push)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t*dest = remote;\n\ncleanup:\n\n\tif (error < 0)\n\t\tgit__free(remote);\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "remote"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_refspec",
          "args": [
            "remote",
            "spec->string",
            "!spec->push"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "add_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "55-58",
          "snippet": "static int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&source->refspecs",
            "i",
            "spec"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&remote->active_refspecs",
            "2",
            "NULL"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote->pushurl"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "source->pushurl"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote->url"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote->name"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_remote)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_dup(git_remote **dest, git_remote *source)\n{\n\tsize_t i;\n\tint error = 0;\n\tgit_refspec *spec;\n\tgit_remote *remote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tif (source->name != NULL) {\n\t\tremote->name = git__strdup(source->name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\t}\n\n\tif (source->url != NULL) {\n\t\tremote->url = git__strdup(source->url);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tif (source->pushurl != NULL) {\n\t\tremote->pushurl = git__strdup(source->pushurl);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tremote->repo = source->repo;\n\tremote->download_tags = source->download_tags;\n\tremote->prune_refs = source->prune_refs;\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tgit_vector_foreach(&source->refspecs, i, spec) {\n\t\tif ((error = add_refspec(remote, spec->string, !spec->push)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t*dest = remote;\n\ncleanup:\n\n\tif (error < 0)\n\t\tgit__free(remote);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_remote_create_anonymous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "329-332",
    "snippet": "int git_remote_create_anonymous(git_remote **out, git_repository *repo, const char *url)\n{\n\treturn create_internal(out, repo, NULL, url, NULL);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_internal",
          "args": [
            "out",
            "repo",
            "NULL",
            "url",
            "NULL"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "create_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "192-267",
          "snippet": "static int create_internal(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote;\n\tgit_config *config = NULL;\n\tgit_buf canonical_url = GIT_BUF_INIT;\n\tgit_buf var = GIT_BUF_INIT;\n\tint error = -1;\n\n\t/* name is optional */\n\tassert(out && repo && url);\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->repo = repo;\n\n\tif ((error = git_vector_init(&remote->refs, 32, NULL)) < 0 ||\n\t\t(error = canonicalize_url(&canonical_url, url)) < 0)\n\t\tgoto on_error;\n\n\tremote->url = apply_insteadof(repo->_config, canonical_url.ptr, GIT_DIRECTION_FETCH);\n\n\tif (name != NULL) {\n\t\tremote->name = git__strdup(name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\n\t\tif ((error = git_buf_printf(&var, CONFIG_URL_FMT, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_config_set_string(config, var.ptr, canonical_url.ptr)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\tif (fetch != NULL) {\n\t\tif ((error = add_refspec(remote, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* only write for non-anonymous remotes */\n\t\tif (name && (error = write_add_refspec(repo, name, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Move the data over to where the matching functions can find them */\n\t\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* A remote without a name doesn't download tags */\n\tif (!name)\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\telse\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\n\tgit_buf_free(&var);\n\n\t*out = remote;\n\terror = 0;\n\non_error:\n\tif (error)\n\t\tgit_remote_free(remote);\n\n\tgit_config_free(config);\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&var);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [
            "#define CONFIG_URL_FMT \"remote.%s.url\""
          ],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_URL_FMT \"remote.%s.url\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int create_internal(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote;\n\tgit_config *config = NULL;\n\tgit_buf canonical_url = GIT_BUF_INIT;\n\tgit_buf var = GIT_BUF_INIT;\n\tint error = -1;\n\n\t/* name is optional */\n\tassert(out && repo && url);\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->repo = repo;\n\n\tif ((error = git_vector_init(&remote->refs, 32, NULL)) < 0 ||\n\t\t(error = canonicalize_url(&canonical_url, url)) < 0)\n\t\tgoto on_error;\n\n\tremote->url = apply_insteadof(repo->_config, canonical_url.ptr, GIT_DIRECTION_FETCH);\n\n\tif (name != NULL) {\n\t\tremote->name = git__strdup(name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\n\t\tif ((error = git_buf_printf(&var, CONFIG_URL_FMT, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_config_set_string(config, var.ptr, canonical_url.ptr)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\tif (fetch != NULL) {\n\t\tif ((error = add_refspec(remote, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* only write for non-anonymous remotes */\n\t\tif (name && (error = write_add_refspec(repo, name, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Move the data over to where the matching functions can find them */\n\t\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* A remote without a name doesn't download tags */\n\tif (!name)\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\telse\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\n\tgit_buf_free(&var);\n\n\t*out = remote;\n\terror = 0;\n\non_error:\n\tif (error)\n\t\tgit_remote_free(remote);\n\n\tgit_config_free(config);\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&var);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nint git_remote_create_anonymous(git_remote **out, git_repository *repo, const char *url)\n{\n\treturn create_internal(out, repo, NULL, url, NULL);\n}"
  },
  {
    "function_name": "git_remote_create_with_fetchspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "306-327",
    "snippet": "int git_remote_create_with_fetchspec(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote = NULL;\n\tint error;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = ensure_remote_doesnot_exist(repo, name)) < 0)\n\t\treturn error;\n\n\tif (create_internal(&remote, repo, name, url, fetch) < 0)\n\t\tgoto on_error;\n\n\t*out = remote;\n\n\treturn 0;\n\non_error:\n\tgit_remote_free(remote);\n\treturn -1;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_internal",
          "args": [
            "&remote",
            "repo",
            "name",
            "url",
            "fetch"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "create_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "192-267",
          "snippet": "static int create_internal(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote;\n\tgit_config *config = NULL;\n\tgit_buf canonical_url = GIT_BUF_INIT;\n\tgit_buf var = GIT_BUF_INIT;\n\tint error = -1;\n\n\t/* name is optional */\n\tassert(out && repo && url);\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->repo = repo;\n\n\tif ((error = git_vector_init(&remote->refs, 32, NULL)) < 0 ||\n\t\t(error = canonicalize_url(&canonical_url, url)) < 0)\n\t\tgoto on_error;\n\n\tremote->url = apply_insteadof(repo->_config, canonical_url.ptr, GIT_DIRECTION_FETCH);\n\n\tif (name != NULL) {\n\t\tremote->name = git__strdup(name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\n\t\tif ((error = git_buf_printf(&var, CONFIG_URL_FMT, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_config_set_string(config, var.ptr, canonical_url.ptr)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\tif (fetch != NULL) {\n\t\tif ((error = add_refspec(remote, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* only write for non-anonymous remotes */\n\t\tif (name && (error = write_add_refspec(repo, name, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Move the data over to where the matching functions can find them */\n\t\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* A remote without a name doesn't download tags */\n\tif (!name)\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\telse\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\n\tgit_buf_free(&var);\n\n\t*out = remote;\n\terror = 0;\n\non_error:\n\tif (error)\n\t\tgit_remote_free(remote);\n\n\tgit_config_free(config);\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&var);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [
            "#define CONFIG_URL_FMT \"remote.%s.url\""
          ],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_URL_FMT \"remote.%s.url\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int create_internal(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote;\n\tgit_config *config = NULL;\n\tgit_buf canonical_url = GIT_BUF_INIT;\n\tgit_buf var = GIT_BUF_INIT;\n\tint error = -1;\n\n\t/* name is optional */\n\tassert(out && repo && url);\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->repo = repo;\n\n\tif ((error = git_vector_init(&remote->refs, 32, NULL)) < 0 ||\n\t\t(error = canonicalize_url(&canonical_url, url)) < 0)\n\t\tgoto on_error;\n\n\tremote->url = apply_insteadof(repo->_config, canonical_url.ptr, GIT_DIRECTION_FETCH);\n\n\tif (name != NULL) {\n\t\tremote->name = git__strdup(name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\n\t\tif ((error = git_buf_printf(&var, CONFIG_URL_FMT, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_config_set_string(config, var.ptr, canonical_url.ptr)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\tif (fetch != NULL) {\n\t\tif ((error = add_refspec(remote, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* only write for non-anonymous remotes */\n\t\tif (name && (error = write_add_refspec(repo, name, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Move the data over to where the matching functions can find them */\n\t\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* A remote without a name doesn't download tags */\n\tif (!name)\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\telse\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\n\tgit_buf_free(&var);\n\n\t*out = remote;\n\terror = 0;\n\non_error:\n\tif (error)\n\t\tgit_remote_free(remote);\n\n\tgit_config_free(config);\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&var);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_remote_doesnot_exist",
          "args": [
            "repo",
            "name"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_remote_doesnot_exist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "269-289",
          "snippet": "static int ensure_remote_doesnot_exist(git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_remote *remote;\n\n\terror = git_remote_lookup(&remote, repo, name);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (error < 0)\n\t\treturn error;\n\n\tgit_remote_free(remote);\n\n\tgiterr_set(\n\t\tGITERR_CONFIG,\n\t\t\"Remote '%s' already exists.\", name);\n\n\treturn GIT_EEXISTS;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_doesnot_exist(git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_remote *remote;\n\n\terror = git_remote_lookup(&remote, repo, name);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (error < 0)\n\t\treturn error;\n\n\tgit_remote_free(remote);\n\n\tgiterr_set(\n\t\tGITERR_CONFIG,\n\t\t\"Remote '%s' already exists.\", name);\n\n\treturn GIT_EEXISTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_remote_name_is_valid",
          "args": [
            "name"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_remote_name_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "83-95",
          "snippet": "static int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_create_with_fetchspec(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote = NULL;\n\tint error;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = ensure_remote_doesnot_exist(repo, name)) < 0)\n\t\treturn error;\n\n\tif (create_internal(&remote, repo, name, url, fetch) < 0)\n\t\tgoto on_error;\n\n\t*out = remote;\n\n\treturn 0;\n\non_error:\n\tgit_remote_free(remote);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_remote_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "292-304",
    "snippet": "int git_remote_create(git_remote **out, git_repository *repo, const char *name, const char *url)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, \"+refs/heads/*:refs/remotes/%s/*\", name) < 0)\n\t\treturn -1;\n\n\terror = git_remote_create_with_fetchspec(out, repo, name, url, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_create_with_fetchspec",
          "args": [
            "out",
            "repo",
            "name",
            "url",
            "git_buf_cstr(&buf)"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_create_with_fetchspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "306-327",
          "snippet": "int git_remote_create_with_fetchspec(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote = NULL;\n\tint error;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = ensure_remote_doesnot_exist(repo, name)) < 0)\n\t\treturn error;\n\n\tif (create_internal(&remote, repo, name, url, fetch) < 0)\n\t\tgoto on_error;\n\n\t*out = remote;\n\n\treturn 0;\n\non_error:\n\tgit_remote_free(remote);\n\treturn -1;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_create_with_fetchspec(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote = NULL;\n\tint error;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = ensure_remote_doesnot_exist(repo, name)) < 0)\n\t\treturn error;\n\n\tif (create_internal(&remote, repo, name, url, fetch) < 0)\n\t\tgoto on_error;\n\n\t*out = remote;\n\n\treturn 0;\n\non_error:\n\tgit_remote_free(remote);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"+refs/heads/*:refs/remotes/%s/*\"",
            "name"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_create(git_remote **out, git_repository *repo, const char *name, const char *url)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, \"+refs/heads/*:refs/remotes/%s/*\", name) < 0)\n\t\treturn -1;\n\n\terror = git_remote_create_with_fetchspec(out, repo, name, url, git_buf_cstr(&buf));\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ensure_remote_doesnot_exist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "269-289",
    "snippet": "static int ensure_remote_doesnot_exist(git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_remote *remote;\n\n\terror = git_remote_lookup(&remote, repo, name);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (error < 0)\n\t\treturn error;\n\n\tgit_remote_free(remote);\n\n\tgiterr_set(\n\t\tGITERR_CONFIG,\n\t\t\"Remote '%s' already exists.\", name);\n\n\treturn GIT_EEXISTS;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"Remote '%s' already exists.\"",
            "name"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_lookup",
          "args": [
            "&remote",
            "repo",
            "name"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "420-524",
          "snippet": "int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_doesnot_exist(git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_remote *remote;\n\n\terror = git_remote_lookup(&remote, repo, name);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn 0;\n\n\tif (error < 0)\n\t\treturn error;\n\n\tgit_remote_free(remote);\n\n\tgiterr_set(\n\t\tGITERR_CONFIG,\n\t\t\"Remote '%s' already exists.\", name);\n\n\treturn GIT_EEXISTS;\n}"
  },
  {
    "function_name": "create_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "192-267",
    "snippet": "static int create_internal(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote;\n\tgit_config *config = NULL;\n\tgit_buf canonical_url = GIT_BUF_INIT;\n\tgit_buf var = GIT_BUF_INIT;\n\tint error = -1;\n\n\t/* name is optional */\n\tassert(out && repo && url);\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->repo = repo;\n\n\tif ((error = git_vector_init(&remote->refs, 32, NULL)) < 0 ||\n\t\t(error = canonicalize_url(&canonical_url, url)) < 0)\n\t\tgoto on_error;\n\n\tremote->url = apply_insteadof(repo->_config, canonical_url.ptr, GIT_DIRECTION_FETCH);\n\n\tif (name != NULL) {\n\t\tremote->name = git__strdup(name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\n\t\tif ((error = git_buf_printf(&var, CONFIG_URL_FMT, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_config_set_string(config, var.ptr, canonical_url.ptr)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\tif (fetch != NULL) {\n\t\tif ((error = add_refspec(remote, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* only write for non-anonymous remotes */\n\t\tif (name && (error = write_add_refspec(repo, name, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Move the data over to where the matching functions can find them */\n\t\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* A remote without a name doesn't download tags */\n\tif (!name)\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\telse\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\n\tgit_buf_free(&var);\n\n\t*out = remote;\n\terror = 0;\n\non_error:\n\tif (error)\n\t\tgit_remote_free(remote);\n\n\tgit_config_free(config);\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&var);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [
      "#define CONFIG_URL_FMT \"remote.%s.url\""
    ],
    "globals_used": [
      "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&var"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "config"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dwim_refspecs",
          "args": [
            "&remote->active_refspecs",
            "&remote->refspecs",
            "&remote->refs"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "dwim_refspecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "839-850",
          "snippet": "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs)\n{\n\tsize_t i;\n\tgit_refspec *spec;\n\n\tgit_vector_foreach(refspecs, i, spec) {\n\t\tif (git_refspec__dwim_one(out, spec, refs) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_remote_prune_config",
          "args": [
            "remote",
            "config",
            "name"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_remote_prune_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "526-548",
          "snippet": "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0;\n\n\tgit_buf_printf(&buf, \"remote.%s.prune\", name);\n\n\tif ((error = git_config_get_bool(&remote->prune_refs, config, git_buf_cstr(&buf))) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\n\t\t\tif ((error = git_config_get_bool(&remote->prune_refs, config, \"fetch.prune\")) < 0) {\n\t\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t\tgiterr_clear();\n\t\t\t\t\terror = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0;\n\n\tgit_buf_printf(&buf, \"remote.%s.prune\", name);\n\n\tif ((error = git_config_get_bool(&remote->prune_refs, config, git_buf_cstr(&buf))) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\n\t\t\tif ((error = git_config_get_bool(&remote->prune_refs, config, \"fetch.prune\")) < 0) {\n\t\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t\tgiterr_clear();\n\t\t\t\t\terror = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config_snapshot",
          "args": [
            "&config",
            "repo"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "716-725",
          "snippet": "int git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_add_refspec",
          "args": [
            "repo",
            "name",
            "fetch",
            "true"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "write_add_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "97-137",
          "snippet": "static int write_add_refspec(git_repository *repo, const char *name, const char *refspec, bool fetch)\n{\n\tgit_config *cfg;\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_refspec spec;\n\tconst char *fmt;\n\tint error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t    return error;\n\n\tfmt = fetch ? CONFIG_FETCH_FMT : CONFIG_PUSH_FMT;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_refspec__parse(&spec, refspec, fetch)) < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\terror = GIT_EINVALIDSPEC;\n\n\t\treturn error;\n\t}\n\n\tgit_refspec__free(&spec);\n\n\tif ((error = git_buf_printf(&var, fmt, name)) < 0)\n\t\treturn error;\n\n\t/*\n\t * \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t * all values will be considered new and we will not replace any\n\t * present value.\n\t */\n\tif ((error = git_config_set_multivar(cfg, var.ptr, \"$^\", refspec)) < 0) {\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&var);\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [
            "#define CONFIG_PUSH_FMT \"remote.%s.push\"",
            "#define CONFIG_FETCH_FMT \"remote.%s.fetch\""
          ],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_PUSH_FMT \"remote.%s.push\"\n#define CONFIG_FETCH_FMT \"remote.%s.fetch\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int write_add_refspec(git_repository *repo, const char *name, const char *refspec, bool fetch)\n{\n\tgit_config *cfg;\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_refspec spec;\n\tconst char *fmt;\n\tint error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t    return error;\n\n\tfmt = fetch ? CONFIG_FETCH_FMT : CONFIG_PUSH_FMT;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_refspec__parse(&spec, refspec, fetch)) < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\terror = GIT_EINVALIDSPEC;\n\n\t\treturn error;\n\t}\n\n\tgit_refspec__free(&spec);\n\n\tif ((error = git_buf_printf(&var, fmt, name)) < 0)\n\t\treturn error;\n\n\t/*\n\t * \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t * all values will be considered new and we will not replace any\n\t * present value.\n\t */\n\tif ((error = git_config_set_multivar(cfg, var.ptr, \"$^\", refspec)) < 0) {\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&var);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_refspec",
          "args": [
            "remote",
            "fetch",
            "true"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "add_refspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "55-58",
          "snippet": "static int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_set_string",
          "args": [
            "config",
            "var.ptr",
            "canonical_url.ptr"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "616-638",
          "snippet": "int git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_set_string(git_config *cfg, const char *name, const char *value)\n{\n\tint error;\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tif (!value) {\n\t\tgiterr_set(GITERR_CONFIG, \"The value to set cannot be NULL\");\n\t\treturn -1;\n\t}\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\terror = file->set(file, name, value);\n\n\tif (!error && GIT_REFCOUNT_OWNER(cfg) != NULL)\n\t\tgit_repository__cvar_cache_clear(GIT_REFCOUNT_OWNER(cfg));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&var",
            "CONFIG_URL_FMT",
            "name"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote->name"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "name"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_insteadof",
          "args": [
            "repo->_config",
            "canonical_url.ptr",
            "GIT_DIRECTION_FETCH"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "apply_insteadof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2490-2549",
          "snippet": "char *apply_insteadof(git_config *config, const char *url, int direction)\n{\n\tsize_t match_length, prefix_length, suffix_length;\n\tchar *replacement = NULL;\n\tconst char *regexp;\n\n\tgit_buf result = GIT_BUF_INIT;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\n\tassert(config);\n\tassert(url);\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\t/* Add 1 to prefix/suffix length due to the additional escaped dot */\n\tprefix_length = strlen(PREFIX) + 1;\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_FETCH;\n\t\tsuffix_length = strlen(SUFFIX_FETCH) + 1;\n\t} else {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_PUSH;\n\t\tsuffix_length = strlen(SUFFIX_PUSH) + 1;\n\t}\n\n\tif (git_config_iterator_glob_new(&iter, config, regexp) < 0)\n\t\treturn NULL;\n\n\tmatch_length = 0;\n\twhile (git_config_next(&entry, iter) == 0) {\n\t\tsize_t n, replacement_length;\n\n\t\t/* Check if entry value is a prefix of URL */\n\t\tif (git__prefixcmp(url, entry->value))\n\t\t\tcontinue;\n\t\t/* Check if entry value is longer than previous\n\t\t * prefixes */\n\t\tif ((n = strlen(entry->value)) <= match_length)\n\t\t\tcontinue;\n\n\t\tgit__free(replacement);\n\t\tmatch_length = n;\n\n\t\t/* Cut off prefix and suffix of the value */\n\t\treplacement_length =\n\t\t    strlen(entry->name) - (prefix_length + suffix_length);\n\t\treplacement = git__strndup(entry->name + prefix_length,\n\t\t\t\treplacement_length);\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (match_length == 0)\n\t\treturn git__strdup(url);\n\n\tgit_buf_printf(&result, \"%s%s\", replacement, url + match_length);\n\n\tgit__free(replacement);\n\n\treturn result.ptr;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [
            "#define SUFFIX_PUSH \"pushinsteadof\"",
            "#define SUFFIX_FETCH \"insteadof\"",
            "#define PREFIX \"url\""
          ],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);",
            "char *apply_insteadof(git_config *config, const char *url, int direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define SUFFIX_PUSH \"pushinsteadof\"\n#define SUFFIX_FETCH \"insteadof\"\n#define PREFIX \"url\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\nchar *apply_insteadof(git_config *config, const char *url, int direction);\n\nchar *apply_insteadof(git_config *config, const char *url, int direction)\n{\n\tsize_t match_length, prefix_length, suffix_length;\n\tchar *replacement = NULL;\n\tconst char *regexp;\n\n\tgit_buf result = GIT_BUF_INIT;\n\tgit_config_entry *entry;\n\tgit_config_iterator *iter;\n\n\tassert(config);\n\tassert(url);\n\tassert(direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH);\n\n\t/* Add 1 to prefix/suffix length due to the additional escaped dot */\n\tprefix_length = strlen(PREFIX) + 1;\n\tif (direction == GIT_DIRECTION_FETCH) {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_FETCH;\n\t\tsuffix_length = strlen(SUFFIX_FETCH) + 1;\n\t} else {\n\t\tregexp = PREFIX \"\\\\..*\\\\.\" SUFFIX_PUSH;\n\t\tsuffix_length = strlen(SUFFIX_PUSH) + 1;\n\t}\n\n\tif (git_config_iterator_glob_new(&iter, config, regexp) < 0)\n\t\treturn NULL;\n\n\tmatch_length = 0;\n\twhile (git_config_next(&entry, iter) == 0) {\n\t\tsize_t n, replacement_length;\n\n\t\t/* Check if entry value is a prefix of URL */\n\t\tif (git__prefixcmp(url, entry->value))\n\t\t\tcontinue;\n\t\t/* Check if entry value is longer than previous\n\t\t * prefixes */\n\t\tif ((n = strlen(entry->value)) <= match_length)\n\t\t\tcontinue;\n\n\t\tgit__free(replacement);\n\t\tmatch_length = n;\n\n\t\t/* Cut off prefix and suffix of the value */\n\t\treplacement_length =\n\t\t    strlen(entry->name) - (prefix_length + suffix_length);\n\t\treplacement = git__strndup(entry->name + prefix_length,\n\t\t\t\treplacement_length);\n\t}\n\n\tgit_config_iterator_free(iter);\n\n\tif (match_length == 0)\n\t\treturn git__strdup(url);\n\n\tgit_buf_printf(&result, \"%s%s\", replacement, url + match_length);\n\n\tgit__free(replacement);\n\n\treturn result.ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalize_url",
          "args": [
            "&canonical_url",
            "url"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "canonicalize_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "168-190",
          "snippet": "static int canonicalize_url(git_buf *out, const char *in)\n{\n\tif (in == NULL || strlen(in) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot set empty URL\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n#ifdef GIT_WIN32\n\t/* Given a UNC path like \\\\server\\path, we need to convert this\n\t * to //server/path for compatibility with core git.\n\t */\n\tif (in[0] == '\\\\' && in[1] == '\\\\' &&\n\t\t(git__isalpha(in[2]) || git__isdigit(in[2]))) {\n\t\tconst char *c;\n\t\tfor (c = in; *c; c++)\n\t\t\tgit_buf_putc(out, *c == '\\\\' ? '/' : *c);\n\n\t\treturn git_buf_oom(out) ? -1 : 0;\n\t}\n#endif\n\n\treturn git_buf_puts(out, in);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int canonicalize_url(git_buf *out, const char *in)\n{\n\tif (in == NULL || strlen(in) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot set empty URL\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n#ifdef GIT_WIN32\n\t/* Given a UNC path like \\\\server\\path, we need to convert this\n\t * to //server/path for compatibility with core git.\n\t */\n\tif (in[0] == '\\\\' && in[1] == '\\\\' &&\n\t\t(git__isalpha(in[2]) || git__isdigit(in[2]))) {\n\t\tconst char *c;\n\t\tfor (c = in; *c; c++)\n\t\t\tgit_buf_putc(out, *c == '\\\\' ? '/' : *c);\n\n\t\treturn git_buf_oom(out) ? -1 : 0;\n\t}\n#endif\n\n\treturn git_buf_puts(out, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&remote->refs",
            "32",
            "NULL"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "remote"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_remote)"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&config",
            "repo"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && url"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_URL_FMT \"remote.%s.url\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int create_internal(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)\n{\n\tgit_remote *remote;\n\tgit_config *config = NULL;\n\tgit_buf canonical_url = GIT_BUF_INIT;\n\tgit_buf var = GIT_BUF_INIT;\n\tint error = -1;\n\n\t/* name is optional */\n\tassert(out && repo && url);\n\n\tif ((error = git_repository_config__weakptr(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->repo = repo;\n\n\tif ((error = git_vector_init(&remote->refs, 32, NULL)) < 0 ||\n\t\t(error = canonicalize_url(&canonical_url, url)) < 0)\n\t\tgoto on_error;\n\n\tremote->url = apply_insteadof(repo->_config, canonical_url.ptr, GIT_DIRECTION_FETCH);\n\n\tif (name != NULL) {\n\t\tremote->name = git__strdup(name);\n\t\tGITERR_CHECK_ALLOC(remote->name);\n\n\t\tif ((error = git_buf_printf(&var, CONFIG_URL_FMT, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_config_set_string(config, var.ptr, canonical_url.ptr)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\tif (fetch != NULL) {\n\t\tif ((error = add_refspec(remote, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* only write for non-anonymous remotes */\n\t\tif (name && (error = write_add_refspec(repo, name, fetch, true)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\t\tgoto on_error;\n\n\t\t/* Move the data over to where the matching functions can find them */\n\t\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* A remote without a name doesn't download tags */\n\tif (!name)\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\telse\n\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\n\tgit_buf_free(&var);\n\n\t*out = remote;\n\terror = 0;\n\non_error:\n\tif (error)\n\t\tgit_remote_free(remote);\n\n\tgit_config_free(config);\n\tgit_buf_free(&canonical_url);\n\tgit_buf_free(&var);\n\treturn error;\n}"
  },
  {
    "function_name": "canonicalize_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "168-190",
    "snippet": "static int canonicalize_url(git_buf *out, const char *in)\n{\n\tif (in == NULL || strlen(in) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot set empty URL\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n#ifdef GIT_WIN32\n\t/* Given a UNC path like \\\\server\\path, we need to convert this\n\t * to //server/path for compatibility with core git.\n\t */\n\tif (in[0] == '\\\\' && in[1] == '\\\\' &&\n\t\t(git__isalpha(in[2]) || git__isdigit(in[2]))) {\n\t\tconst char *c;\n\t\tfor (c = in; *c; c++)\n\t\t\tgit_buf_putc(out, *c == '\\\\' ? '/' : *c);\n\n\t\treturn git_buf_oom(out) ? -1 : 0;\n\t}\n#endif\n\n\treturn git_buf_puts(out, in);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "out",
            "in"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "out"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "out",
            "*c == '\\\\' ? '/' : *c"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isdigit",
          "args": [
            "in[2]"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "git__isdigit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "449-452",
          "snippet": "GIT_INLINE(bool) git__isdigit(int c)\n{\n\treturn (c >= '0' && c <= '9');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isdigit(int c)\n{\n\treturn (c >= '0' && c <= '9');\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isalpha",
          "args": [
            "in[2]"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "git__isalpha",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "444-447",
          "snippet": "GIT_INLINE(bool) git__isalpha(int c)\n{\n\treturn ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isalpha(int c)\n{\n\treturn ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"cannot set empty URL\""
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "in"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int canonicalize_url(git_buf *out, const char *in)\n{\n\tif (in == NULL || strlen(in) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot set empty URL\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n#ifdef GIT_WIN32\n\t/* Given a UNC path like \\\\server\\path, we need to convert this\n\t * to //server/path for compatibility with core git.\n\t */\n\tif (in[0] == '\\\\' && in[1] == '\\\\' &&\n\t\t(git__isalpha(in[2]) || git__isdigit(in[2]))) {\n\t\tconst char *c;\n\t\tfor (c = in; *c; c++)\n\t\t\tgit_buf_putc(out, *c == '\\\\' ? '/' : *c);\n\n\t\treturn git_buf_oom(out) ? -1 : 0;\n\t}\n#endif\n\n\treturn git_buf_puts(out, in);\n}"
  },
  {
    "function_name": "get_check_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "141-165",
    "snippet": "static int get_check_cert(int *out, git_repository *repo)\n{\n\tgit_config *cfg;\n\tconst char *val;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t/* By default, we *DO* want to verify the certificate. */\n\t*out = 1;\n\n\t/* Go through the possible sources for SSL verification settings, from\n\t * most specific to least specific. */\n\n\t/* GIT_SSL_NO_VERIFY environment variable */\n\tif ((val = p_getenv(\"GIT_SSL_NO_VERIFY\")) != NULL)\n\t\treturn git_config_parse_bool(out, val);\n\n\t/* http.sslVerify config setting */\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\t*out = git_config__get_bool_force(cfg, \"http.sslverify\", 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config__get_bool_force",
          "args": [
            "cfg",
            "\"http.sslverify\"",
            "1"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__get_bool_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "890-903",
          "snippet": "int git_config__get_bool_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint val = fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_bool(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn val;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__get_bool_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint val = fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_bool(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "repo"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_parse_bool",
          "args": [
            "out",
            "val"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_parse_bool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1263-1275",
          "snippet": "int git_config_parse_bool(int *out, const char *value)\n{\n\tif (git__parse_bool(out, value) == 0)\n\t\treturn 0;\n\n\tif (git_config_parse_int32(out, value) == 0) {\n\t\t*out = !!(*out);\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse '%s' as a boolean value\", value);\n\treturn -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_parse_bool(int *out, const char *value)\n{\n\tif (git__parse_bool(out, value) == 0)\n\t\treturn 0;\n\n\tif (git_config_parse_int32(out, value) == 0) {\n\t\t*out = !!(*out);\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_CONFIG, \"Failed to parse '%s' as a boolean value\", value);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_getenv",
          "args": [
            "\"GIT_SSL_NO_VERIFY\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int get_check_cert(int *out, git_repository *repo)\n{\n\tgit_config *cfg;\n\tconst char *val;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t/* By default, we *DO* want to verify the certificate. */\n\t*out = 1;\n\n\t/* Go through the possible sources for SSL verification settings, from\n\t * most specific to least specific. */\n\n\t/* GIT_SSL_NO_VERIFY environment variable */\n\tif ((val = p_getenv(\"GIT_SSL_NO_VERIFY\")) != NULL)\n\t\treturn git_config_parse_bool(out, val);\n\n\t/* http.sslVerify config setting */\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\treturn error;\n\n\t*out = git_config__get_bool_force(cfg, \"http.sslverify\", 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "write_add_refspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "97-137",
    "snippet": "static int write_add_refspec(git_repository *repo, const char *name, const char *refspec, bool fetch)\n{\n\tgit_config *cfg;\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_refspec spec;\n\tconst char *fmt;\n\tint error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t    return error;\n\n\tfmt = fetch ? CONFIG_FETCH_FMT : CONFIG_PUSH_FMT;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_refspec__parse(&spec, refspec, fetch)) < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\terror = GIT_EINVALIDSPEC;\n\n\t\treturn error;\n\t}\n\n\tgit_refspec__free(&spec);\n\n\tif ((error = git_buf_printf(&var, fmt, name)) < 0)\n\t\treturn error;\n\n\t/*\n\t * \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t * all values will be considered new and we will not replace any\n\t * present value.\n\t */\n\tif ((error = git_config_set_multivar(cfg, var.ptr, \"$^\", refspec)) < 0) {\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&var);\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [
      "#define CONFIG_PUSH_FMT \"remote.%s.push\"",
      "#define CONFIG_FETCH_FMT \"remote.%s.fetch\""
    ],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&var"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_set_multivar",
          "args": [
            "cfg",
            "var.ptr",
            "\"$^\"",
            "refspec"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_set_multivar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1032-1043",
          "snippet": "int git_config_set_multivar(git_config *cfg, const char *name, const char *regexp, const char *value)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->set_multivar(file, name, regexp, value);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_set_multivar(git_config *cfg, const char *name, const char *regexp, const char *value)\n{\n\tgit_config_backend *file;\n\tfile_internal *internal;\n\n\tinternal = git_vector_get(&cfg->files, 0);\n\tif (!internal || !internal->file)\n\t\treturn config_error_nofiles(name);\n\tfile = internal->file;\n\n\treturn file->set_multivar(file, name, regexp, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&var",
            "fmt",
            "name"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "&spec"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_last",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "134-137",
          "snippet": "const git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__parse",
          "args": [
            "&spec",
            "refspec",
            "fetch"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "17-149",
          "snippet": "int git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_remote_name_is_valid",
          "args": [
            "name"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_remote_name_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "83-95",
          "snippet": "static int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "repo"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\n#define CONFIG_PUSH_FMT \"remote.%s.push\"\n#define CONFIG_FETCH_FMT \"remote.%s.fetch\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int write_add_refspec(git_repository *repo, const char *name, const char *refspec, bool fetch)\n{\n\tgit_config *cfg;\n\tgit_buf var = GIT_BUF_INIT;\n\tgit_refspec spec;\n\tconst char *fmt;\n\tint error;\n\n\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t    return error;\n\n\tfmt = fetch ? CONFIG_FETCH_FMT : CONFIG_PUSH_FMT;\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_refspec__parse(&spec, refspec, fetch)) < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\terror = GIT_EINVALIDSPEC;\n\n\t\treturn error;\n\t}\n\n\tgit_refspec__free(&spec);\n\n\tif ((error = git_buf_printf(&var, fmt, name)) < 0)\n\t\treturn error;\n\n\t/*\n\t * \"$^\" is a unmatcheable regexp: it will not match anything at all, so\n\t * all values will be considered new and we will not replace any\n\t * present value.\n\t */\n\tif ((error = git_config_set_multivar(cfg, var.ptr, \"$^\", refspec)) < 0) {\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&var);\n\treturn 0;\n}"
  },
  {
    "function_name": "ensure_remote_name_is_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "83-95",
    "snippet": "static int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_CONFIG",
            "\"'%s' is not a valid remote name.\"",
            "name ? name : \"(null)\""
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_is_valid_name",
          "args": [
            "name"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_is_valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "2035-2053",
          "snippet": "int git_remote_is_valid_name(\n\tconst char *remote_name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec refspec;\n\tint error = -1;\n\n\tif (!remote_name || *remote_name == '\\0')\n\t\treturn 0;\n\n\tgit_buf_printf(&buf, \"refs/heads/test:refs/remotes/%s/test\", remote_name);\n\terror = git_refspec__parse(&refspec, git_buf_cstr(&buf), true);\n\n\tgit_buf_free(&buf);\n\tgit_refspec__free(&refspec);\n\n\tgiterr_clear();\n\treturn error == 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\n\nint git_remote_is_valid_name(\n\tconst char *remote_name)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec refspec;\n\tint error = -1;\n\n\tif (!remote_name || *remote_name == '\\0')\n\t\treturn 0;\n\n\tgit_buf_printf(&buf, \"refs/heads/test:refs/remotes/%s/test\", remote_name);\n\terror = git_refspec__parse(&refspec, git_buf_cstr(&buf), true);\n\n\tgit_buf_free(&buf);\n\tgit_refspec__free(&refspec);\n\n\tgiterr_clear();\n\treturn error == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int ensure_remote_name_is_valid(const char *name)\n{\n\tint error = 0;\n\n\tif (!git_remote_is_valid_name(name)) {\n\t\tgiterr_set(\n\t\t\tGITERR_CONFIG,\n\t\t\t\"'%s' is not a valid remote name.\", name ? name : \"(null)\");\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "download_tags_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "60-81",
    "snippet": "static int download_tags_value(git_remote *remote, git_config *cfg)\n{\n\tgit_config_entry *ce;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, \"remote.%s.tagopt\", remote->name) < 0)\n\t\treturn -1;\n\n\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\tgit_buf_free(&buf);\n\n\tif (!error && ce && ce->value) {\n\t\tif (!strcmp(ce->value, \"--no-tags\"))\n\t\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\t\telse if (!strcmp(ce->value, \"--tags\"))\n\t\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;\n\t}\n\n\tgit_config_entry_free(ce);\n\treturn error;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_entry_free",
          "args": [
            "ce"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "23-29",
          "snippet": "void git_config_entry_free(git_config_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->free(entry);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_entry_free(git_config_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ce->value",
            "\"--tags\""
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__lookup_entry",
          "args": [
            "&ce",
            "cfg",
            "git_buf_cstr(&buf)",
            "false"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__lookup_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "737-745",
          "snippet": "int git_config__lookup_entry(\n\tgit_config_entry **out,\n\tconst git_config *cfg,\n\tconst char *key,\n\tbool no_errors)\n{\n\treturn get_entry(\n\t\tout, cfg, key, false, no_errors ? GET_NO_ERRORS : GET_NO_MISSING);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__lookup_entry(\n\tgit_config_entry **out,\n\tconst git_config *cfg,\n\tconst char *key,\n\tbool no_errors)\n{\n\treturn get_entry(\n\t\tout, cfg, key, false, no_errors ? GET_NO_ERRORS : GET_NO_MISSING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"remote.%s.tagopt\"",
            "remote->name"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nstatic int download_tags_value(git_remote *remote, git_config *cfg)\n{\n\tgit_config_entry *ce;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (git_buf_printf(&buf, \"remote.%s.tagopt\", remote->name) < 0)\n\t\treturn -1;\n\n\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\tgit_buf_free(&buf);\n\n\tif (!error && ce && ce->value) {\n\t\tif (!strcmp(ce->value, \"--no-tags\"))\n\t\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_NONE;\n\t\telse if (!strcmp(ce->value, \"--tags\"))\n\t\t\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;\n\t}\n\n\tgit_config_entry_free(ce);\n\treturn error;\n}"
  },
  {
    "function_name": "add_refspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "55-58",
    "snippet": "static int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_refspec_to",
          "args": [
            "&remote->refspecs",
            "string",
            "is_fetch"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "add_refspec_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "33-53",
          "snippet": "static int add_refspec_to(git_vector *vector, const char *string, bool is_fetch)\n{\n\tgit_refspec *spec;\n\n\tspec = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(spec);\n\n\tif (git_refspec__parse(spec, string, is_fetch) < 0) {\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\tspec->push = !is_fetch;\n\tif (git_vector_insert(vector, spec) < 0) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int add_refspec_to(git_vector *vector, const char *string, bool is_fetch)\n{\n\tgit_refspec *spec;\n\n\tspec = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(spec);\n\n\tif (git_refspec__parse(spec, string, is_fetch) < 0) {\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\tspec->push = !is_fetch;\n\tif (git_vector_insert(vector, spec) < 0) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int add_refspec(git_remote *remote, const char *string, bool is_fetch)\n{\n\treturn add_refspec_to(&remote->refspecs, string, is_fetch);\n}"
  },
  {
    "function_name": "add_refspec_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
    "lines": "33-53",
    "snippet": "static int add_refspec_to(git_vector *vector, const char *string, bool is_fetch)\n{\n\tgit_refspec *spec;\n\n\tspec = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(spec);\n\n\tif (git_refspec__parse(spec, string, is_fetch) < 0) {\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\tspec->push = !is_fetch;\n\tif (git_vector_insert(vector, spec) < 0) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"push.h\"",
      "#include \"fetchhead.h\"",
      "#include \"refspec.h\"",
      "#include \"refs.h\"",
      "#include \"fetch.h\"",
      "#include \"remote.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"common.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "spec"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "spec"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "vector",
            "spec"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__parse",
          "args": [
            "spec",
            "string",
            "is_fetch"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "17-149",
          "snippet": "int git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "spec"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_refspec)"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int add_refspec_to(git_vector *vector, const char *string, bool is_fetch)\n{\n\tgit_refspec *spec;\n\n\tspec = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(spec);\n\n\tif (git_refspec__parse(spec, string, is_fetch) < 0) {\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\tspec->push = !is_fetch;\n\tif (git_vector_insert(vector, spec) < 0) {\n\t\tgit_refspec__free(spec);\n\t\tgit__free(spec);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  }
]