[
  {
    "function_name": "git_win32_path_readlink_w",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "324-387",
    "snippet": "int git_win32_path_readlink_w(git_win32_path dest, const git_win32_path path)\n{\n\tBYTE buf[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n\tGIT_REPARSE_DATA_BUFFER *reparse_buf = (GIT_REPARSE_DATA_BUFFER *)buf;\n\tHANDLE handle = NULL;\n\tDWORD ioctl_ret;\n\twchar_t *target;\n\tsize_t target_len;\n\n\tint error = -1;\n\n\thandle = CreateFileW(path, GENERIC_READ,\n\t\tFILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING,\n\t\tFILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (handle == INVALID_HANDLE_VALUE) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\tif (!DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0,\n\t\treparse_buf, sizeof(buf), &ioctl_ret, NULL)) {\n\t\terrno = EINVAL;\n\t\tgoto on_error;\n\t}\n\n\tswitch (reparse_buf->ReparseTag) {\n\tcase IO_REPARSE_TAG_SYMLINK:\n\t\ttarget = reparse_buf->SymbolicLinkReparseBuffer.PathBuffer +\n\t\t\t(reparse_buf->SymbolicLinkReparseBuffer.SubstituteNameOffset / sizeof(WCHAR));\n\t\ttarget_len = reparse_buf->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(WCHAR);\n\tbreak;\n\tcase IO_REPARSE_TAG_MOUNT_POINT:\n\t\ttarget = reparse_buf->MountPointReparseBuffer.PathBuffer +\n\t\t\t(reparse_buf->MountPointReparseBuffer.SubstituteNameOffset / sizeof(WCHAR));\n\t\ttarget_len = reparse_buf->MountPointReparseBuffer.SubstituteNameLength / sizeof(WCHAR);\n\tbreak;\n\tdefault:\n\t\terrno = EINVAL;\n\t\tgoto on_error;\n\t}\n\n\tif (path_is_volume(target, target_len)) {\n\t\t/* This path is a reparse point that represents another volume mounted\n\t\t* at this location, it is not a symbolic link our input was canonical.\n\t\t*/\n\t\terrno = EINVAL;\n\t\terror = -1;\n\t} else if (target_len) {\n\t\t/* The path may need to have a prefix removed. */\n\t\ttarget_len = git_win32__canonicalize_path(target, target_len);\n\n\t\t/* Need one additional character in the target buffer\n\t\t* for the terminating NULL. */\n\t\tif (GIT_WIN_PATH_UTF16 > target_len) {\n\t\t\twcscpy(dest, target);\n\t\t\terror = (int)target_len;\n\t\t}\n\t}\n\non_error:\n\tCloseHandle(handle);\n\treturn error;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "handle"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcscpy",
          "args": [
            "dest",
            "target"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32__canonicalize_path",
          "args": [
            "target",
            "target_len"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__canonicalize_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
          "lines": "130-163",
          "snippet": "size_t git_win32__canonicalize_path(wchar_t *str, size_t len)\n{\n\tstatic const wchar_t dosdevices_prefix[] = L\"\\\\\\?\\?\\\\\";\n\tstatic const wchar_t nt_prefix[] = L\"\\\\\\\\?\\\\\";\n\tstatic const wchar_t unc_prefix[] = L\"UNC\\\\\";\n\tsize_t to_advance = 0;\n\n\t/* \"\\??\\\" -- DOS Devices prefix */\n\tif (len >= CONST_STRLEN(dosdevices_prefix) &&\n\t\t!wcsncmp(str, dosdevices_prefix, CONST_STRLEN(dosdevices_prefix))) {\n\t\tto_advance += CONST_STRLEN(dosdevices_prefix);\n\t\tlen -= CONST_STRLEN(dosdevices_prefix);\n\t}\n\t/* \"\\\\?\\\" -- NT namespace prefix */\n\telse if (len >= CONST_STRLEN(nt_prefix) &&\n\t\t!wcsncmp(str, nt_prefix, CONST_STRLEN(nt_prefix))) {\n\t\tto_advance += CONST_STRLEN(nt_prefix);\n\t\tlen -= CONST_STRLEN(nt_prefix);\n\t}\n\n\t/* \"\\??\\UNC\\\", \"\\\\?\\UNC\\\" -- UNC prefix */\n\tif (to_advance && len >= CONST_STRLEN(unc_prefix) &&\n\t\t!wcsncmp(str + to_advance, unc_prefix, CONST_STRLEN(unc_prefix))) {\n\t\tto_advance += CONST_STRLEN(unc_prefix);\n\t\tlen -= CONST_STRLEN(unc_prefix);\n\t}\n\n\tif (to_advance) {\n\t\tmemmove(str, str + to_advance, len * sizeof(wchar_t));\n\t\tstr[len] = L'\\0';\n\t}\n\n\treturn git_win32__path_trim_end(str, len);\n}",
          "includes": [
            "#include \"w32_util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_util.h\"\n\nsize_t git_win32__canonicalize_path(wchar_t *str, size_t len)\n{\n\tstatic const wchar_t dosdevices_prefix[] = L\"\\\\\\?\\?\\\\\";\n\tstatic const wchar_t nt_prefix[] = L\"\\\\\\\\?\\\\\";\n\tstatic const wchar_t unc_prefix[] = L\"UNC\\\\\";\n\tsize_t to_advance = 0;\n\n\t/* \"\\??\\\" -- DOS Devices prefix */\n\tif (len >= CONST_STRLEN(dosdevices_prefix) &&\n\t\t!wcsncmp(str, dosdevices_prefix, CONST_STRLEN(dosdevices_prefix))) {\n\t\tto_advance += CONST_STRLEN(dosdevices_prefix);\n\t\tlen -= CONST_STRLEN(dosdevices_prefix);\n\t}\n\t/* \"\\\\?\\\" -- NT namespace prefix */\n\telse if (len >= CONST_STRLEN(nt_prefix) &&\n\t\t!wcsncmp(str, nt_prefix, CONST_STRLEN(nt_prefix))) {\n\t\tto_advance += CONST_STRLEN(nt_prefix);\n\t\tlen -= CONST_STRLEN(nt_prefix);\n\t}\n\n\t/* \"\\??\\UNC\\\", \"\\\\?\\UNC\\\" -- UNC prefix */\n\tif (to_advance && len >= CONST_STRLEN(unc_prefix) &&\n\t\t!wcsncmp(str + to_advance, unc_prefix, CONST_STRLEN(unc_prefix))) {\n\t\tto_advance += CONST_STRLEN(unc_prefix);\n\t\tlen -= CONST_STRLEN(unc_prefix);\n\t}\n\n\tif (to_advance) {\n\t\tmemmove(str, str + to_advance, len * sizeof(wchar_t));\n\t\tstr[len] = L'\\0';\n\t}\n\n\treturn git_win32__path_trim_end(str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_is_volume",
          "args": [
            "target",
            "target_len"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "path_is_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "317-320",
          "snippet": "static bool path_is_volume(wchar_t *target, size_t target_len)\n{\n\treturn (target_len && wcsncmp(target, L\"\\\\??\\\\Volume{\", 11) == 0);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool path_is_volume(wchar_t *target, size_t target_len)\n{\n\treturn (target_len && wcsncmp(target, L\"\\\\??\\\\Volume{\", 11) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeviceIoControl",
          "args": [
            "handle",
            "FSCTL_GET_REPARSE_POINT",
            "NULL",
            "0",
            "reparse_buf",
            "sizeof(buf)",
            "&ioctl_ret",
            "NULL"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateFileW",
          "args": [
            "path",
            "GENERIC_READ",
            "FILE_SHARE_READ | FILE_SHARE_DELETE",
            "NULL",
            "OPEN_EXISTING",
            "FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS",
            "NULL"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path_readlink_w(git_win32_path dest, const git_win32_path path)\n{\n\tBYTE buf[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n\tGIT_REPARSE_DATA_BUFFER *reparse_buf = (GIT_REPARSE_DATA_BUFFER *)buf;\n\tHANDLE handle = NULL;\n\tDWORD ioctl_ret;\n\twchar_t *target;\n\tsize_t target_len;\n\n\tint error = -1;\n\n\thandle = CreateFileW(path, GENERIC_READ,\n\t\tFILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING,\n\t\tFILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (handle == INVALID_HANDLE_VALUE) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\tif (!DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0,\n\t\treparse_buf, sizeof(buf), &ioctl_ret, NULL)) {\n\t\terrno = EINVAL;\n\t\tgoto on_error;\n\t}\n\n\tswitch (reparse_buf->ReparseTag) {\n\tcase IO_REPARSE_TAG_SYMLINK:\n\t\ttarget = reparse_buf->SymbolicLinkReparseBuffer.PathBuffer +\n\t\t\t(reparse_buf->SymbolicLinkReparseBuffer.SubstituteNameOffset / sizeof(WCHAR));\n\t\ttarget_len = reparse_buf->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(WCHAR);\n\tbreak;\n\tcase IO_REPARSE_TAG_MOUNT_POINT:\n\t\ttarget = reparse_buf->MountPointReparseBuffer.PathBuffer +\n\t\t\t(reparse_buf->MountPointReparseBuffer.SubstituteNameOffset / sizeof(WCHAR));\n\t\ttarget_len = reparse_buf->MountPointReparseBuffer.SubstituteNameLength / sizeof(WCHAR);\n\tbreak;\n\tdefault:\n\t\terrno = EINVAL;\n\t\tgoto on_error;\n\t}\n\n\tif (path_is_volume(target, target_len)) {\n\t\t/* This path is a reparse point that represents another volume mounted\n\t\t* at this location, it is not a symbolic link our input was canonical.\n\t\t*/\n\t\terrno = EINVAL;\n\t\terror = -1;\n\t} else if (target_len) {\n\t\t/* The path may need to have a prefix removed. */\n\t\ttarget_len = git_win32__canonicalize_path(target, target_len);\n\n\t\t/* Need one additional character in the target buffer\n\t\t* for the terminating NULL. */\n\t\tif (GIT_WIN_PATH_UTF16 > target_len) {\n\t\t\twcscpy(dest, target);\n\t\t\terror = (int)target_len;\n\t\t}\n\t}\n\non_error:\n\tCloseHandle(handle);\n\treturn error;\n}"
  },
  {
    "function_name": "path_is_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "317-320",
    "snippet": "static bool path_is_volume(wchar_t *target, size_t target_len)\n{\n\treturn (target_len && wcsncmp(target, L\"\\\\??\\\\Volume{\", 11) == 0);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wcsncmp",
          "args": [
            "target",
            "L\"\\\\??\\\\Volume{\"",
            "11"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic bool path_is_volume(wchar_t *target, size_t target_len)\n{\n\treturn (target_len && wcsncmp(target, L\"\\\\??\\\\Volume{\", 11) == 0);\n}"
  },
  {
    "function_name": "git_win32_path_8dot3_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "281-315",
    "snippet": "char *git_win32_path_8dot3_name(const char *path)\n{\n\tgit_win32_path longpath, shortpath;\n\twchar_t *start;\n\tchar *shortname;\n\tint len, namelen = 1;\n\n\tif (git_win32_path_from_utf8(longpath, path) < 0)\n\t\treturn NULL;\n\n\tlen = GetShortPathNameW(longpath, shortpath, GIT_WIN_PATH_UTF16);\n\n\twhile (len && shortpath[len-1] == L'\\\\')\n\t\tshortpath[--len] = L'\\0';\n\n\tif (len == 0 || len >= GIT_WIN_PATH_UTF16)\n\t\treturn NULL;\n\n\tfor (start = shortpath + (len - 1);\n\t\tstart > shortpath && *(start-1) != '/' && *(start-1) != '\\\\';\n\t\tstart--)\n\t\tnamelen++;\n\n\t/* We may not have actually been given a short name.  But if we have,\n\t * it will be in the ASCII byte range, so we don't need to worry about\n\t * multi-byte sequences and can allocate naively.\n\t */\n\tif (namelen > 12 || (shortname = git__malloc(namelen + 1)) == NULL)\n\t\treturn NULL;\n\n\tif ((len = git__utf16_to_8(shortname, namelen + 1, start)) < 0)\n\t\treturn NULL;\n\n\treturn shortname;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__utf16_to_8",
          "args": [
            "shortname",
            "namelen + 1",
            "start"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf16_to_8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "48-59",
          "snippet": "int git__utf16_to_8(char *dest, size_t dest_size, const wchar_t *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t * turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t * length. WideCharToMultiByte never returns int's minvalue, so underflow is not possible */\n\tif ((len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size, NULL, NULL) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf16_to_8(char *dest, size_t dest_size, const wchar_t *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t * turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t * length. WideCharToMultiByte never returns int's minvalue, so underflow is not possible */\n\tif ((len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size, NULL, NULL) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "namelen + 1"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetShortPathNameW",
          "args": [
            "longpath",
            "shortpath",
            "GIT_WIN_PATH_UTF16"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "longpath",
            "path"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nchar *git_win32_path_8dot3_name(const char *path)\n{\n\tgit_win32_path longpath, shortpath;\n\twchar_t *start;\n\tchar *shortname;\n\tint len, namelen = 1;\n\n\tif (git_win32_path_from_utf8(longpath, path) < 0)\n\t\treturn NULL;\n\n\tlen = GetShortPathNameW(longpath, shortpath, GIT_WIN_PATH_UTF16);\n\n\twhile (len && shortpath[len-1] == L'\\\\')\n\t\tshortpath[--len] = L'\\0';\n\n\tif (len == 0 || len >= GIT_WIN_PATH_UTF16)\n\t\treturn NULL;\n\n\tfor (start = shortpath + (len - 1);\n\t\tstart > shortpath && *(start-1) != '/' && *(start-1) != '\\\\';\n\t\tstart--)\n\t\tnamelen++;\n\n\t/* We may not have actually been given a short name.  But if we have,\n\t * it will be in the ASCII byte range, so we don't need to worry about\n\t * multi-byte sequences and can allocate naively.\n\t */\n\tif (namelen > 12 || (shortname = git__malloc(namelen + 1)) == NULL)\n\t\treturn NULL;\n\n\tif ((len = git__utf16_to_8(shortname, namelen + 1, start)) < 0)\n\t\treturn NULL;\n\n\treturn shortname;\n}"
  },
  {
    "function_name": "git_win32_path_to_utf8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "255-279",
    "snippet": "int git_win32_path_to_utf8(git_win32_utf8_path dest, const wchar_t *src)\n{\n\tchar *out = dest;\n\tint len;\n\n\t/* Strip NT namespacing \"\\\\?\\\" */\n\tif (path__is_nt_namespace(src)) {\n\t\tsrc += 4;\n\n\t\t/* \"\\\\?\\UNC\\server\\share\" -> \"\\\\server\\share\" */\n\t\tif (wcsncmp(src, L\"UNC\\\\\", 4) == 0) {\n\t\t\tsrc += 4;\n\n\t\t\tmemcpy(dest, \"\\\\\\\\\", 2);\n\t\t\tout = dest + 2;\n\t\t}\n\t}\n\n\tif ((len = git__utf16_to_8(out, GIT_WIN_PATH_UTF8, src)) < 0)\n\t\treturn len;\n\n\tgit_path_mkposix(dest);\n\n\treturn len;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_mkposix",
          "args": [
            "dest"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_mkposix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "110-118",
          "snippet": "GIT_INLINE(void) git_path_mkposix(char *path)\n{\n\twhile (*path) {\n\t\tif (*path == '\\\\')\n\t\t\t*path = '/';\n\n\t\tpath++;\n\t}\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) git_path_mkposix(char *path)\n{\n\twhile (*path) {\n\t\tif (*path == '\\\\')\n\t\t\t*path = '/';\n\n\t\tpath++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__utf16_to_8",
          "args": [
            "out",
            "GIT_WIN_PATH_UTF8",
            "src"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf16_to_8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "48-59",
          "snippet": "int git__utf16_to_8(char *dest, size_t dest_size, const wchar_t *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t * turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t * length. WideCharToMultiByte never returns int's minvalue, so underflow is not possible */\n\tif ((len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size, NULL, NULL) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf16_to_8(char *dest, size_t dest_size, const wchar_t *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t * turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t * length. WideCharToMultiByte never returns int's minvalue, so underflow is not possible */\n\tif ((len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size, NULL, NULL) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "\"\\\\\\\\\"",
            "2"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcsncmp",
          "args": [
            "src",
            "L\"UNC\\\\\"",
            "4"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path__is_nt_namespace",
          "args": [
            "src"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path_to_utf8(git_win32_utf8_path dest, const wchar_t *src)\n{\n\tchar *out = dest;\n\tint len;\n\n\t/* Strip NT namespacing \"\\\\?\\\" */\n\tif (path__is_nt_namespace(src)) {\n\t\tsrc += 4;\n\n\t\t/* \"\\\\?\\UNC\\server\\share\" -> \"\\\\server\\share\" */\n\t\tif (wcsncmp(src, L\"UNC\\\\\", 4) == 0) {\n\t\t\tsrc += 4;\n\n\t\t\tmemcpy(dest, \"\\\\\\\\\", 2);\n\t\t\tout = dest + 2;\n\t\t}\n\t}\n\n\tif ((len = git__utf16_to_8(out, GIT_WIN_PATH_UTF8, src)) < 0)\n\t\treturn len;\n\n\tgit_path_mkposix(dest);\n\n\treturn len;\n}"
  },
  {
    "function_name": "git_win32_path_from_utf8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "190-253",
    "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define PATH__NT_NAMESPACE_LEN 4",
      "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetLastError",
          "args": [
            "ERROR_FILENAME_EXCED_RANGE"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_canonicalize",
          "args": [
            "out"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_canonicalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "87-149",
          "snippet": "int git_win32_path_canonicalize(git_win32_path path)\n{\n\twchar_t *base, *from, *to, *next;\n\tsize_t len;\n\n\tbase = to = path__skip_prefix(path);\n\n\t/* Unposixify if the prefix */\n\tfor (from = path; from < to; from++) {\n\t\tif (*from == L'/')\n\t\t\t*from = L'\\\\';\n\t}\n\n\twhile (*from) {\n\t\tfor (next = from; *next; ++next) {\n\t\t\tif (*next == L'/') {\n\t\t\t\t*next = L'\\\\';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*next == L'\\\\')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == L'.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == L'.' && from[1] == L'.') {\n\t\t\tif (to == base) {\n\t\t\t\t/* no more path segments to strip, eat the \"../\" */\n\t\t\t\tif (*next == L'\\\\')\n\t\t\t\t\tlen++;\n\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == L'\\\\') to--;\n\t\t\t\twhile (to > base && to[-1] != L'\\\\') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == L'\\\\' && *from != L'\\\\')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, sizeof(wchar_t) * len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == L'\\\\') from++;\n\t}\n\n\t/* Strip trailing backslashes */\n\twhile (to > base && to[-1] == L'\\\\') to--;\n\n\t*to = L'\\0';\n\n\treturn (to - path);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path_canonicalize(git_win32_path path)\n{\n\twchar_t *base, *from, *to, *next;\n\tsize_t len;\n\n\tbase = to = path__skip_prefix(path);\n\n\t/* Unposixify if the prefix */\n\tfor (from = path; from < to; from++) {\n\t\tif (*from == L'/')\n\t\t\t*from = L'\\\\';\n\t}\n\n\twhile (*from) {\n\t\tfor (next = from; *next; ++next) {\n\t\t\tif (*next == L'/') {\n\t\t\t\t*next = L'\\\\';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*next == L'\\\\')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == L'.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == L'.' && from[1] == L'.') {\n\t\t\tif (to == base) {\n\t\t\t\t/* no more path segments to strip, eat the \"../\" */\n\t\t\t\tif (*next == L'\\\\')\n\t\t\t\t\tlen++;\n\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == L'\\\\') to--;\n\t\t\t\twhile (to > base && to[-1] != L'\\\\') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == L'\\\\' && *from != L'\\\\')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, sizeof(wchar_t) * len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == L'\\\\') from++;\n\t}\n\n\t/* Strip trailing backslashes */\n\twhile (to > base && to[-1] == L'\\\\') to--;\n\n\t*to = L'\\0';\n\n\treturn (to - path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__utf8_to_16",
          "args": [
            "dest + cwd_len",
            "MAX_PATH - cwd_len",
            "src"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf8_to_16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "27-38",
          "snippet": "int git__utf8_to_16(wchar_t *dest, size_t dest_size, const char *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t* turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t* length. MultiByteToWideChar never returns int's minvalue, so underflow is not possible */\n\tif ((len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf8_to_16(wchar_t *dest, size_t dest_size, const char *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t* turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t* length. MultiByteToWideChar never returns int's minvalue, so underflow is not possible */\n\tif ((len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32_path__cwd",
          "args": [
            "dest",
            "MAX_PATH"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path__cwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "151-188",
          "snippet": "int git_win32_path__cwd(wchar_t *out, size_t len)\n{\n\tint cwd_len;\n\n\tif ((cwd_len = path__cwd(out, len)) < 0)\n\t\treturn -1;\n\n\t/* UNC paths */\n\tif (wcsncmp(L\"\\\\\\\\\", out, 2) == 0) {\n\t\t/* Our buffer must be at least 5 characters larger than the\n\t\t * current working directory:  we swallow one of the leading\n\t\t * '\\'s, but we we add a 'UNC' specifier to the path, plus\n\t\t * a trailing directory separator, plus a NUL.\n\t\t */\n\t\tif (cwd_len > MAX_PATH - 4) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(out+2, out, sizeof(wchar_t) * cwd_len);\n\t\tout[0] = L'U';\n\t\tout[1] = L'N';\n\t\tout[2] = L'C';\n\n\t\tcwd_len += 2;\n\t}\n\n\t/* Our buffer must be at least 2 characters larger than the current\n\t * working directory.  (One character for the directory separator,\n\t * one for the null.\n\t */\n\telse if (cwd_len > MAX_PATH - 2) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\treturn cwd_len;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path__cwd(wchar_t *out, size_t len)\n{\n\tint cwd_len;\n\n\tif ((cwd_len = path__cwd(out, len)) < 0)\n\t\treturn -1;\n\n\t/* UNC paths */\n\tif (wcsncmp(L\"\\\\\\\\\", out, 2) == 0) {\n\t\t/* Our buffer must be at least 5 characters larger than the\n\t\t * current working directory:  we swallow one of the leading\n\t\t * '\\'s, but we we add a 'UNC' specifier to the path, plus\n\t\t * a trailing directory separator, plus a NUL.\n\t\t */\n\t\tif (cwd_len > MAX_PATH - 4) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(out+2, out, sizeof(wchar_t) * cwd_len);\n\t\tout[0] = L'U';\n\t\tout[1] = L'N';\n\t\tout[2] = L'C';\n\n\t\tcwd_len += 2;\n\t}\n\n\t/* Our buffer must be at least 2 characters larger than the current\n\t * working directory.  (One character for the directory separator,\n\t * one for the null.\n\t */\n\telse if (cwd_len > MAX_PATH - 2) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\treturn cwd_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path__is_absolute",
          "args": [
            "dest"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "L\"UNC\\\\\"",
            "sizeof(wchar_t) * 4"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path__is_unc",
          "args": [
            "src"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path__is_nt_namespace",
          "args": [
            "src"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path__is_absolute",
          "args": [
            "src"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "PATH__NT_NAMESPACE",
            "sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "git_win32_path__cwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "151-188",
    "snippet": "int git_win32_path__cwd(wchar_t *out, size_t len)\n{\n\tint cwd_len;\n\n\tif ((cwd_len = path__cwd(out, len)) < 0)\n\t\treturn -1;\n\n\t/* UNC paths */\n\tif (wcsncmp(L\"\\\\\\\\\", out, 2) == 0) {\n\t\t/* Our buffer must be at least 5 characters larger than the\n\t\t * current working directory:  we swallow one of the leading\n\t\t * '\\'s, but we we add a 'UNC' specifier to the path, plus\n\t\t * a trailing directory separator, plus a NUL.\n\t\t */\n\t\tif (cwd_len > MAX_PATH - 4) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(out+2, out, sizeof(wchar_t) * cwd_len);\n\t\tout[0] = L'U';\n\t\tout[1] = L'N';\n\t\tout[2] = L'C';\n\n\t\tcwd_len += 2;\n\t}\n\n\t/* Our buffer must be at least 2 characters larger than the current\n\t * working directory.  (One character for the directory separator,\n\t * one for the null.\n\t */\n\telse if (cwd_len > MAX_PATH - 2) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\treturn cwd_len;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "out+2",
            "out",
            "sizeof(wchar_t) * cwd_len"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcsncmp",
          "args": [
            "L\"\\\\\\\\\"",
            "out",
            "2"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path__cwd",
          "args": [
            "out",
            "len"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path__cwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "151-188",
          "snippet": "int git_win32_path__cwd(wchar_t *out, size_t len)\n{\n\tint cwd_len;\n\n\tif ((cwd_len = path__cwd(out, len)) < 0)\n\t\treturn -1;\n\n\t/* UNC paths */\n\tif (wcsncmp(L\"\\\\\\\\\", out, 2) == 0) {\n\t\t/* Our buffer must be at least 5 characters larger than the\n\t\t * current working directory:  we swallow one of the leading\n\t\t * '\\'s, but we we add a 'UNC' specifier to the path, plus\n\t\t * a trailing directory separator, plus a NUL.\n\t\t */\n\t\tif (cwd_len > MAX_PATH - 4) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(out+2, out, sizeof(wchar_t) * cwd_len);\n\t\tout[0] = L'U';\n\t\tout[1] = L'N';\n\t\tout[2] = L'C';\n\n\t\tcwd_len += 2;\n\t}\n\n\t/* Our buffer must be at least 2 characters larger than the current\n\t * working directory.  (One character for the directory separator,\n\t * one for the null.\n\t */\n\telse if (cwd_len > MAX_PATH - 2) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\treturn cwd_len;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path__cwd(wchar_t *out, size_t len)\n{\n\tint cwd_len;\n\n\tif ((cwd_len = path__cwd(out, len)) < 0)\n\t\treturn -1;\n\n\t/* UNC paths */\n\tif (wcsncmp(L\"\\\\\\\\\", out, 2) == 0) {\n\t\t/* Our buffer must be at least 5 characters larger than the\n\t\t * current working directory:  we swallow one of the leading\n\t\t * '\\'s, but we we add a 'UNC' specifier to the path, plus\n\t\t * a trailing directory separator, plus a NUL.\n\t\t */\n\t\tif (cwd_len > MAX_PATH - 4) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(out+2, out, sizeof(wchar_t) * cwd_len);\n\t\tout[0] = L'U';\n\t\tout[1] = L'N';\n\t\tout[2] = L'C';\n\n\t\tcwd_len += 2;\n\t}\n\n\t/* Our buffer must be at least 2 characters larger than the current\n\t * working directory.  (One character for the directory separator,\n\t * one for the null.\n\t */\n\telse if (cwd_len > MAX_PATH - 2) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\treturn cwd_len;\n}"
  },
  {
    "function_name": "git_win32_path_canonicalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "87-149",
    "snippet": "int git_win32_path_canonicalize(git_win32_path path)\n{\n\twchar_t *base, *from, *to, *next;\n\tsize_t len;\n\n\tbase = to = path__skip_prefix(path);\n\n\t/* Unposixify if the prefix */\n\tfor (from = path; from < to; from++) {\n\t\tif (*from == L'/')\n\t\t\t*from = L'\\\\';\n\t}\n\n\twhile (*from) {\n\t\tfor (next = from; *next; ++next) {\n\t\t\tif (*next == L'/') {\n\t\t\t\t*next = L'\\\\';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*next == L'\\\\')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == L'.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == L'.' && from[1] == L'.') {\n\t\t\tif (to == base) {\n\t\t\t\t/* no more path segments to strip, eat the \"../\" */\n\t\t\t\tif (*next == L'\\\\')\n\t\t\t\t\tlen++;\n\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == L'\\\\') to--;\n\t\t\t\twhile (to > base && to[-1] != L'\\\\') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == L'\\\\' && *from != L'\\\\')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, sizeof(wchar_t) * len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == L'\\\\') from++;\n\t}\n\n\t/* Strip trailing backslashes */\n\twhile (to > base && to[-1] == L'\\\\') to--;\n\n\t*to = L'\\0';\n\n\treturn (to - path);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "to",
            "from",
            "sizeof(wchar_t) * len"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path__skip_prefix",
          "args": [
            "path"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "path__skip_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "69-85",
          "snippet": "static wchar_t *path__skip_prefix(wchar_t *path)\n{\n\tif (path__is_nt_namespace(path)) {\n\t\tpath += PATH__NT_NAMESPACE_LEN;\n\n\t\tif (wcsncmp(path, L\"UNC\\\\\", 4) == 0)\n\t\t\tpath = path__skip_server(path + 4);\n\t\telse if (path__is_absolute(path))\n\t\t\tpath += PATH__ABSOLUTE_LEN;\n\t} else if (path__is_absolute(path)) {\n\t\tpath += PATH__ABSOLUTE_LEN;\n\t} else if (path__is_unc(path)) {\n\t\tpath = path__skip_server(path + 2);\n\t}\n\n\treturn path;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__ABSOLUTE_LEN     3",
            "#define PATH__NT_NAMESPACE_LEN 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__ABSOLUTE_LEN     3\n#define PATH__NT_NAMESPACE_LEN 4\n\nstatic wchar_t *path__skip_prefix(wchar_t *path)\n{\n\tif (path__is_nt_namespace(path)) {\n\t\tpath += PATH__NT_NAMESPACE_LEN;\n\n\t\tif (wcsncmp(path, L\"UNC\\\\\", 4) == 0)\n\t\t\tpath = path__skip_server(path + 4);\n\t\telse if (path__is_absolute(path))\n\t\t\tpath += PATH__ABSOLUTE_LEN;\n\t} else if (path__is_absolute(path)) {\n\t\tpath += PATH__ABSOLUTE_LEN;\n\t} else if (path__is_unc(path)) {\n\t\tpath = path__skip_server(path + 2);\n\t}\n\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path_canonicalize(git_win32_path path)\n{\n\twchar_t *base, *from, *to, *next;\n\tsize_t len;\n\n\tbase = to = path__skip_prefix(path);\n\n\t/* Unposixify if the prefix */\n\tfor (from = path; from < to; from++) {\n\t\tif (*from == L'/')\n\t\t\t*from = L'\\\\';\n\t}\n\n\twhile (*from) {\n\t\tfor (next = from; *next; ++next) {\n\t\t\tif (*next == L'/') {\n\t\t\t\t*next = L'\\\\';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*next == L'\\\\')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlen = next - from;\n\n\t\tif (len == 1 && from[0] == L'.')\n\t\t\t/* do nothing with singleton dot */;\n\n\t\telse if (len == 2 && from[0] == L'.' && from[1] == L'.') {\n\t\t\tif (to == base) {\n\t\t\t\t/* no more path segments to strip, eat the \"../\" */\n\t\t\t\tif (*next == L'\\\\')\n\t\t\t\t\tlen++;\n\n\t\t\t\tbase = to;\n\t\t\t} else {\n\t\t\t\t/* back up a path segment */\n\t\t\t\twhile (to > base && to[-1] == L'\\\\') to--;\n\t\t\t\twhile (to > base && to[-1] != L'\\\\') to--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*next == L'\\\\' && *from != L'\\\\')\n\t\t\t\tlen++;\n\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, sizeof(wchar_t) * len);\n\n\t\t\tto += len;\n\t\t}\n\n\t\tfrom += len;\n\n\t\twhile (*from == L'\\\\') from++;\n\t}\n\n\t/* Strip trailing backslashes */\n\twhile (to > base && to[-1] == L'\\\\') to--;\n\n\t*to = L'\\0';\n\n\treturn (to - path);\n}"
  },
  {
    "function_name": "path__skip_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "69-85",
    "snippet": "static wchar_t *path__skip_prefix(wchar_t *path)\n{\n\tif (path__is_nt_namespace(path)) {\n\t\tpath += PATH__NT_NAMESPACE_LEN;\n\n\t\tif (wcsncmp(path, L\"UNC\\\\\", 4) == 0)\n\t\t\tpath = path__skip_server(path + 4);\n\t\telse if (path__is_absolute(path))\n\t\t\tpath += PATH__ABSOLUTE_LEN;\n\t} else if (path__is_absolute(path)) {\n\t\tpath += PATH__ABSOLUTE_LEN;\n\t} else if (path__is_unc(path)) {\n\t\tpath = path__skip_server(path + 2);\n\t}\n\n\treturn path;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define PATH__ABSOLUTE_LEN     3",
      "#define PATH__NT_NAMESPACE_LEN 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path__skip_server",
          "args": [
            "path + 2"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "path__skip_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "57-67",
          "snippet": "static wchar_t *path__skip_server(wchar_t *path)\n{\n\twchar_t *c;\n\n\tfor (c = path; *c; c++) {\n\t\tif (path__is_dirsep(*c))\n\t\t\treturn c + 1;\n\t}\n\n\treturn c;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic wchar_t *path__skip_server(wchar_t *path)\n{\n\twchar_t *c;\n\n\tfor (c = path; *c; c++) {\n\t\tif (path__is_dirsep(*c))\n\t\t\treturn c + 1;\n\t}\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path__is_unc",
          "args": [
            "path"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path__is_absolute",
          "args": [
            "path"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path__is_absolute",
          "args": [
            "path"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcsncmp",
          "args": [
            "path",
            "L\"UNC\\\\\"",
            "4"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path__is_nt_namespace",
          "args": [
            "path"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__ABSOLUTE_LEN     3\n#define PATH__NT_NAMESPACE_LEN 4\n\nstatic wchar_t *path__skip_prefix(wchar_t *path)\n{\n\tif (path__is_nt_namespace(path)) {\n\t\tpath += PATH__NT_NAMESPACE_LEN;\n\n\t\tif (wcsncmp(path, L\"UNC\\\\\", 4) == 0)\n\t\t\tpath = path__skip_server(path + 4);\n\t\telse if (path__is_absolute(path))\n\t\t\tpath += PATH__ABSOLUTE_LEN;\n\t} else if (path__is_absolute(path)) {\n\t\tpath += PATH__ABSOLUTE_LEN;\n\t} else if (path__is_unc(path)) {\n\t\tpath = path__skip_server(path + 2);\n\t}\n\n\treturn path;\n}"
  },
  {
    "function_name": "path__skip_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "57-67",
    "snippet": "static wchar_t *path__skip_server(wchar_t *path)\n{\n\twchar_t *c;\n\n\tfor (c = path; *c; c++) {\n\t\tif (path__is_dirsep(*c))\n\t\t\treturn c + 1;\n\t}\n\n\treturn c;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path__is_dirsep",
          "args": [
            "*c"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nstatic wchar_t *path__skip_server(wchar_t *path)\n{\n\twchar_t *c;\n\n\tfor (c = path; *c; c++) {\n\t\tif (path__is_dirsep(*c))\n\t\t\treturn c + 1;\n\t}\n\n\treturn c;\n}"
  },
  {
    "function_name": "path__cwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
    "lines": "33-55",
    "snippet": "GIT_INLINE(int) path__cwd(wchar_t *path, int size)\n{\n\tint len;\n\n\tif ((len = GetCurrentDirectoryW(size, path)) == 0) {\n\t\terrno = GetLastError() == ERROR_ACCESS_DENIED ? EACCES : ENOENT;\n\t\treturn -1;\n\t} else if (len > size) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\t/* The Win32 APIs may return \"\\\\?\\\" once you've used it first.\n\t * But it may not.  What a gloriously predictible API!\n\t */\n\tif (wcsncmp(path, PATH__NT_NAMESPACE, PATH__NT_NAMESPACE_LEN))\n\t\treturn len;\n\n\tlen -= PATH__NT_NAMESPACE_LEN;\n\n\tmemmove(path, path + PATH__NT_NAMESPACE_LEN, sizeof(wchar_t) * len);\n\treturn len;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"reparse.h\"",
      "#include \"posix.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define PATH__NT_NAMESPACE_LEN 4",
      "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "path",
            "path + PATH__NT_NAMESPACE_LEN",
            "sizeof(wchar_t) * len"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcsncmp",
          "args": [
            "path",
            "PATH__NT_NAMESPACE",
            "PATH__NT_NAMESPACE_LEN"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentDirectoryW",
          "args": [
            "size",
            "path"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nGIT_INLINE(int) path__cwd(wchar_t *path, int size)\n{\n\tint len;\n\n\tif ((len = GetCurrentDirectoryW(size, path)) == 0) {\n\t\terrno = GetLastError() == ERROR_ACCESS_DENIED ? EACCES : ENOENT;\n\t\treturn -1;\n\t} else if (len > size) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\t/* The Win32 APIs may return \"\\\\?\\\" once you've used it first.\n\t * But it may not.  What a gloriously predictible API!\n\t */\n\tif (wcsncmp(path, PATH__NT_NAMESPACE, PATH__NT_NAMESPACE_LEN))\n\t\treturn len;\n\n\tlen -= PATH__NT_NAMESPACE_LEN;\n\n\tmemmove(path, path + PATH__NT_NAMESPACE_LEN, sizeof(wchar_t) * len);\n\treturn len;\n}"
  }
]